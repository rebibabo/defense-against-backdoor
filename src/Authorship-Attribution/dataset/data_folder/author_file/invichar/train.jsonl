{"author": "mth", "index": 0, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/env python\n \nFILE_NAME_BASE = 'B-small-attempt0'\nNUM_PROCESSES = 0\nMEM_LIMIT_GB = 1.5 # per worker process\nRECURSION_LIMIT = 1000\n \ndef parse(inp):\n\tcost, prod, goal = (float(x) for x in inp.readline().split())\n\treturn cost, prod, goal\n \ndef solve(cost, prod, goal):\n\trate = 2\n\tnow = 0\n\twhile True:\n\t\tnobuyEnd = goal / rate\n\t\tbuyEnd = cost / rate + goal / (rate + prod)\n\t\tif buyEnd < nobuyEnd:\n\t\t\tnow += cost / rate\n\t\t\trate += prod\n\t\telse:\n\t\t\treturn '%0.7f' % (now + nobuyEnd)\n \ndef main():\n\timport sys\n\tsys.setrecursionlimit(RECURSION_LIMIT)\n \n\timport resource\n\tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n\tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n\tinp = open(FILE_NAME_BASE + '.in', 'r')\n\tnumCases = int(inp.readline())\n\tif NUM_PROCESSES == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(NUM_PROCESSES)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(FILE_NAME_BASE + '.out', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "mth", "index": 0, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\n \nFILE_NAME_BASE = 'C-small-attempt0'\nNUM_PROCESSES = 0\nMEM_LIMIT_GB = 1.5 # per worker process\nRECURSION_LIMIT = 1000\n \ndef parse(inp):\n\trows, cols, mines = (int(x) for x in inp.readline().split())\n\treturn rows, cols, mines\n \ndef search(rows, cols, mines):\n\t# Boundary cases:\n\t# TODO: Might be redundant once we have a generic solution.\n \n\t# Mine count extremes.\n\tassert 0 <= mines < rows * cols\n\tif mines == 0:\n\t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\n\tif mines == rows * cols - 1:\n\t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n \n\t# One-dimensional board.\n\tif rows == 1:\n\t\treturn ['c' + '.' * (cols - 1 - mines) + '*' * mines]\n\tif cols == 1:\n\t\treturn ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\n \n\t# Nearly-full two-dimensional board: the clicked cell must not have any\n\t# mines as neighbours or the flooding won't start.\n\tif mines > rows * cols - 4:\n\t\treturn None\n \n\t# TODO: For now, we just give up.\n \n\treturn None\n \nclass SearchBoard(object):\n \n\tdef __init__(self, rows, cols):\n\t\tself.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\n\t\tself.mineCount = 0\n \n\tdef addMine(self, row, col):\n\t\tcounts = self.counts\n\t\tassert counts[row + 1][col + 1] < 10\n\t\ttop = counts[row + 0]\n\t\ttop[col + 0] += 1\n\t\ttop[col + 1] += 1\n\t\ttop[col + 2] += 1\n\t\tmid = counts[row + 1]\n\t\tmid[col + 0] += 1\n\t\tmid[col + 1] += 10\n\t\tmid[col + 2] += 1\n\t\tbot = counts[row + 2]\n\t\tbot[col + 0] += 1\n\t\tbot[col + 1] += 1\n\t\tbot[col + 2] += 1\n\t\tself.mineCount += 1\n \n\tdef removeMine(self, row, col):\n\t\tcounts = self.counts\n\t\tassert counts[row + 1][col + 1] >= 10\n\t\ttop = counts[row + 0]\n\t\ttop[col + 0] -= 1\n\t\ttop[col + 1] -= 1\n\t\ttop[col + 2] -= 1\n\t\tmid = counts[row + 1]\n\t\tmid[col + 0] -= 1\n\t\tmid[col + 1] -= 10\n\t\tmid[col + 2] -= 1\n\t\tbot = counts[row + 2]\n\t\tbot[col + 0] -= 1\n\t\tbot[col + 1] -= 1\n\t\tbot[col + 2] -= 1\n\t\tself.mineCount -= 1\n \n\tdef checkConnected(self):\n\t\tcounts = self.counts\n\t\tcols = len(counts[0]) - 2\n\t\trows = len(counts) - 2\n \n\t\t# Pick a cell to click on. Any zero cell will do: if all zeroes are\n\t\t# connected, clicking on any zero will reveal them all.\n\t\tfor rowIdx, row in enumerate(counts):\n\t\t\tif rowIdx == 0 or rowIdx > rows:\n\t\t\t\tcontinue\n\t\t\ttry:\n\t\t\t\tcolIdx = row.index(0, 1, -1)\n\t\t\texcept ValueError:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tclick = (rowIdx, colIdx)\n\t\t\t\tbreak\n\t\telse:\n\t\t\treturn None\n \n\t\trevealed = set()\n\t\tdef reveal(row, col):\n\t\t\tif 1 <= row <= rows and 1 <= col <= cols:\n\t\t\t\tpos = (row, col)\n\t\t\t\tif pos not in revealed:\n\t\t\t\t\trevealed.add(pos)\n\t\t\t\t\tcount = counts[row][col]\n\t\t\t\t\tif count == 0:\n\t\t\t\t\t\tfor dr in (-1, 0, 1):\n\t\t\t\t\t\t\tfor dc in (-1, 0, 1):\n\t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\n\t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\n\t\t\t\t\telse:\n\t\t\t\t\t\tassert count < 10\n\t\treveal(*click)\n\t\tnumNonMines = rows * cols - self.mineCount\n\t\tif len(revealed) != numNonMines:\n\t\t\tassert len(revealed) < numNonMines\n\t\t\treturn None\n \n\t\t# Construct a board in the solution syntax.\n\t\tboard = [\n\t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\n\t\t\t\tfor row in counts[1 : -1]\n\t\t\t\t]\n\t\tboard[click[0] - 1][click[1] - 1] = 'c'\n\t\treturn [''.join(row) for row in board]\n \ndef searchBruteForce(rows, cols, mines):\n\t# This is the only case where there are no zero cells but there is a\n\t# solution.\n\tif mines == rows * cols - 1:\n\t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n \n\tsearchBoard = SearchBoard(rows, cols)\n \n\tdef searchRec(idx, remaining):\n\t\tif remaining == 0:\n\t\t\treturn searchBoard.checkConnected()\n\t\telif idx < remaining:\n\t\t\treturn None\n\t\telse:\n\t\t\tpos = divmod(idx, cols)\n\t\t\tsearchBoard.addMine(*pos)\n\t\t\tfound = searchRec(idx - 1, remaining - 1)\n\t\t\tsearchBoard.removeMine(*pos)\n\t\t\tif found is not None:\n\t\t\t\treturn found\n\t\t\treturn searchRec(idx - 1, remaining)\n \n\treturn searchRec(rows * cols - 1, mines)\n \ndef solve(rows, cols, mines):\n\tboard = search(rows, cols, mines)\n \n\tif board is None:\n\t\tboard = searchBruteForce(rows, cols, mines)\n\t\tif board is None:\n\t\t\treturn '\\n' + 'Impossible'\n\t\tprint ('ERROR: fast search missed solution for %dx%d board, %d mines:' \\\n\t\t\t\t% (rows, cols, mines))\n\t\tfor row in board:\n\t\t\tprint (row)\n\t\tprint\n \n\t# Perform sanity checks.\n\tassert len(board) == rows\n\tassert all(len(row) == cols for row in board)\n\tcounts = { 'c': 0, '.': 0, '*': 0 }\n\tfor row in board:\n\t\tfor cell in row:\n\t\t\tcounts[cell] += 1\n\tassert counts['c'] == 1\n\tassert counts['*'] == mines\n \n\tflowBoard = [\n\t\t\t['.' if cell == 'c' else cell for cell in row]\n\t\t\tfor row in board\n\t\t\t]\n\tdef countMinesOn(row, col):\n\t\tif 0 <= row < rows and 0 <= col < cols:\n\t\t\treturn 1 if flowBoard[row][col] == '*' else 0\n\t\telse:\n\t\t\treturn 0\n\tdef countMinesNear(row, col):\n\t\treturn sum(\n\t\t\tcountMinesOn(row + dr, col + dc)\n\t\t\tfor dr in (-1, 0, 1)\n\t\t\tfor dc in (-1, 0, 1)\n\t\t\t)\n\tdef reveal(row, col):\n\t\tif 0 <= row < rows and 0 <= col < cols:\n\t\t\tassert flowBoard[row][col] != '*'\n\t\t\tif flowBoard[row][col] == '.':\n\t\t\t\tcount = countMinesNear(row, col)\n\t\t\t\tflowBoard[row][col] = str(count)\n\t\t\t\tif count == 0:\n\t\t\t\t\tfor dr in (-1, 0, 1):\n\t\t\t\t\t\tfor dc in (-1, 0, 1):\n\t\t\t\t\t\t\treveal(row + dr, col + dc)\n\tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\n\tclickCol = board[clickRow].index('c')\n\treveal(clickRow, clickCol)\n\tassert all('.' not in row for row in flowBoard), flowBoard\n \n\tassert all(type(row) == str for row in board)\n\treturn '\\n' + ''.join('\\n' + ''.join(row) for row in board)\n \ndef main():\n\timport sys\n\tsys.setrecursionlimit(RECURSION_LIMIT)\n \n\timport resource\n\tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n\tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n\tinp = open(FILE_NAME_BASE + '.in', 'r')\n\tnumCases = int(inp.readline())\n\tif NUM_PROCESSES == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(NUM_PROCESSES)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(FILE_NAME_BASE + '.out', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "mth", "index": 0, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/env python\n \nFILE_NAME_BASE = 'B-small-attempt0'\nNUM_PROCESSES = 0\n \ndef parse(inp):\n\tdata = tuple(int(x) for x in inp.readline().split())\n\tdancers, surprises, points = data[ : 3]\n\ttotals = data[3 : ]\n\tassert len(totals) == dancers\n\treturn totals, surprises, points\n \ndef totalAtDist():\n\t'''\n\tIf a dancer's best result is b, the total can be:\n\t  distance 0: 3b\n\t  distance 1: [3b-2..3b-1]\n\t  distance 2: [3b-4..3b-2]\n\tNote: distance d is only possible if d <= b.\n \n\ttotal 15:\n\tb = 0..4:  impossible\n\tb = 5:     dist = 0\n\tb = 6:     dist = 2\n\tb = 7..10: impossible\n \n\tFor every total we have a number of explanations, which are\n\t(b, d) pairs where b is the best result and d is the distance.\n \n\tThe output of this function shows:\n \n\tExcept for 0, 1, 29 and 30, every total t has exactly 2 explanations:\n\t  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)\n\tIn other words, always one surprise option and one normal option.\n\tThe surprise option can have a result one higher than the normal one or\n\tequal to it.\n\t'''\n \n\tprint ('  '),\n\tfor b in xrange(0, 11):\n\t\tprint ('b=%d' % b),\n\tprint\n\tfor total in xrange(0, 31):\n\t\tprint ('%2d' % total),\n\t\tfor b in xrange(0, 11):\n\t\t\ts = '0' if total == b * 3 else '.'\n\t\t\ts += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'\n\t\t\ts += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'\n\t\t\tprint (s),\n\t\tprint\n \n#totalAtDist()\n \ndef solve(totals, surprises, points):\n\tcountCertain = 0\n\tcountSurprise = 0\n\tfor total in totals:\n\t\tif (total + 2) / 3 >= points:\n\t\t\t# A non-surprising score has a best result >= p.\n\t\t\tcountCertain += 1\n\t\telif 2 <= total <= 28 and (total + 4) / 3 >= points:\n\t\t\t# Only a surprising score has a best result >= p.\n\t\t\tcountSurprise += 1\n\t\telse:\n\t\t\t# The best result cannot be >= p.\n\t\t\tpass\n \n\t# Replacing a non-surprise interpretation of a total by a surprise\n\t# interpretation is always possible for totals in [2..28] and will never\n\t# lower the best result, so it will not put a score in a different\n\t# category. Therefore, it is always possible to assign leftover surprise\n\t# slots to dancers without changing the outcome.\n \n\treturn countCertain + min(countSurprise, surprises)\n \nif __name__ == '__main__':\n\tinp = open(FILE_NAME_BASE + '.in.txt', 'r')\n\tnumCases = int(inp.readline())\n\tif NUM_PROCESSES == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(NUM_PROCESSES)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(FILE_NAME_BASE + '.out.txt', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n"}
{"author": "mth", "index": 0, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\n \nFILE_NAME_BASE = 'A-small-attempt0'\nNUM_PROCESSES = 0\nMEM_LIMIT_GB = 1.5 # per worker process\nRECURSION_LIMIT = 1000\n \ndef parse(inp):\n\tboard = tuple( inp.readline().rstrip() for _ in xrange(4) )\n\tempty = inp.readline().rstrip()\n\tassert empty == '', empty\n\treturn board,\n \ndef solve(board):\n \n\tdef scan(start, delta):\n\t\tx, y = start\n\t\tdx, dy = delta\n\t\tfor _ in xrange(4):\n\t\t\tyield board[y][x]\n\t\t\tx += dx\n\t\t\ty += dy\n \n\t# Look for a winner.\n\tfor start, delta in (\n\t\t# horizontal\n\t\t((0, 0), (1, 0)),\n\t\t((0, 1), (1, 0)),\n\t\t((0, 2), (1, 0)),\n\t\t((0, 3), (1, 0)),\n\t\t# vertical\n\t\t((0, 0), (0, 1)),\n\t\t((1, 0), (0, 1)),\n\t\t((2, 0), (0, 1)),\n\t\t((3, 0), (0, 1)),\n\t\t# diagonal\n\t\t((0, 0), (1, 1)),\n\t\t((3, 0), (-1, 1)),\n\t\t):\n\t\tchars = set(scan(start, delta))\n\t\tif chars == set(['X']) or chars == set(['X', 'T']):\n\t\t\treturn 'X won'\n\t\telif chars == set(['O']) or chars == set(['O', 'T']):\n\t\t\treturn 'O won'\n \n\t# No winner; draw or unfinished game?\n\tif any('.' in row for row in board):\n\t\treturn 'Game has not completed'\n\telse:\n\t\treturn 'Draw'\n \ndef main():\n\timport sys\n\tsys.setrecursionlimit(RECURSION_LIMIT)\n \n\timport resource\n\tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n\tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n\tinp = open(FILE_NAME_BASE + '.in', 'r')\n\tnumCases = int(inp.readline())\n\tif NUM_PROCESSES == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(NUM_PROCESSES)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(FILE_NAME_BASE + '.out', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "mth", "index": 0, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/env python\n \nFILE_NAME_BASE = 'B-small-attempt0'\nNUM_PROCESSES = 0\nMEM_LIMIT_GB = 1.5 # per worker process\nRECURSION_LIMIT = 1000\n \ndef parse(inp):\n\trows, cols = (int(x) for x in inp.readline().split())\n\treturn tuple(\n\t\ttuple(int(x) for x in inp.readline().split())\n\t\tfor row in xrange(rows)\n\t\t),\n \ndef solve(lawn):\n\t#print(lawn)\n \n\trowMax = tuple(max(row) for row in lawn)\n\tcolMax = tuple(max(row[i] for row in lawn) for i in xrange(len(lawn[0])))\n\t#print(rowMax, colMax)\n \n\tdef possible():\n\t\tfor y, row in enumerate(lawn):\n\t\t\tfor x, cell in enumerate(row):\n\t\t\t\th = min(rowMax[y], colMax[x])\n\t\t\t\tif cell != h:\n\t\t\t\t\treturn False\n\t\treturn True\n \n\treturn 'YES' if possible() else 'NO'\n \ndef main():\n\timport sys\n\tsys.setrecursionlimit(RECURSION_LIMIT)\n \n\timport resource\n\tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n\tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n\tinp = open(FILE_NAME_BASE + '.in', 'r')\n\tnumCases = int(inp.readline())\n\tif NUM_PROCESSES == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(NUM_PROCESSES)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(FILE_NAME_BASE + '.out', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "mth", "index": 0, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/env python\n \nFILE_NAME_BASE = 'A-small'\nNUM_PROCESSES = 0\n \ndef findMapping(knowledge):\n\t# Build Googlerese to English mapping from example text.\n\tmapping = {}\n\tfor english, googlerese in knowledge:\n\t\tassert len(english) == len(googlerese)\n\t\tfor engChar, gooChar in zip(english, googlerese):\n\t\t\tif ord('a') <= ord(engChar) <= ord('z'):\n\t\t\t\tassert ord('a') <= ord(gooChar) <= ord('z')\n\t\t\t\tif gooChar in mapping:\n\t\t\t\t\tassert mapping[gooChar] == engChar\n\t\t\t\telse:\n\t\t\t\t\tmapping[gooChar] = engChar\n\t\t\telse:\n\t\t\t\tassert engChar == gooChar\n \n\t# If one letter is not be specified in the example text, we can still\n\t# complete the mapping.\n\talphabet = set(chr(i) for i in xrange(ord('a'), ord('z') + 1))\n\tgooMissing = alphabet - set(mapping.iterkeys())\n\tengMissing = alphabet - set(mapping.itervalues())\n\tassert len(gooMissing) == len(engMissing)\n\tif len(gooMissing) == 1:\n\t\tgooChar, = gooMissing\n\t\tengChar, = engMissing\n\t\tmapping[gooChar] = engChar\n\telse:\n\t\tassert len(gooMissing) == 0\n \n\t# Convert completed mapping to Python translate table.\n\tassert len(mapping) == 26, mapping\n\treturn ''.join(mapping.get(chr(i), chr(i)) for i in xrange(256))\n \ndef parse(inp):\n\treturn inp.readline().rstrip('\\n'),\n \ndef solve(line):\n\treturn line.translate(mapping)\n \nknowledge = (\n\t( 'our language is impossible to understand',\n\t  'ejp mysljylc kd kxveddknmc re jsicpdrysi' ),\n\t( 'there are twenty six factorial possibilities',\n\t  'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' ),\n\t( 'so it is okay if you want to just give up',\n\t  'de kr kd eoya kw aej tysr re ujdr lkgc jv' ),\n\t( 'a zoo',\n\t  'y qee' ),\n\t)\n \nmapping = findMapping(knowledge)\n \nif __name__ == '__main__':\n\tinp = open(FILE_NAME_BASE + '.in.txt', 'r')\n\tnumCases = int(inp.readline())\n\tif NUM_PROCESSES == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(NUM_PROCESSES)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(FILE_NAME_BASE + '.out.txt', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n"}
{"author": "mth", "index": 0, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/env python\n \nfrom math import sqrt\n \nFILE_NAME_BASE = 'C-small-attempt0'\nNUM_PROCESSES = 0\nMEM_LIMIT_GB = 1.5 # per worker process\nRECURSION_LIMIT = 1000\n \ndef parse(inp):\n\ta, b = (int(x) for x in inp.readline().split())\n\treturn a, b\n \ndef isFair(x):\n\tl1 = list(str(x))\n\tl2 = list(l1)\n\tl2.reverse()\n\treturn l1 == l2\n \ndef solve(a, b):\n\tc = 0\n\tfor i in xrange(a, b + 1):\n\t\tr = int(sqrt(i))\n\t\tif r * r == i and isFair(i) and isFair(r):\n\t\t\tc += 1\n \n\treturn str(c)\n \ndef main():\n\timport sys\n\tsys.setrecursionlimit(RECURSION_LIMIT)\n \n\timport resource\n\tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n\tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n\tinp = open(FILE_NAME_BASE + '.in', 'r')\n\tnumCases = int(inp.readline())\n\tif NUM_PROCESSES == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(NUM_PROCESSES)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(FILE_NAME_BASE + '.out', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "mth", "index": 0, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\n \nFILE_NAME_BASE = 'A-small-attempt0'\nNUM_PROCESSES = 0\nMEM_LIMIT_GB = 1.5 # per worker process\nRECURSION_LIMIT = 1000\n \ndef parseBoard(inp):\n\trowSel, = (int(x) for x in inp.readline().split())\n\tboard = tuple(\n\t\ttuple(int(x) for x in inp.readline().split())\n\t\tfor _ in xrange(4)\n\t\t)\n\treturn board, rowSel - 1\n \ndef parse(inp):\n\tbefore, beforeSel = parseBoard(inp)\n\tafter, afterSel = parseBoard(inp)\n\treturn before, beforeSel, after, afterSel\n \ndef solve(before, beforeSel, after, afterSel):\n\tcandidates = set(before[beforeSel]) & set(after[afterSel])\n \n\tif len(candidates) == 0:\n\t\treturn \"Volunteer cheated!\"\n\telif len(candidates) == 1:\n\t\treturn candidates.pop()\n\telse:\n\t\treturn \"Bad magician!\"\n \ndef main():\n\timport sys\n\tsys.setrecursionlimit(RECURSION_LIMIT)\n \n\timport resource\n\tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n\tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n\tinp = open(FILE_NAME_BASE + '.in', 'r')\n\tnumCases = int(inp.readline())\n\tif NUM_PROCESSES == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(NUM_PROCESSES)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(FILE_NAME_BASE + '.out', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "binnie", "index": 1, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\nfrom decimal import *\n \nf = open(sys.argv[1])\nT = int(f.readline())\nfor test in range(T):\n    data = f.readline().split()\n    C = Decimal(data[0])\n    F = Decimal(data[1])\n    X = Decimal(data[2])\n    curr_rate = Decimal(2)\n    best_time = Decimal(10**100)\n    curr_time = Decimal(0)\n    while curr_time < best_time:\n        poss_finish_time = curr_time + X / curr_rate\n        if poss_finish_time < best_time:\n            best_time = poss_finish_time\n \n        curr_time += C / curr_rate\n        curr_rate += F\n \n    print(\"Case #%d: %.7f\" % (test + 1, best_time))\n"}
{"author": "binnie", "index": 1, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\n \nf = open(sys.argv[1])\nT = int(f.readline())\nfor test in range(T):\n    R, C, M = map(int, f.readline().strip().split())\n    Rorig = R\n    Corig = C\n    impossible = False\n    grid = [['.' for i in range(C)] for j in range(R)]\n    #print(grid)\n \n    curr_coord = [0,0]\n    while M > 0 and not impossible:\n        #print(curr_coord, M, grid)\n        if (C > R): # more columns - fill one in\n            num_mines_in_column = R\n            if M < R:\n                num_mines_in_column = min(R - 2, M)\n            if num_mines_in_column <= 0:\n                impossible = True\n                break\n            for ii in range(num_mines_in_column):\n                grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n            C -= 1\n            curr_coord[1] += 1\n            M -= num_mines_in_column\n        else:\n            num_mines_in_row = C\n            if M < C:\n                num_mines_in_row = min(C - 2, M)\n            if num_mines_in_row <= 0:\n                impossible = True\n                break\n            for ii in range(num_mines_in_row):\n                grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n            R -= 1\n            curr_coord[0] += 1\n            M -= num_mines_in_row\n \n    #print(grid)\n    print(\"Case #%d:\" % (test + 1))\n    if impossible:\n        print(\"Impossible\")\n    else:\n        for ii in range(Rorig):\n            for jj in range(Corig):\n                if grid[ii][jj] == '.':\n                    if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                        grid[ii][jj] = 'dirty'\n                    elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                        grid[ii][jj] = 'dirty'\n                    elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                        grid[ii][jj] = 'dirty'\n        #print(grid)\n \n        for ii in range(Rorig):\n            for jj in range(Corig):\n                if grid[ii][jj] == 'dirty':\n                    if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                        grid[ii][jj] = '.'\n                    elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                        grid[ii][jj] = '.'\n                    elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                        grid[ii][jj] = '.'\n                    else:\n                        if ii != Rorig - 1 or jj != Corig - 1:\n                            impossible = True\n        #print(grid)\n \n        if impossible:\n            print(\"Impossible\")\n        else:\n            grid[Rorig-1][Corig-1] = 'c'\n \n            for ii in range(Rorig):\n                print(\" \".join([val for val in grid[ii]]))\n \n \n"}
{"author": "binnie", "index": 1, "filename": "2012_1460488_1595491.py", "code": "import sys\n \nf = open(sys.argv[1])\nT = int(f.readline())\nfor t in range(T):\n    temp = map(int, f.readline().split())\n    N = temp[0]\n    S = temp[1]\n    p = temp[2]\n    scores = temp[3:]\n    non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))\n    if (p<=1):\n        surprising_scores = 0\n    else:\n        surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))\n    num_scores = non_surprising_scores + min(surprising_scores, S)   \n    print(\"Case #%d:\" % (t + 1), num_scores)\n"}
{"author": "binnie", "index": 1, "filename": "2013_2270488_2453486.py", "code": "import sys\n \ndef hasWon(game, player):\n    for ii in range(4):\n        success = True\n        for jj in range(4): # Has the player won in row ii\n            if game[4*ii + jj] != player and game[4*ii + jj] != \"T\":\n                success = False\n        if success: return True\n        success = True\n        for jj in range(4): # Has the player won in column ii\n            if game[4*jj + ii] != player and game[4*jj + ii] != \"T\":\n                success = False\n        if success: return True\n     \n    success = True\n    for ii in range(4):\n        if game[ii*5] != player and game[ii*5] != \"T\":\n            success = False\n    if success: return True\n    success = True\n    for ii in range(4):\n        if game[3+ii*3] != player and game[3+ii*3] != \"T\":\n            success = False\n    if success: return True\n    return False\n \ndef gameOver(game):\n    ret_val = True\n    for ii in range(16):\n        if game[ii] == \".\":\n            ret_val = False\n    return ret_val\n \nf = open(sys.argv[1])\nT = int(f.readline())\nfor t in range(T):\n    game = []\n    for ii in range(4):\n        for elem in f.readline().strip():\n            game.append(elem)\n \n    if hasWon(game, \"O\"):\n        print(\"Case #%d:\" % (t + 1), \"O won\")\n    elif hasWon(game, \"X\"):\n        print(\"Case #%d:\" % (t + 1), \"X won\")\n    elif gameOver(game):\n        print(\"Case #%d:\" % (t + 1), \"Draw\")\n    else:\n        print(\"Case #%d:\" % (t + 1), \"Game has not completed\")\n \n    f.readline()\n"}
{"author": "binnie", "index": 1, "filename": "2013_2270488_2449486.py", "code": "import sys\n \nf = open(sys.argv[1])\nT = int(f.readline())\nfor t in range(T):\n    N, M = map(int, f.readline().strip().split())\n    grass_lengths = []\n    for nn in range(N):\n        grass_lengths.append(map(int, f.readline().strip().split())) # Read in all grass heights\n \n    x_max = [0] * M\n    y_max = [0] * N\n    for xx in range(M):\n        for yy in range(N):\n            height = grass_lengths[yy][xx]\n            x_max[xx] = max(x_max[xx], height)  # Update the max required height for column x\n            y_max[yy] = max(y_max[yy], height)  # Update the max required height for row y\n \n    impossible = False\n    for xx in range(M):\n        for yy in range(N):\n            height = grass_lengths[yy][xx]\n            if (x_max[xx] > height and y_max[yy] > height): # Can we cut this row down to this level?\n                impossible = True\n \n    print(\"Case #%d:\" % (t + 1), \"NO\" if impossible else \"YES\")\n"}
{"author": "binnie", "index": 1, "filename": "2012_1460488_1483485.py", "code": "import sys\n \ndef translate(letter):\n    input =  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    output = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']\n    index = input.index(letter)\n    return output[index]\n \nf = open(sys.argv[1])\nT = int(f.readline())\nfor t in range(T):\n    string = []\n    A = f.readline().split()\n    for elem in A:\n        for ii in range(len(elem)):\n            string.append(translate(elem[ii]))\n        string.append(' ')           \n    print(\"Case #%d:\" % (t + 1), ''.join(elem for elem in string))\n"}
{"author": "binnie", "index": 1, "filename": "2013_2270488_2463486.py", "code": "import sys, itertools\n \ndef get_generators_up_to_length_n(n):\n    generators = []\n    for ii in range(1, n + 1):\n        generators += get_generators_length_n(ii)\n    return generators        \n \ndef get_generators_length_n(length):\n    if length % 2 == 0: return get_even_generators_length_n(length)\n    else: return get_odd_generators_length_n(length)\n \ndef get_odd_generators_length_n(length):\n    if length == 1: return [1, 2, 3]\n    else: \n        n = length / 2\n        generators = []\n        for ii in range(min(n, 4)):\n            for comb in itertools.combinations(range(1, n), ii):\n                first_half = [\"1\"] + [\"0\"] * (n-1)\n                for jj in comb:\n                    first_half[jj] = \"1\"\n                second_half = list(first_half)\n                second_half.reverse()\n                palin = first_half + [\"0\"] + second_half\n                generators.append(int(\"\".join([elem for elem in palin])))\n                palin[n] = \"1\"\n                generators.append(int(\"\".join([elem for elem in palin])))\n                if ii <= 1:\n                    palin[n] = \"2\"\n                    generators.append(int(\"\".join([elem for elem in palin])))\n        generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (n - 1) + [\"0\"] + [\"0\"] * (n - 1) + [\"2\"])])))\n        generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (n - 1) + [\"1\"] + [\"0\"] * (n - 1) + [\"2\"])])))\n        generators.sort()\n        return generators\n \ndef get_even_generators_length_n(length):\n    if length == 2: return [11, 22]\n    n = length / 2\n    generators = []\n    for ii in range(min(n, 4)):\n        for comb in itertools.combinations(range(1, n), ii):\n            first_half = [\"1\"] + [\"0\"] * (n-1)\n            for jj in comb:\n                first_half[jj] = \"1\"\n            second_half = list(first_half)\n            second_half.reverse()\n            palin = first_half + second_half\n            generators.append(int(\"\".join([elem for elem in palin])))\n    generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (length - 2) + [\"2\"])])))\n    generators.sort()\n    return generators\n \ndef is_palin(num):\n    string = str(num)\n    length = len(string)\n    ii = 0\n    while ii < length/2:\n        if string[ii] != string[-(1+ii)]:\n            return False\n        ii += 1\n    return True\n \ndef gen_fair_and_squares(upper_limit):\n    fair_and_squares = []\n    for ii in range(1, upper_limit + 1):\n        if (is_palin(ii) and is_palin(ii*ii)):\n            fair_and_squares.append(ii)\n    return fair_and_squares\n \nf = open(sys.argv[1])\nT = int(f.readline())\ngens = get_generators_up_to_length_n(60)\nsquares = map(lambda x: x*x, gens)\n \nfor t in range(T):\n    A, B = map(int, f.readline().strip().split())\n    total = 0\n    for elem in squares:\n        assert(is_palin(elem))\n        if elem >= A and elem <= B: total += 1\n        if elem > B:\n            break\n \n    print(\"Case #%d:\" % (t + 1), total)\n"}
{"author": "binnie", "index": 1, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \nf = open(sys.argv[1])\nT = int(f.readline())\nfor test in range(T):\n    first_row_index = int(f.readline())\n    first_row = []\n    for ii in range(4):\n        if (ii + 1) == first_row_index:\n            first_row = f.readline().strip().split()\n        else:\n            f.readline()\n    second_row_index = int(f.readline())\n    second_row = []\n    for ii in range(4):\n        if (ii + 1) == second_row_index:\n            second_row = f.readline().strip().split()\n        else:\n            f.readline()\n    combined = [val for val in first_row if val in second_row]\n \n    print(\"Case #%d:\" % (test + 1), \"Bad magician!\" if len(combined) > 1 else \"Volunteer cheated!\" if len(combined) == 0 else combined[0])\n \n \n"}
{"author": "imakaramegane", "index": 2, "filename": "2014_2974486_5709773144064000.py", "code": "# coding: utf-8\nimport sys\nimport os.path\nimport itertools\nfrom itertools import groupby\nimport math\n \ndef debug(v):\n    pass#print(v)\n \ndef read(f):\n    t = tuple(int(v) for v in f.readline().split())\n    debug(t)\n    return t\n \ndef readf(f):\n    t = tuple(float(v) for v in f.readline().split())\n    debug(t)\n    return t\n \ndef answer(f, X, ans):\n    out = \"Case #{}: {}\".format(X, ans)\n    f.write(out)\n    f.write(\"\\n\")\n    print(out)\n \n \n \ndef main(inf, outf):\n    T, = read(inf)\n    for casenmbr in range(1, T + 1):\n        C, F, X = readf(inf)\n \n        power = 2\n        farmtime = round(C / power, 7)\n        keikatime = 0\n        totaltime = round(X / power, 7)\n \n        while True:\n            keikatime += farmtime\n            power += F\n            farmtime = round(C / power, 7)\n            nokoritime = round(X / power, 7)\n            if keikatime + nokoritime > totaltime:\n                break\n            totaltime = keikatime + nokoritime\n \n        answer(outf, casenmbr, totaltime)\n \n \nif __name__==\"__main__\":\n    infname = sys.argv[1]\n    outfname = os.path.splitext(infname)[0] + \".out\"\n    with open(infname, \"r\") as inf:\n        with open(outfname, \"w\") as outf:\n            main(inf, outf)\n"}
{"author": "imakaramegane", "index": 2, "filename": "2014_2974486_5690574640250880.py", "code": "# coding: utf-8\nimport sys\nimport os.path\nimport itertools\nfrom itertools import groupby\nimport math\n \ndef debug(v):\n    pass#print(v)\n \ndef read(f):\n    t = tuple(int(v) for v in f.readline().split())\n    debug(t)\n    return t\n \ndef readf(f):\n    t = tuple(float(v) for v in f.readline().split())\n    debug(t)\n    return t\n \ndef answer(f, X, ans):\n    out = \"Case #{}:\\n{}\".format(X, ans)\n    f.write(out)\n    f.write(\"\\n\")\n    print(out)\n \ndef answer_cells(f, X, cells):\n    out = \"Case #{}:\".format(X)\n    f.write(out)\n    f.write(\"\\n\")\n    print(out)\n    for row in cells:\n        out = \"\".join(row)\n        f.write(out)\n        f.write(\"\\n\")\n        print(out)\n \ndef main(inf, outf):\n    T, = read(inf)\n    for casenmbr in range(1, T + 1):\n        R, C, M = read(inf)\n \n        if M == 0:\n            cells = [['.'] * C for i in range(R)]\n            cells[0][0] = 'c'\n            answer_cells(outf, casenmbr, cells)\n            continue\n \n        empty = R * C - M\n \n        if empty == 1:\n            cells = [['*'] * C for i in range(R)]\n            cells[0][0] = 'c'\n            answer_cells(outf, casenmbr, cells)\n            continue\n \n        if R == 1 or C == 1:\n            cells = [['.'] * C for i in range(R)]\n            m = 0\n            for r in range(R):\n                for c in range(C):\n                    cells[r][c] = '*'\n                    m += 1\n                    if m == M:\n                        break\n                else:\n                    continue\n                break\n            cells[-1][-1] = 'c'\n            answer_cells(outf, casenmbr, cells)\n            continue\n \n        if empty in (2, 3, 5, 7):\n            answer(outf, casenmbr, \"Impossible\")\n            continue\n \n        if (R == 2 or C == 2) and empty % 2:\n            answer(outf, casenmbr, \"Impossible\")\n            continue\n \n        cells = [['*'] * C for i in range(R)]\n \n \n        cells[0][0] = 'c'\n        empty -= 1\n        cc = 1\n        rr = 1\n        while empty > 0:\n            if cc < C:\n                for r in range(rr):\n                    if empty == 2 and r == rr - 1:\n                        break\n                    cells[r][cc] = '.'\n                    empty -= 1\n                    if empty == 0:\n                        break\n                cc += 1\n            if rr < R and empty > 0:\n                for c in range(cc):\n                    if empty == 2 and c == cc - 1:\n                        break\n                    cells[rr][c] = '.'\n                    empty -= 1\n                    if empty == 0:\n                        break\n                rr += 1            \n \n        # cnt = 0\n        # for row in cells:\n        #     for v in row:\n        #         if v == '*':\n        #             cnt += 1\n        # if cnt != M:\n        #     raise \"!\"\n        answer_cells(outf, casenmbr, cells)\n \n \nif __name__==\"__main__\":\n    infname = sys.argv[1]\n    outfname = os.path.splitext(infname)[0] + \".out\"\n    with open(infname, \"r\") as inf:\n        with open(outfname, \"w\") as outf:\n            main(inf, outf)\n"}
{"author": "imakaramegane", "index": 2, "filename": "2012_1460488_1595491.py", "code": "# coding:utf-8\nimport sys\n \ndef testcases():\n    with open(sys.argv[1], \"r\") as f:\n        f.readline()  # skip number of testcases\n        for X, T in enumerate(f, 1):\n            yield X, [int(t) for t in T.split()]\n \ndef main():\n    for X, T in testcases():\n        N = T[0]   # the number of Googlers\n        S = T[1]   # the number of surprising triplets of scores\n        p = T[2]   # best result of at least\n \n        y = 0\n \n        for t in T[3:]:\n            d, m = divmod(t, 3)\n            if m == 0:\n                if p <= d:\n                    y += 1\n                elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:\n                    y += 1\n                    S -= 1\n            elif m == 1:\n                if p <= d + 1:\n                    y += 1\n            else:\n                if p <= d + 1:\n                    y += 1\n                elif p <= d + 2 and S:\n                    y += 1\n                    S -= 1\n \n        print(\"Case #{:d}: {:d}\".format(X, y))\n \nif __name__==\"__main__\":\n    main()\n"}
{"author": "imakaramegane", "index": 2, "filename": "2013_2270488_2453486.py", "code": "# coding: utf-8\nimport sys\nfrom itertools import groupby\n \ndef testcases():\n    with open(sys.argv[1], \"r\") as f:\n        T = int(f.readline())\n        for X in range(1, T + 1):\n            BOARD = [\n                f.readline().strip(),\n                f.readline().strip(),\n                f.readline().strip(),\n                f.readline().strip(),\n            ]\n            f.readline()\n            yield X, BOARD\n \ndef main():\n    for X, BOARD in testcases():\n        points = [0] * 10\n        for iR, cols in enumerate(BOARD):\n            cols = list( p(c) for c in cols )\n \n            # \n            points[iR] = sum(cols)\n \n            # c\n            for iC, c in enumerate(cols):\n                points[4 + iC] += c  # c\n \n            # ΂\n            points[8] += cols[0 + iR]\n            points[9] += cols[3 - iR]\n \n        status = \"Draw\"\n        for pp in points:\n            if pp >= 1000:\n                status = \"Game has not completed\"\n            elif pp in (4, 103):\n                status = \"X won\"\n                break\n            elif pp in (40, 130):\n                status = \"O won\"\n                break\n \n        print(\"Case #{}: {}\".format(X, status))\n \n \ndef p(c):\n    if  c == 'X':\n        return 1\n    elif c == 'O':\n        return 10\n    elif c == 'T':\n        return 100\n    else:\n        return 1000\n \nif __name__==\"__main__\":\n    main()\n"}
{"author": "imakaramegane", "index": 2, "filename": "2013_2270488_2449486.py", "code": "# coding: utf-8\nimport sys\nimport os.path\nfrom itertools import groupby\n \ndef read(f):\n    return list( int(v) for v in f.readline().split() )\n \ndef answer(f, X, ans):\n    out = \"Case #{}: {}\".format(X, ans)\n    f.write(out)\n    f.write(\"\\n\")\n    print(out)\n \ndef testcases(f):\n    T = int(f.readline())\n    for X in range(1, T + 1):\n        N, M = read(f)\n        GRASS = []\n        for n in range(N):\n            GRASS.append( read(f) )\n        result = yield X, N, M, GRASS\n \ndef main(inf, outf):\n    for X, N, M, GRASS in testcases(inf):\n        maxN = list( max(gn) for gn in GRASS )\n        maxM = list( max( gn[m] for gn in GRASS ) for m in range(M) )\n \n        ans = \"YES\"\n        for n, m in ( (n, m) for m in range(M) for n in range(N) ):\n            if ( GRASS[n][m] < maxN[n] and\n                GRASS[n][m] < maxM[m] ):\n                ans = \"NO\"\n                break\n         \n        answer(outf, X, ans)\n \nif __name__==\"__main__\":\n    infname = sys.argv[1]\n    outfname = os.path.splitext(infname)[0] + \".out\"\n    with open(infname, \"r\") as inf:\n        with open(outfname, \"w\") as outf:\n            main(inf, outf)\n"}
{"author": "imakaramegane", "index": 2, "filename": "2012_1460488_1483485.py", "code": "import sys\n \ndef testcases():\n    with open(sys.argv[1], \"r\") as f:\n        f.readline()  # skip number of testcases\n        for X, T in enumerate(f, 1):\n            yield X, T[:-1]\n \ndef main():\n    for X, T in testcases():\n        tbl = str.maketrans(\"abcdefghijklmnopqrstuvwxyz\",\n                            \"yhesocvxduiglbkrztnwjpfmaq\")\n        S = T.translate(tbl)\n        print(\"Case #{:d}: {}\".format(X, S))\n \nif __name__==\"__main__\":\n    main()\n   \n"}
{"author": "imakaramegane", "index": 2, "filename": "2013_2270488_2463486.py", "code": "# coding: utf-8\nimport sys\nimport os.path\nimport itertools\nfrom itertools import groupby\n \ndef read(f):\n    return list( int(v) for v in f.readline().split() )\n \ndef answer(f, X, ans):\n    out = \"Case #{}: {}\".format(X, ans)\n    f.write(out)\n    f.write(\"\\n\")\n    print(out)\n \ndef testcases(f):\n    T = int(f.readline())\n    for X in range(1, T + 1):\n        A, B = read(f)\n        yield X, A, B\n \ndef ispalindrome(v):\n    s = str(v)\n    for i in range(len(s) // 2):\n        if s[i] != s[-i-1]:\n            return False\n    return True\n \ndef main(inf, outf):\n    MAX = 1000\n    fslst = []\n    for i in itertools.count():\n        if ispalindrome(i):\n            squere = i * i\n            print(MAX, squere, ispalindrome(squere))\n            if squere > MAX:\n                break\n            if ispalindrome(squere):\n                fslst.append(squere)\n    for X, A, B in testcases(inf):\n        cnt = 0\n        for fs in fslst:\n            if A <= fs <= B:\n                cnt += 1\n        answer(outf, X, cnt)\n \nif __name__==\"__main__\":\n    infname = sys.argv[1]\n    outfname = os.path.splitext(infname)[0] + \".out\"\n    with open(infname, \"r\") as inf:\n        with open(outfname, \"w\") as outf:\n            main(inf, outf)\n"}
{"author": "imakaramegane", "index": 2, "filename": "2014_2974486_5756407898963968.py", "code": "# coding: utf-8\nimport sys\nimport os.path\nimport itertools\nfrom itertools import groupby\nimport math\n \ndef debug(v):\n    pass #print(v)\n \ndef read(f):\n    t = tuple(int(v) for v in f.readline().split())\n    debug(t)\n    return t\n \ndef answer(f, X, ans):\n    out = \"Case #{}: {}\".format(X, ans)\n    f.write(out)\n    f.write(\"\\n\")\n    print(out)\n \n \n \ndef main(inf, outf):\n    T, = read(inf)\n    for X in range(1, T + 1):\n        row1, = read(inf)\n        cards1 = tuple(read(inf) for i in range(4))\n        row2, = read(inf)\n        cards2 = tuple(read(inf) for i in range(4))\n \n        kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n \n        if kouho:\n            if len(kouho) == 1:\n                ans = kouho.pop()\n            else:\n                ans = \"Bad magician!\"\n        else:\n            ans = \"Volunteer cheated!\"\n \n        answer(outf, X, ans)\n \n \nif __name__==\"__main__\":\n    infname = sys.argv[1]\n    outfname = os.path.splitext(infname)[0] + \".out\"\n    with open(infname, \"r\") as inf:\n        with open(outfname, \"w\") as outf:\n            main(inf, outf)\n"}
{"author": "serialk", "index": 3, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\n \nsys.setrecursionlimit(9299999)\n \ndef min_time(C, F, X, speed, nb_cookies):\n\tif (X - nb_cookies) / speed < (X - (nb_cookies - C)) / (speed + F):\n\t\treturn (X - nb_cookies) / speed\n\telif nb_cookies >= C:\n\t\treturn min_time(C, F, X, speed + F, nb_cookies - C)\n\telse:\n\t\treturn (C - nb_cookies) / speed + min_time(C, F, X, speed, C)\n \nT = int(raw_input())\nfor i in range(T):\n\tC, F, X = map(float, raw_input().split())\n\tprint('Case #%d: %f' % (i + 1, min_time(C, F, X, 2, 0)))\n"}
{"author": "serialk", "index": 3, "filename": "2014_2974486_5690574640250880.py", "code": "CACHE = {(1, 1, 0): ['c'],\n(1, 2, 0): ['c.'],\n(1, 2, 1): ['*c'],\n(1, 3, 0): ['c..'],\n(1, 3, 1): ['*.c'],\n(1, 3, 2): ['**c'],\n(1, 4, 0): ['c...'],\n(1, 4, 1): ['*.c.'],\n(1, 4, 2): ['**.c'],\n(1, 4, 3): ['***c'],\n(1, 5, 0): ['c....'],\n(1, 5, 1): ['*.c..'],\n(1, 5, 2): ['**.c.'],\n(1, 5, 3): ['***.c'],\n(1, 5, 4): ['****c'],\n(2, 1, 0): ['c', '.'],\n(2, 1, 1): ['*', 'c'],\n(2, 2, 0): ['c.', '..'],\n(2, 2, 1): None,\n(2, 2, 2): None,\n(2, 2, 3): ['**', '*c'],\n(2, 3, 0): ['c..', '...'],\n(2, 3, 1): None,\n(2, 3, 2): ['*.c', '*..'],\n(2, 3, 3): None,\n(2, 3, 4): None,\n(2, 3, 5): ['***', '**c'],\n(2, 4, 0): ['c...', '....'],\n(2, 4, 1): None,\n(2, 4, 2): ['*.c.', '*...'],\n(2, 4, 3): None,\n(2, 4, 4): ['**.c', '**..'],\n(2, 4, 5): None,\n(2, 4, 6): None,\n(2, 4, 7): ['****', '***c'],\n(2, 5, 0): ['c....', '.....'],\n(2, 5, 1): None,\n(2, 5, 2): ['*.c..', '*....'],\n(2, 5, 3): None,\n(2, 5, 4): ['**.c.', '**...'],\n(2, 5, 5): None,\n(2, 5, 6): ['***.c', '***..'],\n(2, 5, 7): None,\n(2, 5, 8): None,\n(2, 5, 9): ['*****', '****c'],\n(3, 1, 0): ['c', '.', '.'],\n(3, 1, 1): ['*', '.', 'c'],\n(3, 1, 2): ['*', '*', 'c'],\n(3, 2, 0): ['c.', '..', '..'],\n(3, 2, 1): None,\n(3, 2, 2): ['**', '..', 'c.'],\n(3, 2, 3): None,\n(3, 2, 4): None,\n(3, 2, 5): ['**', '**', '*c'],\n(3, 3, 0): ['c..', '...', '...'],\n(3, 3, 1): ['*.c', '...', '...'],\n(3, 3, 2): None,\n(3, 3, 3): ['***', '...', 'c..'],\n(3, 3, 4): None,\n(3, 3, 5): ['***', '*..', '*.c'],\n(3, 3, 6): None,\n(3, 3, 7): None,\n(3, 3, 8): ['***', '***', '**c'],\n(3, 4, 0): ['c...', '....', '....'],\n(3, 4, 1): ['*.c.', '....', '....'],\n(3, 4, 2): ['**.c', '....', '....'],\n(3, 4, 3): ['*.c.', '*...', '*...'],\n(3, 4, 4): ['****', '....', 'c...'],\n(3, 4, 5): None,\n(3, 4, 6): ['****', '*...', '*.c.'],\n(3, 4, 7): None,\n(3, 4, 8): ['****', '**..', '**.c'],\n(3, 4, 9): None,\n(3, 4, 10): None,\n(3, 4, 11): ['****', '****', '***c'],\n(3, 5, 0): ['c....', '.....', '.....'],\n(3, 5, 1): ['*.c..', '.....', '.....'],\n(3, 5, 2): ['**.c.', '.....', '.....'],\n(3, 5, 3): ['***.c', '.....', '.....'],\n(3, 5, 4): ['**.c.', '*....', '*....'],\n(3, 5, 5): ['*****', '.....', 'c....'],\n(3, 5, 6): ['**.c.', '**...', '**...'],\n(3, 5, 7): ['*****', '*....', '*.c..'],\n(3, 5, 8): None,\n(3, 5, 9): ['*****', '**...', '**.c.'],\n(3, 5, 10): None,\n(3, 5, 11): ['*****', '***..', '***.c'],\n(3, 5, 12): None,\n(3, 5, 13): None,\n(3, 5, 14): ['*****', '*****', '****c'],\n(4, 1, 0): ['c', '.', '.', '.'],\n(4, 1, 1): ['*', '.', 'c', '.'],\n(4, 1, 2): ['*', '*', '.', 'c'],\n(4, 1, 3): ['*', '*', '*', 'c'],\n(4, 2, 0): ['c.', '..', '..', '..'],\n(4, 2, 1): None,\n(4, 2, 2): ['**', '..', 'c.', '..'],\n(4, 2, 3): None,\n(4, 2, 4): ['**', '**', '..', 'c.'],\n(4, 2, 5): None,\n(4, 2, 6): None,\n(4, 2, 7): ['**', '**', '**', '*c'],\n(4, 3, 0): ['c..', '...', '...', '...'],\n(4, 3, 1): ['*.c', '...', '...', '...'],\n(4, 3, 2): ['*.c', '*..', '...', '...'],\n(4, 3, 3): ['***', '...', 'c..', '...'],\n(4, 3, 4): ['***', '*..', '..c', '...'],\n(4, 3, 5): None,\n(4, 3, 6): ['***', '***', '...', 'c..'],\n(4, 3, 7): None,\n(4, 3, 8): ['***', '***', '*..', '*.c'],\n(4, 3, 9): None,\n(4, 3, 10): None,\n(4, 3, 11): ['***', '***', '***', '**c'],\n(4, 4, 0): ['c...', '....', '....', '....'],\n(4, 4, 1): ['*.c.', '....', '....', '....'],\n(4, 4, 2): ['**.c', '....', '....', '....'],\n(4, 4, 3): ['**.c', '*...', '....', '....'],\n(4, 4, 4): ['****', '....', 'c...', '....'],\n(4, 4, 5): ['****', '*...', '..c.', '....'],\n(4, 4, 6): ['****', '**..', '...c', '....'],\n(4, 4, 7): ['****', '*...', '*.c.', '*...'],\n(4, 4, 8): ['****', '****', '....', 'c...'],\n(4, 4, 9): None,\n(4, 4, 10): ['****', '****', '*...', '*.c.'],\n(4, 4, 11): None,\n(4, 4, 12): ['****', '****', '**..', '**.c'],\n(4, 4, 13): None,\n(4, 4, 14): None,\n(4, 4, 15): ['****', '****', '****', '***c'],\n(4, 5, 0): ['c....', '.....', '.....', '.....'],\n(4, 5, 1): ['*.c..', '.....', '.....', '.....'],\n(4, 5, 2): ['**.c.', '.....', '.....', '.....'],\n(4, 5, 3): ['***.c', '.....', '.....', '.....'],\n(4, 5, 4): ['***.c', '*....', '.....', '.....'],\n(4, 5, 5): ['*****', '.....', 'c....', '.....'],\n(4, 5, 6): ['*****', '*....', '..c..', '.....'],\n(4, 5, 7): ['*****', '**...', '...c.', '.....'],\n(4, 5, 8): ['*****', '***..', '....c', '.....'],\n(4, 5, 9): ['*****', '**...', '*..c.', '*....'],\n(4, 5, 10): ['*****', '*****', '.....', 'c....'],\n(4, 5, 11): ['*****', '**...', '**.c.', '**...'],\n(4, 5, 12): ['*****', '*****', '*....', '*.c..'],\n(4, 5, 13): None,\n(4, 5, 14): ['*****', '*****', '**...', '**.c.'],\n(4, 5, 15): None,\n(4, 5, 16): ['*****', '*****', '***..', '***.c'],\n(4, 5, 17): None,\n(4, 5, 18): None,\n(4, 5, 19): ['*****', '*****', '*****', '****c'],\n(5, 1, 0): ['c', '.', '.', '.', '.'],\n(5, 1, 1): ['*', '.', 'c', '.', '.'],\n(5, 1, 2): ['*', '*', '.', 'c', '.'],\n(5, 1, 3): ['*', '*', '*', '.', 'c'],\n(5, 1, 4): ['*', '*', '*', '*', 'c'],\n(5, 2, 0): ['c.', '..', '..', '..', '..'],\n(5, 2, 1): None,\n(5, 2, 2): ['**', '..', 'c.', '..', '..'],\n(5, 2, 3): None,\n(5, 2, 4): ['**', '**', '..', 'c.', '..'],\n(5, 2, 5): None,\n(5, 2, 6): ['**', '**', '**', '..', 'c.'],\n(5, 2, 7): None,\n(5, 2, 8): None,\n(5, 2, 9): ['**', '**', '**', '**', '*c'],\n(5, 3, 0): ['c..', '...', '...', '...', '...'],\n(5, 3, 1): ['*.c', '...', '...', '...', '...'],\n(5, 3, 2): ['*.c', '*..', '...', '...', '...'],\n(5, 3, 3): ['***', '...', 'c..', '...', '...'],\n(5, 3, 4): ['***', '*..', '..c', '...', '...'],\n(5, 3, 5): ['***', '*..', '*.c', '...', '...'],\n(5, 3, 6): ['***', '***', '...', 'c..', '...'],\n(5, 3, 7): ['***', '***', '*..', '..c', '...'],\n(5, 3, 8): None,\n(5, 3, 9): ['***', '***', '***', '...', 'c..'],\n(5, 3, 10): None,\n(5, 3, 11): ['***', '***', '***', '*..', '*.c'],\n(5, 3, 12): None,\n(5, 3, 13): None,\n(5, 3, 14): ['***', '***', '***', '***', '**c'],\n(5, 4, 0): ['c...', '....', '....', '....', '....'],\n(5, 4, 1): ['*.c.', '....', '....', '....', '....'],\n(5, 4, 2): ['**.c', '....', '....', '....', '....'],\n(5, 4, 3): ['**.c', '*...', '....', '....', '....'],\n(5, 4, 4): ['****', '....', 'c...', '....', '....'],\n(5, 4, 5): ['****', '*...', '..c.', '....', '....'],\n(5, 4, 6): ['****', '**..', '...c', '....', '....'],\n(5, 4, 7): ['****', '**..', '*..c', '....', '....'],\n(5, 4, 8): ['****', '****', '....', 'c...', '....'],\n(5, 4, 9): ['****', '****', '*...', '..c.', '....'],\n(5, 4, 10): ['****', '****', '**..', '...c', '....'],\n(5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],\n(5, 4, 12): ['****', '****', '****', '....', 'c...'],\n(5, 4, 13): None,\n(5, 4, 14): ['****', '****', '****', '*...', '*.c.'],\n(5, 4, 15): None,\n(5, 4, 16): ['****', '****', '****', '**..', '**.c'],\n(5, 4, 17): None,\n(5, 4, 18): None,\n(5, 4, 19): ['****', '****', '****', '****', '***c'],\n(5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],\n(5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],\n(5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],\n(5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],\n(5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],\n(5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],\n(5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],\n(5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],\n(5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],\n(5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],\n(5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],\n(5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],\n(5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],\n(5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],\n(5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],\n(5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],\n(5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],\n(5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],\n(5, 5, 18): None,\n(5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],\n(5, 5, 20): None,\n(5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],\n(5, 5, 22): None,\n(5, 5, 23): None,\n(5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}\n \n \nT = int(input())\nfor i in range(T):\n\tR, C, M = map(int, input().split())\n\tprint('Case #{}:'.format(i + 1))\n\ttry:\n\t\tprint('\\n'.join(CACHE[(R, C, M)]))\n\texcept:\n\t\tprint('Impossible')\n"}
{"author": "serialk", "index": 3, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/env python2.7\n \nT = int(raw_input())\nfor i in xrange(T):\n    values = map(int, raw_input().split())\n    [N,s,p] = values[0:3]\n    t = values[3:]\n    answer = 0\n    for note in t:\n        if note < 2:\n            if note >= p:\n                answer += 1\n        elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n            answer += 1\n        elif note % 3 == 0:\n            n = note / 3\n            if n >= p:\n                answer += 1\n            elif s > 0 and n + 1 >= p:\n                answer += 1\n                s -= 1\n        elif note % 3 == 2:\n            n = (note - 2) / 3\n            if n + 1 >= p:\n                answer += 1\n            elif s > 0 and n + 2 >= p:\n                answer += 1\n                s -= 1\n    print('Case #{0}: {1}'.format(i+1, answer))\n"}
{"author": "serialk", "index": 3, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python3\n# -*- encoding: utf-8 -*-\n \n \ndef who_won(l):\n    current = None\n    for i in l:\n        if i == '.':\n            return None\n        if not current and i in 'OX':\n            current = i\n        if current and current != i and i != 'T':\n            return None\n    return current\n \n \ndef f(m):\n    still = False\n    for i in m:\n        for j in i:\n            if j == '.':\n                still = True\n \n    rows = m # [[m[i][j] for i in range(4)] for j in range(4)]\n    cols = [[m[i][j] for i in range(4)] for j in range(4)]\n    diag = [[m[i][i] for i in range(4)], [m[3-i][i] for i in range(4)]]\n \n    winner = None\n \n    for l in rows + cols + diag:\n        c = who_won(l)\n        if c:\n            winner = c + ' won'\n \n    if not winner:\n        if still:\n            winner = 'Game has not completed'\n        else:\n            winner = 'Draw'\n    return winner\n \nif __name__ == '__main__':\n    T = int(input())\n    for i in range(T):\n        m = [list(input()) for k in range(4)]\n        if i != T- 1:\n            input()\n        r = f(m)\n        print('Case #{}: {}'.format(i+1, r))\n"}
{"author": "serialk", "index": 3, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/env python3\n# -*- encoding: utf-8 -*-\n \n \ndef f(m):\n    max_cols = []\n    for e in zip(*m):\n        max_cols.append(max(e))\n \n    for r in m:\n        max_row = max(r)\n        for y, c in enumerate(r):\n            if c != max_row and c != max_cols[y]:\n                return 'NO'\n    return 'YES'\n \nif __name__ == '__main__':\n    T = int(input())\n    for i in range(T):\n        n, m = map(int, input().split())\n        r = f([input().split() for i in range(n)])\n        print('Case #{}: {}'.format(i+1, r))\n"}
{"author": "serialk", "index": 3, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/env python2.6\n \ntranslate = {'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'q': 'z', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm', 'z': 'q'}\n \nnb = int(raw_input())\nfor i in xrange(nb):\n    s = ''.join([translate[char] if char in translate.keys() else char for char in str(raw_input())])\n    print('Case #{0}:'.format(i+1), s)\n"}
{"author": "serialk", "index": 3, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/env python3\n# -*- encoding: utf-8 -*-\n \nfrom math import sqrt\n \ndef is_palindromic(i):\n    n = i\n    rev = 0\n    while i > 0:\n        dig = i % 10\n        rev = rev * 10 + dig\n        i = i // 10\n    return n == rev\n \ndef is_square(i):\n    if i == 1:\n        return True\n    x = i // 2\n    seen = set([x])\n    while x * x != i:\n        x = (x + (i // x)) // 2\n        if x in seen:\n            return False\n        seen.add(x)\n    return True\n \ndef f(a, b):\n    tot = 0\n \n    sra = a\n    while not is_square(sra):\n        sra += 1\n    srb = b\n    while not is_square(srb):\n        srb -= 1\n \n    sra = int(sqrt(sra))\n    srb = int(sqrt(srb))\n \n    for i in range(sra, srb+1):\n        if is_palindromic(i) and is_palindromic(i ** 2):\n            tot += 1\n \n    return tot\n \nif __name__ == '__main__':\n    T = int(input())\n    for i in range(T):\n        a, b = map(int, input().split())\n        r = f(a, b)\n        print('Case #{}: {}'.format(i+1, r))\n"}
{"author": "serialk", "index": 3, "filename": "2014_2974486_5756407898963968.py", "code": "T = int(input())\n \nfor i in range(T):\n    a1 = int(input())\n    mat1 = [list(map(int, input().split())) for k in range(4)]\n    a2 = int(input())\n    mat2 = [list(map(int, input().split())) for k in range(4)]\n    final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])\n    if not len(final_set):\n        s = 'Volunteer cheated!'\n    elif len(final_set) > 1:\n        s = 'Bad magician!'\n    else:\n        s = list(final_set)[0]\n    print('Case #{}: {}'.format(i + 1, s))\n"}
{"author": "j4b", "index": 4, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\nimport math\nfrom itertools import chain, combinations\nfrom heapq import heappop, heappush, _siftup\n \ndef solve(C, F, X):\n    rate = 2.0\n    time_to_win = X / rate\n \n    time_used = C / rate\n    rate += F\n    time_to_win_new = time_used + X / rate\n \n    while time_to_win_new < time_to_win:\n        time_to_win = time_to_win_new\n         \n        time_used += C / rate\n        rate += F\n        time_to_win_new = time_used + X / rate\n \n    return time_to_win\n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        [C, F, X] = [float(x) for x in sys.stdin.readline().rstrip().split()]\n \n        result = solve(C, F, X)\n        print((\"Case #%s: %.7f\" % (i+1, result)))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "j4b", "index": 4, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\nimport math\nfrom itertools import chain, combinations\nfrom heapq import heappop, heappush, _siftup\n \ndef neighbours(grid, pos, n, m):\n    i, j = pos\n    for a in range(max(i-1, 0), min(i+2, n)):\n        for b in range(max(j-1, 0), min(j+2, m)):\n            if (a != i or b != j):\n                yield (a, b)\n \ndef isGridCorrect(grid):\n    g = list(grid)\n    n = len(g)\n    m = len(g[0])\n    queue = [(0, 0)]\n \n    while queue:\n        v = queue.pop(0)\n        g[v[0]][v[1]] = 'r'\n        bomb = False\n        for (i, j) in neighbours(g, v, n, m):\n            if g[i][j] == '*':\n                bomb = True\n        if not bomb:\n            for (i, j) in neighbours(g, v, n, m):\n                if g[i][j] != 'r':\n                    #print('append')\n                    queue.append((i, j))\n \n    for i in range(n):\n        for j in range(m):\n            if g[i][j] != 'r' and g[i][j] != '*':\n                #print draw(g)\n                return 'WRONG'\n \n    return 'Right'\n \ndef createGrid(R, C, s):\n    field = []\n    for i in range(R):\n        field.append([s] * C)\n    field[0][0] = 'c'\n    return field\n \ndef draw(grid):\n    s = \"\"\n    for row in grid:\n        s += \"\\n\" + ''.join(row)\n    return s\n \ndef reduceRows(grid, k, l, M):\n    if k <= 2:\n        return (grid, k, l, M)\n     \n    #num_rows = M / l\n    #lowest = max(k - num_rows, 2)\n    #num_rows = k - lowest\n \n    #print('k: ' + str(k))\n    #print('l: ' + str(l))\n    for j in range(l):\n        #print grid\n        #print i, j\n        grid[k-1][j] = '*'\n    k -= 1\n    M -= l\n    return (grid, k, l, M)\n \ndef reduceCols(grid, k, l, M):\n    if l <= 2:\n        return (grid, k, l, M)\n     \n    #num_cols = M / k\n    #lowest = max(l - num_cols, 2)\n    #num_cols = l - lowest\n \n    for i in range(k):\n        grid[i][l-1] = '*'\n    l -= 1\n    M -= k\n    return (grid, k, l, M)\n \ndef solve(R, C, M):\n    mp = M\n    if M == 0:\n        f = createGrid(R, C, '.')\n        #print(isGridCorrect(f))\n        return draw(f)\n    elif M == R*C - 1:\n        f = createGrid(R, C, '*')\n        #print(isGridCorrect(f))\n        return draw(f)\n    elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):\n        return \"\\n\" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n    elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):\n        return \"\\n\" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n    else:\n        grid = createGrid(R, C, '.')\n \n        #print('R: ' + str(R))\n        #print('C: ' + str(C))\n \n        k = R\n        l = C\n \n        while (M >= l and k > 2) or (M >= k and l > 2):\n            if l >= k:\n                #print('l >= k')\n                (grid, k, l, M) = reduceCols(grid, k, l, M)\n                #print grid\n                #print k, l, M\n            elif k > l:\n                #print('k > l')\n                (grid, k, l, M) = reduceRows(grid, k, l, M)\n                #print grid\n                #print k, l, M\n \n        #print(grid)\n        #print M\n \n        if M == 0:\n            #print(isGridCorrect(grid))\n            return draw(grid)\n        if M < l - 1 and k > 2:\n            for j in range(l - M, l):\n                grid[k-1][j] = '*'\n        elif M < k - 1 and l > 2:\n            for i in range(k - M, k):\n                grid[i][l-1] = '*'\n        elif l > 3 and k > 3:\n            for i in range(2, k):\n                grid[i][l-1] = '*'\n            M -= k - 2\n            for j in range(l - M - 1, l - 1):\n                grid[k-1][j] = '*'\n        else:\n            return \"\\n\" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n \n        #print(isGridCorrect(grid))\n        return draw(grid)\n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n \n        result = solve(R, C, M)\n        print (\"Case #%s:%s\" % (i+1, result))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "j4b", "index": 4, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\n \n \ndef solve(num_surprises, p, ts):\n    s = 0\n    u = 0\n    for t in ts:\n        a = int(t/3)\n        r = t % 3\n        if a+1 >= p and not r == 0:\n            u += 1\n        elif a >= p and r == 0:\n            u += 1\n        elif a > 0 and a+1 >= p and r == 0:\n            s += 1\n        elif a+2 >= p and r == 2:\n            s += 1\n \n    return min(num_surprises, s) + u\n         \n         \n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        line = [int(x) for x in sys.stdin.readline().split()]\n        num_surprises = line[1]\n        p = line[2]\n        ts = line[3:]\n        result = solve(num_surprises, p, ts)\n        print((\"Case #%s: %s\" % (i+1, result)))\n \n \nif __name__ == '__main__':\n    main()\n"}
{"author": "j4b", "index": 4, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\n \ndef result(l):\n    xcount = 0\n    ocount = 0\n    empty = False\n    for field in l:\n        if field == 'X' or field == 'T':\n            xcount += 1\n        if field == 'O' or field == 'T':\n            ocount += 1\n        if field == '.':\n            empty = True\n \n    if xcount == 4:\n        return 'X'\n    if ocount == 4:\n        return 'O'\n    if empty:\n        return '.'\n    else:\n        return ''\n \ndef solve(M):\n    # check rows\n    empty = False\n    for i in range(4):\n        r = result(M[i])\n        if (r == 'X' or r == 'O'):\n            return r + ' won'\n        if r == '.':\n            empty = True\n \n    # check columns\n    for i in range(4):\n        r = result([M[j][i] for j in range(4)])\n        if (r == 'X' or r == 'O'):\n            return r + ' won'\n \n    # check diagonals\n    r = result([M[i][i] for i in range(4)])\n    if (r == 'X' or r == 'O'):\n        return r + ' won'\n    r = result([M[i][3-i] for i in range(4)])\n    if (r == 'X' or r == 'O'):\n        return r + ' won'\n \n    # determine whether it's a draw\n    if empty:\n        return 'Game has not completed'\n    else:\n        return 'Draw'\n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        M = []\n        for j in range(4):\n            M += [list(sys.stdin.readline().rstrip())]\n        sys.stdin.readline()\n        result = solve(M)\n        print((\"Case #%s: %s\" % (i+1, result)))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "j4b", "index": 4, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\n \ndef solve(M, a, b):\n    rowmax = [max(r) for r in M]\n    colmax = [max([M[j][i] for j in range(a)]) for i in range(b)]\n    rowmin = [min(r) for r in M]\n    colmin = [min([M[j][i] for j in range(a)]) for i in range(b)]\n \n    for i in range(a):\n        for j in range(b):\n            if M[i][j] != min(rowmax[i], colmax[j]):\n                return 'NO'\n    return 'YES'\n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n        M = []\n        for j in range(a):\n            M += [[int(x) for x in sys.stdin.readline().split()]]\n        result = solve(M, a, b)\n        print((\"Case #%s: %s\" % (i+1, result)))\n \n \nif __name__ == '__main__':\n    main()\n"}
{"author": "j4b", "index": 4, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\n \n \ntable = {'a': 'y',\n        'b': 'h',\n        'c': 'e',\n        'd': 's',\n        'e': 'o',\n        'f': 'c',\n        'g': 'v',\n        'h': 'x',\n        'i': 'd',\n        'j': 'u',\n        'k': 'i',\n        'l': 'g',\n        'm': 'l',\n        'n': 'b',\n        'o': 'k',\n        'p': 'r',\n        'q': 'z',\n        'r': 't',\n        's': 'n',\n        't': 'w',\n        'u': 'j',\n        'v': 'p',\n        'w': 'f',\n        'x': 'm',\n        'y': 'a',\n        'z': 'q',\n        ' ': ' ',\n        '\\n': ''}\n \ndef solve(s):\n    return ''.join([table[c] for c in s])\n         \n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        # use something like:\n        # sys.stdin.readline()\n        # [int(x) for x in sys.stdin.readline().split()]\n        result = solve(sys.stdin.readline())\n        print((\"Case #%s: %s\" % (i+1, result)))\n \n \nif __name__ == '__main__':\n    main()\n"}
{"author": "j4b", "index": 4, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\nimport math\n \ndef isPal(n):\n    l = str(n)\n    return l == l[::-1]\n \ndef solve(a, b):\n    l = int(math.ceil(math.sqrt(a)))\n    u = int(math.floor(math.sqrt(b)))\n \n    count = 0\n    for x in range(l, u + 1):\n        if isPal(x):\n            if isPal(x*x):\n                count += 1\n    return str(count)\n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n        result = solve(a, b)\n        print((\"Case #%s: %s\" % (i+1, result)))\n \n        # use something like:\n        # sys.stdin.readline()\n        # [int(x) for x in sys.stdin.readline().split()]\n \n \nif __name__ == '__main__':\n    main()\n"}
{"author": "j4b", "index": 4, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\nimport math\nfrom itertools import chain, combinations\nfrom heapq import heappop, heappush, _siftup\n \ndef solve(row1, row2):\n    common = [x for x in row1 if x in row2]\n    num_common = len(common)\n    if num_common == 0:\n        return 'Volunteer cheated!'\n    elif num_common > 1:\n        return 'Bad magician!'\n    else:\n        return common[0]\n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        row_index1 = int(sys.stdin.readline())\n        row1 = list()\n        for j in range(4):\n            if row_index1 == j + 1:\n                row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n            else:\n                sys.stdin.readline()\n \n        row_index2 = int(sys.stdin.readline())\n        row2 = list()\n        for j in range(4):\n            if row_index2 == j + 1:\n                row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n            else:\n                sys.stdin.readline()\n \n        result = solve(row1, row2)\n        print((\"Case #%s: %s\" % (i+1, result)))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "argaen", "index": 5, "filename": "2014_2974486_5709773144064000.py", "code": "t = int(raw_input())\n \nfor case in range(t):\n \n\tc, f, x = raw_input().split()\n\tc = float(c)\n\tf = float(f)\n\tx = float(x)\n \n\tt = 0\n\tcps = 2.0\n\twhile c/cps < x/cps and t+x/cps > t+c/cps + x/(cps+f):\n\t\t# print(t, c/cps, x/cps)\n\t\tt += c/cps\n\t\tcps += f\n\t\t# raw_input()\n \n\tt += x/cps\n \n\tprint('Case #'+str(case+1)+':', t)\n"}
{"author": "argaen", "index": 5, "filename": "2014_2974486_5690574640250880.py", "code": "t = int(raw_input())\n \nfor case in range(t):\n\tprint('Case #'+str(case+1)+':')\n\tr, c, m = raw_input().split()\n\tr = int(r)\n\tc = int(c)\n\tm = int(m)\n \n\tif m==0:\n\t\tprint('c' + ('.'*(c-1)))\n\t\tfor i in range(r-1):\n\t\t\tprint('.'*c)\n\telif r == 1:\n\t\tprint('c'+('.'*(c-m-1))+('*'*(m)))\n\telif c == 1:\n\t\tprint('c')\n\t\tfor i in range(r-m-1):\n\t\t\tprint('.')\n\t\tfor i in range(m):\n\t\t\tprint('*')\n\telif r == 2:\n\t\tif m%2==0 and c>2 and m<r*c-2:\n\t\t\tprint('c'+('.'*(c-m/2-1))+('*'*(m/2)))\n\t\t\tprint(('.'*(c-m/2))+('*'*(m/2)))\n\t\telif m == r*c - 1:\n\t\t\tprint('c'+('*'*(c-1)))\n\t\t\tprint('*'*c)\n\t\telse:\n\t\t\tprint('Impossible')\n\telif c == 2:\n\t\tif m%2==0 and r>2 and m<r*c-2:\n\t\t\tprint('c.')\n\t\t\tfor i in range(r-m/2-1):\n\t\t\t\tprint('..')\n\t\t\tfor i in range(m/2):\n\t\t\t\tprint('**')\n\t\telif m == r*c - 1:\n\t\t\tprint('c*')\n\t\t\tfor i in range(r-1):\n\t\t\t\tprint('**')\n\t\telse:\n\t\t\tprint('Impossible')\n\telif c == 3 and r == 3:\n\t\tif m == 1:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('..*')\n\t\telif m == 2:\n\t\t\tprint('Impossible')\n\t\telif m == 3:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('***')\n\t\telif m == 4:\n\t\t\tprint('Impossible')\n\t\telif m == 5:\n\t\t\tprint('c.*')\n\t\t\tprint('..*')\n\t\t\tprint('***')\n\t\telif m == 6:\n\t\t\tprint('Impossible')\n\t\telif m == 7:\n\t\t\tprint('Impossible')\n\t\telif m == 8:\n\t\t\tprint('c**')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\telif c == 3 and r == 4:\n\t\tif m == 1:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('...')\n\t\t\tprint('..*')\n\t\telif m == 2:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('..*')\n\t\t\tprint('..*')\n\t\telif m == 3:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('...')\n\t\t\tprint('***')\n\t\telif m == 4:\n\t\t\tprint('c.*')\n\t\t\tprint('..*')\n\t\t\tprint('..*')\n\t\t\tprint('..*')\n\t\telif m == 5:\n\t\t\tprint('Impossible')\n\t\telif m == 6:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\telif m == 7:\n\t\t\tprint('Impossible')\n\t\telif m == 8:\n\t\t\tprint('c.*')\n\t\t\tprint('..*')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\telif m == 9:\n\t\t\tprint('Impossible')\n\t\telif m == 10:\n\t\t\tprint('Impossible')\n\t\telif m == 11:\n\t\t\tprint('c**')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\telif c == 3 and r == 5:\n\t\tif m == 1:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('...')\n\t\t\tprint('...')\n\t\t\tprint('..*')\n\t\telif m == 2:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('...')\n\t\t\tprint('..*')\n\t\t\tprint('..*')\n\t\telif m == 3:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('..*')\n\t\t\tprint('..*')\n\t\t\tprint('..*')\n\t\telif m == 4:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('...')\n\t\t\tprint('..*')\n\t\t\tprint('***')\n\t\telif m == 5:\n\t\t\tprint('c.*')\n\t\t\tprint('..*')\n\t\t\tprint('..*')\n\t\t\tprint('..*')\n\t\t\tprint('..*')\n\t\telif m == 6:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('...')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\telif m == 7:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('..*')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\telif m == 8:\n\t\t\tprint('Impossible')\n\t\telif m == 9:\n\t\t\tprint('c..')\n\t\t\tprint('...')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\telif m == 10:\n\t\t\tprint('Impossible')\n\t\telif m == 11:\n\t\t\tprint('c.*')\n\t\t\tprint('..*')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\telif m == 12:\n\t\t\tprint('Impossible')\n\t\telif m == 13:\n\t\t\tprint('Impossible')\n\t\telif m == 14:\n\t\t\tprint('c**')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\t\t\tprint('***')\n\telif c == 4 and r == 3:\n\t\tif m == 1:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('...*')\n\t\telif m == 2:\n\t\t\tprint('c...')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\telif m == 3:\n\t\t\tprint('c..*')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\telif m == 4:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('****')\n\t\telif m == 5:\n\t\t\tprint('Impossible')\n\t\telif m == 6:\n\t\t\tprint('c.**')\n\t\t\tprint('..**')\n\t\t\tprint('..**')\n\t\telif m == 7:\n\t\t\tprint('Impossible')\n\t\telif m == 8:\n\t\t\tprint('c.**')\n\t\t\tprint('..**')\n\t\t\tprint('****')\n\t\telif m == 9:\n\t\t\tprint('Impossible')\n\t\telif m == 10:\n\t\t\tprint('Impossible')\n\t\telif m == 11:\n\t\t\tprint('c***')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\telif c == 4 and r == 4:\n\t\tif m == 1:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('...*')\n\t\telif m == 2:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('..**')\n\t\telif m == 3:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('...*')\n\t\t\tprint('..**')\n\t\telif m == 4:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('****')\n\t\telif m == 5:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('...*')\n\t\t\tprint('****')\n\t\telif m == 6:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('..**')\n\t\t\tprint('****')\n\t\telif m == 7:\n\t\t\tprint('c..*')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\t\tprint('****')\n\t\telif m == 8:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\telif m == 9:\n\t\t\tprint('Impossible')\n\t\telif m == 10:\n\t\t\tprint('c.**')\n\t\t\tprint('..**')\n\t\t\tprint('..**')\n\t\t\tprint('****')\n\t\telif m == 11:\n\t\t\tprint('Impossible')\n\t\telif m == 12:\n\t\t\tprint('c.**')\n\t\t\tprint('..**')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\telif m == 13:\n\t\t\tprint('Impossible')\n\t\telif m == 14:\n\t\t\tprint('Impossible')\n\t\telif m == 15:\n\t\t\tprint('c***')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\telif c == 4 and r == 5:\n\t\tif m == 1:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('...*')\n\t\telif m == 2:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('..**')\n\t\telif m == 3:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\telif m == 4:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('****')\n\t\telif m == 5:\n\t\t\tprint('c..*')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\telif m == 6:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('..**')\n\t\t\tprint('****')\n\t\telif m == 7:\n\t\t\tprint('c..*')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\t\tprint('..**')\n\t\t\tprint('..**')\n\t\telif m == 8:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('....')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\telif m == 9:\n\t\t\tprint('c..*')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\t\tprint('..**')\n\t\t\tprint('****')\n\t\telif m == 10:\n\t\t\tprint('c.**')\n\t\t\tprint('..**')\n\t\t\tprint('..**')\n\t\t\tprint('..**')\n\t\t\tprint('..**')\n\t\telif m == 11:\n\t\t\tprint('c..*')\n\t\t\tprint('...*')\n\t\t\tprint('...*')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\telif m == 12:\n\t\t\tprint('c...')\n\t\t\tprint('....')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\telif m == 13:\n\t\t\tprint('Impossible')\n\t\telif m == 14:\n\t\t\tprint('c..*')\n\t\t\tprint('...*')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\telif m == 15:\n\t\t\tprint('Impossible')\n\t\telif m == 16:\n\t\t\tprint('c.**')\n\t\t\tprint('..**')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\telif m == 17:\n\t\t\tprint('Impossible')\n\t\telif m == 18:\n\t\t\tprint('Impossible')\n\t\telif m == 19:\n\t\t\tprint('c***')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\t\t\tprint('****')\n\telif c == 5 and r == 3:\n\t\tif m == 1:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('....*')\n\t\telif m == 2:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('...**')\n\t\telif m == 3:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('..***')\n\t\telif m == 4:\n\t\t\tprint('c...*')\n\t\t\tprint('....*')\n\t\t\tprint('...**')\n\t\telif m == 5:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('*****')\n\t\telif m == 6:\n\t\t\tprint('c..**')\n\t\t\tprint('...**')\n\t\t\tprint('...**')\n\t\telif m == 7:\n\t\t\tprint('c..**')\n\t\t\tprint('...**')\n\t\t\tprint('..***')\n\t\telif m == 8:\n\t\t\tprint('Impossible')\n\t\telif m == 9:\n\t\t\tprint('c.***')\n\t\t\tprint('..***')\n\t\t\tprint('..***')\n\t\telif m == 10:\n\t\t\tprint('Impossible')\n\t\telif m == 11:\n\t\t\tprint('c.***')\n\t\t\tprint('..***')\n\t\t\tprint('*****')\n\t\telif m == 12:\n\t\t\tprint('Impossible')\n\t\telif m == 13:\n\t\t\tprint('Impossible')\n\t\telif m == 14:\n\t\t\tprint('c****')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\telif c == 5 and r == 4:\n\t\tif m == 1:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('....*')\n\t\telif m == 2:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('...**')\n\t\telif m == 3:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('..***')\n\t\telif m == 4:\n\t\t\tprint('c...*')\n\t\t\tprint('....*')\n\t\t\tprint('....*')\n\t\t\tprint('....*')\n\t\telif m == 5:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('*****')\n\t\telif m == 6:\n\t\t\tprint('c...*')\n\t\t\tprint('....*')\n\t\t\tprint('....*')\n\t\t\tprint('..***')\n\t\telif m == 7:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('...**')\n\t\t\tprint('*****')\n\t\telif m == 8:\n\t\t\tprint('c..**')\n\t\t\tprint('...**')\n\t\t\tprint('...**')\n\t\t\tprint('...**')\n\t\telif m == 9:\n\t\t\tprint('c...*')\n\t\t\tprint('....*')\n\t\t\tprint('...**')\n\t\t\tprint('*****')\n\t\telif m == 10:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 11:\n\t\t\tprint('c..**')\n\t\t\tprint('...**')\n\t\t\tprint('...**')\n\t\t\tprint('*****')\n\t\telif m == 12:\n\t\t\tprint('c.***')\n\t\t\tprint('..***')\n\t\t\tprint('..***')\n\t\t\tprint('..***')\n\t\telif m == 13:\n\t\t\tprint('Impossible')\n\t\telif m == 14:\n\t\t\tprint('c.***')\n\t\t\tprint('..***')\n\t\t\tprint('..***')\n\t\t\tprint('*****')\n\t\telif m == 15:\n\t\t\tprint('Impossible')\n\t\telif m == 16:\n\t\t\tprint('c.***')\n\t\t\tprint('..***')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 17:\n\t\t\tprint('Impossible')\n\t\telif m == 18:\n\t\t\tprint('Impossible')\n\t\telif m == 19:\n\t\t\tprint('c****')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\telif c == 5 and r == 5:\n\t\tif m == 1:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('....*')\n\t\telif m == 2:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('...**')\n\t\telif m == 3:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('..***')\n\t\telif m == 4:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('...**')\n\t\t\tprint('...**')\n\t\telif m == 5:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('*****')\n\t\telif m == 6:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('..***')\n\t\t\tprint('..***')\n\t\telif m == 7:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('...**')\n\t\t\tprint('*****')\n\t\telif m == 8:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('..***')\n\t\t\tprint('*****')\n\t\telif m == 9:\n\t\t\tprint('c...*')\n\t\t\tprint('....*')\n\t\t\tprint('....*')\n\t\t\tprint('....*')\n\t\t\tprint('*****')\n\t\telif m == 10:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('.....')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 11:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('....*')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 12:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('...**')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 13:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('..***')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 14:\n\t\t\tprint('c..**')\n\t\t\tprint('...**')\n\t\t\tprint('...**')\n\t\t\tprint('..***')\n\t\t\tprint('*****')\n\t\telif m == 15:\n\t\t\tprint('c....')\n\t\t\tprint('.....')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 16:\n\t\t\tprint('c..**')\n\t\t\tprint('...**')\n\t\t\tprint('...**')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 17:\n\t\t\tprint('c..**')\n\t\t\tprint('...**')\n\t\t\tprint('..***')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 18:\n\t\t\tprint('Impossible')\n\t\telif m == 19:\n\t\t\tprint('c..**')\n\t\t\tprint('...**')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 20:\n\t\t\tprint('Impossible')\n\t\telif m == 21:\n\t\t\tprint('c.***')\n\t\t\tprint('..***')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\telif m == 22:\n\t\t\tprint('Impossible')\n\t\telif m == 23:\n\t\t\tprint('Impossible')\n\t\telif m == 24:\n\t\t\tprint('c****')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\t\t\tprint('*****')\n\telse:\n\t\tprint('Impossible')\n \n"}
{"author": "argaen", "index": 5, "filename": "2012_1460488_1595491.py", "code": "t = int(raw_input())\n \nmax = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n \nfor i in range(t):\n\tline = raw_input().split(' ')\n\tn = int(line[0])\n\ts = int(line[1])\n\tp = int(line[2])\n \n\ttotal = 0\n \n\tfor j in range(3, len(line)):\n\t\tt = int(line[j])\n\t\tif t == 0:\n\t\t\tif p == 0:\n\t\t\t\ttotal += 1\n\t\telif t%3 == 0:\n\t\t\tif t/3 >= p:\n\t\t\t\ttotal +=1\n\t\t\telif t/3 + 1 >= p and s>0:\n\t\t\t\ttotal +=1\n\t\t\t\ts -=1\n\t\telif t%3 == 1:\n\t\t\tif (t+2)/3 >= p:\n\t\t\t\ttotal +=1\n\t\telse:\n\t\t\tif (t+1)/3 >= p:\n\t\t\t\ttotal +=1\n\t\t\telif (t+1)/3 + 1 >= p and s>0:\n\t\t\t\ttotal +=1\n\t\t\t\ts -=1\n \n \n \n\tprint('Case #'+str(i+1)+':', total)\n \n \n"}
{"author": "argaen", "index": 5, "filename": "2013_2270488_2453486.py", "code": "t = int(raw_input())\n \ncode = 'yhesocvxduiglbkrztnwjpfmaq'\n \nfor i in range(t):\n\tl = []\n\tfor j in range(4):\n\t\tl.append(raw_input())\n\tif i != t-1:\n\t\traw_input()\n \n\t# filas\n\tv = False\n\tfin = False\n\tfor li in l:\n\t\tx = True\n\t\to = True\n\t\tfor c in li:\n\t\t\tif c != 'X' and c != 'T':\n\t\t\t\tx = False\n\t\t\tif c != 'O' and c != 'T':\n\t\t\t\to = False\n\t\t\tif c == '.':\n\t\t\t\tv = True\n\t\tif x:\n\t\t\tprint('Case #'+str(i+1)+': X won')\n\t\t\tfin = True\n\t\tif o:\n\t\t\tprint('Case #'+str(i+1)+': O won')\n\t\t\tfin = True\n \n\tif fin:\n\t\tcontinue\n \n\t#columnas\n\tfor a in range(4):\n\t\tx = True\n\t\to = True\n\t\tfor b in range(4):\n\t\t\tif l[b][a] != 'X' and l[b][a] != 'T':\n\t\t\t\tx = False\n\t\t\tif l[b][a] != 'O' and l[b][a] != 'T':\n\t\t\t\to = False\n\t\tif x:\n\t\t\tprint('Case #'+str(i+1)+': X won')\n\t\t\tfin = True\n\t\tif o:\n\t\t\tprint('Case #'+str(i+1)+': O won')\n\t\t\tfin = True\n\tif fin:\n\t\tcontinue\n \n\t#diagonales\n\tx = True\n\to = True\n\tfor j in range(4):\n\t\tif l[j][j] != 'X' and l[j][j] != 'T':\n\t\t\tx = False\n\t\tif l[j][j] != 'O' and l[j][j] != 'T':\n\t\t\to = False\n\tif x:\n\t\tprint('Case #'+str(i+1)+': X won')\n\t\tcontinue\n\tif o:\n\t\tprint('Case #'+str(i+1)+': O won')\n\t\tcontinue\n\tx = True\n\to = True\n\tfor j in range(4):\n\t\tif l[3-j][j] != 'X' and l[3-j][j] != 'T':\n\t\t\tx = False\n\t\tif l[3-j][j] != 'O' and l[3-j][j] != 'T':\n\t\t\to = False\n\tif x:\n\t\tprint('Case #'+str(i+1)+': X won')\n\t\tcontinue\n\tif o:\n\t\tprint('Case #'+str(i+1)+': O won')\n\t\tcontinue\n \n\tif v:\n\t\tprint('Case #'+str(i+1)+': Game has not completed')\n\telse:\n\t\tprint('Case #'+str(i+1)+': Draw')\n"}
{"author": "argaen", "index": 5, "filename": "2013_2270488_2449486.py", "code": "t = int(raw_input())\n \nfor case in range(t):\n\tline = raw_input().split(' ')\n\tn = int(line[0])\n\tm = int(line[1])\n \n\tl = []\n\tfor j in range(n):\n\t\ta = raw_input().split(' ')\n\t\tb = []\n\t\tfor x in a:\n\t\t\tb.append(int(x))\n\t\tl.append(b)\n \n\t# para cada valor, revisar que la fila o columna que lo contenga sea de alto menor o igual\n \n\tcumple = True\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tcol = True\n\t\t\tfil = True\n\t\t\tfor x in range(n):\n\t\t\t\tif l[x][j] > l[i][j]:\n\t\t\t\t\tcol = False\n\t\t\t\t\tbreak\n\t\t\tfor x in range(m):\n\t\t\t\tif l[i][x] > l[i][j]:\n\t\t\t\t\tfil = False\n\t\t\t\t\tbreak\n \n\t\t\tif not col and not fil:\n\t\t\t\tcumple = False\n\t\t\t\tbreak\n \n\t\tif not cumple:\n\t\t\tbreak\n \n\tif cumple:\n\t\tprint('Case #'+str(case+1)+': YES')\n\telse:\n\t\tprint('Case #'+str(case+1)+': NO')\n"}
{"author": "argaen", "index": 5, "filename": "2012_1460488_1483485.py", "code": "t = int(raw_input())\n \ncode = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']\n \nfor i in range(t):\n\tline = raw_input()\n\tdecoded = ''\n \n\tfor c in line:\n\t\tif c==' ':\\n\t\t\tdecoded += c\\n\t\telse:\\n\t\t\tdecoded += code[ord(c)-97]\\n \\n\tprint('Case #'+str(i+1)+':', decoded)\n"}
{"author": "argaen", "index": 5, "filename": "2013_2270488_2463486.py", "code": "def esPal(x):\n\treturn str(x) == str(x)[::-1]\n \nt = int(raw_input())\n \nfor case in range(t):\n\tline = raw_input().split(' ')\n\ta = int(line[0])\n\tb = int(line[1])\n \n\ti = int(a**.5)\n\tif i*i != a:\n\t\ti += 1\n\tmax = int(b**.5)\n\tcantidad = 0\n\twhile i <= max:\n\t\tif esPal(i) and esPal(i*i):\n\t\t\tcantidad += 1\n\t\ti += 1\n \n\tprint('Case #'+str(case+1)+':', cantidad)\n"}
{"author": "argaen", "index": 5, "filename": "2014_2974486_5756407898963968.py", "code": "t = int(raw_input())\n \nfor case in range(t):\n\tr1 = int(raw_input())\n\tc1 = []\n\tfor j in range(4):\n\t\tc1.append([int(i) for i in raw_input().split()])\n \n\tr2 = int(raw_input())\n\tc2 = []\n\tfor j in range(4):\n\t\tc2.append([int(i) for i in raw_input().split()])\n \n\tnum = -1\n\tpossibles = 0\n\tfor j in c1[r1-1]:\n\t\tif c2[r2-1].count(j) == 1:\n\t\t\tnum = j\n\t\t\tpossibles += 1\n \n\tif possibles > 1:\n\t\tprint('Case #'+str(case+1)+': Bad magician!')\n\telif possibles == 0:\n\t\tprint('Case #'+str(case+1)+': Volunteer cheated!')\n\telse:\n\t\tprint('Case #'+str(case+1)+': '+str(num))\\n"}
{"author": "graygrass", "index": 6, "filename": "2014_2974486_5709773144064000.py", "code": "import os\nimport math\n \nclass Solver(object):\n    def __init__(self):\n        pass\n     \n    def solve(self, inputs):\n        c, f, x = [float(t) for t in inputs[0].split()]\n        if x <= c:\n            return '%.7f'%(x/2)\n        ii = int(math.ceil((f*x-2*c)/(f*c)-1))\n        if ii <= 0:\n            return '%.7f'%(x/2)\n        t = 0\n        for i in range(ii):\n            t += c/(2+i*f)\n        t += x/(2+ii*f)\n        return '%.7f'%t\n        pass\n     \n    def feed(self, inputs):\n        lines = [x.strip() for x in inputs]\n        outputs = []\n        test_case_n = int(lines[0])\n        cur = 1\n        for i in range(test_case_n):\n            i = i\n            case_line_cnt = 1\n            case_inputs = lines[cur:cur+case_line_cnt]\n            cur += case_line_cnt\n            outputs.append(self.solve(case_inputs))\n        return outputs\n \nif __name__ == '__main__':\n    iname = 'B-small-attempt0.in'\n#     iname = 'foo'\n    sample_in = '''\n    4\n30.0 1.0 2.0\n30.0 2.0 100.0\n30.50000 3.14159 1999.19990\n500.0 4.0 2000.0\n    '''\n    sample_out = '''\nCase #1: 1.0000000\nCase #2: 39.1666667\nCase #3: 63.9680013\nCase #4: 526.1904762\n    '''\n    if os.path.exists(iname):\n        with open(iname) as f:\n            inputs = f.readlines()\n    else:\n        inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\n    solver = Solver()\n    outputs = solver.feed(inputs)\n    fail_flag = False\n    if os.path.exists(iname):\n        with open(iname+'.out', 'w') as f:\n            for i, v in enumerate(outputs):\n                print >> f, 'Case #%d: %s'%(i+1, str(v))\n    else:\n        ans = set([x.strip() for x in sample_out.split('\\n') if x.strip()])\n        for i, v in enumerate(outputs):\n            t = 'Case #%d: %s'%(i+1, str(v))\n            if t not in ans:\n                print ('!!! Wrong:', t)\n                fail_flag = True\n    print ('====================================================')\n    for i, v in enumerate(outputs):\n        print ('Case #%d: %s'%(i+1, str(v)))\n    print ('====================================================')\n    print ('done' if not fail_flag else 'fail')\n    pass"}
{"author": "graygrass", "index": 6, "filename": "2014_2974486_5690574640250880.py", "code": "import os\n \nclass Solver(object):\n    def __init__(self):\n        pass\n     \n    def solve(self, inputs):\n        R, C, M = [int(x) for x in inputs[0].split()]\n        mp = []\n        for r in range(R):\n            mp.append(['.']*C)\n        mp[0][0] = 'c'\n        outputs = []\n        if M == 0:\n            for row in mp:\n                outputs.append(''.join(row))\n            return outputs\n        rr, cc, rm = R, C, M\n        while rm >= min(rr, cc):\n            if rr <= cc:\n                for r in range(rr):\n                    mp[r][cc-1] = '*'\n                cc -= 1\n                rm -= rr\n            else:\n                for c in range(cc):\n                    mp[rr-1][c] = '*'\n                rr -= 1\n                rm -= cc\n         \n        if rm == 0:\n            if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\n                return ['Impossible']\n        else:\n            if min(rr, cc) - rm >= 2:\n                if rr <= cc:\n                    for r in range(rr-rm, rr):\n                        mp[r][cc-1] = '*'\n                else:\n                    for c in range(cc-rm, cc):\n                        mp[rr-1][c] = '*'\n            else:\n                if min(rr, cc) >= 4:\n                    if rr <= cc:\n                        for r in range(2, rr):\n                            mp[r][cc-1] = '*'\n                        mp[rr-1][cc-2] = '*'\n                    else:\n                        for c in range(2, cc):\n                            mp[rr-1][c] = '*'\n                        mp[rr-2][cc-1]='*'\n                elif min(rr,cc) == 3:\n                    if max(rr, cc) == 3:\n                        return ['Impossible']\n                    else:\n                        if rr <= cc:\n                            mp[2][cc-1] = '*'\n                            mp[2][cc-2] = '*'\n                        else:\n                            mp[rr-1][2] = '*'\n                            mp[rr-2][2] = '*'\n                else:\n                    return ['Impossible']\n                     \n        for row in mp:\n            outputs.append(''.join(row))\n        return outputs\n        pass\n     \n    def feed(self, inputs):\n        lines = [x.strip() for x in inputs]\n        outputs = []\n        test_case_n = int(lines[0])\n        cur = 1\n        for i in range(test_case_n):\n            i = i\n            case_line_cnt = 1\n            case_inputs = lines[cur:cur+case_line_cnt]\n            cur += case_line_cnt\n            R, C, M = [int(x) for x in case_inputs[0].split()]\n            rslt = self.solve(case_inputs)\n            if self.verify(rslt, R, C, M):\n                outputs.append(rslt)\n            else:\n                raise 'Failed'\n        return outputs\n     \n    def verify(self, outputs, RR, CC, MCNT):\n        if 'Impossible' == outputs[0]:\n            return True\n        rr = len(outputs)\n        cc = len(outputs[0])\n        if RR != rr or CC != cc:\n            return False\n        bd = []\n        mask = []\n        for i in range(rr):\n            mask.append([1]*cc)\n            bd.append([0]*cc)\n            for j in range(cc):\n                if outputs[i][j] == '*':\n                    bd[i][j] = 9\n                elif outputs[i][j] == 'c':\n                    start = (i, j)\n        for r in range(rr):\n            for c in range(cc):\n                if bd[r][c] == 9:\n                    for i in [r-1,r,r+1]:\n                        for j in [c-1,c,c+1]:\n                            if 0 <= i < rr and 0 <= j < cc:\n                                if bd[i][j] != 9:\n                                    bd[i][j] += 1\n#         for i, row in enumerate(bd):\n#             print i, row\n \n        nlist = [start]\n        while len(nlist):\n            i, j = nlist.pop(0)\n            if mask[i][j] != 0:\n                mask[i][j] = 0\n                if bd[i][j] == 9:\n                    raise '!!! BOMB'\n                elif bd[i][j] == 0:\n                    for ii in [i-1,i,i+1]:\n                        for jj in [j-1,j,j+1]:\n                            if 0<=ii<rr and 0<=jj<cc:\n                                if ii != i or jj != j:\n                                    nlist.append((ii,jj))\n        mcnt = 0\n        for r in range(rr):\n#             print mask[r]\n            for c in range(cc):\n                if mask[r][c] == 1:\n                    mcnt += 1\n                if mask[r][c] == 1 and bd[r][c] != 9:\n                    return False\n                if mask[r][c] != 1 and bd[r][c] == 9:\n                    return False\n        return (mcnt == MCNT)\n                 \n \nif __name__ == '__main__':\n    iname = 'C-small-attempt0.in'\n#     iname = 'foo'\n    sample_in = '''\n7\n5 5 23\n3 1 1\n2 2 1\n4 7 3\n10 10 82\n3 4 0\n2 2 3\n    '''\n    sample_out = '''\nCase #1: 1.0000000\nCase #2: 39.1666667\nCase #3: 63.9680013\nCase #4: 526.1904762\n    '''\n    if os.path.exists(iname):\n        with open(iname) as f:\n            inputs = f.readlines()\n    else:\n        inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\n    solver = Solver()\n    outputs = solver.feed(inputs)\n    fail_flag = False\n    if os.path.exists(iname):\n        with open(iname+'.out', 'w') as f:\n            for i, v in enumerate(outputs):\n                print >> f, 'Case #%d:'%(i+1)\n                print >> f, '\\n'.join(v)\n    print ('====================================================')\n    for i, v in enumerate(outputs):\n        print ('Case #%d:'%(i+1))\n        print ('\\n'.join(v))\n    print ('====================================================')\n    print ('done' if not fail_flag else 'fail')\n    pass"}
{"author": "graygrass", "index": 6, "filename": "2012_1460488_1595491.py", "code": "#! /usr/bin/env python\n#coding=utf-8\n \ndef solve(icase, case_input):\n    case_output = 'Case #%i: '%icase\n     \n    result = 0\n    raw = [int(x) for x in case_input[0].split()]\n    ts = raw[3:]\n    ct = raw[1]\n    n = raw[2]\n    cc = 0\n    for i in ts:\n        if i > 3*n-3:\n            result += 1\n        elif i > max(3*n-5, 0):\n            cc += 1\n    result += min(cc, ct)\n \n    case_output += '%d'%result\n     \n    return case_output\n \n \ndef main():\n    global use_test_data\n    global test_data\n    global input_file\n    global output_file\n     \n    if use_test_data:\n        data = [x.strip() for x in test_data.split('\\n')]\n    else:\n        data = [x.strip() for x in input_file.readlines()]\n     \n    T = int(data[0])\n    iLine = 1\n    caseLineNum = 1\n    for icase in range(1, T + 1):\n        input = []\n        for i in range(caseLineNum):\n            input.append(data[iLine])\n            iLine += 1\n        rslt = solve(icase, input)\n        print (rslt)\n        if not use_test_data:\n            print >> output_file, rslt\n     \n    if not use_test_data:\n        input_file.close()\n        output_file.close()\n     \n     \nif __name__ == '__main__':\n    test_data = \"\"\"4\n3 1 5 15 13 11\n3 0 8 23 22 21\n2 1 1 8 0\n6 2 8 29 20 8 18 18 21\n\"\"\"\n    use_test_data = False\n     \n    test_file = 'B-small-attempt0.in'\n    if not use_test_data and '' != test_file:\n        input_file = open(test_file)\n        output_file = open(test_file + '.out', 'w')\n     \n    main()"}
{"author": "graygrass", "index": 6, "filename": "2013_2270488_2453486.py", "code": "import math\n \nmm = [0xf, 0xf0, 0xf00, 0xf000, 0x8888, 0x4444, 0x2222, 0x1111, 0x8421, 0x1248]\n \ndef solve(case, in_lines):\n    out = 'Case #%d: '%case\n    s = ''.join(in_lines)\n    x = 0\n    o = 0\n    nc = False\n    for i in xrange(16):\n        m = 1 << i\n        c = s[i]\n        if c == 'X':\n            x |= m\n        elif c == 'O':\n            o |= m\n        elif c == 'T':\n            x |= m\n            o |= m\n        else:\n            nc = True\n    r = ''\n    for m in mm:\n        if m & x == m:\n            r = 'X won'\n            break\n        if m & o == m:\n            r = 'O won'\n            break\n    if not r:\n        if nc:\n            r = 'Game has not completed'\n        else:\n            r = 'Draw'\n     \n    return out + r\n \n \ndef main(raw):\n    lines = raw.split('\\n')\n    n = int(lines[0])\n    ln = 0\n    outs = []\n    for case in xrange(1, n+1):\n        buff = []\n        ln += 1\n        while ln < len(lines) and lines[ln]:\n            buff.append(lines[ln])\n            ln += 1\n        s = solve(case, buff)\n        print(s)\n        outs.append(s)\n    return '\\n'.join(outs)\n    pass\n \nif __name__ == '__main__':\n    test_input = \"\"\"6\nXXXT\n....\nOO..\n....\n \nXOXT\nXXOO\nOXOX\nXXOO\n \nXOX.\nOX..\n....\n....\n \nOOXX\nOXXX\nOX.T\nO..O\n \nXXXO\n..O.\n.O..\nT...\n \nOXXX\nXO..\n..O.\n...O\"\"\"\n    force_no_file = False\n    in_file_name = '' if force_no_file else 'A-small-attempt0.in'\n    base_path = 'G:/workspace/py/codejam2013/RQ/'\n    if in_file_name:\n        with open(base_path + in_file_name) as f:\n            raw = f.read()\n    else:\n        raw = test_input\n    out = main(raw)\n    if in_file_name:\n        with open(base_path + in_file_name + '.out', 'w') as f:\n            f.write(out)\n    pass"}
{"author": "graygrass", "index": 6, "filename": "2013_2270488_2449486.py", "code": "import math\n \ndef ss(t, amap, bmap):\n    s = 0\n    for m in amap:\n        if len(m) == 1 and t == m.keys()[0]:\n            s += m[t]\n            for b in bmap:\n                if t in b:\n                    b[t] -= 1\n                    if b[t] == 0:\n                        b.pop(t)\n            m.clear()\n    return s           \n \n \ndef solve(case, in_lines):\n    out = 'Case #%d: '%case\n  \n    rn, cn = [int(x) for x in in_lines[0].split()]\n    mtx = []\n    for i in xrange(rn):\n        mtx.append([int(x) for x in in_lines[i+1].split()])\n    rmap = [{} for x in xrange(rn)]\n    cmap = [{} for x in xrange(cn)]\n    td = {}\n     \n    for i in xrange(rn):\n        for j in range(cn):\n            k = mtx[i][j]\n            if k in rmap[i]:\n                rmap[i][k] += 1\n            else:\n                rmap[i][k] = 1\n            if k in cmap[j]:\n                cmap[j][k] += 1\n            else:\n                cmap[j][k] = 1\n            if k in td:\n                td[k] += 1\n            else:\n                td[k] = 1\n                 \n    while len(td):\n        k = min(td.keys())\n        sb = ss(k, rmap, cmap)\n        sb += ss(k, cmap, rmap)\n        if sb == 0:\n            break;\n        td[k] -= sb\n        if td[k] == 0:\n            td.pop(k)\n \n    return out + ('YES' if sb else 'NO')\n \n \ndef main(raw):\n    lines = raw.split('\\n')\n    n = int(lines[0])\n    ln = 1\n    outs = []\n    for case in xrange(1, n+1):\n        buff = []\n        cl = int(lines[ln].split()[0]) + ln + 1\n        while ln < cl and lines[ln]:\n            buff.append(lines[ln])\n            ln += 1\n        s = solve(case, buff)\n        print(s)\n        outs.append(s)\n    return '\\n'.join(outs)\n    pass\n \nif __name__ == '__main__':\n    test_input = \"\"\"4\n4 3\n2 5 2\n1 1 1\n2 4 2\n2 3 2\n3 3\n2 1 2\n1 1 1\n2 1 2\n5 5\n2 2 2 2 2\n2 1 1 1 2\n2 1 2 1 2\n2 1 1 1 2\n2 2 2 2 2\n1 3\n1 2 1\"\"\"\n    force_no_file = False\n    in_file_name = '' if force_no_file else 'B-small-attempt0.in'\n    base_path = 'G:/workspace/py/codejam2013/RQ/'\n    if in_file_name:\n        with open(base_path + in_file_name) as f:\n            raw = f.read()\n    else:\n        raw = test_input\n    out = main(raw)\n    if in_file_name:\n        with open(base_path + in_file_name + '.out', 'w') as f:\n            f.write(out)\n    pass"}
{"author": "graygrass", "index": 6, "filename": "2012_1460488_1483485.py", "code": "#! /usr/bin/env python\n#coding=utf-8\n \ndef solve(icase, case_input):\n    case_output = 'Case #%i: '%icase\n     \n    result = \"\"\n    for c in case_input[0]:\n        if c in map:\n            result += map[c]\n        else:\n            result += c\n \n    case_output += '%s'%result\n     \n    return case_output\n \n \ndef getmap():\n    inputs = [\"ejp mysljylc kd kxveddknmc re jsicpdrysi\",\n            \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\",\n            \"de kr kd eoya kw aej tysr re ujdr lkgc jv\"]\n    outputs = [\"our language is impossible to understand\",\n                \"there are twenty six factorial possibilities\",\n                \"so it is okay if you want to just give up\"]\n    map = {}\n    for case in xrange(3):\n        for i, c in enumerate(inputs[case]):\n            map[c] = outputs[case][i]\n     \n    map['q'] = 'z'\n    map['z'] = 'q'\n     \n    print (map)\n    print (len(map))\n    for c in \"abcdefghijklmnopqrstuvwxyz\":\n        if c not in map:\n            print (c)\n    return map\n \n \ndef main():\n    global use_test_data\n    global test_data\n    global input_file\n    global output_file\n     \n    if use_test_data:\n        data = [x.strip() for x in test_data.split('\\n')]\n    else:\n        data = [x.strip() for x in input_file.readlines()]\n     \n    T = int(data[0])\n    iLine = 1\n    caseLineNum = 1\n    for icase in range(1, T + 1):\n        input = []\n        for i in range(caseLineNum):\n            input.append(data[iLine])\n            iLine += 1\n        rslt = solve(icase, input)\n        print (rslt)\n        if not use_test_data:\n            print >> output_file, rslt\n     \n    if not use_test_data:\n        input_file.close()\n        output_file.close()\n     \n     \nif __name__ == '__main__':\n    test_data = \"\"\"3\nejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv\n    \"\"\"\n    use_test_data = False\n     \n    map = getmap()\n     \n    test_file = 'A-small-attempt2.in'\n    if not use_test_data and '' != test_file:\n        input_file = open(test_file)\n        output_file = open(test_file + '.out', 'w')\n     \n    main()"}
{"author": "graygrass", "index": 6, "filename": "2013_2270488_2463486.py", "code": "import math\n \ndef ss(t, amap, bmap):\n    s = 0\n    for m in amap:\n        if len(m) == 1 and t == m.keys()[0]:\n            s += m[t]\n            for b in bmap:\n                if t in b:\n                    b[t] -= 1\n                    if b[t] == 0:\n                        b.pop(t)\n            m.clear()\n    return s           \n \n \ndef solve(case, in_lines):\n    out = 'Case #%d: '%case\n  \n    rn, cn = [int(x) for x in in_lines[0].split()]\n    mtx = []\n    for i in xrange(rn):\n        mtx.append([int(x) for x in in_lines[i+1].split()])\n    rmap = [{} for x in xrange(rn)]\n    cmap = [{} for x in xrange(cn)]\n    td = {}\n     \n    for i in xrange(rn):\n        for j in range(cn):\n            k = mtx[i][j]\n            if k in rmap[i]:\n                rmap[i][k] += 1\n            else:\n                rmap[i][k] = 1\n            if k in cmap[j]:\n                cmap[j][k] += 1\n            else:\n                cmap[j][k] = 1\n            if k in td:\n                td[k] += 1\n            else:\n                td[k] = 1\n                 \n    while len(td):\n        k = min(td.keys())\n        sb = ss(k, rmap, cmap)\n        sb += ss(k, cmap, rmap)\n        if sb == 0:\n            break;\n        td[k] -= sb\n        if td[k] == 0:\n            td.pop(k)\n \n    return out + ('YES' if sb else 'NO')\n \n \ndef main(raw):\n    lines = raw.split('\\n')\n    n = int(lines[0])\n    ln = 1\n    outs = []\n    for case in xrange(1, n+1):\n        buff = []\n        cl = int(lines[ln].split()[0]) + ln + 1\n        while ln < cl and lines[ln]:\n            buff.append(lines[ln])\n            ln += 1\n        s = solve(case, buff)\n        print(s)\n        outs.append(s)\n    return '\\n'.join(outs)\n    pass\n \nif __name__ == '__main__':\n    test_input = \"\"\"4\n4 3\n2 5 2\n1 1 1\n2 4 2\n2 3 2\n3 3\n2 1 2\n1 1 1\n2 1 2\n5 5\n2 2 2 2 2\n2 1 1 1 2\n2 1 2 1 2\n2 1 1 1 2\n2 2 2 2 2\n1 3\n1 2 1\"\"\"\n    force_no_file = False\n    in_file_name = '' if force_no_file else 'B-large.in'\n    base_path = 'G:/workspace/py/codejam2013/RQ/'\n    if in_file_name:\n        with open(base_path + in_file_name) as f:\n            raw = f.read()\n    else:\n        raw = test_input\n    out = main(raw)\n    if in_file_name:\n        with open(base_path + in_file_name + '.out', 'w') as f:\n            f.write(out)\n    pass"}
{"author": "graygrass", "index": 6, "filename": "2014_2974486_5756407898963968.py", "code": "import os\n \nclass Solver(object):\n    def __init__(self):\n        pass\n     \n    def solve(self, inputs):\n        r1 = int(inputs[0])\n        cs1 = set([int(x) for x in inputs[r1].split()])\n        r2 = int(inputs[5])\n        cs2 = set([int(x) for x in inputs[5+r2].split()])\n        r = cs1.intersection(cs2)\n        cnt = len(r)\n        if 1 == cnt:\n            return max(r)\n        elif 0 == cnt:\n            return 'Volunteer cheated!'\n        else:\n            return 'Bad magician!'\n        pass\n     \n    def feed(self, inputs):\n        lines = [x.strip() for x in inputs]\n        outputs = []\n        test_case_n = int(lines[0])\n        cur = 1\n        for i in range(test_case_n):\n            i = i\n            case_line_cnt = 10\n            case_inputs = lines[cur:cur+case_line_cnt]\n            cur += case_line_cnt\n            outputs.append(self.solve(case_inputs))\n        return outputs\n \nif __name__ == '__main__':\n    iname = 'A-small-attempt0.in'\n#     iname = 'foo'\n    sample_in = '''\n    3\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 5 4\n3 11 6 15\n9 10 7 12\n13 14 8 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n    '''\n    sample_out = '''\nCase #1: 7\nCase #2: Bad magician!\nCase #3: Volunteer cheated!\n    '''\n    if os.path.exists(iname):\n        with open(iname) as f:\n            inputs = f.readlines()\n    else:\n        inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\n    solver = Solver()\n    outputs = solver.feed(inputs)\n    fail_flag = False\n    if os.path.exists(iname):\n        with open(iname+'.out', 'w') as f:\n            for i, v in enumerate(outputs):\n                print >> f, 'Case #%d: %s'%(i+1, str(v))\n    else:\n        ans = set([x.strip() for x in sample_out.split('\\n') if x.strip()])\n        for i, v in enumerate(outputs):\n            t = 'Case #%d: %s'%(i+1, str(v))\n            if t not in ans:\n                print ('!!! Wrong:', t)\n                fail_flag = True\n    print ('====================================================')\n    for i, v in enumerate(outputs):\n        print ('Case #%d: %s'%(i+1, str(v)))\n    print ('====================================================')\n    print ('done' if not fail_flag else 'fail')\n    pass"}
{"author": "alexamici", "index": 7, "filename": "2014_2974486_5709773144064000.py", "code": "\"\"\"Usage:\n    pypy X.py < X-size.in > X-size.out\nor sometimes\n    python X.py < X-size.in > X-size.out\n\"\"\"\n \ndef setup(infile):\n    #C = {}\n    return locals()\n \ndef reader(testcase, infile, C=None, **ignore):\n    #N = int(infile.next())\n    #P = map(int, infile.next().split())\n    I = map(float, infile.next().split())\n    #T = infile.next().split()\n    #S = [infile.next().strip() for i in range(N)]\n    return locals()\n \ndef solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n    #import collections as co\n    #import functools32 as ft\n    #import itertools as it\n    #import operator as op\n    #import math as ma\n    #import re\n    #import numpypy as np\n    #import scipy as sp\n    #import networkx as nx\n \n    C, F, X = I\n    n = [0]\n    r = 2.\n \n    res = X / r\n    while True:\n        n.append(n[-1] + C / r)\n        r += F\n        nres = n[-1] + X / r\n        if nres >= res:\n            break\n        res = nres\n \n    return 'Case #%s: %s\\n' % (testcase, res)\n \nif __name__ == '__main__':\n    import sys\n    T = int(sys.stdin.next())\n    common = setup(sys.stdin)\n    for t in xrange(1, T+1):\n        sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "alexamici", "index": 7, "filename": "2014_2974486_5690574640250880.py", "code": "\"\"\"Usage:\n    pypy X.py < X-size.in > X-size.out\nor sometimes\n    python X.py < X-size.in > X-size.out\n\"\"\"\n \ndef setup(infile):\n    #C = {}\n    return locals()\n \ndef reader(testcase, infile, C=None, **ignore):\n    #N = int(infile.next())\n    P = map(int, infile.next().split())\n    #I = map(int, infile.next().split())\n    #T = infile.next().split()\n    #S = [infile.next().strip() for i in range(N)]\n    return locals()\n \ndef solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n    #import collections as co\n    #import functools32 as ft\n    #import itertools as it\n    #import operator as op\n    #import math as ma\n    #import re\n    import numpy as np\n    #import scipy as sp\n    #import networkx as nx\n \n    R, C, M = P\n    #print('--', R, C, M)\n    MM = M\n \n    F = np.array([['.'] * C] * R)\n    while M > 0:\n        # reduce if possible\n        if R >= C and M >= C and R > 2:\n            M -= C\n            R -= 1\n            F[R] = '*'\n        elif C > R  and M >= R and C > 2:\n            M -= R\n            C -= 1\n            F[:, C] = '*'\n        # solve simple\n        elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\n            if M < C - 1:\n                R -= 1\n                F[R, C - M:C] = '*'\n            elif M < R - 1:\n                C -= 1\n                F[R - M:R, C] = '*'\n            elif M == C - 1:\n                R -= 1\n                F[R, C - M + 1:C] = '*'\n                F[R - 1, C - 1] = '*'\n            else:\n                C -= 1\n                F[R - M + 1:R, C] = '*'\n                F[R - 1, C - 1] = '*'\n            M = 0\n        # special cases\n        elif M == R * C - 1:\n            F[:, :] = '*'\n            M = 0\n        else:\n            #print(F)\n            #print(R, C, M)\n            return 'Case #%s:\\n%s\\n' % (testcase, 'Impossible')\n \n    F[0, 0] = 'c'\n    assert (F == '*').sum() == MM\n    return 'Case #%s:\\n%s\\n' % (testcase, '\\n'.join(''.join(f.tolist()) for f in F))\n \nif __name__ == '__main__':\n    import sys\n    T = int(sys.stdin.next())\n    common = setup(sys.stdin)\n    for t in xrange(1, T+1):\n        sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "alexamici", "index": 7, "filename": "2012_1460488_1595491.py", "code": "\"\"\"Usage:\n    X.py < X.in > X.out\n\"\"\"\n \nimport sys\n \n \nclass Solver(object):\n    cache = {}\n \n    def __init__(self, infile, testcase):\n        self.testcase = testcase\n        self.P = P = map(int, infile.next().split())\n \n    def init_cache(self):\n        if 'main' in self.cache:\n            return\n        #self.cache['main'] = res\n \n    def solve(self):\n \n        N, S, p = self.P[:3]\n        G = sorted(self.P[3:], reverse=True)\n \n        r = 0\n        s = 0\n        for g in G:\n            if g >= 3 * p - 2 and g >= p:\n                r += 1\n            elif g >= 3 * p - 4 and g >= p:\n                if s == S:\n                    break\n                r += 1\n                s += 1\n \n        return r\n \n \ndef main():\n    T = int(sys.stdin.next())\n    for t in xrange(T):\n        sys.stdout.write('Case #%s: %s\\n' % (t + 1, Solver(sys.stdin, t).solve()))\n \n \nif __name__ == '__main__':\n    main()\n"}
{"author": "alexamici", "index": 7, "filename": "2013_2270488_2453486.py", "code": "\"\"\"Usage:\n    X.py < X.in > X.out\n\"\"\"\n \ndef setup(infile):\n    #C = {}\n    return locals()\n \ndef reader(testcase, infile, **ignore):\n    #N = int(infile.next())\n    #P = map(int, infile.next().split())\n    #I = map(int, infile.next().split())\n    #T = infile.next().split()\n    S = [infile.next().strip() for i in range(5)]\n    return locals()\n \ndef solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n    #import collections as co\n    #import functools as ft\n    import itertools as it\n    #import operator as op\n    #import math as ma\n    #import re\n    #import numpy as np\n    #import scipy as sp\n    #import networkx as nx\n     \n    not_draw = False\n    for line in S[:4]:\n        not_win = set()\n        if '.' in line:\n            not_draw = True\n            continue\n        if 'O' in line:\n            not_win.add('X')\n        if 'X' in line:\n            not_win.add('O')\n        if len(not_win) == 1:\n            return 'Case #%s: %s\\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n \n    ST = []\n    for j in range(4):\n        ST.append(''.join(S[i][j] for i in range(4)))\n    for line in ST:\n        not_win = set()\n        if '.' in line:\n            continue\n        if 'O' in line:\n            not_win.add('X')\n        if 'X' in line:\n            not_win.add('O')\n        if len(not_win) == 1:\n            return 'Case #%s: %s\\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n \n    line = ''.join(S[i][i] for i in range(4))\n    not_win = set()\n    if '.' not in line:   \n        if 'O' in line:\n            not_win.add('X')\n        if 'X' in line:\n            not_win.add('O')\n        if len(not_win) == 1:\n            return 'Case #%s: %s\\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n \n    line = ''.join(S[i][3-i] for i in range(4))\n    not_win = set()\n    if '.' not in line:\n        if 'O' in line:\n            not_win.add('X')\n        if 'X' in line:\n            not_win.add('O')\n        if len(not_win) == 1:\n            return 'Case #%s: %s\\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n \n    if not_draw:\n        return 'Case #%s: %s\\n' % (testcase, 'Game has not completed')\n    else:\n        return 'Case #%s: %s\\n' % (testcase, 'Draw')\n \nif __name__ == '__main__':\n    import sys\n    T = int(sys.stdin.next())\n    common = setup(sys.stdin)\n    for t in xrange(1, T+1):\n        sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "alexamici", "index": 7, "filename": "2013_2270488_2449486.py", "code": "\"\"\"Usage:\n    X.py < X.in > X.out\n\"\"\"\n \ndef setup(infile):\n    #C = {}\n    return locals()\n \ndef reader(testcase, infile, **ignore):\n    #N = int(infile.next())\n    P = map(int, infile.next().split())\n    #I = map(int, infile.next().split())\n    #T = infile.next().split()\n    S = [map(int, infile.next().split()) for i in range(P[0])]\n    return locals()\n \ndef solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n    #import collections as co\n    #import functools as ft\n    #import itertools as it\n    #import operator as op\n    #import math as ma\n    #import re\n    import numpypy as np\n    #import scipy as sp\n    #import networkx as nx\n     \n    S = np.array(S)\n    done = np.zeros(P, dtype=int)\n    for row in range(P[0]):\n        m = S[row].max()\n        done[row][S[row]==m] = 1\n \n    for col in range(P[1]):\n        m = S[:,col].max()\n        done[:,col][S[:,col]==m] = 1\n \n    res = 'YES' if done.sum() == P[0]*P[1] else 'NO'\n    return 'Case #%s: %s\\n' % (testcase, res)\n \nif __name__ == '__main__':\n    import sys\n    T = int(sys.stdin.next())\n    common = setup(sys.stdin)\n    for t in xrange(1, T+1):\n        sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "alexamici", "index": 7, "filename": "2012_1460488_1483485.py", "code": "\"\"\"Usage:\n    X.py < X.in > X.out\n\"\"\"\n\nimport sys\n\nins = \"\"\"ejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jvqz\n\"\"\"\n\nouts = \"\"\"our language is impossible to understand\nthere are twenty six factorial possibilities\nso it is okay if you want to just give upzq\n\"\"\"\n\nclass Solver(object):\n    cache = {}\n\n    def __init__(self, infile, testcase):\n        self.testcase = testcase\n        self.S = S = infile.next().strip()\n\n        self.init_cache()\n\n    def init_cache(self):\n        if 'main' in self.cache:\n            return\n        t = {}\n        for i in xrange(len(ins)):\n            t[ins[i]] = outs[i]\n        print((t))\n        self.cache['main'] = t\n\n    def solve(self):\n\n        S = self.S\n        \n\n        return ''.join(self.cache['main'][c] for c in list(S))\n\n\ndef main():\n    T = int(sys.stdin.next())\n    for t in xrange(T):\n        sys.stdout.write('Case #%s: %s\\n' % (t + 1, Solver(sys.stdin, t).solve()))\n\n\nif __name__ == '__main__':\n    main()\n"}
{"author": "alexamici", "index": 7, "filename": "2013_2270488_2463486.py", "code": "\"\"\"Usage:\n    X.py < X.in > X.out\n\"\"\"\n \n# http://code.activestate.com/recipes/577821-integer-square-root-function/\ndef isqrt(x):\n    \"returns int(floor(sqrt(x))) using only integer math\"\n    assert x >= 0, 'Undefined %r' % locals()\n    n = int(x)\n    if n == 0:\n        return 0\n    a, b = divmod(n.bit_length(), 2)\n    x = 2**(a+b)\n    while True:\n        y = (x + n//x)//2\n        if y >= x:\n            return x\n        x = y\n \ndef setup(infile):\n    #C = {}\n    return locals()\n \ndef reader(testcase, infile, **ignore):\n    #N = int(infile.next())\n    P = map(int, infile.next().split())\n    #I = map(int, infile.next().split())\n    #T = infile.next().split()\n    #S = [infile.next().strip() for i in range(N)]\n    return locals()\n \ndef solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n    #import collections as co\n    #import functools as ft\n    #import itertools as it\n    #import operator as op\n    #import math as ma\n    #import re\n    #import numpy as np\n    #import scipy as sp\n    #import networkx as nx\n \n    low = isqrt(P[0])\n    high = isqrt(P[1])+1\n \n    def is_pal(n):\n        n = str(n)\n        for i in range(len(n)/2+1):\n            if n[i]!=n[len(n)-1-i]:\n                return False\n        return True\n \n    res = 0\n    for i in range(low, high+1):\n        if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):\n            res += 1\n \n    return 'Case #%s: %s\\n' % (testcase, res)\n \nif __name__ == '__main__':\n    import sys\n    T = int(sys.stdin.next())\n    common = setup(sys.stdin)\n    for t in xrange(1, T+1):\n        sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "alexamici", "index": 7, "filename": "2014_2974486_5756407898963968.py", "code": "\"\"\"Usage:\n    pypy X.py < X-size.in > X-size.out\nor sometimes\n    python X.py < X-size.in > X-size.out\n\"\"\"\n \ndef setup(infile):\n    #C = {}\n    return locals()\n \ndef reader(testcase, infile, C=None, **ignore):\n    N = int(infile.next())\n    #P = int(infile.next())\n    #P = map(int, infile.next().split())\n    I = [map(int, infile.next().split()) for i in range(4)]\n    T = int(infile.next())\n    #T = infile.next().split()\n    S = [map(int, infile.next().split()) for i in range(4)]\n    return locals()\n \ndef solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n    #import collections as co\n    #import functools32 as ft\n    #import itertools as it\n    #import operator as op\n    #import math as ma\n    #import re\n    #import numpypy as np\n    #import scipy as sp\n    #import networkx as nx\n \n    res = set(I[N-1]) & set(S[T-1])\n    if len(res) == 1:\n        res = res.pop()\n    elif len(res) > 1:\n        res = 'Bad magician!'\n    else:\n        res = 'Volunteer cheated!'\n    return 'Case #%s: %s\\n' % (testcase, res)\n \nif __name__ == '__main__':\n    import sys\n    T = int(sys.stdin.next())\n    common = setup(sys.stdin)\n    for t in xrange(1, T+1):\n        sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "ralfkistner", "index": 8, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Uses https://github.com/rkistner/contest-algorithms\n \n# Cookie Clicker is a Javascript game by Orteil, where players click on a picture of a giant cookie. Clicking on the giant cookie gives them cookies. They can spend those cookies to buy buildings. Those buildings help them get even more cookies. Like this problem, the game is very cookie-focused. This problem has a similar idea, but it does not assume you have played Cookie Clicker. Please don't go play it now: it might be a long time before you come back.\n \n# Problem\n \n# In this problem, you start with 0 cookies. You gain cookies at a rate of 2 cookies per second, by clicking on a giant cookie. Any time you have at least C cookies, you can buy a cookie farm. Every time you buy a cookie farm, it costs you C cookies and gives you an extra F cookies per second.\n \n# Once you have X cookies that you haven't spent on farms, you win! Figure out how long it will take you to win if you use the best possible strategy.\n \n# Example\n \n# Suppose C=500.0, F=4.0 and X=2000.0. Here's how the best possible strategy plays out:\n \n# You start with 0 cookies, but producing 2 cookies per second.\n# After 250 seconds, you will have C=500 cookies and can buy a farm that produces F=4 cookies per second.\n# After buying the farm, you have 0 cookies, and your total cookie production is 6 cookies per second.\n# The next farm will cost 500 cookies, which you can buy after about 83.3333333 seconds.\n# After buying your second farm, you have 0 cookies, and your total cookie production is 10 cookies per second.\n# Another farm will cost 500 cookies, which you can buy after 50 seconds.\n# After buying your third farm, you have 0 cookies, and your total cookie production is 14 cookies per second.\n# Another farm would cost 500 cookies, but it actually makes sense not to buy it: instead you can just wait until you have X=2000 cookies, which takes about 142.8571429 seconds.\n# Total time: 250 + 83.3333333 + 50 + 142.8571429 = 526.1904762 seconds.\n# Notice that you get cookies continuously: so 0.1 seconds after the game starts you'll have 0.2 cookies, and π seconds after the game starts you'll have 2π cookies.\n \n# Input\n \n# The first line of the input gives the number of test cases, T. T lines follow. Each line contains three space-separated real-valued numbers: C, F and X, whose meanings are described earlier in the problem statement.\n \n# C, F and X will each consist of at least 1 digit followed by 1 decimal point followed by from 1 to 5 digits. There will be no leading zeroes.\n \n# Output\n \n# For each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of seconds it takes before you can have X delicious cookies.\n \n \n# Limits\n \n# 1 ≤ T ≤ 100.\n \n# Small dataset\n \n# 1 ≤ C ≤ 500.\n# 1 ≤ F ≤ 4.\n# 1 ≤ X ≤ 2000.\n# Large dataset\n \n# 1 ≤ C ≤ 10000.\n# 1 ≤ F ≤ 100.\n# 1 ≤ X ≤ 100000.\n \nimport sys\n \n \ndef debug(*args):\n    print(*args, file=sys.stderr)\n \nfin = sys.stdin\nT = int(fin.readline())\nfor case in range(1, T + 1):\n    C, F, X = map(float, fin.readline().split())\n \n \n    rate = 2\n    time = 0\n \n    best = 10**20\n \n    while time < best:\n        result = X / rate + time\n        if result < best:\n            best = result\n        time += C / rate\n        rate += F\n \n \n \n    print(\"Case #%d: %.7f\" % (case, best))\n \n"}
{"author": "ralfkistner", "index": 8, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Uses https://github.com/rkistner/contest-algorithms\n \n# Minesweeper is a computer game that became popular in the 1980s, and is still included in some versions of the Microsoft Windows operating system. This problem has a similar idea, but it does not assume you have played Minesweeper.\n \n# In this problem, you are playing a game on a grid of identical cells. The content of each cell is initially hidden. There are M mines hidden in M different cells of the grid. No other cells contain mines. You may click on any cell to reveal it. If the revealed cell contains a mine, then the game is over, and you lose. Otherwise, the revealed cell will contain a digit between 0 and 8, inclusive, which corresponds to the number of neighboring cells that contain mines. Two cells are neighbors if they share a corner or an edge. Additionally, if the revealed cell contains a 0, then all of the neighbors of the revealed cell are automatically revealed as well, recursively. When all the cells that don't contain mines have been revealed, the game ends, and you win.\n \n# For example, an initial configuration of the board may look like this ('*' denotes a mine, and 'c' is the first clicked cell):\n \n# *..*...**.\n# ....*.....\n# ..c..*....\n# ........*.\n# ..........\n# There are no mines adjacent to the clicked cell, so when it is revealed, it becomes a 0, and its 8 adjacent cells are revealed as well. This process continues, resulting in the following board:\n# *..*...**.\n# 1112*.....\n# 00012*....\n# 00001111*.\n# 00000001..\n# At this point, there are still un-revealed cells that do not contain mines (denoted by '.' characters), so the player has to click again in order to continue the game.\n# You want to win the game as quickly as possible. There is nothing quicker than winning in one click. Given the size of the board (R x C) and the number of hidden mines M, is it possible (however unlikely) to win in one click? You may choose where you click. If it is possible, then print(any valid mine configuration and the coordinates of your click, following the specifications in the Output section. Otherwise, print \"Impossible\".)\n \n# Input\n \n# The first line of the input gives the number of test cases, T. T lines follow. Each line contains three space-separated integers: R, C, and M.\n \n# Output\n \n# For each test case, output a line containing \"Case #x:\", where x is the test case number (starting from 1). On the following R lines, output the board configuration with C characters per line, using '.' to represent an empty cell, '*' to represent a cell that contains a mine, and 'c' to represent the clicked cell.\n \n# If there is no possible configuration, then instead of the grid, output a line with \"Impossible\" instead. If there are multiple possible configurations, output any one of them.\n \n# Limits\n \n# 0 ≤ M < R * C.\n# Small dataset\n \n# 1 ≤ T ≤ 230.\n# 1 ≤ R, C ≤ 5.\n# Large dataset\n \n# 1 ≤ T ≤ 140.\n# 1 ≤ R, C ≤ 50.\n  \n \n \nimport sys\n \n \ndef debug(*args):\n    print(*args, file=sys.stderr)\n \nfin = sys.stdin\nT = int(fin.readline())\nfor case in range(1, T + 1):\n    RR, CC, M = map(int, fin.readline().split())\n    R, C = None, None\n    blocks = RR*CC - M\n    inverse = False\n    if RR > CC:\n        inverse = True\n        R, C = CC, RR\n    else:\n        R, C = RR, CC\n    result = None\n    # Now R <= C\n    if R == 1:\n        # Always possible\n        result = [('.' * blocks) + ('*' * M)]\n    elif R == 2:\n        # Possible if blocks == 1 or blocks % 2 == 0\n        if blocks == 1:\n            result = ['.' + ('*' * (C-1)), '*' * C]\n        elif blocks % 2 == 0 and blocks != 2:\n            cc = blocks // 2\n            result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n        else:\n            result = None\n    else:\n        if blocks == 1:\n            result = ['*' * C] * R\n        elif blocks == 4:\n            result = ['..' + (C-2)*'*']*2\n            result += ['*'*C] * (R-2)\n        elif blocks == 6:\n            result = ['...' + (C-3)*'*']*2\n            result += ['*'*C] * (R-2)\n        for rows in range(3, R+1):\n            for columns in range(rows, C+1):\n                size = rows * columns\n                if size - blocks >= 0:\n                    if size - blocks <= columns - 2: \n                        result = []\n                        for r in range(rows):\n                            if r < rows - 1:\n                                result.append(('.' * columns) + ('*' * (C - columns)))\n                            else:\n                                cc = columns - (size - blocks)\n                                result.append(('.' * cc) + ('*' * (C - cc)))\n                        for r in range(R - rows):\n                            result.append('*' * C)\n                    elif size - blocks == columns - 1 and rows >= 4:\n                        result = []\n                        for r in range(rows):\n                            if r < rows - 2:\n                                result.append(('.' * columns) + ('*' * (C - columns)))\n                            elif r == rows - 2:\n                                cc = columns - 1\n                                result.append(('.' * cc) + ('*' * (C - cc)))\n                            else:\n                                cc = 2\n                                result.append(('.' * cc) + ('*' * (C - cc)))\n                        for r in range(R - rows):\n                            result.append('*' * C)\n                     \n \n \n \n    print(\"Case #%d: \" % (case))\n    if result is None:\n        debug('impossible', blocks, RR, CC)\n        print(\"Impossible\")\n    else:\n        mines = 0\n        for r in range(RR):\n            row = ''\n            for c in range(CC):\n                rr, cc = r, c\n                if inverse:\n                    rr, cc = c, r\n                if rr == 0 and cc == 0:\n                    row += 'c'\n                else:\n                    row += result[rr][cc]\n                    if result[rr][cc] == '*':\n                        mines += 1\n            print(row)\n        if mines != M:\n            raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\n             \n \n \n"}
{"author": "ralfkistner", "index": 8, "filename": "2012_1460488_1595491.py", "code": "# -*- coding: utf-8 -*-\nimport sys\nfin = sys.stdin\nT = int(fin.readline())\nfor case in range(1,T+1):\n    numbers = map(int, fin.readline().split())\n    N, S, p = numbers[:3]\n    T = numbers[3:]\n    normal_limit = p + 2*max(0, (p-1))\n    surpising_limit = p + 2*max(0, (p-2))\n \n    normal_count = 0\n    surprising_count = 0\n \n    for t in T:\n        if t >= normal_limit:\n            normal_count += 1\n        elif t >= surpising_limit:\n            surprising_count += 1\n \n    result = normal_count + min(surprising_count, S)\n \n    print(\"Case #%d: %s\" % (case, result))\n \n"}
{"author": "ralfkistner", "index": 8, "filename": "2013_2270488_2453486.py", "code": "\nimport sys\nfin = sys.stdin\nT = int(fin.readline())\nfor case in range(1,T+1):\n    board = []\n    for i in range(4):\n        row = list(fin.readline().strip())\n        board.append(row)\n \n    fin.readline()\n \n    rows = [[], [], [], []]\n    cols = [[], [], [], []]\n    diags = [[], []]\n \n    for i in range(4):\n        for j in range(4):\n            v = board[i][j]\n            rows[i].append(v)\n            cols[j].append(v)\n            if i == j:\n                diags[0].append(v)\n            if i + j == 3:\n                diags[1].append(v)\n \n    buckets = rows + cols + diags\n    result = 'Draw'\n    filled = True\n    for bucket in buckets:\n        d = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n        for v in bucket:\n            d[v] += 1\n        if d['T'] + d['X'] == 4:\n            result = 'X won'\n            break\n        if d['T'] + d['O'] == 4:\n            result = 'O won'\n            break\n        if d['.'] > 0:\n            result = 'Game has not completed'\n \n    print(\"Case #%d: %s\" % (case, result))\n \n \n \n"}
{"author": "ralfkistner", "index": 8, "filename": "2013_2270488_2449486.py", "code": "\nimport sys\nfin = sys.stdin\nT = int(fin.readline())\nfor case in range(1,T+1):\n    board = []\n    N, M = map(int, fin.readline().split())\n    for i in range(N):\n        board.append(list(map(int, fin.readline().split())))\n     \n    row_min = [100]*N\n    row_max = [0]*N\n    col_min = [100]*M\n    col_max = [0]*M\n \n    for i in range(N):\n        for j in range(M):\n            v = board[i][j]\n            row_min[i] = min(v, row_min[i])\n            row_max[i] = max(v, row_max[i])\n            col_min[j] = min(v, col_min[j])\n            col_max[j] = max(v, col_max[j])\n \n \n    possible = True\n    for i in range(N):\n        for j in range(M):\n            v = board[i][j]\n            if v != row_max[i] and v != col_max[j]:\n                possible = False\n                break\n \n \n    print(\"Case #%d: %s\" % (case, possible and \"YES\" or \"NO\"))\n \n \n \n"}
{"author": "ralfkistner", "index": 8, "filename": "2012_1460488_1483485.py", "code": "# -*- coding: utf-8 -*-\nimport sys\n \ninput = \"\"\"ejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv\"\"\"\n \noutput = \"\"\"our language is impossible to understand\nthere are twenty six factorial possibilities\nso it is okay if you want to just give up\"\"\"\n \nmapping = {'a': 'y', 'o': 'e', 'z': 'q', 'q': 'z'}\n \nfor i, c in enumerate(input):\n    mapping[c] = output[i]\n \n \nfin = sys.stdin\nT = int(fin.readline())\nfor case in range(1,T+1):\n    line = fin.readline().strip()\n \n    result = \"\"\n    for c in line:\n        result += mapping[c]\n#    N, M = map(int, fin.readline().split())\n \n    print(\"Case #%d: %s\" % (case, result))\n \n"}
{"author": "ralfkistner", "index": 8, "filename": "2013_2270488_2463486.py", "code": "import sys\nimport bisect\n \nN = 10**4\n \n# [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]\n# [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001, 100220141022001, 102012040210201, 102234363432201, 121000242000121, 121242363242121, 123212464212321, 123456787654321, 400000080000004, 10000000200000001, 10002000300020001, 10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, 10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, 10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, 12122232623222121, 12124434743442121, 12321024642012321, 12323244744232321, 12343456865434321, 12345678987654321, 40000000800000004, 40004000900040004, 1000000002000000001, 1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, 1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, 1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, 1232344458544432321, 1234323468643234321, 4000000008000000004, 100000000020000000001L, 100002000030000200001L, 100004000060000400001L, 100020201040102020001L, 100022201252102220001L, 100024201484102420001L, 100200120040021002001L, 100202122050221202001L, 100204124080421402001L, 100220341262143022001L, 100222343474343222001L, 102010002040200010201L, 102012022050220210201L, 102014042080240410201L, 102030405060504030201L, 102032425272524230201L, 102212122262221212201L, 102214144272441412201L, 102232545484545232201L, 102234567696765432201L, 121000000242000000121L, 121002200252002200121L, 121004400282004400121L, 121022221262122220121L, 121024421474124420121L, 121220122262221022121L, 121222324272423222121L, 121242363484363242121L, 121244565696565442121L, 123210002464200012321L, 123212222474222212321L, 123232425484524232321L, 123234645696546432321L, 123432124686421234321L, 123434346696643434321L, 400000000080000000004L, 400004000090000400004L, 10000000000200000000001L, 10000220001410002200001L, 10002002100400120020001L, 10002222123632122220001L, 10020010200400201002001L, 10020230421612403202001L, 10022014302620341022001L, 10022234545854543222001L, 10201000020402000010201L, 10201222221612222210201L, 10203022140604122030201L, 10203244363836344230201L, 10221210222622201212201L, 10221432643834623412201L, 10223234344844343232201L, 12100000002420000000121L, 12100242003630024200121L, 12102202302620320220121L, 12102444325852344420121L, 12122010222622201022121L, 12122252443834425222121L, 12124214524842541242121L, 12321000024642000012321L, 12321244225852244212321L, 12323222344844322232321L, 12343210246864201234321L, 40000000000800000000004L]\ndef isp(n):\n    s = str(n)\n    return s == s[::-1]\n \nfs = []\nfor i in range(N):\n    s = str(i)\n    n1 = int(s + s[::-1])**2\n    n2 = int(s[:-1] + s[::-1])**2\n \n    if isp(n1):\n        fs.append(n1)\n    if isp(n2):\n        fs.append(n2)\n \nfs.sort()\n \nprint(fs, file=sys.stderr)\n \n \nfin = sys.stdin\nT = int(fin.readline())\nfor case in range(1,T+1):\n    board = []\n    A, B = map(int, fin.readline().split())\n \n    i = bisect.bisect_left(fs, A)\n    j = bisect.bisect_right(fs, B)\n \n    print(\"Case #%d: %s\" % (case, j-i))\n \n \n"}
{"author": "ralfkistner", "index": 8, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Uses https://github.com/rkistner/contest-algorithms\n \n# Recently you went to a magic show. You were very impressed by one of the tricks, so you decided to try to figure out the secret behind it!\n \n# The magician starts by arranging 16 cards in a square grid: 4 rows of cards, with 4 cards in each row. Each card has a different number from 1 to 16 written on the side that is showing. Next, the magician asks a volunteer to choose a card, and to tell him which row that card is in.\n \n# Finally, the magician arranges the 16 cards in a square grid again, possibly in a different order. Once again, he asks the volunteer which row her card is in. With only the answers to these two questions, the magician then correctly determines which card the volunteer chose. Amazing, right?\n \n# You decide to write a program to help you understand the magician's technique. The program will be given the two arrangements of the cards, and the volunteer's answers to the two questions: the row number of the selected card in the first arrangement, and the row number of the selected card in the second arrangement. The rows are numbered 1 to 4 from top to bottom.\n \n# Your program should determine which card the volunteer chose; or if there is more than one card the volunteer might have chosen (the magician did a bad job); or if there's no card consistent with the volunteer's answers (the volunteer cheated).\n \n# Solving this problem\n \n# Usually, Google Code Jam problems have 1 Small input and 1 Large input. This problem has only 1 Small input. Once you have solved the Small input, you have finished solving this problem.\n \n# Input\n \n# The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with a line containing an integer: the answer to the first question. The next 4 lines represent the first arrangement of the cards: each contains 4 integers, separated by a single space. The next line contains the answer to the second question, and the following four lines contain the second arrangement in the same format.\n \n# Output\n \n# For each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1).\n \n# If there is a single card the volunteer could have chosen, y should be the number on the card. If there are multiple cards the volunteer could have chosen, y should be \"Bad magician!\", without the quotes. If there are no cards consistent with the volunteer's answers, y should be \"Volunteer cheated!\", without the quotes. The text needs to be exactly right, so consider copying/pasting it from here.\n \n# Limits\n \n# 1 ≤ T ≤ 100.\n# 1 ≤ both answers ≤ 4.\n# Each number from 1 to 16 will appear exactly once in each arrangement.\n \n \nimport sys\n \n \ndef debug(*args):\n    print(*args, file=sys.stderr)\n \nfin = sys.stdin\nT = int(fin.readline())\nfor case in range(1, T + 1):\n    answer1 = int(fin.readline())\n    rows1 = []\n    for i in range(4):\n        rows1.append(set(map(int, fin.readline().split())))\n    answer2 = int(fin.readline())\n    rows2 = []\n    for i in range(4):\n        rows2.append(set(map(int, fin.readline().split())))\n \n    possibilities1 = rows1[answer1-1]\n    possibilities2 = rows2[answer2-1]\n \n    numbers = possibilities1.intersection(possibilities2)\n    result = None\n    if len(numbers) == 1:\n        result = list(numbers)[0]\n    elif len(numbers) == 0:\n        result = 'Volunteer cheated!'\n    else:\n        result = 'Bad magician!'\n \n \n    print(\"Case #%d: %s\" % (case, result))\n \n"}
{"author": "cathco", "index": 9, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\nimport time as tm\nsys.setrecursionlimit(15000)\n \ndef solve(C, F, X, rate, time):\n    if (time + (X / rate)) < ((C / rate) + ((X / (rate+F)) + time)):\n        return time + (X / rate)\n    else:\n        return solve(C, F, X, rate+F, time + (C / rate))\n \nT = int(raw_input())\nfor t in range(T):\n    C, F, X = map(float, raw_input().split())\nprint ('Case #%i: %.7f' % (t+1, solve(C, F, X, 2, 0)))\n"}
{"author": "cathco", "index": 9, "filename": "2014_2974486_5690574640250880.py", "code": "from copy import deepcopy\nimport time\n \ndef solve(W, H, M):\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\n    board[0][0] = 'c'\n    \n    S = [((H*W)-1, board, 0, 0, set())]\n    H -= 1\n    W -= 1\n    while len(S) > 0:\n        state = S.pop()\n        mines = state[0]\n        board = deepcopy(state[1])\n        x = state[2]\n        y = state[3]\n        visited = deepcopy(state[4])\n        visited.add((x, y))\n     \n    if mines == M:\n        s = ''\n        for row in board:\n            s += ''.join(row)\n            s += '\\n'\n        return s\n     \n    elif mines > M:\n        # Up\n        if x > 0 and board[x-1][y] == '*':\n            board[x-1][y] = '.'\n            mines -= 1\n        \n        # Down\n        if x < W and board[x+1][y] == '*':\n            board[x+1][y] = '.'\n            mines -= 1\n        \n        # Left\n        if y > 0 and board[x][y-1] == '*':\n            board[x][y-1] = '.'\n            mines -= 1\n        \n        # Right\n        if y < H and board[x][y+1] == '*':\n            board[x][y+1] = '.'\n            mines -= 1\n        \n        # Up and Left\n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\n            board[x-1][y-1] = '.'\n            mines -= 1\n        \n        # Up and Right\n        if x > 0 and y < H and board[x-1][y+1] == '*':\n            board[x-1][y+1] = '.'\n            mines -= 1\n        \n        # Down and Left\n        if x < W and y > 0 and board[x+1][y-1] == '*':\n            board[x+1][y-1] = '.'\n            mines -= 1\n        \n        # Down and Right\n        if x < W and y < H and board[x+1][y+1] == '*':\n            board[x+1][y+1] = '.'\n            mines -= 1\n        \n        # Up\n        if x > 0 and not (x-1, y) in visited:\n            S.append((mines, board, x-1, y, visited))\n        \n        # Down\n        if x < W and not (x+1, y) in visited:\n            S.append((mines, board, x+1, y, visited))\n        \n        # Left\n        if y > 0 and not (x, y-1) in visited:\n            S.append((mines, board, x, y-1, visited))\n        \n        # Right\n        if y < H and not (x, y+1) in visited:\n            S.append((mines, board, x, y+1, visited))\n        \n        # Up and Left\n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\n            S.append((mines, board, x-1, y-1, visited))\n        \n        # Up and Right\n        if x > 0 and y < H and not (x-1, y+1) in visited:\n            S.append((mines, board, x-1, y+1, visited))\n        \n        # Down and Left\n        if x < W and y > 0 and not (x+1, y-1) in visited:\n            S.append((mines, board, x+1, y-1, visited))\n        \n        # Down and Right\n        if x < W and y < H and not (x+1, y+1) in visited:\n            S.append((mines, board, x+1, y+1, visited))\n    return 'Impossible'\n \nT = int(raw_input())\nfor t in range(T):\n    W, H, M = map(int, raw_input().split())\nprint ('Case #%i:\\n%s' % (t+1, solve(W, H, M).strip()))\n"}
{"author": "cathco", "index": 9, "filename": "2012_1460488_1595491.py", "code": "import sys\n \nT = int(sys.stdin.readline())\nfor i in range(T):\n    line = sys.stdin.readline().strip()\n    values = map(int, line.split(' '))\n    N = values[0]\n    S = values[1]\n    p = values[2]\n    totals = values[3:]\n    ans = 0\n    for total in totals:\n        base = total / 3\n        remainder = total - (base * 3)\n        scores = [base, base, base]\n        j = 0\n        while remainder > 0:\n            scores[j] += 1\n            remainder -= 1\n            j = (j + 1) % 3\n        if max(scores) >= p:\n            ans += 1\n        else:\n            if S > 0:\n                remainder = total - (base * 3)\n                if remainder == 0 and base > 0:\n                    if base + 2 >= p:\n                        ans += 1\n                        S -= 1\n                elif base + min(remainder, 2) >= p:\n                    ans += 1\n                    S -= 1\n    print('Case #%s: %s' % (i+1, ans))\n"}
{"author": "cathco", "index": 9, "filename": "2013_2270488_2453486.py", "code": "def check(board):\n    # Check rows.\n    for i in range(4):\n        row = board[i]\n        if set(row) in [set(['X', 'T']), set(['X'])]:\n            return 'X won'\n        if set(row) in [set(['O', 'T']), set(['O'])]:\n            return 'O won'\n    \n    # Check columns.\n    for i in range(4):\n        column = []\n        for j in range(4):\n            column.append(board[j][i])\n        if set(column) in [set(['X', 'T']), set(['X'])]:\n            return 'X won'\n        if set(column) in [set(['O', 'T']), set(['O'])]:\n            return 'O won'\n    \n    # Check diagonal top_left->bottom_right\n    diag1 = [board[0][0], board[1][1], board[2][2], board[3][3]]\n    if set(diag1) in [set(['X', 'T']), set(['X'])]:\n        return 'X won'\n    if set(diag1) in [set(['O', 'T']), set(['O'])]:\n        return 'O won'\n    \n    # Check diagonal top_right->bottom_left\n    diag2 = [board[3][0], board[2][1], board[1][2], board[0][3]]\n    if set(diag2) in [set(['X', 'T']), set(['X'])]:\n        return 'X won'\n    if set(diag2) in [set(['O', 'T']), set(['O'])]:\n        return 'O won'\n    \n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                return 'Game has not completed'\n    return 'Draw'\n \nn = int(raw_input().strip())\nfor i in range(n):\n    board = []\nfor j in range(4):\n    line = raw_input()\n    board.append([c for c in line])\nraw_input()\nprint ('Case #%i: %s' % (i+1, check(board)))\n"}
{"author": "cathco", "index": 9, "filename": "2013_2270488_2449486.py", "code": "def up_down(board, height, y, x):\n    # Move up from (x, y).\n    above = y - 1\n    while above >= 0:\n        if board[above][x] > board[y][x]: \n            return False\n        above -= 1\n    # Move down from (x, y).\n    below = y + 1\n    while below < height:\n        if board[below][x] > board[y][x]: \n            return False\n        below += 1\n    return True\n   \ndef left_right(board, width, y, x):\n    # Move left from (x, y).\n    before = x - 1\n    while before >= 0:\n        if board[y][before] > board[y][x]: \n            return False\n        before -= 1\n    # Move right from (x, y).\n    after = y + 1\n    while after < width:\n        if board[y][after] > board[y][x]: \n            return False\n        after += 1\n    return True\n   \ndef check(board, height, width):\n    if height == 1 or width == 1:\n        return 'YES'\n    for i in range(height):\n        for j in range(width):\n            if (not up_down(board, height, i, j)) and (not left_right(board, width, i, j)):\n                return 'NO'\n    return 'YES'\n \nn = int(raw_input().strip())\nfor i in range(n):\n    height, width = map(int,  raw_input().strip().split(' '))\nboard = []\nfor _ in range(height):\n    row = map(int, raw_input().strip().split(' '))\n    board.append(row)\nprint ('Case #%i: %s' % (i+1, check(board, height, width)))\n"}
{"author": "cathco", "index": 9, "filename": "2012_1460488_1483485.py", "code": "import sys\n \ndata = [\n    ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'],\n    ['rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'],\n    ['de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up']]\n \ntrans = {'y': 'a', 'e': 'o', 'q': 'z', 'z': 'q'}\nfor row in data:\n    [googlerese, english] = row\n    for i in range(0, len(googlerese)):\n        if not googlerese[i] in trans:\n            trans[googlerese[i]] = english[i]\n \ndef translate(googlerese):\n    english = ''\n    for c in googlerese:\n        english += trans[c]\n    return english\n \nT = int(sys.stdin.readline())\nfor i in range(T):\n    print('Case #%s: %s' % (i+1, translate(sys.stdin.readline().strip())))\n"}
{"author": "cathco", "index": 9, "filename": "2013_2270488_2463486.py", "code": "import math\n \ndef isPalindrome(s):\n    length = len(s)\n    for i in xrange(length / 2):\n        if s[i] != s[length - 1 - i]: \n            return False\n    return True\n \nn = int(raw_input())\nfor i in range(n):\n    a, b = map(int, raw_input().strip().split(' '))\ncount = 0\nfor j in range(a, b+1):\n    if isPalindrome(str(j)):\n        s = math.sqrt(j)\n    if s == int(s) and isPalindrome(str(int(s))):\n        count += 1\nprint ('Case #%i: %i' % (i+1, count))\n"}
{"author": "cathco", "index": 9, "filename": "2014_2974486_5756407898963968.py", "code": "T = int(raw_input())\nfor i in range(T):\n    index = int(raw_input())\nX = []\nfor j in range(4):\n    X.append(map(int, raw_input().split()))\nx1 = X[index-1]\nindex = int(raw_input())\nX = []\nfor j in range(4):\n    X.append(map(int, raw_input().split()))\nx2 = X[index-1]\nans = set(x1).intersection(set(x2))\nif len(ans) == 0:\n    print ('Case #%i: Volunteer cheated!' % (i+1))\nelif len(ans) == 1:\n    print ('Case #%i: %i' % (i+1, ans.pop()))\nelse:\n    print ('Case #%i: Bad magician!' % (i+1))\n"}
{"author": "gepa", "index": 10, "filename": "2014_2974486_5709773144064000.py", "code": "import math\nimport sys\n \n \ndef compute(C, F, X):\n    k = int(math.floor(X / C - 2.0 / F))\n    if k <= 0:\n        return X / 2\n    total = 0.0\n    for i in xrange(k):\n        total += 1.0 / (2.0 + i * F)\n    return C * total + X / (2.0 + k * F)\n \n \ndef parse():\n    C, F, X = map(float, sys.stdin.readline().strip().split())\n    return C, F, X\n \n \nif __name__ == \"__main__\":\n    sys.setrecursionlimit(100000)\n    T = int(sys.stdin.readline().strip())\n    for i in xrange(T):\n        data = parse()\n        result = compute(*data)\n        print(\"Case #%d: %0.7f\" % (i + 1, result))\n"}
{"author": "gepa", "index": 10, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\n \n \nDX = (-1, -1, -1, 0, 1, 1, 1, 0)\nDY = (-1, 0, 1, 1, 1, 0, -1, -1)\n \n \ndef compute(R, C, M):\n    if M == 0:\n        return empty(R, C)\n    free = R * C - M\n    if free == 1:\n        return single_free(R, C)\n    if R == 1:\n        return single_row(C, M)\n    if C == 1:\n        return single_column(R, M)\n    if R == 2:\n        return two_rows(C, M)\n    if C == 2:\n        return two_columns(R, M)\n    if free in (2,3,5,7):\n        return \"\\nImpossible\"\n    return at_least_three(R, C, M)\n \n \ndef make_board(R, C, default='.'):\n    return [[default for j in xrange(C)] for i in xrange(R)]\n \n \ndef to_string(board):\n    s = \"\"\n    for i in xrange(len(board)):\n        s += '\\n' + ''.join(board[i])\n    return s\n \n         \ndef empty(R, C):\n    board = make_board(R, C)\n    board[0][0] = 'c'\n    return to_string(board)\n \n \ndef single_free(R, C):\n    board = make_board(R, C, default='*')\n    board[0][0] = 'c'\n    return to_string(board)\n \n \ndef single_row(C, M):\n    board = make_board(1, C)\n    board[0][0] = 'c'\n    for i in xrange(M):\n        board[0][C - 1 - i] = '*'\n    return to_string(board)\n \n \ndef single_column(R, M):\n    board = make_board(R, 1)\n    board[0][0] = 'c'\n    for i in xrange(M):\n        board[R - 1 - i][0] = '*'\n    return to_string(board)\n \n \ndef two_rows(C, M):\n    if M % 2 != 0:\n        return \"\\nImpossible\"\n    if 2 * C - M < 4:\n        return \"\\nImpossible\"\n    board = make_board(2, C)\n    for i in xrange(M / 2):\n        board[0][C - 1 - i] = '*'\n        board[1][C - 1 - i] = '*'\n    board[0][0] = 'c'\n    return to_string(board)\n \n \ndef two_columns(R, M):\n    if M % 2 != 0:\n        return \"\\nImpossible\"\n    if 2 * R - M < 4:\n        return \"\\nImpossible\"\n    board = make_board(R, 2)\n    for i in xrange(M / 2):\n        board[R - 1 - i][0] = '*'\n        board[R - 1 - i][1] = '*'\n    board[0][0] = 'c'\n    return to_string(board)\n \n \ndef finalize(R, C, M, board):\n    mines = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            if board[i][j] == '0':\n                continue\n            empty = False\n            for d in xrange(8):\n                if i + DX[d] < 0 or i + DX[d] >= R or j + DY[d] < 0 or j + DY[d] >= C:\n                    continue\n                if board[i + DX[d]][j + DY[d]] == '0':\n                    empty = True\n                    break\n            if empty:\n                board[i][j] = '.'\n            else:\n                board[i][j] = '*'\n                mines += 1\n    for i in xrange(R):\n        for j in xrange(C):\n            if board[i][j] == '0':\n                board[i][j] = '.'\n    board[0][0] = 'c'\n    if mines != M:\n        sys.stderr.write(\"mines:%s expected:%s\\n\" % (mines, M))\n    return to_string(board)\n \n \ndef at_least_three(R, C, M):\n    board = make_board(R, C)\n    board[0][0] = '0'\n    free = R * C - M\n    count = 4\n    if count == free:\n        return finalize(R, C, M, board)\n    board[0][1] = '0'\n    count += 2\n    if count == free:\n        return finalize(R, C, M, board)\n    board[1][0] = '0'\n    count += 2\n    if count == free:\n        return finalize(R, C, M, board)\n    for j in xrange(2, C - 1):\n        if count + 2 > free:\n            break\n        board[0][j] = '0'\n        count += 2\n    for i in xrange(2, R - 1):\n        if count + 2 > free:\n            break\n        board[i][0] = '0'\n        count += 2\n    for i in xrange(1, R - 1):\n        for j in xrange(1, C - 1):\n            if count == free:\n                return finalize(R, C, M, board)\n            board[i][j] = '0'\n            count += 1\n    sys.stderr.write(\"empty board?\\n\")\n    return finalize(board)\n \n \ndef parse():\n    R, C, M = map(int, sys.stdin.readline().strip().split())\n    return R, C, M\n \n \nif __name__ == \"__main__\":\n    sys.setrecursionlimit(100000)\n    T = int(sys.stdin.readline().strip())\n    for i in xrange(T):\n        sys.stderr.write(\"case:%s\\n\" % (i + 1))\n        data = parse()\n        result = compute(*data)\n        print(\"Case #%d: %s\" % (i + 1, result))\n"}
{"author": "gepa", "index": 10, "filename": "2012_1460488_1595491.py", "code": "import sys\n \n \nif __name__ == \"__main__\":\n    T = int(sys.stdin.readline().strip())\n    for i in xrange(T):\n        values = map(int, sys.stdin.readline().strip().split(' '))\n        _N, S, p = values[0:3]\n        t = values[3:]\n        min_normal = p + 2 * max(0, p - 1)\n        min_surprising = p + 2 * max(0, p - 2)\n        cnt_normal = len(filter(lambda x : x >= min_normal, t))\n        cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal\n        print(\"Case #%d: %s\" % (i + 1, cnt_normal + min(cnt_surprising, S)))\n"}
{"author": "gepa", "index": 10, "filename": "2013_2270488_2453486.py", "code": "import sys\nimport string\n \n \ndef won(board, mapping):\n    val = int(board.translate(string.maketrans(mapping, \"1100\")), 2)\n    for v in [0x000f, 0x00f0, 0x0f00, 0xf000,\n            0x1111, 0x2222, 0x4444, 0x8888,\n            0x1248, 0x8421]:\n        if (val & v) == v:\n            return True\n    return False\n \n \ndef finished(board):\n    return '.' not in board\n \n \ndef compute(board):\n    if won(board, 'XTO.'):\n        return \"X won\"\n    if won(board, 'OTX.'):\n        return \"O won\"\n    if finished(board):\n        return \"Draw\"\n    return \"Game has not completed\"\n \n \ndef parse():\n    board = []\n    for i in xrange(4):\n        board.append(sys.stdin.readline().strip())\n    sys.stdin.readline()\n    return (''.join(board),)\n \n \nif __name__ == \"__main__\":\n    sys.setrecursionlimit(100000)\n    T = int(sys.stdin.readline().strip())\n    count = 1\n    part = 0\n    if len(sys.argv) == 3:\n        part = int(sys.argv[1])\n        count = int(sys.argv[2])\n    for i in xrange(T):\n        data = parse()\n        if i * count >= part * T and i * count < (part + 1) * T:\n            result = compute(*data)\n            print(\"Case #%d: %s\" % (i + 1, result))\n"}
{"author": "gepa", "index": 10, "filename": "2013_2270488_2449486.py", "code": "import sys\n \n \ndef compute(N, M, a):\n    rows = [0] * N\n    cols = [0] * M\n    for r in xrange(N):\n        rows[r] = 0\n        for c in xrange(M):\n            if a[r][c] > rows[r]:\n                rows[r] = a[r][c]\n    for c in xrange(M):\n        cols[c] = 0\n        for r in xrange(N):\n            if a[r][c] > cols[c]:\n                cols[c] = a[r][c]\n    for r in xrange(N):\n        for c in xrange(M):\n            if a[r][c] < rows[r] and a[r][c] < cols[c]:\n                return \"NO\"\n    return \"YES\"\n \n \ndef parse():\n    N, M = map(int, sys.stdin.readline().strip().split())\n    a = []\n    for i in xrange(N):\n        a.append(map(int, sys.stdin.readline().strip().split()))\n    return N, M, a,\n \n \nif __name__ == \"__main__\":\n    sys.setrecursionlimit(100000)\n    T = int(sys.stdin.readline().strip())\n    count = 1\n    part = 0\n    if len(sys.argv) == 3:\n        part = int(sys.argv[1])\n        count = int(sys.argv[2])\n    for i in xrange(T):\n        data = parse()\n        if i * count >= part * T and i * count < (part + 1) * T:\n            result = compute(*data)\n            print(\"Case #%d: %s\" % (i + 1, result))\n"}
{"author": "gepa", "index": 10, "filename": "2012_1460488_1483485.py", "code": "import sys\n \nmapping = {}\n \ndef init_mapping():\n    encoded = [\"ejp mysljylc kd kxveddknmc re jsicpdrysi\",\n            \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\",\n            \"de kr kd eoya kw aej tysr re ujdr lkgc jv\",\n            \"y qee z\"\n            ]\n    decoded = [\"our language is impossible to understand\",\n            \"there are twenty six factorial possibilities\",\n            \"so it is okay if you want to just give up\",\n            \"a zoo q\"\n            ]\n    for i in xrange(len(encoded)):\n        for j in xrange(len(encoded[i])):\n            if encoded[i][j] in mapping and mapping[encoded[i][j]] != decoded[i][j]:\n                raise Exception(\"Multiple mapping for %s\" % encoded[i][j])\n            mapping[encoded[i][j]] = decoded[i][j]\n \n \ndef decode(sentence):\n    return ''.join(map(lambda x : mapping.get(x, x), sentence))\n \n \nif __name__ == \"__main__\":\n    init_mapping()\n    T = int(sys.stdin.readline().strip())\n    for i in xrange(T):\n        result = decode(sys.stdin.readline().strip())\n        print(\"Case #%d: %s\" % (i + 1, result))\n"}
{"author": "gepa", "index": 10, "filename": "2013_2270488_2463486.py", "code": "import sys\nimport math\n \n \nfairsquares = []\n \n \ndef read_fairsquares():\n    global fairsquares\n    f = open('fairsquares.txt')\n    for x in f:\n        fairsquares.append(int(x.strip()))\n \n \ndef count_less_than(A):\n    left = 0\n    right = len(fairsquares)\n    # fairsquares[left - 1] < A <= fairsquares[right]\n    while left < right:\n        middle = (left + right) // 2\n        if fairsquares[middle] < A:\n            left = middle + 1\n        else:\n            right = middle\n    return left\n \n \ndef compute(A, B):\n    count_b = count_less_than(B + 1)\n    count_a = count_less_than(A)\n    return count_b - count_a\n \n \ndef parse():\n    return map(int, sys.stdin.readline().strip().split())\n \n \nif __name__ == \"__main__\":\n    read_fairsquares()\n    T = int(sys.stdin.readline().strip())\n    count = 1\n    part = 0\n    if len(sys.argv) == 3:\n        part = int(sys.argv[1])\n        count = int(sys.argv[2])\n    for i in xrange(T):\n        data = parse()\n        if i * count >= part * T and i * count < (part + 1) * T:\n            result = compute(*data)\n            print(\"Case #%d: %s\" % (i + 1, result))\n"}
{"author": "gepa", "index": 10, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \n \ndef compute(r1, m1, r2, m2):\n    valid1 = set(m1[r1 - 1])\n    valid2 = set(m2[r2 - 1])\n    valid = valid1 & valid2\n    if len(valid) == 0:\n        return 'Volunteer cheated!'\n    if len(valid) > 1:\n        return 'Bad magician!'\n    return valid.pop()\n \n \ndef parse_single():\n    r = int(sys.stdin.readline().strip())\n    m = []\n    for i in xrange(4):\n        m.append(map(int, sys.stdin.readline().strip().split()))\n    return r, m\n \ndef parse():\n    r1, m1 = parse_single()\n    r2, m2 = parse_single()\n    return r1, m1, r2, m2\n \n \nif __name__ == \"__main__\":\n    sys.setrecursionlimit(100000)\n    T = int(sys.stdin.readline().strip())\n    for i in xrange(T):\n        data = parse()\n        result = compute(*data)\n        print(\"Case #%d: %s\" % (i + 1, result))\n"}
{"author": "jgaten", "index": 11, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/env python\n \nimport sys\n \ndef solve(c, f, x):\n    time = 0\n    cps = 2.0\n    while True:\n        time_to_farm = c / cps\n        time_to_end = x / cps\n        buy_a_farm = (time_to_farm + x / (cps + f)) < time_to_end\n        #print time_to_farm, time_to_end, (time_to_farm + x / (cps + f)), buy_a_farm\n        if buy_a_farm:\n            time += time_to_farm\n            cps += f\n        else:\n            time += time_to_end\n            return time\n \nif __name__ == '__main__':\n    fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n    fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n    with fin, fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n            c, f, x = map(float, fin.readline().split())\n            soln = solve(c, f, x)\n            print >> fout, \"Case #{0}: {1:.7f}\".format(case, soln)\n \n"}
{"author": "jgaten", "index": 11, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\n \nimport sys\n \nIMPOSSIBLE = []\n \ndef transpose(grid):\n    return map(list, zip(*grid))\n \ndef find_grid(R, C, M):\n    \"\"\"Return a grid of a solution, if one exists, otherwise []\n \n    Observations:\n    * WLOG, C <= R (otherwise, take the transpose of a solution)\n    * Trivial cases are:\n    - M = 0 or  M = RC - 1\n    - C = 1\n    - (R, C) = (2, 2)\n    - (R, C, M) = (3, 3, 2)\n    - (C, M) = (2, 1)\n    * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1\n    * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable\n    \"\"\"\n    # Take care of simple cases\n    if M == 0:\n        #print \"zero \", R, C, M\n        grid = [['.' for c in xrange(C)] for r in xrange(R)]\n        grid[0][0] = 'c'\n        return grid\n    elif M == R * C - 1:\n        #print \"full \", R, C, M\n        grid = [['*' for c in xrange(C)] for r in xrange(R)]\n        grid[0][0] = 'c'\n        return grid\n    elif C > R:\n        #print \"trans\", R, C, M\n        return transpose(find_grid(C, R, M))\n    elif C == 1:\n        #print \"C=1  \", R, C, M\n        return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]\n    elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):\n        #print \"impos\", R, C, M\n        return IMPOSSIBLE\n \n    assert 2 <= C <= R >= 3, \"R={} C={} M={}\".format(R, C, M)\n \n    if M >= C:\n        #print \"M>=C \", R, C, M\n        s = find_grid(R-1, C, M-C)\n        return s and s + [['*' for c in xrange(C)]]\n    elif M <= R-2 and C >= 3:\n        #print \"M+1<R\", R, C, M\n        grid = [['.' for c in xrange(C)] for r in xrange(R)]\n        grid[0][0] = 'c'\n        for i in xrange(M):\n            grid[R-i-1][C-1] = '*'\n        return grid\n    elif M + 1 == R == C >= 4:\n        #print \"M+1=R\", R, C, M\n        grid = [['.' for c in xrange(C)] for r in xrange(R)]\n        grid[0][0] = 'c'\n        grid[R-1][C-2] = '*'\n        for i in xrange(M-1):\n            grid[R-i-1][C-1] = '*'\n        return grid\n \n    assert False, \"R={} C={} M={}\".format(R, C, M)\n \ndef check_soln(grid, R, C, M):\n    \"\"\"checking, because debugging...\"\"\"\n    error = \"R={} C={} M={}\".format(R, C, M)\n    assert sum(row.count('*') for row in grid) == M, error\n    assert sum(row.count('c') for row in grid) == 1, error\n    assert len(grid) == R, error\n    assert all(len(row) == C for row in grid), error\n    _ = [i for i, row in enumerate(grid) if 'c' in row][0]\n    click = (_, [i for i, c in enumerate(grid[_]) if c == 'c'][0])\n \n    def neighbours(r, c):\n        ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]\n        ns.remove((r, c))\n        return ns\n \n    cpy = map(list, grid)\n    def fill(cpy, pos):\n        cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if grid[i][j] == '*'))\n        if cpy[pos[0]][pos[1]] == '0':\n            for i, j in neighbours(*pos):\n                if cpy[i][j] == '.':\n                    fill(cpy, (i, j))\n    fill(cpy, click)\n    assert sum(row.count('.') for row in cpy) == 0, error\n \ndef solve(R, C, M):\n    soln = find_grid(R, C, M)\n    if soln == IMPOSSIBLE:\n        return \"Impossible\"\n    else:\n        check_soln(soln, R, C, M)\n        return '\\n'.join(''.join(row) for row in soln)\n \nif __name__ == '__main__':\n    fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n    fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n    with fin, fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n            r, c, m = map(int, fin.readline().split())\n            soln = solve(r, c, m)\n            print >> fout, \"Case #{0}:\\n{1}\".format(case, soln)\n \n"}
{"author": "jgaten", "index": 11, "filename": "2012_1460488_1595491.py", "code": "#!/usr/local/bin/python3\nimport sys\nfrom math import ceil\n \ndef solve(n, s, p, scores):\n    count = 0\n    for t in scores:\n        if ceil(t/3) >= p:\n            # This one must have a best score, even if it wasn't surprising.\n            count += 1\n        elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:\n            # This one could be surprising\n            count += 1\n            s -= 1\n    return count\n \nif __name__ == '__main__':\n    with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n        T = int(fin.readline())\n        for case in range(1, T+1):\n            line = map(int, fin.readline().split())\n            n, s, p, *scores = line\n            result = solve(n, s, p, scores)\n            print(\"Case #{0}: {1}\".format(case, result), file=fout)\n"}
{"author": "jgaten", "index": 11, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\nimport sys\n \ndef fours(grid):\n    for i in xrange(4):\n        yield list(grid[i]) # row i\n        yield [grid[x][i] for x in xrange(4)] # column i\n    yield [grid[x][x] for x in xrange(4)] # major diagonal\n    yield [grid[x][3-x] for x in xrange(4)] # minor diagonal\n \ndef solve(grid):\n    for x in fours(grid):\n        if set(x) in ({'X', 'T'}, {'X'}):\n            return \"X won\"\n        elif set(x) in ({'O', 'T'}, {'O'}):\n            return \"O won\"\n    if any('.' in x for x in grid):\n        return \"Game has not completed\"\n    else:\n        return \"Draw\"\n \nif __name__ == '__main__':\n    with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n \n            grid = [fin.readline().strip() for _ in xrange(4)]\n            assert fin.readline().strip() == ''\n \n            soln = solve(grid)\n            print >> fout, \"Case #{0}: {1}\".format(case, soln)\n"}
{"author": "jgaten", "index": 11, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/env python\nimport sys\n \ndef solve(N, M, grid):\n    possible = [[False for _ in xrange(M)] for _ in xrange(N)]\n    for i in xrange(N):\n        m = max(grid[i])\n        for j in xrange(M):\n            possible[i][j] = possible[i][j] or grid[i][j] == m\n \n    for j in xrange(M):\n        m = max(grid[_][j] for _ in xrange(N))\n        for i in xrange(N):\n            possible[i][j] = possible[i][j] or grid[i][j] == m\n \n    if all(all(row) for row in possible):\n        return \"YES\"\n    else:\n        return \"NO\"\n \nif __name__ == '__main__':\n    with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n            print (\"Case #{0}:\".format(case))\n \n            N, M = map(int, fin.readline().split())\n            grid = [map(int, fin.readline().split()) for _ in xrange(N)]\n \n            soln = solve(N, M, grid)\n            print (soln)\n            print >> fout, \"Case #{0}: {1}\".format(case, soln)\n"}
{"author": "jgaten", "index": 11, "filename": "2012_1460488_1483485.py", "code": "import sys\n \nfrom string import translate, maketrans\n \ncode = maketrans(\"y qee\"\n                \"ejp mysljylc kd kxveddknmc re jsicpdrysi\"\n                \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\"\n                \"de kr kd eoya kw aej tysr re ujdr lkgc jv\"\n                \"z\",\n                \"a zoo\"\n                \"our language is impossible to understand\"\n                \"there are twenty six factorial possibilities\"\n                \"so it is okay if you want to just give up\"\n                \"q\")\n \nif __name__ == '__main__':\n    with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n            line = fin.readline().strip('\\n')\n            decrypted = translate(line, code)\n            print >> fout, \"Case #{0}: {1}\".format(case, decrypted)"}
{"author": "jgaten", "index": 11, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/env python\nimport sys\n \nfrom itertools import count\n \ndef palindromes():\n    # it's not straightforward to get the numbers in order...\n    for digits in count(1):\n        for n in xrange(10**(digits-1), 10**digits):\n            n = str(n)\n            yield int(n + n[-2::-1])\n        for n in xrange(10**(digits-1), 10**digits):\n            n = str(n)\n            yield int(n + n[::-1])\n \ndef is_palindrome(n):\n    n = str(n)\n    return n == n[::-1]\n \ndef solve(A, B):\n    # Loop through palindromic numbers and check that their squares are palindromes.\n    count = 0\n    for n in palindromes():\n        square = n**2\n        if square > B:\n            break\n        if square >= A and is_palindrome(square):\n            count += 1\n    return count\n \nif __name__ == '__main__':\n    with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n \n            A, B = map(int,fin.readline().split())\n            soln = solve(A, B)\n \n            print >> fout, \"Case #{0}: {1}\".format(case, soln)\n"}
{"author": "jgaten", "index": 11, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\n \nimport sys\n \ndef read_row(fin, n):\n    rows = [set(map(int, fin.readline().strip().split())) for i in xrange(4)]\n    return rows[n-1]\n \ndef solve(rowa, rowb):\n    both = rowa & rowb\n    if len(both) == 1:\n        return list(both)[0]\n    elif len(both) > 1:\n        return \"Bad magician!\"\n    elif not both:\n        return \"Volunteer cheated!\"\n \nif __name__ == '__main__':\n    fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n    fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n    with fin, fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n            n = int(fin.readline())\n            rowa = read_row(fin, n)\n            n = int(fin.readline())\n            rowb = read_row(fin, n)\n            soln = solve(rowa, rowb)\n            print >> fout, \"Case #{0}: {1}\".format(case, soln)\n \n"}
{"author": "ziyan", "index": 12, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\nimport Queue\n \n \ndef click(C, F, X):\n    states = Queue.PriorityQueue()\n \n    # (time, rate, is_done)\n    states.put((0.0, 2.0, False))\n    while not states.empty():\n        time, rate, is_done = states.get()\n \n        # done\n        if is_done:\n            return time\n \n        # two ways to move forward\n        # 1. wait\n        states.put((\n            time + X / rate,\n            rate,\n            True\n        ))\n \n        # 2. wait for a farm\n        states.put((\n            time + C / rate,\n            rate + F,\n            False\n        ))\n \n    return None\n \ndef main():\n    cases = int(sys.stdin.readline())\n \n    for case in range(cases):\n        C, F, X = map(float, sys.stdin.readline().split())\n        print('Case #%d: %.7f' % (case + 1, click(C, F, X)))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "ziyan", "index": 12, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\nimport random\n \nNEIGHBOURS = [\n    (-1, -1), (-1, 0), (-1, 1),\n    ( 0, -1),          ( 0, 1),\n    ( 1, -1), ( 1, 0), ( 1, 1),\n]\n \nMOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n \ndef valid(size, location, changes):\n    y, x = location\n    for y1, x1 in changes:\n        y1 += y\n        x1 += x\n        if y1 < 0 or y1 >= size[0]:\n            continue\n        if x1 < 0 or x1 >= size[1]:\n            continue\n        yield (y1, x1)\n \ndef click(size, grid, location):\n    y, x = location\n    if grid[y][x] is 0:\n        return None\n \n    grid = [row[:] for row in grid]\n    grid[y][x] = 0\n \n    for y, x in valid(size, location, NEIGHBOURS):\n        if grid[y][x]:\n            grid[y][x] = False\n \n    return grid\n \ndef sweep(R, C, M):\n    # create initial grid\n    grid = [[True] * C for _ in range(R)]\n    size = (R, C)\n \n    if M + 1 == R * C:\n        grid[0][0] = False\n        return grid, (0, 0)\n \n    # start by click top left\n    states = []\n    for y in range(R):\n        for x in range(C):\n            location = (y, x)\n            states.append((click(size, grid, location), location))\n \n    while states:\n        grid, location = states.pop(0)\n \n        mines_count = sum([sum(row) for row in grid])\n        if mines_count == M:\n            return grid, location\n \n        if mines_count < M:\n            continue\n \n        for new_location in valid(size, location, NEIGHBOURS):\n            new_grid = click(size, grid, new_location)\n            if new_grid:\n                states.insert(0, (new_grid, new_location))\n \n    return None\n \ndef validate(size, grid, location):\n \n    result = [row[:] for row in grid]\n \n    y, x = location\n    result[y][x] = sum([\n        grid[y1][x1]\n        for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n    ])\n    assert result[y][x] == 0\n \n    seen = set([location])\n    locations = set([location])\n \n    while locations:\n        location = locations.pop()\n        for y, x in valid(size, location, NEIGHBOURS):\n            assert grid[y][x] is not True\n            result[y][x] = sum([\n                grid[y1][x1]\n                for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n            ])\n            if result[y][x] == 0 and (y, x) not in seen:\n                locations.add((y, x))\n                seen.add((y, x))\n \n    for row in result:\n        for col in row:\n            assert col is not False\n    #print(result)\n \n    for y, row in enumerate(result):\n        output = ''\n        for x, col in enumerate(row):\n            if col is True:\n                output += '*'\n            else:\n                output += str(col)\n        print(output)\n \n \ndef process(case, R, C, M):\n    result = sweep(R, C, M)\n \n    print('Case #%d:' % (case + 1))\n    #print(R, C, M)\n    if not result:\n        #print(R, C, M)\n        print('Impossible')\n        return\n \n    grid, location = result\n    for y, row in enumerate(grid):\n        output = ''\n        for x, col in enumerate(row):\n            if (y, x) == location:\n                output += 'c'\n            elif col:\n                output += '*'\n            #elif col is 0:\n            #    output += '0'\n            else:\n                output += '.'\n        print(output)\n \n    #validate((R, C), grid, location)\n \n \ndef main():\n    #for R in range(1, 6):\n    #    for C in range(1, 6):\n    #        for M in range(R * C):\n    #            process(0, R, C, M)\n    #return\n    #for M in range(1, 25):\n    #    process(M - 1, 5, 5, M)\n    #return\n    cases = int(sys.stdin.readline())\n \n    for case in range(cases):\n        R, C, M = map(int, sys.stdin.readline().split())\n        process(case, R, C, M)\n \n    return\n    for case in range(100):\n        R = random.randrange(51) + 1\n        C = random.randrange(51) + 1\n        M = random.randrange(R * C - 1) + 1\n        process(case * 100000 + M - 1, R, C, M)\n \n \nif __name__ == '__main__':\n    main()\n"}
{"author": "ziyan", "index": 12, "filename": "2012_1460488_1595491.py", "code": "import sys\n \n \ndef calculate_max_score(scores_sum):\n    if scores_sum % 3 == 1:\n        max_score = (scores_sum + 2) / 3\n        return (max_score, max_score)\n    if scores_sum % 3 == 2:\n        max_score = (scores_sum + 1) / 3\n        return (max_score, max_score + 1)\n    max_score = scores_sum / 3\n    if max_score == 0:\n        return (0, 0)\n    return (max_score, max_score + 1)\n \ndef find_max_dancers(s, p, *scores_sums):\n    dancers_count = 0\n    for scores_sum in scores_sums:\n        (normal_max, surprise_max) = calculate_max_score(scores_sum)\n        if normal_max >= p:\n            dancers_count = dancers_count + 1\n            continue\n        if surprise_max >= p and s > 0:\n            s = s - 1\n            dancers_count = dancers_count + 1\n            continue\n    return dancers_count\n \ndef main():\n \n    case_count = int(sys.stdin.readline())\n \n    for case_index in range(1, case_count + 1):\n        line = sys.stdin.readline().strip().split(' ')\n        s = int(line[1])\n        p = int(line[2])\n        scores_sums = [int(scores_sum) for scores_sum in line[3:]]\n        print('Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums)))\n \nif __name__ == '__main__':\n    main()"}
{"author": "ziyan", "index": 12, "filename": "2013_2270488_2453486.py", "code": "\nimport sys\n \ndef process():\n    empty = 0\n    board = [['.', '.', '.', '.'] for i in range(4)]\n    for r in range(4):\n        row = sys.stdin.readline()\n        for c in range(4):\n            board[r][c] = row[c]\n            if row[c] == '.': empty = empty + 1\n    sys.stdin.readline()\n \n    # print(board)\n \n    # check rows\n    for r in range(4):\n        x = 0\n        o = 0\n        for c in range(4):\n            if board[r][c] == 'X':\n                x = x + 1\n            if board[r][c] == 'O':\n                o = o + 1\n            if board[r][c] == 'T':\n                x = x + 1\n                o = o + 1\n        if x == 4: return \"X won\"\n        if o == 4: return \"O won\"\n \n    for c in range(4):\n        x = 0\n        o = 0\n        for r in range(4):\n            if board[r][c] == 'X':\n                x = x + 1\n            if board[r][c] == 'O':\n                o = o + 1\n            if board[r][c] == 'T':\n                x = x + 1\n                o = o + 1\n        if x == 4: return \"X won\"\n        if o == 4: return \"O won\"\n \n    x = 0\n    o = 0\n    for c in range(4):\n        r = c\n        if board[r][c] == 'X':\n            x = x + 1\n        if board[r][c] == 'O':\n            o = o + 1\n        if board[r][c] == 'T':\n            x = x + 1\n            o = o + 1\n \n    if x == 4: return \"X won\"\n    if o == 4: return \"O won\"\n \n    x = 0\n    o = 0\n    for c in range(4):\n        r = 3 - c\n        if board[r][c] == 'X':\n            x = x + 1\n        if board[r][c] == 'O':\n            o = o + 1\n        if board[r][c] == 'T':\n            x = x + 1\n            o = o + 1\n \n    if x == 4: return \"X won\"\n    if o == 4: return \"O won\"\n \n    if empty == 0: return \"Draw\"\n \n    return \"Game has not completed\"\n \n         \n \ndef main():\n \n    count = int(sys.stdin.readline())\n    for index in range(count):\n        result = process()\n        print(\"Case #%d: %s\" % (index + 1, result))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "ziyan", "index": 12, "filename": "2013_2270488_2449486.py", "code": "\nimport sys\n \ndef process():\n    height, width = sys.stdin.readline().split()\n    width = int(width)\n    height = int(height)\n \n    lawn = [[0 for c in range(width)] for r in range(height)]\n    mark = [[0 for c in range(width)] for r in range(height)]\n    settings = []\n \n    for r in range(height):\n        row = sys.stdin.readline().split()\n        for c in range(width):\n            h = int(row[c])\n            lawn[r][c] = h\n            if h not in settings: settings.append(h)\n \n    settings = sorted(settings)\n \n    for i in range(len(settings)):\n        h = settings[i]\n        h_next = 0\n        if i < len(settings) - 1:\n            h_next = settings[i + 1]\n \n        # check row\n        for r in range(height):\n            count = 0\n            for c in range(width):\n                if lawn[r][c] == h: count = count + 1\n            if count == width:\n                for c in range(width): mark[r][c] = h\n \n        # check col\n        for c in range(width):\n            count = 0\n            for r in range(height):\n                if lawn[r][c] == h: count = count + 1\n            if count == height:\n                for r in range(height): mark[r][c] = h\n \n        # anything left?\n        for c in range(width):\n            for r in range(height):\n                if lawn[r][c] == h:\n                    if mark[r][c] != h: return \"NO\"\n                    lawn[r][c] = h_next\n \n    return \"YES\"\n \n         \n \ndef main():\n \n    count = int(sys.stdin.readline())\n    for index in range(count):\n        result = process()\n        print(\"Case #%d: %s\" % (index + 1, result))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "ziyan", "index": 12, "filename": "2012_1460488_1483485.py", "code": "import sys\n \ncipher = dict()\n \ndef learn(encrypted_text, clear_text):\n    for encrypted_letter, clear_letter in zip(encrypted_text, clear_text):\n        if encrypted_letter in cipher:\n            assert cipher[encrypted_letter] == clear_letter\n        cipher[encrypted_letter] = clear_letter\n \ndef test():\n    alphabet = 'abcdefghijklmnopqrstuvwxyz '\n    for letter in alphabet:\n        if letter not in cipher.keys():\n            print('Googlerese letter %s does not have corresponding English letter.' % letter)\n        if letter not in cipher.values():\n            print('English letter %s not found in cipher dictionary values.' % letter)\n    if len(cipher.keys()) != len(alphabet):\n        print('Size of cipher dictionary and alphabet mismatch.')\n \ndef decrypt(text):\n    decrypted_text = ''\n    for letter in text:\n        assert letter in cipher\n        decrypted_text += cipher[letter]\n    return decrypted_text\n \ndef main():\n    learn(' yeqz', ' aozq')\n    learn('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand')\n    learn('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities')\n    learn('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')\n    test()\n \n    case_count = int(sys.stdin.readline())\n \n    for case_index in range(1, case_count + 1):\n        print('Case #%i: %s' % (case_index, decrypt(sys.stdin.readline().strip())))\n \nif __name__ == '__main__':\n    main()"}
{"author": "ziyan", "index": 12, "filename": "2013_2270488_2463486.py", "code": "\nimport sys\nimport math\n \ndef is_fair(n):\n    n = str(n)\n    for i in range(long(len(n) / 2)):\n        if n[i] != n[len(n) - i - 1]:\n            return False\n    return True\n \ndef is_square_and_fair(n):\n    if not is_fair(n): return False\n    root = math.sqrt(n)\n    if root != math.floor(root): return False\n    if not is_fair(long(root)): return False\n    return True\n \ndef process():\n    a, b = sys.stdin.readline().split()\n    a = long(a)\n    b = long(b)\n     \n    count = 0\n    for i in range(a, b + 1):\n        if is_square_and_fair(i): count = count + 1\n \n    return count\n \ndef main():\n \n    count = int(sys.stdin.readline())\n    for index in range(count):\n        result = process()\n        print(\"Case #%d: %s\" % (index + 1, result))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "ziyan", "index": 12, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \n \ndef main():\n    cases = int(sys.stdin.readline())\n \n    for case in range(cases):\n        row1 = int(sys.stdin.readline())\n        arrangement1 = [\n            map(int, sys.stdin.readline().split())\n            for _ in range(4)\n        ]\n        chosen1 = set(arrangement1[row1 - 1])\n \n        row2 = int(sys.stdin.readline())\n        arrangement2 = [\n            map(int, sys.stdin.readline().split())\n            for _ in range(4)\n        ]\n        chosen2 = set(arrangement2[row2 - 1])\n \n        chosen = chosen1 & chosen2\n \n        if not chosen:\n            print('Case #%d: Volunteer cheated!' % (case + 1))\n        elif len(chosen) != 1:\n            print('Case #%d: Bad magician!' % (case + 1))\n        else:\n            print('Case #%d: %d' % (case + 1, chosen.pop()))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "enterr", "index": 13, "filename": "2014_2974486_5709773144064000.py", "code": "#\n# Google Code Jam 2014\n# Roaund 0: B. Cookie Clicker Alpha\n# submission by EnTerr\n#\n \n'''\nInput\nThe first line of the input gives the number of test cases, T. T lines follow. \nEach line contains three space-separated real-valued numbers: C, F and X.\n \nOutput\nFor each test case, output one line containing \"Case #x: y\", where x is \nthe test case number (starting from 1) and y is the minimum number of seconds \nit takes before you can have X delicious cookies.\n \nWe recommend outputting y to 7 decimal places, but it is not required. \ny will be considered correct if it is close enough to the correct number: \nwithin an absolute or relative error of 10^-6. \n \nLimits\n1 <= T <= 100.\n \nSmall dataset\n1 <= C <= 500.\n1 <= F <= 4.\n1 <= X <= 2000.\n \nLarge dataset\n1 <= C <= 10000.\n1 <= F <= 100.\n1 <= X <= 100000.\n \n \n---Input  \n4\n30.0 1.0 2.0\n30.0 2.0 100.0\n30.50000 3.14159 1999.19990\n500.0 4.0 2000.0\n \n---Output \nCase #1: 1.0000000\nCase #2: 39.1666667\nCase #3: 63.9680013\nCase #4: 526.1904762\n \n'''\n \n \n \nimport sys\nfrom time import clock\n \n \nf = open(sys.argv[1])\ndef input(): return f.readline().strip();\n \ndef bestTime(C, F, X):\n    #C= cost of cookie farm, ck\n    #F= farm production, ck/sec\n    #X= goal, ck\n    v = 2   #speed of production, cookies/sec\n    t = 0   #total time of production, sec\n    while True:\n        tX = X / v          #time to reach goal at current speed\n        tC = C / v          #time to buy farm\n        tXc = X / (v + F)   #time to reach goal after adding farm\n        if tX <= tC + tXc:\n            #no more farms\n            break\n        #we are buying farm\n        t += tC\n        v += F\n    #finishing at current speed\n    t += tX\n    return t\n \n#clk = clock()\n \nfor caseNo in xrange(1, int(input())+1):\n    C, F, X = map(float, input().split())\n    #print(>>sys.stderr, caseNo)\n    print('Case #%d: %.7f' % (caseNo, bestTime(C, F, X)))\n     \n#print(>>sys.stderr, 'time= %.1f seconds' % (clock()-clk ))\n \n \n"}
{"author": "enterr", "index": 13, "filename": "2014_2974486_5690574640250880.py", "code": "#\n# Google Code Jam 2014\n# Roaund 0: C. Minesweeper Master\n# submission by EnTerr\n#\n \n'''\nInput\nThe first line of the input gives the number of test cases, T. T lines follow. \nEach line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\n \nOutput\nFor each test case, output a line containing \"Case #x:\", where x is the test case number. \nOn the following R lines, output the board configuration with C characters per line, \nusing '.' to represent an empty cell, '*' to represent a cell that contains a mine, \nand 'c' to represent the clicked cell. If there is no possible configuration, \nthen instead of the grid, output a line with \"Impossible\" instead. \nIf there are multiple possible configurations, output any one of them.\n \nLimits\n0 <= M < R * C.\n \nSmall dataset\n1 <= T <= 230.\n1 <= R, C <= 5.\n \nLarge dataset\n1 <= T <= 140.\n1 <= R, C <= 50.\n \nSample\n---Input \n5\n5 5 23\n3 1 1\n2 2 1\n4 7 3\n10 10 82\n \n---Output \nCase #1:\nImpossible\nCase #2:\nc\n.\n*\nCase #3:\nImpossible\nCase #4:\n......*\n.c....*\n.......\n..*....\nCase #5:\n**********\n**********\n**********\n****....**\n***.....**\n***.c...**\n***....***\n**********\n**********\n**********\n \n \n'''\n \nimport sys\nfrom time import clock\n \nf = open(sys.argv[1])\ndef input(): return f.readline().strip();\n \nfrom itertools import product, combinations\ndef genBoards(R, C, M):\n    #extra empty/boundary row added at the end (also reached as the one before [0])\n    #each row has extra empty/boundary element at the end\n    for mines in combinations( product(range(R), range(C)), M):\n        board = [ ['.'] * C + [''] for _ in range(R) ]\n        for row, col in mines:\n            board[row][col] = '*'\n        yield board + [[''] * (C+1)]\n    pass\n \ndef oneClickSolution(R, C, M):\n    for bd in genBoards(R, C, M):\n        #count number of mines\n        minTile = 10\n        for r in range(R):\n            for c in range(C):\n                if bd[r][c] == '.':\n                    n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\n                    bd[r][c] = repr(n)\n                    if n <= minTile:\n                        minTile = n\n                        minR, minC = r, c\n        if minTile < 10:\n            #use flood from a 0 square, does it reach all 0-s?\n            queue = [ (minR, minC) ]\n            nOpen = 0\n            while queue:\n                r,c = queue.pop()\n                if bd[r][c] == '0':\n                    for i in -1,0,1:\n                        for j in -1,0,1:\n                            if i or j: # we don't add the one we popped back\n                                queue.append( (r+i, c+j) )\n                if bd[r][c] not in '.*':\n                    bd[r][c] = '.'\n                    nOpen += 1\n            if M + nOpen == R*C:\n                bd[minR][minC] = 'c'\n                return '\\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\n \n    return 'Impossible'\n \n \nclk = clock()\n \nfor caseNo in xrange(1, int(input())+1):\n    R, C, M = map(int, input().split())\n    print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\n    print ('Case #%d:' % caseNo  )\n    print (neClickSolution(R, C, M))\n     \nprint >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n \n"}
{"author": "enterr", "index": 13, "filename": "2012_1460488_1595491.py", "code": "#\n# Google Code Jam 2012\n# Round 0: B. Dancing With the Googlers\n# submission by EnTerr\n#\n \n'''\nLimits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]\nAt least S of the ti values will be between 2 and 28, inclusive.\n \nSmall dataset 1 = N = 3.\nLarge dataset 1 = N = 100.\n \nSample Input \n4\n3 1 5 15 13 11\n3 0 8 23 22 21\n2 1 1 8 0\n6 2 8 29 20 8 18 18 21\n \nOutput \nCase #1: 3\nCase #2: 2\nCase #3: 1\nCase #4: 3\n'''\n \n#import psyco\n#psyco.full()\n \nimport sys\nfrom time import clock\n \ninf = open(sys.argv[1])\ndef input(): return inf.readline().strip()\n \ndef maxBestDancers(N, S, p, *Ti):\n    cnt = 0\n    for score in Ti:\n        mx = (score + 2) // 3\n        if mx >= p:\n            cnt += 1\n        elif mx >= p-1 > 0 and S>0:\n            S -= 1\n            cnt += 1\n    return cnt\n \nfor caseNo in range(1, int(input())+1):\n    #tm = clock()\n    print('Case #%d:' % caseNo,)\n    lst = map(int, input().split())\n    print(maxBestDancers(*lst))\n    #print(>>sys.stderr, caseNo, clock() - tm)\n \n"}
{"author": "enterr", "index": 13, "filename": "2013_2270488_2453486.py", "code": "#\n# Google Code Jam 2013\n# Round 0: A. Tic-Tac-Toe-Tomek\n# submission by EnTerr\n#\n \n'''\nLimits\nThe game board provided will represent a valid state that was reached\nthrough play of the game Tic-Tac-Toe-Tomek as described above.\n \nSmall dataset   1 = T = 10.\nLarge dataset   1 = T = 1000.\n \n*** Sample Input \n6\nXXXT\n....\nOO..\n....\n \nXOXT\nXXOO\nOXOX\nXXOO\n \nXOX.\nOX..\n....\n....\n \nOOXX\nOXXX\nOX.T\nO..O\n \nXXXO\n..O.\n.O..\nT...\n \nOXXX\nXO..\n..O.\n...O\n \n***Output \nCase #1: X won\nCase #2: Draw\nCase #3: Game has not completed\nCase #4: O won\nCase #5: O won\nCase #6: O won\n \n'''\n \n#import psyco\n#psyco.full()\n \nimport sys\nfrom time import clock\n \ninf = open(sys.argv[1])\ndef input(): return inf.readline().strip()\n \nimport re\n \n# compile \"just in case\" not to rely on `re` caching\n# check horizontal or vertical or diagonal type1 or diag. type2\nx_ptrn = re.compile('X{4}|X(.{4}X){3}|X(.{3}X){3}|X(.{5}X){3}')\no_ptrn = re.compile('O{4}|O(.{4}O){3}|O(.{3}O){3}|O(.{5}O){3}')\n \n \ndef check_game_status(board):\n    if x_ptrn.search(board.replace('T','X')):\n        return 'X won'\n    elif o_ptrn.search(board.replace('T','O')):\n        return 'O won'\n    elif '.' not in board:\n        return 'Draw'\n    else:\n        return 'Game has not completed'\n \nfor caseNo in range(1, int(input())+1):\n    #tm = clock()\n    board = '|'.join(input() for _ in range(4))\n    input() # skip empty line\n    print('Case #%d:' % caseNo, check_game_status(board))\n    #print(>>sys.stderr, caseNo, clock() - tm)\n \n"}
{"author": "enterr", "index": 13, "filename": "2013_2270488_2449486.py", "code": "#\n# Google Code Jam 2013\n# Round 0: B. Lawnmower\n# submission by EnTerr\n#\n \n'''\nLimits\n \n1 <= T <= 100.\n \nSmall dataset   1 <= N, M <= 10. 1 <= a[i,j] <= 2.\nLarge dataset   1 <= N, M <= 100. 1 <= a[i,j] <= 100.\n \nSample\n \n*** Input \n3\n3 3\n2 1 2\n1 1 1\n2 1 2\n5 5\n2 2 2 2 2\n2 1 1 1 2\n2 1 2 1 2\n2 1 1 1 2\n2 2 2 2 2\n1 3\n1 2 1\n \n*** Output \nCase #1: YES\nCase #2: NO\nCase #3: YES\n \n'''\n \n#import psyco\n#psyco.full()\n \nimport sys\nfrom time import clock\n \ninf = open(sys.argv[1])\ndef input(): return inf.readline().strip()\n \n \ndef check_lawn(board):\n    n = len(board)\n    m = len(board[0])\n    hmax = map(max, board)\n    vmax = map(max, zip(*board))\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] < min(hmax[i], vmax[j]):\n                return 'NO'\n    return 'YES'\n \nfor caseNo in range(1, int(input())+1):\n    #tm = clock()\n    n,m = map(int, input().split())\n    board = [map(int, input().split()) for _ in range(n)]\n    print('Case #%d:' % caseNo, check_lawn(board))\n    #print(>>sys.stderr, caseNo, clock() - tm)\n \n"}
{"author": "enterr", "index": 13, "filename": "2012_1460488_1483485.py", "code": "#\n# Google Code Jam 2012\n# Round 0: A. Speaking in Tongues\n# submission by EnTerr\n#\n \n'''\nLimits: 1 = T = 30. G contains at most 100 characters.\nNone of the text is guaranteed to be valid English.\nSample\n \nInput\n3\nejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv\n \nOutput\nCase #1: our language is impossible to understand\nCase #2: there are twenty six factorial possibilities\nCase #3: so it is okay if you want to just give up\n'''\n \n#import psyco\n#psyco.full()\n \nimport sys\n#from time import clock\n \ninf = open(sys.argv[1])\ndef input(): return inf.readline().strip()\n \nknownPairs = [\n    ('zq', 'qz'),\n    ('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'),\n    ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'),\n    ('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')\n]\n \nxlat = [chr(0) for ch in range(256)]\nfor crypt, plain in knownPairs:\n    for a,b in zip(crypt, plain):\n        xlat[ord(a)] = b\nfor i in range(26):\n    xlat[ord('A')+i] = chr(ord(xlat[ord('a')+i]) - ord('a') + ord('A'))\nxlat = ''.join(xlat)\n \nfor caseNo in range(1, int(input())+1):\n    #print(>>sys.stderr, caseNo)\n    print('Case #%d:' % caseNo, input().translate(xlat))\n \n \n"}
{"author": "enterr", "index": 13, "filename": "2013_2270488_2463486.py", "code": "#\n# Google Code Jam 2013\n# Round 0: C. Fair and Square\n# submission by EnTerr\n#\n \n'''\nLimits\n \nSmall dataset       1 <= T <= 100, 1 <= A <= B <= 1000.\nFirst large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.\nSecond large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.\n \nSample\n*** Input \n3\n1 4\n10 120\n100 1000\n  \t\n*** Output \nCase #1: 2\nCase #2: 0\nCase #3: 2\n \n \n'''\n \n#import psyco\n#psyco.full()\n \nimport sys\nfrom time import clock\n \ninf = open(sys.argv[1])\ndef input(): return inf.readline().strip()\n \n# \"cheat\" from http://www.worldofnumbers.com/allsquar.htm\n# \"Exhaustive list of Palindromic Squares up to length 31\"\n# roots of palindromic squares\npal_sqr_roots = '''1 \n2 \n3 \n11 \n22 \n26 \n101 \n111 \n121 \n202 \n212 \n264 \n307 \n836 \n1001 \n1111 \n2002 \n2285 \n2636 \n10001 \n10101 \n10201 \n11011 \n11111 \n11211 \n20002 \n20102 \n22865 \n24846 \n30693 \n100001 \n101101 \n110011 \n111111 \n200002 \n798644 \n1000001 \n1001001 \n1002001 \n1010101 \n1011101 \n1012101 \n1042151 \n1100011 \n1101011 \n1102011 \n1109111 \n1110111 \n1111111 \n1270869 \n2000002 \n2001002 \n2012748 \n2294675 \n3069307 \n10000001 \n10011001 \n10100101 \n10111101 \n11000011 \n11011011 \n11100111 \n11111111 \n11129361 \n12028229 \n12866669 \n20000002 \n30001253 \n64030648 \n100000001 \n100010001 \n100020001 \n100101001 \n100111001 \n100121001 \n101000101 \n101010101 \n101020101 \n101101101 \n101111101 \n110000011 \n110010011 \n110020011 \n110091011 \n110101011 \n110111011 \n111000111 \n111010111 \n111091111 \n111101111 \n111111111 \n200000002 \n200010002 \n306930693 \n1000000001 \n1000110001 \n1001001001 \n1001111001 \n1010000101 \n1010110101 \n1011001101 \n1011111101 \n1100000011 \n1100110011 \n1101001011 \n1101111011 \n1110000111 \n1110110111 \n1111001111 \n2000000002 \n2062386218 \n2481623254 \n10000000001 \n10000100001 \n10000200001 \n10001010001 \n10001110001 \n10001210001 \n10010001001 \n10010101001 \n10010201001 \n10011011001 \n10011111001 \n10100000101 \n10100100101 \n10100200101 \n10101010101 \n10101110101 \n10106064399 \n10109901101 \n10110001101 \n10110101101 \n10110911101 \n10111011101 \n10111111101 \n10207355549 \n11000000011 \n11000100011 \n11000200011 \n11000910011 \n11001010011 \n11001110011 \n11010001011 \n11010101011 \n11010911011 \n11011011011 \n11011111011 \n11100000111 \n11100100111 \n11100910111 \n11101010111 \n11101110111 \n11110001111 \n11110101111 \n13579355059 \n20000000002 \n20000100002 \n22865150135 \n30101273647 \n30693069307 \n83163115486 \n100000000001 \n100001100001 \n100010010001 \n100011110001 \n100100001001 \n100101101001 \n100110011001 \n100111111001 \n101000000101 \n101001100101 \n101010010101 \n101011110101 \n101100001101 \n101101101101 \n101110011101 \n101116809851 \n110000000011 \n110001100011 \n110010010011 \n110011110011 \n110100001011 \n110101101011 \n110110011011 \n111000000111 \n111001100111 \n111010010111 \n111100001111 \n111283619361 \n112247658961 \n128817084669 \n200000000002 \n1000000000001 \n1000001000001 \n1000002000001 \n1000010100001 \n1000011100001 \n1000012100001 \n1000100010001 \n1000101010001 \n1000102010001 \n1000110110001 \n1000111110001 \n1001000001001 \n1001001001001 \n1001002001001 \n1001010101001 \n1001011101001 \n1001100011001 \n1001101011001 \n1001110111001 \n1001111111001 \n1010000000101 \n1010001000101 \n1010002000101 \n1010010100101 \n1010011100101 \n1010099010101 \n1010100010101 \n1010101010101 \n1010109110101 \n1010110110101 \n1010111110101 \n1011000001101 \n1011001001101 \n1011010101101 \n1011011101101 \n1011099011101 \n1011100011101 \n1011101011101 \n1100000000011 \n1100001000011 \n1100002000011 \n1100009100011 \n1100010100011 \n1100011100011 \n1100100010011 \n1100101010011 \n1100110110011 \n1100111110011 \n1101000001011 \n1101001001011 \n1101009101011 \n1101010101011 \n1101011101011 \n1101100011011 \n1101101011011 \n1110000000111 \n1110001000111 \n1110009100111 \n1110010100111 \n1110011100111 \n1110100010111 \n1110101010111 \n1111000001111 \n1111001001111 \n1349465117841 \n2000000000002 \n2000001000002 \n2149099165358 \n2634812417864 \n3069306930693 \n6360832925898 \n10000000000001 \n10000011000001 \n10000100100001 \n10000111100001 \n10001000010001 \n10001011010001 \n10001100110001 \n10001111110001 \n10010000001001 \n10010011001001 \n10010100101001 \n10010111101001 \n10011000011001 \n10011011011001 \n10011100111001 \n10100000000101 \n10100011000101 \n10100100100101 \n10100111100101 \n10101000010101 \n10101011010101 \n10101100110101 \n10110000001101 \n10110011001101 \n10110100101101 \n10111000011101 \n11000000000011 \n11000011000011 \n11000100100011 \n11000111100011 \n11001000010011 \n11001011010011 \n11001100110011 \n11010000001011 \n11010011001011 \n11010100101011 \n11011000011011 \n11100000000111 \n11100011000111 \n11100100100111 \n11101000010111 \n11110000001111 \n20000000000002 \n30395080190573 \n69800670077028 \n98275825201587 \n100000000000001 \n100000010000001 \n100000020000001 \n100000101000001 \n100000111000001 \n100000121000001 \n100001000100001 \n100001010100001 \n100001020100001 \n100001101100001 \n100001111100001 \n100010000010001 \n100010010010001 \n100010020010001 \n100010101010001 \n100010111010001 \n100011000110001 \n100011010110001 \n100011101110001 \n100011111110001 \n100100000001001 \n100100010001001 \n100100020001001 \n100100101001001 \n100100111001001 \n100101000101001 \n100101010101001 \n100101101101001 \n100101111101001 \n100109990011001 \n100110000011001 \n100110010011001 \n100110091011001 \n100110101011001 \n100110111011001 \n100110990111001 \n100111000111001 \n100111010111001 \n101000000000101 \n101000010000101 \n101000020000101 \n101000101000101 \n101000111000101 \n101000990100101 \n101001000100101 \n101001010100101 \n101001091100101 \n101001101100101 \n101001111100101 \n101010000010101 \n101010010010101 \n101010101010101 \n101010111010101 \n101010990110101 \n101011000110101 \n101011010110101 \n101100000001101 \n101100010001101 \n101100101001101 \n101100111001101 \n101101000101101 \n101101010101101 \n101110000011101 \n101110010011101 \n110000000000011 \n110000010000011 \n110000020000011 \n110000091000011 \n110000101000011 \n110000111000011 \n110001000100011 \n110001010100011 \n110001101100011 \n110001111100011 \n110010000010011 \n110010010010011 \n110010091010011 \n110010101010011 \n110010111010011 \n110011000110011 \n110011010110011 \n110100000001011 \n110100010001011 \n110100101001011 \n110100111001011 \n110101000101011 \n110101010101011 \n110110000011011 \n110110010011011 \n111000000000111 \n111000010000111 \n111000091000111 \n111000101000111 \n111000111000111 \n111001000100111 \n111001010100111 \n111010000010111 \n111010010010111 \n111100000001111 \n111100010001111 \n129610990752569 \n200000000000002 \n200000010000002 \n210786628549538 \n314155324482867 \n1000000000000000 \n1000000110000000 \n1000001001000000 \n1000001111000000 \n1000010000100000 \n1000010110100000 \n1000011001100000 \n1000011111100000 \n1000100000010000 \n1000100110010000 \n1000101001010000 \n1000101111010000 \n1000110000110000 \n1000110110110000 \n1000111001110000 \n1001000000001000 \n1001000110001000 \n1001001001001000 \n1001001111001000 \n1001010000101000 \n1001010110101000 \n1001011001101000 \n1001100000011000 \n1001100110011000 \n1001101001011000 \n1001110000111000 \n1010000000000100 \n1010000110000100 \n1010001001000100 \n1010001111000100 \n1010010000100100 \n1010010110100100 \n1010011001100100 \n1010100000010100 \n1010100110010100 \n1010101001010100 \n1010110000110100 \n1011000000001100 \n1011000110001100 \n1011001001001100 \n1011010000101100 \n1011100000011100 \n1100000000000010 \n1100000110000010 \n1100001001000010 \n1100001111000010 \n1100010000100010 \n1100010110100010 \n1100011001100010 \n1100100000010010 \n1100100110010010 \n1100101001010010 \n1100110000110010 \n1101000000001010 \n1101000110001010 \n1101001001001010 \n1101010000101010 \n1101100000011010 \n1110000000000110 \n1110000110000110 \n1110001001000110 \n1110010000100110 \n1110100000010110 \n1111000000001110 \n2000000000000000 \n2201019508986470 \n2564053868197730 \n3066446727654240 \n3107974295870660 \n3138199296186060'''\npal_sqr_roots = map(int, pal_sqr_roots.split())\n \n# see also http://web.archive.org/web/20020614225321/http://www.geocities.com/williamrexmarshall/math/palsq.html\n# http://www.worldofnumbers.com/square.htm\n# http://mathforum.org/library/drmath/view/51510.html\n \n \ndef is_palindrome(n):\n    return str(n)[::-1] == str(n)\n \npalindromic_roots = [x for x in pal_sqr_roots if is_palindrome(x)]\n \nfair_and_square = [x*x for x in palindromic_roots]\n \n \ndef get_num_fair_and_square(a, b):\n    return len([x for x in fair_and_square if a <= x <= b])\n \nfor caseNo in range(1, int(input())+1):\n    #tm = clock()\n    a,b = map(int, input().split())\n    print('Case #%d:' % caseNo, get_num_fair_and_square(a, b))\n    #print(>>sys.stderr, caseNo, clock() - tm)\n \n"}
{"author": "enterr", "index": 13, "filename": "2014_2974486_5756407898963968.py", "code": "#\n# Google Code Jam 2014\n# Roaund 0: A. Magic Trick\n# submission by EnTerr\n#\n \n'''\n---Input \n3\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 5 4\n3 11 6 15\n9 10 7 12\n13 14 8 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n \n---Output \nCase #1: 7\nCase #2: Bad magician!\nCase #3: Volunteer cheated!\n'''\n \n \n \nimport sys\nfrom time import clock\n \n \nf = open(sys.argv[1])\ndef input(): return f.readline().strip();\n \n        \n \n#clk = clock()\n \nfor caseNo in xrange(1, int(input())+1):\n    #first time\n    row_no = int(input())\n    for i in 1,2,3,4:\n        row = input()\n        if i == row_no:\n            nums = set(row.split())\n             \n    #second time\n    row_no = int(input())\n    for i in 1,2,3,4:\n        row = input()\n        if i == row_no:\n            nums &= set(row.split())\n \n#    print(>>sys.stderr, caseNo)\n    if not nums:\n        res = 'Volunteer cheated!'\n    elif len(nums) > 1:\n        res = 'Bad magician!'        \n    else:\n        res = nums.pop()\n    print('Case #%d:' % caseNo, res)\n     \n#print(>>sys.stderr, 'time= %.1f seconds' % (clock()-clk ))\n \n"}
{"author": "fractal", "index": 14, "filename": "2014_2974486_5709773144064000.py", "code": "#! /usr/bin/python3\n \nT = int(input())\n \nfor x in range(1, T+1):\n    (C, F, X) = [float(y) for y in input().split()]\n    totalsecs = 0\n    cur_speed = 2\n    while True:\n        cur_time = X/cur_speed\n        new_speed = cur_speed + F\n        new_time = C/cur_speed + X/new_speed\n        if new_time < cur_time:\n            totalsecs += C/cur_speed\n            cur_speed = new_speed\n        else:\n            totalsecs += cur_time\n            break\n     \n    print(\"Case #%d: %.7f\" % (x, totalsecs))\n"}
{"author": "fractal", "index": 14, "filename": "2014_2974486_5690574640250880.py", "code": "#! /usr/bin/python3\n \nT = int(input())\n \nfor n in range(1, T+1):\n    print(\"Case #%d:\" % n)\n    (R, C, M) = (int(x) for x in input().split())\n    dots = R*C - M\n    if M == 0:\n        print(\"\\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\n    elif dots == 0:\n        print(\"Impossible\")\n    elif R == 1:\n        assert C - M > 0\n        print(\"c\"+(C-M-1)*\".\"+M*\"*\")\n    elif C == 1:\n        assert R - M > 0\n        print(\"c\\n\"+(R-M-1)*\".\\n\"+M*\"*\\n\", end='')\n    elif dots == 1:\n        print(\"\\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\n    elif dots > 3:\n        if (dots == 5) or (dots == 7):\n            print(\"Impossible\")\n            continue\n        if (R == 2) or (C == 2):\n            if dots%2 != 0 :\n                print(\"Impossible\")\n                continue\n            elif R == 2:\n                l = int(dots/2)\n                print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n                print(l*\".\"+(C-l)*\"*\")\n                continue\n            elif C == 2:\n                l = int(dots/2)\n                print(\"c.\")\n                print((l-1)*\"..\\n\", end='')\n                print(int(M/2)*\"**\\n\", end='')\n                continue\n        (lines, extra) = divmod(dots, C)\n        temp = []\n        if (lines >= 2) and (extra != 1):\n            temp.append(\"c\"+(C-1)*\".\")\n            temp.extend((lines-1)*[C*\".\"])\n            temp.append(extra*\".\"+(C-extra)*\"*\")\n            temp.extend((R-lines-1)*[C*\"*\"])\n            print(\"\\n\".join(temp))\n            continue\n        elif (lines > 2) and (extra == 1):\n            temp.append(\"c\"+(C-1)*\".\")\n            temp.extend((lines-2)*[C*\".\"])\n            temp.append((C-1)*\".\"+\"*\")\n            temp.append(\"..\"+ (C-2)*\"*\")\n            temp.extend((R-lines-1)*[C*\"*\"])\n            print(\"\\n\".join(temp))\n            continue\n        elif (lines == 2) and (extra == 1):\n            temp.append(\"c\"+(C-2)*\".\"+\"*\")\n            temp.append((C-1)*\".\"+\"*\")\n            temp.append(3*\".\"+(C-3)*\"*\")\n            temp.extend((R-3)*[C*\"*\"])\n            print(\"\\n\".join(temp))\n            continue\n        elif lines < 2:\n            (l, rem) = divmod(dots, 2)\n            if rem == 1:\n                l -= 1\n                rem += 2\n            temp.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n            temp.append(l*\".\"+(C-l)*\"*\")\n            temp.append(rem*\".\"+(C-rem)*\"*\")\n            temp.extend( (R-3)*[ C*\"*\" ])\n            print(\"\\n\".join(temp))\n            continue\n    else:\n        print(\"Impossible\")\n \n"}
{"author": "fractal", "index": 14, "filename": "2012_1460488_1595491.py", "code": "import fileinput\n \nT=0 #no. of Test cases\nfor line in fileinput.input():\n    if fileinput.isfirstline():\n        T=int(line)\n        print(\"no. of test cases:\", T)\n        continue\n     \n    nums=[int(x) for x in line.split()]\n    N=nums[0] #no. of googlers\n    S=nums[1] #no. of surprising triplets\n    p=nums[2] #max value\n    #print(\"N S p:\", N, S, p)\n     \n    del nums[:3]\n    count=0\n    for num in nums:\n        quo=num//3\n        rem=num%3\n        #print(\"num, quo, rem\", num, quo, rem)\n        if quo >= p:\n            count += 1\n            continue\n        elif quo+1 == p and rem > 0:\n            count += 1\n            continue\n        elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:\n            count += 1\n            S -= 1\n            continue\n        elif quo+2 >= p and rem == 2 and S > 0:\n            count += 1\n            S -= 1\n     \n    print(\"Case #%(k)i: %(count)i\" % {\"k\":fileinput.lineno()-1,\"count\":count})\n"}
{"author": "fractal", "index": 14, "filename": "2013_2270488_2453486.py", "code": "#! /usr/bin/python\nimport re\n \nT=input()\nfor i in range(1, T+1):\n    game = []\n    res = \"\"\n    unfinished = False\n    for j in range(4):\n        game.append(raw_input())\n    diag1=\"\"\n    diag2=\"\"\n    for (j, line) in zip(range(4), game):\n        if re.match(\"(X|T){4}|(O|T){4}\", line):\n            res = line[0] if line[0] != 'T' else line[1]\n            break\n        else:\n            if \".\" in line:\n                unfinished = True\n            diag1 += line[j]\n            diag2 += line[3-j]\n    if not res:\n        game = [\"\".join(x) for x in zip(*game)]\n        game.append(diag1)\n        game.append(diag2)\n        for line in game:\n            grp = re.match(\"(X|T){4}|(O|T){4}\", line)\n            if grp:\n                res = line[0] if line[0] != 'T' else line[1]\n                break\n \n    if res:\n        print(\"Case #%d: %s won\" % (i, res))\n    elif unfinished:\n        print(\"Case #%d: Game has not completed\" % i)\n    else:\n        print(\"Case #%d: Draw\" % i)\n    raw_input() #empty line after each test case\n"}
{"author": "fractal", "index": 14, "filename": "2013_2270488_2449486.py", "code": "#! /usr/bin/python\n \nT=input()\n \nfor i in range(1, T+1):\n    N, M = raw_input().split()\n    N, M = int(N), int(M)\n    matrix = []\n    for j in range(N):\n        row = raw_input().split()\n        assert len(row) == M\n        row = [int(x) for x in row]\n        matrix.append(row)\n    rmax = [max(x) for x in matrix]\n    matrix_t = [list(x) for x in zip(*matrix)]\n    cmax = [max(x) for x in matrix_t]\n    feasible = True\n    for r, k in zip(matrix, range(N)):\n        for c, l in zip(r, range(M)):\n            if c == rmax[k]:\n                continue\n            elif c == cmax[l]:\n                continue\n            else:\n                break\n        else:\n            continue\n        break\n    else:\n        print(\"Case #%d: %s\" % (i, \"YES\"))\n        continue\n    print(\"Case #%d: %s\" % (i, \"NO\"))\n"}
{"author": "fractal", "index": 14, "filename": "2012_1460488_1483485.py", "code": "import fileinput\n \nstr1=\"\"\"ejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv\"\"\"\n \nstrlist=str1.split()\n \nstr2=\"\"\"our language is impossible to understand\nthere are twenty six factorial possibilities\nso it is okay if you want to just give up\"\"\"\n \nstrlist2=str2.split()\n \nmapLang={\"y\":\"a\",\"e\":\"o\",\"q\":\"z\"}\nfor x,y in zip(strlist,strlist2):\n    for xi,yj in zip(x,y):\n        if xi not in mapLang:\n            mapLang[xi]=yj\n             \nalphabet= ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nfor letter in  alphabet:\n    if letter not in mapLang.keys():\n        for lv in alphabet:\n            if lv not in mapLang.values():\n                mapLang[letter]=lv\n                break\n     \n#print(\"dict size is:\", len(mapLang))\n#print(mapLang)\nncases=0\nsp=\" \"\\nfor txt in fileinput.input():\\n    if fileinput.isfirstline():\\n        ncases=int(txt)\\n        continue\\n    txtList=txt.split()\\n    outList=[]\\n    for word in txtList:\\n        outword=\"\"\n        for letter in word:\n            outword += mapLang[letter]\n        outList.append(outword)\n    outstr=sp.join(outList)\n    print(\"Case #%(k)i: %(str)s\" % {\"k\":fileinput.lineno()-1,\"str\":outstr})\n"}
{"author": "fractal", "index": 14, "filename": "2013_2270488_2463486.py", "code": "#! /usr/bin/python\n \nT = input()\n \nfor n in range(1, T+1):\n \n    A, B = raw_input().split()\n    A, B = int(A), int(B)\n \n    j = 0\n    for i in range(A, B+1):\n        s = str(i)\n        m = int(i**.5)\n        if s[-1] in [\"1\", \"4\", \"5\", \"6\", \"9\"] and \\\n                (s == \"\".join(reversed(s))) and \\\n                m**2 == i:\n            s = str(m)\n            if s == \"\".join(reversed(s)):\n                j += 1\n \n \n    print(\"Case #%d: %d\" % (n, j))\n"}
{"author": "fractal", "index": 14, "filename": "2014_2974486_5756407898963968.py", "code": "#! /usr/bin/python3\nncases = int(input())\n \nfor n in range(1, ncases+1):\n    row = int(input())\n    for m in range(1, 5):\n        if m == row:\n            r1list = [int(x) for x in input().split()]\n            assert len(r1list) == 4\n        else:\n            tmp = input()\n    row = int(input())\n    for m in range(1,5):\n        if m == row:\n            r2list = [int(x) for x in input().split()]\n            assert len(r1list) == 4\n        else:\n            tmp = input()\n    nset = set(r1list) & set(r2list)\n    if len(nset) == 1:\n        print(\"Case #%d:\" % n, nset.pop())\n    elif len(nset) > 1:\n        print(\"Case #%d:\" % n, \"Bad magician!\")\n    else:\n        print(\"Case #%d:\" % n, \"Volunteer cheated!\")\n"}
{"author": "pawko", "index": 15, "filename": "2014_2974486_5709773144064000.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \nBASE_RATE = 2.0\n \ndef process_case(C, F, X):\n    rate = BASE_RATE\n    total_time = 0.0\n    while True:        \n        xtime = X / rate\n        ctime = C / rate\n        ext_rate = rate + F\n        ext_time = ctime + (X / ext_rate)\n        if xtime <= ext_time:\n            total_time += xtime\n            break\n        total_time += ctime\n        rate = ext_rate\n    return total_time\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        C, F, X = line_of_floats(next(lines))\n        result = process_case(C, F, X)\n        yield 'Case #{0}: {1:.7f}\\n'.format(ci, result)\n \ndef line_of_floats(s):\n    return [float(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('B-test')\nstart('B-small-attempt0')\n##start('B-large')\n"}
{"author": "pawko", "index": 15, "filename": "2014_2974486_5690574640250880.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\nfrom pprint import pprint\n \ndef mines_refill(board, xr, xc, nfree):\n    to_refill = xr*xc - nfree\n    for r in reversed(range(2, xr)):\n        for c in reversed(range(2, xc)):\n            if not to_refill:\n                return\n            assert(board[r][c] == '.')\n            board[r][c] = '*'\n            to_refill -= 1\n    # Bad board, but valid one\n    for r in reversed(range(xr)):\n        for c in reversed(range(xc)):\n            if not to_refill:\n                return\n            if board[r][c] == '.':\n                board[r][c] = '*'\n                to_refill -= 1\n    assert(to_refill == 0)\n     \ndef generate_board(nrows, ncols, nmines):\n    nfree = nrows*ncols - nmines\n    xr=1; xc=1;\n    while True:\n        if xr*xc >= nfree:\n            break\n        if xr < nrows:\n            xr += 1\n        if xr*xc >= nfree:\n            break\n        if xc < ncols:\n            xc += 1\n    board = [['*' for c in range(ncols)] for r in range(nrows)]\n    for r in range(xr):\n        for c in range(xc):\n            board[r][c] = '.'\n    mines_refill(board, xr, xc, nfree)\n    board[0][0] = 'c'\n    return board\n         \ndef find_click_point(board):\n    nrows = len(board)\n    ncols = len(board[0])\n    for r in range(nrows):\n        for c in range(ncols):\n            if board[r][c] == 'c':\n                return (r,c)\n    raise ValueError('Start point not present')\n \ndef enum_neighbour_coords(r0, c0, nrows, ncols):\n    for r in range(r0-1, r0+2):\n        if r<0 or r>=nrows:\n            continue\n        for c in range(c0-1, c0+2):\n            if c<0 or c>=ncols:\n                continue\n            yield (r,c)\n \ndef click_board(board, click_coords):\n    nrows = len(board)\n    ncols = len(board[0])\n    points = [click_coords]\n    while points:\n        r0,c0 = points.pop()\n        mines_cnt = 0\n        for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\n            if board[r][c] == '*':\n                mines_cnt += 1\n        board[r0][c0] = str(mines_cnt)\n        if not mines_cnt:\n            for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\n                if board[r][c] == '.':\n                    points.append((r,c))\n \ndef all_fields_checked(board):\n    nrows = len(board)\n    ncols = len(board[0])\n    for r in range(nrows):\n        for c in range(ncols):\n            if board[r][c] == '.':\n                return False\n    return True\n \ndef is_board_oneclick(original_board):\n    board = [row[:] for row in original_board] # deep copy\n    assert(board[0][0] == 'c')\n    r,c = find_click_point(board)\n    click_board(board, (r,c))\n    is_oneclick = all_fields_checked(board)\n    return is_oneclick\n \ndef board2result(board):\n    return [''.join(row) for row in board]\n \ndef process_case(nrows, ncols, nmines):\n    board = generate_board(nrows, ncols, nmines)\n    if is_board_oneclick(board):\n        result = board2result(board)\n    else:\n        result = ['Impossible']\n    return result\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        R, C, M = line_of_numbers(next(lines))\n        result = process_case(R, C, M)\n        yield 'Case #{0}:\\n'.format(ci, result)\n        for res_line in result:\n            yield res_line + '\\n'\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('C-test')\nstart('C-small-attempt0')\n##start('C-large')\n"}
{"author": "pawko", "index": 15, "filename": "2012_1460488_1595491.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \ndef threshold(p, maxdiff):\n    minval = max(p - maxdiff, 0)\n    return p + minval + minval\n \ndef process_case(numdata):\n    N,S,p = numdata[0:3]\n    scores = numdata[3:]\n    thre_normal = threshold(p, 1)\n    thre_surprise = threshold(p, 2)\n    result = 0\n    for tot in scores:\n        if tot >= thre_normal:\n            result += 1\n        elif S > 0 and tot >= thre_surprise:\n            result += 1\n            S -= 1\n    return result\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        result = process_case(line_of_numbers(next(lines)))\n        yield 'Case #{0}: {1}\\n'.format(ci, result)\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('B-test')\nstart('B-small-attempt0')\n##start('B-large')\n"}
{"author": "pawko", "index": 15, "filename": "2013_2270488_2453486.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \nP1 = 'X'\nP2 = 'O'\nPA = 'T'\nEMPTY = '.'\n \ndef no_empty_fields(board):\n    for row in board:\n        for field in row:\n            if field==EMPTY:\n                return False\n    return True\n \ndef is_winning_series(board, r0, c0, dr, dc, player):\n    r,c = r0,c0\n    for i in range(4):\n        if board[r][c] != player and board[r][c] != PA:\n            return False\n        r,c = r+dr,c+dc\n    return True\n \ndef win_condition(board, player):\n    if is_winning_series(board, 0,0, 1,1, player):\n        return True\n    if is_winning_series(board, 0,3, 1,-1, player):\n        return True\n    for i in range(4):\n        if is_winning_series(board, 0,i, 1,0, player):\n            return True\n        if is_winning_series(board, i,0, 0,1, player):\n            return True\n    return False\n \ndef process_case(board):\n    for player in {P1, P2}:\n        if win_condition(board, player):\n            return '{0} won'.format(player)\n    if no_empty_fields(board):\n        return 'Draw'\n    return 'Game has not completed'\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        board = [[ch for ch in next(lines)] for i in range(4)]\n        next(lines)\n        result = process_case(board)\n        yield 'Case #{0}: {1}\\n'.format(ci, result)\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('A-test')\nstart('A-small-attempt0')\n##start('A-large')\n"}
{"author": "pawko", "index": 15, "filename": "2013_2270488_2449486.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \ndef is_valid(height, max1, max2):\n    if height < max1 and height < max2:\n        return False\n    return True\n \ndef process_case(heights):\n    nrows = len(heights)\n    ncols = len(heights[0])\n    col_max_vals = [max((heights[r][c] for r in range(nrows)))\n                    for c in range(ncols)]\n    row_max_vals = [max((heights[r][c] for c in range(ncols)))\n                    for r in range(nrows)]\n    for r in range(nrows):\n        for c in range(ncols):\n            if not is_valid(heights[r][c], row_max_vals[r], col_max_vals[c]):\n                return 'NO'\n    return 'YES'\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        nrows, ncols = line_of_numbers(next(lines))\n        heights = [line_of_numbers(next(lines)) for r in range(nrows)]\n        result = process_case(heights)\n        yield 'Case #{0}: {1}\\n'.format(ci, result)\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('B-test')\nstart('B-small-attempt0')\n##start('B-large')\n"}
{"author": "pawko", "index": 15, "filename": "2012_1460488_1483485.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \nsamples = [('a zoo',\n            'y qee'),\n            ('our language is impossible to understand',\n            'ejp mysljylc kd kxveddknmc re jsicpdrysi'),\n            ('there are twenty six factorial possibilities',\n            'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd'),\n            ('so it is okay if you want to just give up',\n            'de kr kd eoya kw aej tysr re ujdr lkgc jv')]\n            \ndef process_case(line, trans):\n    return ''.join(trans[ch] for ch in line)\n \ndef prepare_translation():\n    trans = {}\n    for eg_seqs in samples:\n        for echar,gchar in zip(*eg_seqs):\n            trans[gchar] = echar\n    miss_g = set(string.ascii_lowercase) - set(trans.keys())\n    miss_e = set(string.ascii_lowercase) - set(trans.values())\n    if (len(miss_g) == 1 and len(miss_e) == 1):\n        trans[miss_g.pop()] = miss_e.pop();\n    return trans\n \ndef result_gen(lines):\n    trans = prepare_translation()\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        result = process_case(next(lines), trans)\n        yield 'Case #{0}: {1}\\n'.format(ci, result)\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('A-test')\nstart('A-small-attempt0')\n##start('A-large')\n"}
{"author": "pawko", "index": 15, "filename": "2013_2270488_2463486.py", "code": "# python 3\n \nimport math\n \ndef is_palindrome(num):\n    s = str(num)\n    end_idx = len(s)-1\n    for i in range(len(s)//2):\n        if s[i] != s[end_idx-i]:\n            return False\n    return True\n \ndef is_valid_base(base):\n    return is_palindrome(base) and is_palindrome(base*base)\n \ndef process_case(lo, hi):\n    cnt = 0\n    base_lo = math.ceil(math.sqrt(lo))\n    base_hi = math.floor(math.sqrt(hi))\n    for base in range(base_lo, base_hi+1):\n        if is_valid_base(base):\n            cnt += 1\n    return cnt\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        lo,hi = line_of_numbers(next(lines))\n        result = process_case(lo, hi)\n        yield 'Case #{0}: {1}\\n'.format(ci, result)\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('C-test')\nstart('C-small-attempt0')\n##start('C-large')\n"}
{"author": "pawko", "index": 15, "filename": "2014_2974486_5756407898963968.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \ndef process_case(row1, tab1, row2, tab2):\n    s1 = set(tab1[row1])\n    s2 = set(tab2[row2])\n    xset = s1 & s2\n    if len(xset) == 1:\n        result = xset.pop()\n    elif len(xset) == 0:\n        result = 'Volunteer cheated!'\n    else:\n        result = 'Bad magician!'\n    return result\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        row1 = int(next(lines)) - 1\n        tab1 = [line_of_numbers(next(lines)) for i in range(4)]\n        row2 = int(next(lines)) - 1\n        tab2 = [line_of_numbers(next(lines)) for i in range(4)]\n        result = process_case(row1, tab1, row2, tab2)\n        yield 'Case #{0}: {1}\\n'.format(ci, result)\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('A-test')\nstart('A-small-attempt0')\n##start('A-large')\n"}
{"author": "pavlovic", "index": 16, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\nimport math\n \ndef calculate_time(c, f, x, num_farms):\n\tt = 0.0\n\trate = 2.0\n\tfor i in range(num_farms):\n\t\tt += c / rate\n\t\trate += f\n \t\t\n\tt += x / rate\n\treturn t\t\n \nt = int(sys.stdin.readline().strip())\n \nfor i in range(t):\n\tprint(\"Case #\" + str(i + 1) + \":\",)\n \n\t(c, f, x) = [float(i) for i in sys.stdin.readline().strip().split()]\n \t\n\tif x <= c:\n\t\tt = calculate_time(c, f, x, 0)\n\telse:\n\t\topt_rate = f * (x - c) / c\n\t\tnum_farms = (opt_rate - 2) / f\n\t\tt1 = calculate_time(c, f, x, int(math.floor(num_farms)))\n\t\tt2 = calculate_time(c, f, x, int(math.ceil(num_farms)))\n \n\t\tt = min(t1, t2)\n \t\t\n\tprint(\"%.7f\" % t)\n"}
{"author": "pavlovic", "index": 16, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\n \ndef generate_matrix(r, c, char):\n\tmat = [[char for i in range(c)] for j in range(r)]\n\treturn mat\n \t\ndef merge(mat1, mat2):\n\tfor i in range(len(mat1)):\n\t\tfor j in range(len(mat1[i])):\n\t\t\tmat2[i][j] = mat1[i][j]\n\treturn mat2\n \ndef solve(r, c, m):\n\tif 0 == m:\n\t\tmat = generate_matrix(r, c, '.')\n\t\tmat[0][0] = 'c'\n\t\treturn mat\n \t\t\n\tf = r * c - m\n \t\n\tif 0 == f:\n\t\treturn False\n \t\t\n\tif 1 == f:\n\t\tmat = generate_matrix(r, c, '*')\n\t\tmat[0][0] = 'c'\n\t\treturn mat\n \t\t\n\tif 1 == min(r, c):\n\t\tmat = generate_matrix(r, c, '*')\n\t\tfor i in range(f):\n\t\t\tmat[0 if 1 == r else i][0 if 1 == c else i] = '.'\n\t\tmat[0][0] = 'c'\n\t\treturn mat\n \n\tif 2 == min(r, c):\n\t\tif (0 != f % 2) or (2 == f):\n\t\t\treturn False\n\t\tmat = generate_matrix(r, c, '*')\n\t\tfor i in range(f // 2):\n\t\t\tmat[0 if 2 == r else i][0 if 2 == c else i] = '.'\n\t\t\tmat[1 if 2 == r else i][1 if 2 == c else i] = '.'\n\t\tmat[0][0] = 'c'\n\t\treturn mat\n \t\t\n\tif (3 == r) and (3 == c):\n\t\tif (4 == f) or (6 == f):\n\t\t\tmat = generate_matrix(r, c, '*')\n\t\t\tfor i in range(f // 2):\n\t\t\t\tmat[0][i] = '.'\n\t\t\t\tmat[1][i] = '.'\n\t\t\tmat[0][0] = 'c'\n\t\t\treturn mat\n\t\tif 8 == f:\n\t\t\tmat = generate_matrix(r, c, '.')\n\t\t\tmat[2][2] = '*'\n\t\t\tmat[0][0] = 'c'\n\t\t\treturn mat\n\t\treturn False\n \t\t\n\trows_to_reduce = min(r - 3, m // c)\n\tif 0 < rows_to_reduce:\n\t\tres = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)\n\t\tif False == res:\n\t\t\treturn False\n\t\tmat = merge(res, generate_matrix(r, c, '*'))\n\t\treturn mat\n \t\t\n\tcols_to_reduce = min(c - 3, m // r)\n\tif 0 < cols_to_reduce:\n\t\tres = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)\n\t\tif False == res:\n\t\t\treturn False\n\t\tmat = merge(res, generate_matrix(r, c, '*'))\n\t\treturn mat\n \t\n\tmat = generate_matrix(r, c, '.')\n\tfor i in range(min(m, r - 2)):\n\t\tmat[r - i - 1][c - 1] = '*'\n\tif m == r - 1:\n\t\tmat[r - 1][c - 2] = '*'\n\tmat[0][0] = 'c'\n\treturn mat\n \t\t\t\n \nt = int(sys.stdin.readline().strip())\n \nfor i in range(t):\n\tprint(\"Case #\" + str(i + 1) + \":\")\n \n\tr, c, m = [int(i) for i in sys.stdin.readline().strip().split()]\n \t\n\tres = solve(r, c, m)\n \t\n\tif False == res:\n\t\tprint(\"Impossible\")\n\telse:\n\t\tfor i in range(r):\n\t\t\tfor j in range(c):\n\t\t\t\tsys.stdout.write(res[i][j])\n\t\t\tprint\n"}
{"author": "pavlovic", "index": 16, "filename": "2012_1460488_1595491.py", "code": "import sys\n \nt = int(sys.stdin.readline())\nfor i in range(t):\n\tinputline = sys.stdin.readline().strip()\n\tinputparams = inputline.split()\n \n\tn = int(inputparams[0])\n\ts = int(inputparams[1])\n\tp = int(inputparams[2])\n\tvalidcount = 0\n\tsurprisingcount = 0\n\tfor j in range(n):\n\t\tscore = int(inputparams[3 + j])\n\t\tif (p + (p - 1) * 2) <= score:\n\t\t\tvalidcount += 1\n\t\telif ((p + (p - 2) * 2) <= score) and (p <= score):\n\t\t\tsurprisingcount += 1\n \n\tprint(\"Case #%d: %d\" % (i + 1, validcount + min(surprisingcount, s)))\n"}
{"author": "pavlovic", "index": 16, "filename": "2013_2270488_2453486.py", "code": "import sys\n \nt = int(sys.stdin.readline())\nfor i in range(t):\n\tboard = []\n\tfor j in range(4):\n\t\tboard.append(sys.stdin.readline().strip())\n \n\tsys.stdin.readline()\n \n\twinX = False\n\twinO = False\n\tgameEnded = True\n \n\tfor j in range(4):\n\t\txCount = 0\n\t\toCount = 0\n\t\ttCount = 0\n\t\tfor k in range(4):\n\t\t\tif board[j][k] == 'X':\n\t\t\t\txCount += 1\n\t\t\tif board[j][k] == 'O':\n\t\t\t\toCount += 1\n\t\t\tif board[j][k] == 'T':\n\t\t\t\ttCount += 1\n \n\t\tif xCount + tCount == 4:\n\t\t\twinX = True\n \t\t\n\t\tif oCount + tCount == 4:\n\t\t\twinO = True\n \n\t\tif xCount + oCount + tCount < 4:\n\t\t\tgameEnded = False\n \n\tfor k in range(4):\n\t\txCount = 0\n\t\toCount = 0\n\t\ttCount = 0\n\t\tfor j in range(4):\n\t\t\tif board[j][k] == 'X':\n\t\t\t\txCount += 1\n\t\t\tif board[j][k] == 'O':\n\t\t\t\toCount += 1\n\t\t\tif board[j][k] == 'T':\n\t\t\t\ttCount += 1\n \n\t\tif xCount + tCount == 4:\n\t\t\twinX = True\n \t\t\n\t\tif oCount + tCount == 4:\n\t\t\twinO = True\n \n\t\tif xCount + oCount + tCount < 4:\n\t\t\tgameEnded = False\n \n\txCount = 0\n\toCount = 0\n\ttCount = 0\n\tfor j in range(4):\n\t\tif board[j][j] == 'X':\n\t\t\txCount += 1\n\t\tif board[j][j] == 'O':\n\t\t\toCount += 1\n\t\tif board[j][j] == 'T':\n\t\t\ttCount += 1\n \n\tif xCount + tCount == 4:\n\t\twinX = True\n \t\n\tif oCount + tCount == 4:\n\t\twinO = True\n \n\tif xCount + oCount + tCount < 4:\n\t\tgameEnded = False\n \n \n\txCount = 0\n\toCount = 0\n\ttCount = 0\n\tfor j in range(4):\n\t\tif board[3 - j][j] == 'X':\n\t\t\txCount += 1\n\t\tif board[3 - j][j] == 'O':\n\t\t\toCount += 1\n\t\tif board[3 - j][j] == 'T':\n\t\t\ttCount += 1\n \n\tif xCount + tCount == 4:\n\t\twinX = True\n \t\n\tif oCount + tCount == 4:\n\t\twinO = True\n \n\tif xCount + oCount + tCount < 4:\n\t\tgameEnded = False\n \n\tprint(\"Case #\" + str(i + 1) + \": \",)\n\tif winX:\n\t\tprint(\"X won\")\n\telif winO:\n\t\tprint(\"O won\")\n\telif gameEnded:\n\t\tprint(\"Draw\")\n\telse:\n\t\tprint(\"Game has not completed\")\n"}
{"author": "pavlovic", "index": 16, "filename": "2013_2270488_2449486.py", "code": "import sys\n \ndirection = [[0, 1], [1, 0]]\n \nt = int(sys.stdin.readline())\nfor i in range(t):\n\tline = sys.stdin.readline().strip().split()\n\tn = int(line[0])\n\tm = int(line[1])\n\tfield = []\n\tfor j in range(n):\n\t\tline = [int(x) for x in sys.stdin.readline().strip().split()]\n\t\tfield.append(line)\n \n\tpossibleLawn = True\n\tfor j in range(n):\n\t\tfor k in range(m):\n\t\t\tfor direct in range(2):\n\t\t\t\tcoords = [j if (direct == 0) else 0, 0 if (direct == 0) else k]\n\t\t\t\tpossibleField = True\n\t\t\t\twhile (coords[0] < n) and (coords[1] < m):\n\t\t\t\t\tif field[j][k] < field[coords[0]][coords[1]]:\n\t\t\t\t\t\tpossibleField = False\n\t\t\t\t\tcoords[0] += direction[direct][0]\n\t\t\t\t\tcoords[1] += direction[direct][1]\n \n\t\t\t\tif possibleField:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tpossibleLawn = False\n \n\tprint(\"Case #\" + str(i + 1) + \": \" + ('YES' if possibleLawn else 'NO'))\n \n"}
{"author": "pavlovic", "index": 16, "filename": "2012_1460488_1483485.py", "code": "import sys\n \ninputmapping  = \"abcdefghijklmnopqrstuvwxyz \"\noutputmapping = \"ynficwlbkuomxsevzpdrjgthaq \"\n \nn = int(sys.stdin.readline())\nfor i in range(n):\n\toutputstring = sys.stdin.readline().strip()\n\tinputstring = \"\"\n\tfor j in range(len(outputstring)):\n\t\toutputletter = outputstring[j]\n\t\tk = 0\n\t\twhile outputmapping[k] != outputletter:\n\t\t\tk += 1\n \n\t\tinputstring += inputmapping[k]\n \n\tprint(\"Case #%d: %s\" % (i + 1, inputstring)\t)\n \n \t\t\n"}
{"author": "pavlovic", "index": 16, "filename": "2013_2270488_2463486.py", "code": "def is_palindrome(s):\n\tif s == '':\n\t\treturn True\n\telse:\n\t\tif (ord(s[0]) - ord(s[len(s)-1])) == 0:\n\t\t\treturn is_palindrome(s[1 : len(s) - 1])\n\t\telse:\n\t\t\treturn False\n \nall_fair_and_square = set()\nfor i in range(10000):\n\torig = str(i)\n\trev = orig[::-1]\n \n\tpalin = orig + rev\n\tintpalin = int(palin)\n\tif is_palindrome(str(intpalin * intpalin)):\n\t\tall_fair_and_square.add(intpalin * intpalin)\n \n\tpalin = orig[:-1] + rev\n\tintpalin = int(palin)\n\tif is_palindrome(str(intpalin * intpalin)):\n\t\tall_fair_and_square.add(intpalin * intpalin)\n \t\n \nimport sys\n \nt = int(sys.stdin.readline().strip())\nfor ii in range(t):\n\tline = sys.stdin.readline().strip().split()\n\ta = int(line[0])\n\tb = int(line[1])\n\tcount = 0\n\tfor num in all_fair_and_square:\n\t\tif (num >= a) and (num <= b):\n\t\t\tcount += 1\n\tprint(\"Case #\" + str(ii + 1) + \": \" + str(count))\n \n"}
{"author": "pavlovic", "index": 16, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \ndef read_row():\n\ta = int(sys.stdin.readline().strip())\n\tfor j in range(a - 1):\n\t\tsys.stdin.readline()\n\tread_set = set(sys.stdin.readline().strip().split(\" \"))\n\tfor j in range(5 - a - 1):\n\t\tsys.stdin.readline()\n \t\t\n\treturn read_set\n \n \nt = int(sys.stdin.readline().strip())\n \nfor i in range(t):\n\tprint(\"Case #\" + str(i + 1) + \":\",)\n \n\tset1 = read_row()\n\tset2 = read_row()\n \t\n\tintersect = set1.intersection(set2)\n \t\n\tif 1 == len(intersect):\n\t\tprint(intersect.pop())\n\telif 0 == len(intersect):\n\t\tprint(\"Volunteer cheated!\")\n\telse:\n\t\tprint(\"Bad magician!\")\n"}
{"author": "bastiandantilus", "index": 17, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in range(t):\n \n        C, F, X = [float(x) for x in f.readline().split()]\n \n        base = X / 2.0\n \n        new_strategy = old_strategy = base\n        time_building = 0\n        farms = 0\n        fastest_speed = 2\n        while new_strategy <= old_strategy:\n            old_strategy = new_strategy\n            time_building += C / fastest_speed\n            farms += 1\n            fastest_speed += F\n            new_strategy = time_building + X / fastest_speed\n             \n         \n        print((\"Case #\" + str(_t+1) + \": \" + str(old_strategy)))\n     \n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\nimport pprint\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in range(t):\n \n        R, C, M = [int(x) for x in f.readline().split()]\n        free_spots = R * C - M - 1\n \n        if M == 0:\n            answer = [[\".\" for x in range(C)] for y in range(R)]\n            answer[0][0] = \"c\"\n        elif R == 1:\n            answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\n        elif C == 1:\n            answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\n            answer = zip(*answer[::-1])\n        elif free_spots >= 3: # and M % R >= 2:\n            answer = [[\"*\" for x in range(C)] for y in range(R)]\n            answer[0][0] = \"c\"\n            answer[0][1] = \".\"\n            answer[1][1] = \".\"\n            answer[1][0] = \".\"\n            free_spots -= 3\n            tr, br, c = 0, 1, 2\n            if c >= C:\n                tr, br, c = 2, 3, 0\n            for _i in range(free_spots):\n                #pprint.pprint(answer)\n                if answer[tr][c] == \"*\":\n                    answer[tr][c] = \".\"\n                elif answer[br][c] == \"*\":\n                    answer[br][c] = \".\"\n                    if c < C-1:\n                        c+=1\n                    else:\n                        tr, br = tr + 2, br + 2\n                        c = 0\n                        if br == R:\n                            br, tr = br-1, tr-1\n                 \n        else:\n            answer = [\"Impossible\",]\n \n         \n         \n        print (\"Case #\" + str(_t+1) + \":\")\n        for _i in answer:\n            print (\"\".join(_i))\n     \n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2012_1460488_1595491.py", "code": "import sys\n \ndef decode_data(input):\n    output = \"\"\n    for letter in input:\n        if letter in library:\n            output += library[letter]\n    return output\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())    \n    for _t in range(t):\n        s = f.readline()\n        s = s.split()\n        N = int(s[0])\n        S = int(s[1])\n        p = int(s[2])\n        low_scores = (p - 1) * 2\n        ti = s[3:]\n        ti.sort()\n        r = 0\n        ti = [int(x) for x in ti]\n        for i in ti:\n            score = i - low_scores\n            if p <= i:\n                if score >= p:\n                    r += 1\n                    #print(([score, \" > \", p]))\n                elif score >= p - 2 and S > 0:\n                    S -= 1\n                    r +=1\n        print((\"Case #\" + str(_t+1) + \": \" + str(r)))\n     \n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2013_2270488_2453486.py", "code": "import sys\n \ndef decode_data(input):\n    output = \"\"\n    Total = 0\n    for row in input:\n        T = row.count(\"T\")\n        X = row.count(\"X\")\n        O = row.count(\"O\")\n        #print((row, T, X, O, Total))\n        if X + T == 4:\n            return \"X won\"\n        elif O + T == 4:\n            return \"O won\"\n        else:\n            Total += T + X + O\n             \n    rotated = zip(*input[::-1])\n    for row in rotated:\n        T = row.count(\"T\")\n        X = row.count(\"X\")\n        O = row.count(\"O\")\n        if X + T == 4:\n            return \"X won\"\n        elif O + T == 4:\n            return \"O won\"\n \n    row = [input[x][x] for x in range(4)]\n    row.count(\"T\")\n    X = row.count(\"X\")\n    O = row.count(\"O\")\n    if X + T == 4:\n        return \"X won\"\n    elif O + T == 4:\n        return \"O won\"\n \n    row = [input[3-x][x] for x in range(4)]\n    T = row.count(\"T\")\n    X = row.count(\"X\")\n    O = row.count(\"O\")\n    if X + T == 4:\n        return \"X won\"\n    elif O + T == 4:\n        return \"O won\"\n \n    if Total < 16:\n        return \"Game has not completed\"\n    else:\n        return \"Draw\"\n    return output\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in range(t):\n        s = [f.readline() for i in range(4)]\n        print((\"Case #\" + str(_t+1) + \": \" + decode_data(s)))\n        f.readline()\n     \n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2013_2270488_2449486.py", "code": "import sys\n \ndef decode_data(input, x, y, z):\n    rotated = zip(*input[::-1])\n    #for row in rotated:\n        #print((row))\n    #for row in input:\n        #print((row))\n    for i in range(x):\n        for j in range(y):\n            if not input[i][j] == \"1\":\n                continue            \n            if sum((int(xx) for xx in input[i])) != y and \\\n                sum((int(xx) for xx in rotated[j])) != x:\n                return \"NO\"\n    return \"YES\"\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in range(t):\n        x, y = f.readline().split()\n        s = [f.readline().split() for i in range(int(x))]\n        print((\"Case #\" + str(_t+1) + \": \" + decode_data(s, int(x), int(y), 2)))\n     \n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2012_1460488_1483485.py", "code": "import sys\n \nlibrary = {'a': 'y', 'o': 'e', 'z': 'q', 'q' : 'z'}\n \ndef parse_example(input, output):\n    for key, value in zip(input, output):\n        library[key] = value\n \nparse_example(\"ejp mysljylc kd kxveddknmc re jsicpdrysi\", \"our language is impossible to understand\")\nparse_example(\"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\", \"there are twenty six factorial possibilities\")\nparse_example(\"de kr kd eoya kw aej tysr re ujdr lkgc jv\", \"so it is okay if you want to just give up\")\n \ndef decode_data(input):\n    output = \"\"\n    for letter in input:\n        if letter in library:\n            output += library[letter]\n    return output\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())\n    d = {'O':0, 'B':1}\n    for _t in range(t):\n        s = f.readline()\n        print((\"Case #\" + str(_t+1) + \": \" + decode_data(s)))\n     \n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2013_2270488_2463486.py", "code": "import sys\nimport math\n \ndef is_square(n):\n    if n in square:\n        return True\n    if is_fair(n):\n        root = int(math.sqrt(n))\n        if root**2 != n:\n            return False\n        ss = is_fair(root)\n        if ss: square.add(n)\n        return ss\n    return False\n \ndef is_fair(n):\n    if n in fair:\n        return True\n    if n in unfair:\n        return False\n    sn = str(n)\n    l = len(sn)\n    mid = math.ceil(n/2)\n    if sn[0:mid] == sn[mid::-1]:\n        fair.add(n)\n        return True\n    else:\n        unfair.add(n)\n        return False\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n             \n    fair = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])\n    unfair = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n    square = set([1, 4])\n \n    t = int(f.readline())\n    for _t in range(t):\n        s = f.readline()\n        if s:\n            x, y = s.split()\n            Total = sum([is_square(n) for n in range(int(x), int(y)+1)])             \n            print((\"Case #\" + str(_t+1) + \": \" + str(Total)))\n     \n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in range(t):\n        X = int(f.readline())\n        cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\n        row = cardsX[X-1]\n        Y = int(f.readline())\n        cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\n        column = cardsY[Y-1]\n        card = [x for x in row if x in column]\n        if len(card) > 1:\n            answer = \"Bad magician!\"\n        elif len(card) == 0:\n            answer = \"Volunteer cheated!\"\n        else:\n            answer = str(card[0])\n        print((\"Case #\" + str(_t+1) + \": \" + answer))\n     \n \n"}
{"author": "nooodles", "index": 18, "filename": "2014_2974486_5709773144064000.py", "code": "T = int(raw_input());\nfor q in range(T):\n    [C,F,X] = map(float, raw_input().split());\n \n    # Default rate is 2 cookies / s;\n    # Farm costs C\n    #   produces F\n    # Target is X;\n \n    Time = 0.;\n    Rate = 2.;\n    Fin = False;\n    while (not Fin):\n        t0 = X/Rate;\n        t1 = C/Rate + X/(Rate+F);\n \n        if t0 <= t1:\n            Time += t0;\n            Fin = True;\n        else:\n            Time += C/Rate;\n            Rate += F;\n \n    print (\"Case #%d:\" % (q+1),);\n    print (\"%.7f\" % Time);\n     \n         \n"}
{"author": "nooodles", "index": 18, "filename": "2014_2974486_5690574640250880.py", "code": "def Trivial(R,C,char):\n#    print\n    for i in range(R):\n        Ans = '';\n        for j in range(C):\n            if (i==j==0):\n                Ans += 'c';\n            else:\n                Ans += char;\n        print (Ans);\n \n \ndef Draw1(R,C,Blank):\n#    print\n    Ans = \"c\";\n    for i in range(Blank-1):\n        Ans += '.';\n    for i in range(R*C-Blank):\n        Ans += '*';\n    if (R == 1):\n        print (Ans);        \n        return;\n    if (C == 1):\n        for i in range(len(Ans)):\n            print (Ans[i]);\n \ndef Draw2(R,C,Blank):\n    if (Blank%2 != 0) or (Blank == 2):\n        print (\"Impossible\");\n        return;\n    Row1 = '.'*(Blank/2) + '*'*(Mine/2);\n    Row0 = 'c' + Row1[1:];\n    if R==2:\n        print (Row0);\n        print (Row1);\n    else:\n        for i in range(len(Row0)):\n            print (Row0[i]+Row1[i]);\n    return;\n \n \ndef Generate(R, C, Blank):\n    TODO = Blank;\n    Spaces = [0]*R;\n    if TODO <= 2*C:\n        if TODO%2 == 0:\n            Spaces[0] = TODO/2;\n            Spaces[1] = TODO-Spaces[0];\n        else:\n            if (TODO == 7):\n                Spaces[0] = 3;\n                Spaces[1] = 2;\n                Spaces[2] = 2;\n            else:\n                Spaces[0] = (TODO-3)/2;\n                Spaces[1] = (TODO-3)/2;\n                Spaces[2] = 3;\n    else:\n        row = 0;\n        if (TODO >= 2*C+2):\n            Spaces[0] = C;\n            Spaces[1] = C;\n            TODO -= 2*C;\n            row = 2;\n             \n        while TODO > C+1:\n            if (TODO == 2*C+1) and (C != 3):\n                Spaces[row] = C-1;\n                Spaces[row+1] = C-1;\n                Spaces[row+2] = 3;\n                TODO = 0;\n            else:\n                Spaces[row] = C;\n                TODO -= C;\n                row += 1;\n        if (TODO == C+1):\n            Spaces[row] += C-1;\n            Spaces[row+1] = 2;\n            TODO = 0;\n        Spaces[row] += TODO;\n \n    for r in range(R):\n        Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\n        if r == 0:\n            Ans = 'c'+Ans[1:];\n        print (Ans);\n \n \ndef Solve(R, C, M):\n    Blank = R*C-M;\n    if Blank == 0:\n        print (\"Impossible\");\n        return;\n \n    if (Blank == 1):\n        Trivial(R,C,'*');\n        return\n    if (Blank == R*C):\n        Trivial(R,C,'.');\n        return\n \n    if (R == 1) or (C == 1):\n        Draw1(R,C,Blank);\n        return\n \n    if (R-2)*(C-2) == 0:\n        Draw2(R,C,Blank);\n        return\n \n    if Blank in [2,3,5,7]:\n        print (\"Impossible\");\n        return;\n     \n    if (R >= 3) and (C >= 3):\n        Generate(R, C, Blank);\n \n    return;\n \n \nT = int(raw_input());\nfor q in range(T):\n    [Row,Col,Mine] = map(int, raw_input().split());\n \n    Blanks = Row*Col - Mine;\n     \n    print (\"Case #%d:\" % (q+1))\n#    print str(Row)+'x'+str(Col)+' with '+str(Mine)+' mines ('+str(Blanks)+' gaps)'\n    Solve(Row, Col, Mine);\n     \n         \n"}
{"author": "nooodles", "index": 18, "filename": "2012_1460488_1595491.py", "code": "T = int(raw_input());\nfor i in range(T):\n    Data = map(int, raw_input().split());\n    N = Data.pop(0);\n    S = Data.pop(0);\n    p = Data.pop(0);\n    \n    Good = 0;\n    for score in Data:\n        if score >= 3*p-2:\n            Good += 1;\n        else:\n            if (S > 0) and (score >= 3*p-4) and (score >= p):\n                S -= 1;\n                Good += 1;\n \n    print (\"Case #%d:\" % (i+1),);\n    print (Good);\n    \n \n"}
{"author": "nooodles", "index": 18, "filename": "2013_2270488_2453486.py", "code": "def Winner( M ):\n    for i in range(4):          # Check rows\n        nX = 0;     nO = 0;     \n        for j in range(4):\n            if M[i][j] == 'X':\n                nX += 1;\n            if M[i][j] == 'O':\n                nO += 1;\n            if M[i][j] == 'T':\n                nX += 1;\n                nO += 1;\n        if nX == 4:\n            return 'X';\n        if nO == 4:\n            return 'O';\n         \n    for j in range(4):          # Check columns\n        nX = 0;     nO = 0;     \n        for i in range(4):\n            if M[i][j] == 'X':\n                nX += 1;\n            if M[i][j] == 'O':\n                nO += 1;\n            if M[i][j] == 'T':\n                nX += 1;\n                nO += 1;\n        if nX == 4:\n            return 'X';\n        if nO == 4:\n            return 'O';\n \n    if (M[0][0] in ['X','T']) and (M[1][1] in ['X','T']) and (M[2][2] in ['X','T']) and (M[3][3] in ['X','T']):\n        return 'X';\n    if (M[0][3] in ['X','T']) and (M[1][2] in ['X','T']) and (M[2][1] in ['X','T']) and (M[3][0] in ['X','T']):\n        return 'X';\n    if (M[0][0] in ['O','T']) and (M[1][1] in ['O','T']) and (M[2][2] in ['O','T']) and (M[3][3] in ['O','T']):\n        return 'O';           \n    if (M[0][3] in ['O','T']) and (M[1][2] in ['O','T']) and (M[2][1] in ['O','T']) and (M[3][0] in ['O','T']):\n        return 'O';\n \n    return 'D';            \n \n \nT = int(raw_input());\nfor q in range(T):\n    if q != 0:\n        raw_input();\n    Map = [];\n    Dot = False;\n    for i in range(4):\n        Map.append( raw_input() );\n        if '.' in Map[-1]:\n            Dot = True;\n \n    ANS = Winner(Map);\n#    print(ANS)\n    if ANS == 'X':\n        print(\"Case #%d: X won\" %(q+1))\n    if ANS == 'O':\n        print(\"Case #%d: O won\" %(q+1))\n    if ANS == 'D':\n        if Dot:\n            print(\"Case #%d: Game has not completed\" %(q+1))\n        else:\n            print(\"Case #%d: Draw \" % (q+1))\n \n"}
{"author": "nooodles", "index": 18, "filename": "2013_2270488_2449486.py", "code": "T = int(raw_input());\nfor q in range(T):\n    [H,W] = map(int, raw_input().split());\n    Lawn = [];\n    MRow = [0]*H;\n    MCol = [0]*W;\n    for i in range(H):\n        Lawn.append( map(int, raw_input().split()) );\n        MRow[i] = max(Lawn[-1]);\n        for j in range(W):\n            MCol[j] = max(MCol[j], Lawn[-1][j]);\n \n    Valid = True;\n    for i in range(H):\n        for j in range(W):\n            if Lawn[i][j] not in [MRow[i], MCol[j]]:\n                Valid = False;\n                break;\n     \n \n    if Valid:\n        print (\"Case #%d: YES\" %(q+1));\n    else:\n        print (\"Case #%d: NO\" %(q+1));        \n"}
{"author": "nooodles", "index": 18, "filename": "2012_1460488_1483485.py", "code": "RAW = ['ejp mysljylc kd kxveddknmc re jsicpdrysi',\n        'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',\n        'de kr kd eoya kw aej tysr re ujdr lkgc jv']\nENG = ['our language is impossible to understand',\n        'there are twenty six factorial possibilities',\n        'so it is okay if you want to just give up'];\n \nNew = [32]*128;\nLeft = [];\nfor c in range(97, 123):\n    Left += [chr(c)];\n \nfor i in range(3):\n    for j in range(len(RAW[i])):\n        x = ord(RAW[i][j]);\n        if (New[x] == 32) and (x != 32):\n            Left.remove(RAW[i][j]);\n            New[x] = ord(ENG[i][j]);\n \nNew[ord('q')] = ord('z');\nNew[ord('z')] = ord('q');\n \n \nT = int(raw_input());\nfor i in range(T):\n    print (\"Case #%d:\" % (i+1),);\n    S_in = raw_input();\n    S_out = '';\n    for c in S_in:\n        S_out += chr(New[ord(c)])\n    print (S_out)\n    \n \n"}
{"author": "nooodles", "index": 18, "filename": "2013_2270488_2463486.py", "code": "def IsPal(n):\n    S = str(n);\n    return S == S[::-1];\n \n \ndef Gen():\n    LIM = 10**14;\n    N = 10**7;\n    LIST = [];\n    for i in range(1, N):\n        if IsPal(i):\n            if IsPal(i*i):\n                LIST.append(i);\n    return LIST\n \nPP = Gen();\n#print 'Generated'\n \nT = int(raw_input());\nfor q in range(1,T+1):\n    [A,B] = map(int, raw_input().split());    \n    ANS = 0;\n    for i in range(len(PP)):\n        if B >= PP[i]**2 >= A:\n            ANS += 1;\n     \n    print (\"Case #%d: %d\" %(q, ANS));\n"}
{"author": "nooodles", "index": 18, "filename": "2014_2974486_5756407898963968.py", "code": "T = int(raw_input());\nfor q in range(T):\n    R1 = int(raw_input());\n    Data1 = [];\n    for i in range(4):\n        Data1.append( map(int, raw_input().split()) );\n         \n    R2 = int(raw_input());\n    Data2 = [];\n    for i in range(4):\n        Data2.append( map(int, raw_input().split()) );\n \n    Ans = [];\n    for entry in Data1[R1-1]:\n        if entry in Data2[R2-1]:\n            Ans.append(entry);\n \n    print (\"Case #%d:\" % (q+1),);\n \n    if len(Ans) == 0:\n        print (\"Volunteer cheated!\");\n    if len(Ans) == 1:\n        print (Ans[0]);\n    if len(Ans) > 1:\n        print (\"Bad magician!\")\n         \n"}
{"author": "netsuso", "index": 19, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/python3\n \nimport sys\n \nncases = int(sys.stdin.readline().strip())\n \nfor t in range(1, ncases+1):\n    values = sys.stdin.readline().split()\n    c = float(values[0])\n    f = float(values[1])\n    x = float(values[2])\n    r = 2\n \n    time = 0\n \n    while True:\n        tdirect = x/r\n        tfactory = c/r + x/(r+f)\n \n        if tdirect<tfactory:\n            time += tdirect\n            break\n        else:\n            time += c/r\n            r += f\n \n    print(\"Case #{0}: {1:.7f}\".format(t, time))\n"}
{"author": "netsuso", "index": 19, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/python3\n#\n# Algorithm:\n# - For boards with one row: you need at least 1 free cells\n# - For boards with two rows, you need either 1 or at least 4 free cells\n#   - It needs to be an even number!\n# - For general boards, you need either 1 or at least 4 free cells (except 5 or 7)\n#\n# - To fill the board, you cannot have a row or a column with only one\n#   free cell, so you fill it in groups of two.\n#\n#   - First you start with the minimum of 4:\n#       c . * * * *\n#       . . * * * *\n#       * * * * * *\n#\n#   - Then you fill next columns and rows two by two:\n#       c . % * * *\n#       . . % * * *\n#       * * * * * *\n#\n#       c . . * * *\n#       . . . * * *\n#       % % * * * *\n#\n#       c . . % * *\n#       . . . % * *\n#       . . * * * *\n#\n#   - In case there's a pending free cell, you simply fill it in the inner board:\n#       c . . . * *\n#       . . . . * *\n#       . . % * * *\n#\n#   - In case you fill the outer border, you simply start filling the inner board:\n#       c . . . . %\n#       . . . . . %\n#       . . * * * *\n#\n#       c . . . . .\n#       . . . . . .\n#       . . % * * *\n#\n \nimport sys\n \nncases = int(sys.stdin.readline().strip())\n \ndef print_board(r, c, free):\n    board = {}\n    for row in range(0, r):\n        board[row] = {}\n        for col in range(0, c):\n            board[row][col] = '*'\n \n    pending = free\n \n    if free == 1:\n        board[0][0] = '.'\n    elif r == 1 or c == 1:\n        for row in range(0, r):\n            for col in range(0, c):\n                if pending > 0:\n                    pending -= 1\n                    board[row][col] = '.'\n    else:\n        for row in range(0,2):\n            for col in range(0,2):\n                board[row][col] = '.'\n        pending -= 4\n        col=2\n        row=2\n \n        # First fill the outer border with groups of two\n        while pending >= 2 and (col<c or row<r):\n            if pending >= 2 and col<c:\n                board[0][col] = '.'\n                board[1][col] = '.'\n                col += 1\n                pending -= 2\n            if pending >= 2 and row<r:\n                board[row][0] = '.'\n                board[row][1] = '.'\n                row += 1\n                pending -= 2\n \n        # Now fill the inner board with the remaining free cells\n        for row in range(2, r):\n            for col in range(2, c):\n                if pending > 0:\n                    board[row][col] = '.'\n                    pending -= 1\n \n    # The clicked one is always on the top left corner\n    board[0][0] = 'c'\n \n    # Finally print(the board)\n    for row in range(0, r):\n        line = ''\n        for col in range(0, c):\n            line += board[row][col]\n        print(line)\n \n \nfor t in range(1, ncases+1):\n    values = sys.stdin.readline().strip().split()\n    r = int(values[0])\n    c = int(values[1])\n    m = int(values[2])\n \n    cells = r * c\n    free = cells - m\n \n    possible = False\n \n    if r == 1 or c == 1:\n        if free >= 1:\n            possible = True\n    elif r == 2 or c == 2:\n        if free == 1 or (free >= 4 and free%2 == 0):\n            possible = True\n    else:\n        if free == 1 or (free >= 4 and free != 5 and free != 7):\n            possible = True\n \n    print(\"Case #{0}:\".format(t))\n \n    if possible:\n        print_board(r, c, free)\n    else:\n        print(\"Impossible\")\n"}
{"author": "netsuso", "index": 19, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/python3\n \nimport sys\nimport math\n \ndef findbest(score):\n\t# Corner case\n\tif score == 0: return (0, 0)\n \n\tbest = math.ceil(score / 3)\n\tbestsurp = round(score / 3) + 1\n \n\treturn (best, bestsurp)\n \t\n# Ignore the number of cases\nsys.stdin.readline()\n \ncasenum = 0\nfor line in sys.stdin:\n\tcasenum += 1\n \n\tdata = line.strip().split(' ')\n\tmaxsurprising = int(data[1])\n\tp = int(data[2])\n\tscores = data[3:]\n\tmaxgooglers = 0\n \n\tfor s in scores:\n\t\t(best, bestsurp) = findbest(int(s))\n\t\tif best >= p:\n\t\t\tmaxgooglers += 1\n\t\telse:\n\t\t\tif bestsurp >= p and maxsurprising > 0:\n\t\t\t\tmaxgooglers += 1\n\t\t\t\tmaxsurprising -= 1\n \n\tprint(\"Case #%d: %d\" % (casenum, maxgooglers))\n"}
{"author": "netsuso", "index": 19, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/python3\n \nimport sys\n \nncases = int(sys.stdin.readline())\n \nfor t in range(1, ncases+1):\n    board = []\n    winner = False\n    numDots = 0\n \n    # Fill the board while finding the winning rows\n    for row in range(0, 4):\n        rowdata = sys.stdin.readline().strip()\n        board.append([])\n        numX = 0\n        numO = 0\n        for col in range(0, 4):\n            value = rowdata[col]\n            if value == \".\":\n                numDots += 1\n            if value == \"X\":\n                numX += 1\n            if value == \"O\":\n                numO += 1\n            if value == \"T\":\n                numX += 1\n                numO += 1\n            board[row].append(value)\n        if numX == 4:\n            winner = True\n            print(\"Case #%d: X won\" % t)\n            break\n        if numO == 4:\n            winner = True\n            print(\"Case #%d: O won\" % t)\n            break\n    while sys.stdin.readline().strip() != \"\": pass\n \n    if winner == True: continue\n \n    # Find columns\n    for col in range(0, 4):\n        numX = 0\n        numO = 0\n        for row in range(0, 4):\n            value = board[row][col]\n            if value == \"X\":\n                numX += 1\n            if value == \"O\":\n                numO += 1\n            if value == \"T\":\n                numX += 1\n                numO += 1\n        if numX == 4:\n            winner = True\n            print(\"Case #%d: X won\" % t)\n            break\n        if numO == 4:\n            winner = True\n            print(\"Case #%d: O won\" % t)\n            break\n \n    if winner == True: continue\n \n    # Find first diagonal\n    numX = 0\n    numO = 0\n    for rowcol in range(0, 4):\n        value = board[rowcol][rowcol]\n        if value == \"X\":\n            numX += 1\n        if value == \"O\":\n            numO += 1\n        if value == \"T\":\n            numX += 1\n            numO += 1\n    if numX == 4:\n        print(\"Case #%d: X won\" % t)\n        continue\n    if numO == 4:\n        print(\"Case #%d: O won\" % t)\n        continue\n \n    # Find second diagonal\n    numX = 0\n    numO = 0\n    for rowcol in range(0, 4):\n        value = board[rowcol][3-rowcol]\n        if value == \"X\":\n            numX += 1\n        if value == \"O\":\n            numO += 1\n        if value == \"T\":\n            numX += 1\n            numO += 1\n    if numX == 4:\n        print(\"Case #%d: X won\" % t)\n        continue\n    if numO == 4:\n        print(\"Case #%d: O won\" % t)\n        continue\n \n    # Final case\n    if numDots == 0:\n        print(\"Case #%d: Draw\" % t)\n    else:\n        print(\"Case #%d: Game has not completed\" % t)\n \n"}
{"author": "netsuso", "index": 19, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/python3\n \nimport sys\n \nncases = int(sys.stdin.readline())\n \nfor t in range(1, ncases+1):\n    (n, m) = [int(x) for x in sys.stdin.readline().strip().split(\" \")]\n    lawn = []\n    cuttable = []\n    for row in range(0, n):\n        lawn.append([int(x) for x in sys.stdin.readline().strip().split(\" \")])\n        cuttable.append([False for x in range(0, m)])\n \n    # Find cuttable squares in rows\n    for row in range(0, n):\n        rowdata = lawn[row]\n        maxheight = max(rowdata)\n        for col in range(0, m):\n            if lawn[row][col] == maxheight:\n                cuttable[row][col] = True\n \n    # Find cuttable squares in columns\n    for col in range(0, m):\n        coldata = [x[col] for x in lawn]\n        maxheight = max(coldata)\n        for row in range(0, n):\n            if lawn[row][col] == maxheight:\n                cuttable[row][col] = True\n \n    # Find if there's any square that is not cuttable\n    result = True\n    for row in range(0, n):\n        for col in range(0, m):\n            if not cuttable[row][col]:\n                result = False\n                break\n        if result == False:\n            break\n \n    if result == False:\n        print(\"Case #%d: NO\" % t)\n    else:\n        print(\"Case #%d: YES\" % t)\n"}
{"author": "netsuso", "index": 19, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/python3\n \nimport sys\n \nreverseMappings = {\n'a': 'y',\n'b': 'h',\n'c': 'e',\n'd': 's',\n'e': 'o',\n'f': 'c',\n'g': 'v',\n'h': 'x',\n'i': 'd',\n'j': 'u',\n'k': 'i',\n'l': 'g',\n'm': 'l',\n'n': 'b',\n'o': 'k',\n'p': 'r',\n'q': 'z',\n'r': 't',\n's': 'n',\n't': 'w',\n'u': 'j',\n'v': 'p',\n'w': 'f',\n'x': 'm',\n'y': 'a',\n'z': 'q',\n' ': ' '\\n}\\n \\ndef reverse(string):\\n\treturn ''.join([reverseMappings[c] for c in string])\n \n# Ignore number of tests\nsys.stdin.readline()\n \ncasenum=0\nfor line in sys.stdin:\n\tcasenum += 1\n\treversed = reverse(line.strip())\n\tprint(\"Case #%d: %s\" % (casenum, reversed))\n"}
{"author": "netsuso", "index": 19, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/python3\n#\n# Some notes:\n# - It's better to find palindromes in the square rooted numbers (there will be a lot fewer)\n# - It's also much faster to generate the palindromes than to detect if a random number is a palindrome\n#   - Number of palindromes with n digits: 10^(ceil(n/2))\n#   - E.g, 3 digits => 10^2  -  4 digits => 10^2  -  5 digits => 10^3\n# - So the problem is reduced to generate the palindromes which are still palindromes when squared\n#\n# - And how to detect is a squared palindrome is still a palindrome? Easy, let's draw a multiplication:\n#          1 2 1\n#          1 2 1\n#       --------\n#          1 2 1\n#        2 4 2\n#      1 2 1\n#      ---------\n#      1 4 6 4 1\n#\n#   - The extreme case is the central column. If the sum is >=10, then resulting number will not be a palindrome\n#   - As the original number is a palindrome, this central column will always be the sum of the squares of all\n#     the digits in the number. E.g: 121 => 1^2 + 2^2 + 1^2 = 1 + 4 + 1 = 6 => less than 10 => square is a palindrome\n#   - This means that palindromes with digits 4-9 can never become a palindrome when squared\n#   - 3 can only appear once => 3 is the only valid number containing digit 3\n#   - 2 can appear at most twice:\n#     - 2 twos + 0/1 one (in this case 2 have to be the first and last digit)\n#     - 1 two + 0/2/4 ones (in this case 2 has to be in the middle position)\n#   - 1 can appear alone up to 9 times\n#   - 0 can appear as many times as you want\n#\n \n \nimport sys\nimport math\n \n# This is the same as findpalindromes, but much faster (it just calculates the combinations\n# instead of obtaining all the actual numbers)\ndef calculatepalindromes(ndigits):\n    # Special case: only 1 digit\n    if ndigits == 1:\n        return 3\n \n    result = 0\n    isEven = ndigits % 2 == 0\n    fillingdigits = math.floor((ndigits - 2)/2)\n \n    # Palindromes with 2's\n    if isEven:\n        result += 1\n    else:\n        result += 3\n \n    # Palindromes with only 1's\n    for numones in range(0, min(6, fillingdigits) + 1):\n        combinations = int(math.factorial(fillingdigits) / (math.factorial(fillingdigits-numones) * math.factorial(numones)))\n        result += combinations\n        if not isEven:\n            result += combinations\n \n    return result\n \n \ndef findpalindromes(ndigits):\n    # Special case: only 1 digit\n    if ndigits == 1:\n        return [1, 2, 3]\n \n    result = []\n    isEven = ndigits % 2 == 0\n    fillingdigits = math.floor((ndigits - 2)/2)\n \n    # Palindromes with 2's\n    if isEven:\n        result.append(int(\"2\" + \"0\"*(fillingdigits*2) + \"2\"))\n    else:\n        result.append(int(\"2\" + \"0\"*fillingdigits + \"0\" + \"0\"*fillingdigits + \"2\"))\n        result.append(int(\"2\" + \"0\"*fillingdigits + \"1\" + \"0\"*fillingdigits + \"2\"))\n        result.append(int(\"1\" + \"0\"*fillingdigits + \"2\" + \"0\"*fillingdigits + \"1\"))\n \n    # Palindromes with only 1's\n    for numones in range(0, min(6, fillingdigits)+1):\n        ones = fillOnes([], fillingdigits, numones)\n        for o in ones:\n            if isEven:\n                result.append(int(\"1\" + \"\".join(o) + \"\".join(list(reversed(o))) + \"1\"))\n            else:\n                result.append(int(\"1\" + \"\".join(o) + \"0\" + \"\".join(list(reversed(o))) + \"1\"))\n                result.append(int(\"1\" + \"\".join(o) + \"1\" + \"\".join(list(reversed(o))) + \"1\"))\n \n    return result\n \ndef fillOnes(combination, size, remainingOnes):\n    if len(combination) == size:\n        return [combination]\n    result = []\n    if remainingOnes > 0:\n        c = combination + [\"1\"]\n        result += fillOnes(c, size, remainingOnes - 1)\n    if remainingOnes < size - len(combination):\n        c = combination + [\"0\"]\n        result += fillOnes(c, size, remainingOnes)\n    return result\n \n \n \nncases = int(sys.stdin.readline())\n \nfor t in range(1, ncases+1):\n    fairsquare = 0\n    (a, b) = sys.stdin.readline().strip().split(\" \")\n    intA = int(a)\n    intB = int(b)\n    ndigitsA = len(a)\n    ndigitsB = len(b)\n    ndigitsARooted = math.ceil(ndigitsA/2)\n    ndigitsBRooted = math.ceil(ndigitsB/2)\n \n    if ndigitsBRooted == ndigitsARooted:\n        palindromes = findpalindromes(ndigitsARooted)\n        for p in palindromes:\n            if p ** 2 >= intA and p ** 2 <= intB:\n                fairsquare +=1\n    else:\n        palindromes = findpalindromes(ndigitsARooted)\n        for p in palindromes:\n            if p ** 2 >= intA:\n                fairsquare +=1\n \n        for i in range(ndigitsARooted + 1, ndigitsBRooted):\n            fairsquare += calculatepalindromes(i)\n \n        palindromes = findpalindromes(ndigitsBRooted)\n        for p in palindromes:\n            if p ** 2 <= intB:\n                fairsquare +=1\n \n    print(\"Case #%d: %d\" % (t, fairsquare))\n"}
{"author": "netsuso", "index": 19, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python3\n \nimport sys\n \nncases = int(sys.stdin.readline().strip())\n \ndef read_arrangement():\n    arr = []\n    for row in range(0,4):\n        arr.append(sys.stdin.readline().strip().split(' '))\n    return arr\n \nfor t in range(1, ncases+1):\n    answer1 = int(sys.stdin.readline().strip())\n    arrang1 = read_arrangement()\n    answer2 = int(sys.stdin.readline().strip())\n    arrang2 = read_arrangement()\n \n    row1 = arrang1[answer1-1]\n    row2 = arrang2[answer2-1]\n \n    intersect = set(row1) & set(row2)\n \n    if len(intersect) == 1:\n        print(\"Case #{0}: {1}\".format(t, intersect.pop()))\n    elif len(intersect) == 0:\n        print(\"Case #{0}: Volunteer cheated!\".format(t))\n    else:\n        print(\"Case #{0}: Bad magician!\".format(t))\n"}
{"author": "nwin", "index": 20, "filename": "2014_2974486_5709773144064000.py", "code": "def solve():\n    c, f, x = map(float, raw_input().split())\n    ans = 1e40\n    cur = 0.0\n    psp = 2.0\n    while cur < ans + 1e-8:\n        ans = min(ans, cur + x / psp)\n        cur += c / psp\n        psp += f\n    return ans\nfor t in xrange(int(raw_input())):\n    print(\"Case #%d: %.7f\" % (t + 1, solve()))\n"}
{"author": "nwin", "index": 20, "filename": "2014_2974486_5690574640250880.py", "code": "from itertools import product\ndef solve():\n    h, w, m = map(int, raw_input().split())\n    if h == 1:\n        print('c' + '.' * (h * w - m - 1) + '*' * m)\n    elif w == 1:\n        for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n            print(c)\n    elif h * w - m == 1:\n        print('c' + '*' * (w - 1))\n        for _ in xrange(h-1):\n            print('*' * w)\n    else:\n        m = h * w - m\n        for i in xrange(h-1):\n            for j in xrange(w-1):\n                t = (i + 2) * 2 + (j + 2) * 2 - 4\n                r = (i + 2) * (j + 2)\n                if t <= m <= r:\n                    a = [['*'] * w for _ in xrange(h)]\n                    for k in xrange(i+2):\n                        a[k][0] = '.'\n                        a[k][1] = '.'\n                    for k in xrange(j+2):\n                        a[0][k] = '.'\n                        a[1][k] = '.'\n                    for y, x in product(range(2, i+2), range(2, j+2)):\n                        if y == 1 and x == 1:\n                            continue\n                        if t >= m:\n                            break\n                        a[y][x] = '.'\n                        t += 1\n                    a[0][0] = 'c'\n                    for s in a:\n                        print(''.join(s))\n                    return\n        print('Impossible')\nfor t in xrange(int(raw_input())):\n    print(\"Case #%d:\" % (t + 1))\n    solve()\n"}
{"author": "nwin", "index": 20, "filename": "2012_1460488_1595491.py", "code": "T = int(raw_input())\nfor t in xrange(T):\n    line = map(int, raw_input().split())\n    N, S, p = line[0:3]\n    a = line[3:]\n    cnt = 0\n    a.sort(reverse=True)\n    for x in a:\n        if (x + 2) / 3 >= p:\n            cnt += 1\n        elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:\n            cnt += 1\n            S -= 1\n        else:\n            break\n    print(\"Case #%d: %d\" % (t + 1, cnt))\n"}
{"author": "nwin", "index": 20, "filename": "2013_2270488_2453486.py", "code": "def solve(pre):\n    b = [raw_input().strip() for _ in xrange(4)]\n    raw_input()\n    for s in b + zip(*b) + [''.join(b[i][i] for i in xrange(4)), ''.join(b[3-i][i] for i in xrange(4))]:\n        for c in 'XO':\n            if s.count('T') + s.count(c) == 4:\n                print(pre, c, \"won\")\n                return\n    if ''.join(b).count('.'):\n        print(pre, \"Game has not completed\")\n    else:\n        print(pre, \"Draw\")\n \nn = int(raw_input())\nfor i in xrange(n):\n    solve(\"Case #%d:\" % (i + 1))\n"}
{"author": "nwin", "index": 20, "filename": "2013_2270488_2449486.py", "code": "def solve(pre):\n    read_ints = lambda: map(int, raw_input().split())\n    h, w = read_ints()\n    to = [read_ints() for _ in xrange(h)]\n    lawn = [[100] * w for _ in xrange(h)]\n    for i, r in enumerate(to):\n        cut = max(r)\n        for j in xrange(w):\n            lawn[i][j] = min(lawn[i][j], cut)\n    for i, c in enumerate(zip(*to)):\n        cut = max(c)\n        for j in xrange(h):\n            lawn[j][i] = min(lawn[j][i], cut)\n    if lawn == to:\n        print(pre, \"YES\")\n    else:\n        print(pre, \"NO\")\n \nn = int(raw_input())\nfor i in xrange(n):\n    solve(\"Case #%d:\" % (i + 1))\n"}
{"author": "nwin", "index": 20, "filename": "2012_1460488_1483485.py", "code": "import string\nn = int(raw_input())\nS = \"\"\"\ny qee\nejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv\nz\n\"\"\"\nT = \"\"\"\na zoo\nour language is impossible to understand\nthere are twenty six factorial possibilities\nso it is okay if you want to just give up\nq\n\"\"\"\ntrans = {}\nfor i in xrange(len(S)):\n    trans[S[i]] = T[i]\nA = \"\"\nB = \"\"\nfor (c, d) in trans.items():\n    A += c\n    B += d\nfor i in xrange(n):\n    print(\"Case #%d: %s\" % (i + 1, raw_input().strip().translate(string.maketrans(A, B))))\n"}
{"author": "nwin", "index": 20, "filename": "2013_2270488_2463486.py", "code": "from bisect import *\na = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]\nA = a[:10]\ndef subdfs(pre, mid, d, t, n):\n    if d == t:\n        k = long(''.join([pre, mid, pre[::-1]]))\n        k = k * k\n        if k > n:\n            return [1, 0]\n        sqk = str(k)\n        if sqk == sqk[::-1]:\n            A.append(k)\n            return [0, 1]\n        else:\n            return [0, 0]\n    res = subdfs(pre + '0', mid, d + 1, t, n)\n    if res[0]: return res\n    if not res[1]: return res\n    res2 = subdfs(pre + '1', mid, d + 1, t, n)\n    if res2[0]: return [1, res[1] + res2[1]]\n    return [0, res[1] + res2[1]]\n \ndef dfs(d, n):\n    subdfs('1', '', 0, d, n)\n    subdfs('2' + '0' * d, '', d, d, n)\n    subdfs('1', '0', 0, d, n)\n    subdfs('1', '1', 0, d, n)\n    subdfs('1', '2', 0, d, n)\n    subdfs('2' + '0' * d, '0', d, d, n)\n    subdfs('2' + '0' * d, '1', d, d, n)\n \ndef solve(pre):\n    read_ints = lambda: map(int, raw_input().split())\n    l, r = read_ints()\n    cl = bisect_left(A, l)\n    cr = bisect_right(A, r)\n    cl_ = cr_ = 0\n    for i in xrange(40):\n        if a[i] < l: cl_ += 1\n    for i in xrange(40):\n        if a[i] <= r: cr_ += 1\n    #print(pre, cr_ - cl_)\n    print(pre, cr - cl)\n \nfor k in xrange(1, 48):\n    dfs(k, 10 ** 100 + 1)\nA.sort()\nN = int(raw_input())\nfor i in xrange(1, N + 1):\n    solve(\"Case #%d:\" % i)\n"}
{"author": "nwin", "index": 20, "filename": "2014_2974486_5756407898963968.py", "code": "def solve():\n    r1 = int(raw_input())\n    a1 = [map(int, raw_input().split()) for i in xrange(4)]\n    r2 = int(raw_input())\n    a2 = [map(int, raw_input().split()) for i in xrange(4)]\n    ans = -1\n    for i in xrange(1, 17):\n        if i in a1[r1-1] and i in a2[r2-1]:\n            if ans != -1:\n                return \"Bad magician!\"\n            ans = i\n    if ans == -1:\n        return \"Volunteer cheated!\"\n    return ans\nfor t in xrange(int(raw_input())):\n    print(\"Case #%d:\" % (t + 1), solve())\n"}
{"author": "joegunrok", "index": 21, "filename": "2014_2974486_5709773144064000.py", "code": "__author__ = 'jrokicki'\n \nimport sys\nRL = lambda: sys.stdin.readline().strip()\nIA = lambda: map(int, RL().split(\" \"))\nLA = lambda: map(long, RL().split(\" \"))\nFA = lambda: map(float, RL().split(\" \"))\n \nT = int(sys.stdin.readline())\n \nfor CASE in range(T):\n    C,F,X = FA()\n    tick = 2.\n    answer = X/tick\n \n    game = 0\n    while True:\n        span = C / tick\n        tick += F\n        test = game + span + X/tick\n        game = game + span\n \n        if test < answer:\n            answer = test\n        else:\n            if tick > X:\n                break\n \n    print(\"Case #%d: %s\" % (CASE+1, answer))\n \n"}
{"author": "joegunrok", "index": 21, "filename": "2014_2974486_5690574640250880.py", "code": "__author__ = 'jrokicki'\n \nimport sys\nRL = lambda: sys.stdin.readline().strip()\nIA = lambda: map(int, RL().split(\" \"))\nLA = lambda: map(long, RL().split(\" \"))\nFA = lambda: map(float, RL().split(\" \"))\n \nT = int(sys.stdin.readline())\n \ndef clear(R,C,b, x, y):\n    b = b[:]\n    n = 0\n    for i in range(max(0,x-1), min(R,x+2)):\n        for j in range(max(0,y-1), min(C, y+2)):\n            if b[C*i+j] == '*':\n                n += 1\n                b = b[:C*i+j] + '.' + b[C*i+j+1:]\n    return b, n\nmem = dict()\ndef pb(R,C,b):\n    for x in range(R):\n        print(b[x*C:x*C+C])\n \ndef board(R,C,b,x,y,M,m):\n    global mem\n    print(x)\n    key = (R,C,b,M,x,y,m)\n    if key in mem: return mem[key]\n    if x >= R or y >= C:\n        mem[key] = None\n    else:\n        lb = b\n        n = 0\n        good = False\n        for i in range(y,C):\n            nb,nn = clear(R,C, lb, x, i)\n            n += nn\n            if m - n - M == 0:\n                mem[key] = nb\n                good = True\n                break\n            elif m - n - M < 0:\n                break\n            lb = bb\n        mem[key] = board(R,C,bb,M,x+1,0,m-n)\n    return mem[key]\n \nfor CASE in range(T):\n    R,C,M = IA()\n    IMPOSSIBLE = \"Impossible\"\n \n    b = \"\"\n    cleared = R*C-M\n    for x in range(R):\n        b += \"*\" * C\n    if M == R*C-1:\n        b = \"c\" + b[1:]\n        answer = b\n    else:\n        good = False\n        x,y = 0,0\n        q = [(b,0,0,0)]\n        mem = {}\n        while not good and q:\n            board,total_cleared,x,y = q.pop(0)\n            if (board,total_cleared,x,y) in mem:\n                continue\n            mem[(board,total_cleared,x,y)] = True\n            if x >= R: continue\n            if y >= C:\n                q.append((last_board,total_cleared,x+1,0))\n                continue\n            last_board = board\n            new_board, cleared_mines = clear(R,C,last_board,x,y)\n            total_cleared += cleared_mines\n \n            if total_cleared == cleared:\n                good = True\n                last_board = new_board\n                q = []\n                break\n            elif total_cleared - cleared == -1:\n                q.append((new_board,total_cleared,x,y+1))\n                q.append((new_board,total_cleared,x+1,0))\n                q.append((last_board,total_cleared-cleared_mines,x+1,0))\n            elif total_cleared > cleared:\n                q.append((last_board,total_cleared-cleared_mines,x+1,0))\n            else:\n                q.append((new_board,total_cleared,x,y+1))\n            last_board = new_board\n        if good:\n            answer = last_board\n        else:\n            answer = None\n    if not answer:\n        answer = \"Impossible\"\n    else:\n        b = \"\"\n        for x in range(R):\n            b += answer[x*C:x*C+C] + \"\\n\"\n        answer = \"c\" + b[1:-1]\n    print(\"Case #%d:\\n%s\" % (CASE+1, answer))\n \n"}
{"author": "joegunrok", "index": 21, "filename": "2012_1460488_1595491.py", "code": "#!/bin/env python       \n\"\"\"\nGCJ framework (gcj.fw.framework)\n- Command Line and Package interface\n- output redirection\n- parsing case input\n- executing problem code against cases\n- testing framework\n\"\"\"\nimport sys\nimport unittest\nimport StringIO\n \nclass Framework(object):\n    class Case(object):\n        def __init__(self, caseNumber, caseData=None):\n            self.number = caseNumber\n            self.data = caseData\n            self.result = None\n     \n        @classmethod\n        def parser(cls, f_in):\n            pass\n     \n        def run(self):\n            pass\n     \n        def execute(self, f_in=None):\n            if self.data is None:\n                self.data = self.parser(f_in)\n            self.result = self.run(**self.data)\n     \n        def __str__(self):\n            return \"Case #%d: %s\" % (self.number, self.result)\n     \n     \n    class Result(object):\n        def __init__(self, resultData):\n            self.data = resultData\n     \n        def __str__(self):\n            return str(self.ata)\n \n    def __init__(self, f_in, f_out):\n        sys.stdout = f_out\n        self.f_in = f_in if f_in is not None else sys.stdin\n \n    def run(self):\n        nCases = int(self.f_in.readline().strip())\n        for num in xrange(nCases):\n            case = type(self).Case(num+1)\n            case.execute( f_in=self.f_in)\n            print(case)\n \n \n    @classmethod\n    def __main__(cls):\n        f_in = sys.stdin\n        if len(sys.argv) > 1:\n            if sys.argv[1] == \"-t\":\n                unittest.main()\n                sys.exit()\n            f_in = open(sys.argv[1])\n        framework = cls(f_in, sys.stdout)\n        framework.run()\n     \nclass Test(unittest.TestCase):\n    cases = []\n    case = None\n    c=[]\n     \n    def setUp(self):\n        self.c = []\n        self.defineCases()\n        counter = 1\n        self.cases = []\n        for c in self.c:\n            case = self.case(counter)\n            case.data = case.parser(StringIO.StringIO(c[0]))\n            self.cases.append( [case, c[1]])\n     \n    def defineCases(self):\n        pass\n     \n    def tearDown(self):\n        pass \n \n    def test_Name(self):\n        self.setUp()\n        for case in self.cases:\n            print(case[0].data, case[1])\n            case[0].execute()\n            self.assertEqual(case[0].result, case[1])\n'''\nCreated on Apr 8, 2012\n \n@author: Joe\n'''\n \n \nclass B(Framework):\n    class Case(Framework.Case):\n        def parser(self, fh):\n            args = map(int, fh.readline().strip().split(\" \"))\n            N,S,p = args[:3]\n            scores = args[3:] \n            return {\"N\":N,\"S\":S,\"p\":p,\"scores\":scores}\n         \n        def run(self, N=None,S=None,p=None,scores=None):\n            ret = 0\n            surps = 0\n            for score in scores:\n                if p > 0 and score == 0: continue\n                if 3*p-2 <= score:\n                    ret += 1\n                else:\n                    if 3*p - 4 <= score:\n                        surps += 1\n            return str(ret + min(surps,S))\n             \nclass Test(Test):\n    def defineCases(self):\n        self.case = B.Case\n        self.c = [\n                [\"3 1 5 15 13 11\",\"3\"],\n                [\"3 0 8 23 22 21\",\"2\"],\n                [\"2 1 1 8 0\",\"1\"],\n                [\"6 2 8 29 20 8 18 18 21\",\"3\"],\n                [\"1 1 1 1\", \"1\"]\n                ]\n \nif __name__ == \"__main__\":\n    B.__main__()\n     \n"}
{"author": "joegunrok", "index": 21, "filename": "2013_2270488_2453486.py", "code": "import sys\n \nlines = sys.stdin.readlines()\ndef parseCase(lines):\n    return 5,lines[0:4]\n \ndef getCases(lines):\n    i =0\n    while i < len(lines):\n        lines_used, case = parseCase(lines[i:])\n        i += lines_used\n        yield case\n \ndef test(r):\n    if 'O' in r and '.' not in r and 'X' not in r: \n        return \"O won\"\n    elif 'X' in r and '.' not in r and 'O' not in r: \n        return \"X won\"\n    return None\n         \ncNum =0\nfor c in getCases(lines[1:]):\n    cNum += 1\n    answer = None\n    for i in range(0,4):\n        if answer: break\n        r = c[i]\n        answer = test(r) \\\n            or test(\"\".join(c[j][i] for j in range(4)))\n \n    if not answer:\n        answer = test(\"\".join([c[j][3-j] for j in range(4)])) \\\n            or test(\"\".join(c[j][j] for j in range(4)))\n             \n    if not answer:\n        answer = any([\".\" in c[i] for i in range(4)]) and \"Game has not completed\"\n    if not answer:\n        answer = \"Draw\"\n    print(\"Case #%d: %s\" % ( cNum, answer))\n \n \n \n \n \n \n \n \n \n \n \n     \n \n \n"}
{"author": "joegunrok", "index": 21, "filename": "2013_2270488_2449486.py", "code": "import sys\n \nlines = sys.stdin.readlines()\ndef parseCase(lines):\n    dims = map(int,lines[0].split(\" \"))\n    return dims[0]+1, [map(int,l.split(\" \")) for l in lines[1:dims[0]+1]]\n \n \ndef getCases(lines):\n    i =0\n    while i < len(lines):\n        lines_used, case = parseCase(lines[i:])\n        i += lines_used\n        yield case\n \n         \ncNum =0\nfor c in getCases(lines[1:]):\n    cNum += 1\n    answer = None\n    for i in range(len(c)):\n        if answer: break\n        for j in range(len(c[i])):\n            if answer: break\n            answer = max(c[i]) > c[i][j] and max([c[k][j] for k in range(len(c))]) > c[i][j]\n    print(\"Case #%d: %s\" % ( cNum, \"NO\" if answer else \"YES\"))\n \n \n     \n \n \n"}
{"author": "joegunrok", "index": 21, "filename": "2012_1460488_1483485.py", "code": "       \n\"\"\"\nGCJ framework (gcj.fw.framework)\n- Command Line and Package interface\n- output redirection\n- parsing case input\n- executing problem code against cases\n- testing framework\n\"\"\"\nimport sys\nimport unittest\nimport StringIO\n \nclass Framework(object):\n    class Case(object):\n        def __init__(self, caseNumber, caseData=None):\n            self.number = caseNumber\n            self.data = caseData\n            self.result = None\n     \n        @classmethod\n        def parser(cls, f_in):\n            pass\n     \n        def run(self):\n            pass\n     \n        def execute(self, f_in=None):\n            if self.data is None:\n                self.data = self.parser(f_in)\n            self.result = self.run(**self.data)\n     \n        def __str__(self):\n            return \"Case #%d: %s\" % (self.number, self.result)\n     \n     \n    class Result(object):\n        def __init__(self, resultData):\n            self.data = resultData\n     \n        def __str__(self):\n            return str(self.ata)\n \n    def __init__(self, f_in, f_out):\n        sys.stdout = f_out\n        self.f_in = f_in if f_in is not None else sys.stdin\n \n    def run(self):\n        nCases = int(self.f_in.readline().strip())\n        for num in xrange(nCases):\n            case = type(self).Case(num+1)\n            case.execute( f_in=self.f_in)\n            print(case)\n \n \n    @classmethod\n    def __main__(cls):\n        f_in = sys.stdin\n        if len(sys.argv) > 1:\n            if sys.argv[1] == \"-t\":\n                unittest.main()\n                sys.exit()\n            f_in = open(sys.argv[1])\n        framework = cls(f_in, sys.stdout)\n        framework.run()\n     \nclass Test(unittest.TestCase):\n    cases = []\n    case = None\n    c=[]\n     \n    def setUp(self):\n        self.c = []\n        self.defineCases()\n        counter = 1\n        self.cases = []\n        for c in self.c:\n            case = self.case(counter)\n            case.data = case.parser(StringIO.StringIO(c[0]))\n            self.cases.append( [case, c[1]])\n     \n    def defineCases(self):\n        pass\n     \n    def tearDown(self):\n        pass \n \n    def test_Name(self):\n        self.setUp()\n        for case in self.cases:\n            print(case[0].data, case[1])\n            case[0].execute()\n            self.assertEqual(case[0].result, case[1])\n \nD={'a':'y','o':'e','z':'q','q':'z'}\n \na=[\"ejp mysljylc kd kxveddknmc re jsicpdrysi\",\n    \"our language is impossible to understand\",\n    \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\",\n    \"there are twenty six factorial possibilities\",\n    \"de kr kd eoya kw aej tysr re ujdr lkgc jv\",\n    \"so it is okay if you want to just give up\"]\n \nfor i in range(0,len(a),2):\n    for j in range(0,len(a[i])):\n        D[a[i][j]] = a[i+1][j]\n \nclass A(Framework):\n    class Case(Framework.Case):\n        def parser(self, fh):\n            statement = fh.readline().strip() \n            return {'secret': statement}\n         \n        def run(self, secret=None):\n            word = \"\"\n            for i in range(0,len(secret)):\n                word += D[secret[i]]\n            return word\n         \nclass Test(Test):\n    def defineCases(self):\n        self.case = A.Case\n        self.c = [[\"ejp mysljylc kd kxveddknmc re jsicpdrysi\",\n    \"our language is impossible to understand\"],\n                [   \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\",\n    \"there are twenty six factorial possibilities\",],\n                [ \"de kr kd eoya kw aej tysr re ujdr lkgc jv\",\n    \"so it is okay if you want to just give up\"],\n                ]\n \nif __name__ == \"__main__\":\n    A.__main__()\n     \n"}
{"author": "joegunrok", "index": 21, "filename": "2013_2270488_2463486.py", "code": "import sys\n \nlines = sys.stdin.readlines()\ndef parseCase(lines):\n    dims = map(int,lines[0].split(\" \"))\n    return 1, dims\n \ndef getCases(lines):\n    i =0\n    while i < len(lines):\n        lines_used, case = parseCase(lines[i:])\n        i += lines_used\n        yield case\n \nimport math\n \nfands = []\nphash = {1:True}\ndef isPalindrome(p):\n    return p in phash\n \ndef test(p):\n    square = p**.5\n    return square == int(square) and isPalindrome(int(square))\n \nfor i in range(1,10**5):\n    if i > 9:\n        small_p = int(i * 10 ** int(math.log(i,10)) + int(\"\".join(reversed(str(i)[:-1]))))\n    else: small_p = i\n    phash[small_p]= test(small_p)\n    if phash[small_p]: fands.append(small_p)\n    big_p = int(i * 10 ** int(math.log(i,10)+1) + int(\"\".join(reversed(str(i)))))\n    phash[big_p] = test(big_p)\n    if phash[big_p]: fands.append(big_p)\ncNum =0\n \nfor c in getCases(lines[1:]):\n    cNum += 1\n    answer = []\n    for i in fands:\n        if i < c[0]: continue\n        if i > c[1]: break\n        if phash[i]: answer.append(i)\n    answer = str(len(answer))\n    print(\"Case #%d: %s\" % ( cNum, answer))\n \n \n     \n \n \n"}
{"author": "joegunrok", "index": 21, "filename": "2014_2974486_5756407898963968.py", "code": "__author__ = 'jrokicki'\n \nimport sys\nRL = lambda: sys.stdin.readline().strip()\nIA = lambda: map(int, RL().split(\" \"))\nLA = lambda: map(long, RL().split(\" \"))\n \nT = int(sys.stdin.readline())\n \nfor CASE in range(T):\n    g1 = IA()[0]-1\n    board1 = []\n    for i in range(4):\n        board1.append(IA())\n    g2 = IA()[0]-1\n    board2 = []\n    for i in range(4):\n        board2.append(IA())\n \n    r1 = board1[g1]\n    r2 = board2[g2]\n \n    answer = set(r1).intersection(r2)\n    if len(answer) > 1:\n        answer = \"Bad magician!\"\n    elif len(answer) == 0:\n        answer = \"Volunteer cheated!\"\n    else:\n        answer = list(answer)[0]\n \n    print(\"Case #%d: %s\" % (CASE+1, answer))\n \n"}
{"author": "idahojacket", "index": 22, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\n \nnumCases = input()\nfor case in range( 1, numCases + 1 ):\n    C, F, X = raw_input().split()\n    C = float(C)\n    F = float(F)\n    X = float(X)\ntime = 0.0\nrate = 2.0\n   \nwhile ( True ):\n    timeToFinish = X / rate\n    timeToFarm   = C / rate\n    farmPayoffTime = C / F\n \n    if timeToFinish < ( timeToFarm + farmPayoffTime ):\n        time += timeToFinish\n        break\n    else:\n        time += timeToFarm\n        rate += F\n \n \noutput = '{0:0.15f}'.format( time )\n \nprint ('Case #' + str( case ) + ': ' + str( output ))\n"}
{"author": "idahojacket", "index": 22, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\n \ndef DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines ):\n    x = []\n    numSpaces = 0\n    numMines = 0\n    \n    gridRows = max( R-2, 0 )\n    gridCols = max( C-2, 0 )\n    \n    for r in xrange( 0, R ):\n        x.append( [] )\n        for c in xrange( 0, C ):\n            x[ r ].append( '.' )\n            numSpaces += 1\n    \n    if gridMines > 0:\n        for r in xrange( 0, gridRows ):\n            if numMines >= gridMines:\n                break;\n            for c in xrange( 0, gridCols ):\n                x[ r ][ c ] = '*'\n                numMines += 1\n                numSpaces -= 1\n                if numMines >= gridMines:\n                    break;\n    \n    for r in xrange( 0, R ):\n        if sideMines <= 0:\n            break\n        for c in xrange( gridCols, C ):\n            x[ r ][ c ] = '*'\n            numMines += 1\n            numSpaces -= 1\n            sideMines -= 1\n            if sideMines <= 0:\n                break\n    \n    for c in xrange( 0, C ):\n        if bottomMines <= 0:\n            break\n        for r in xrange( gridRows, R ):\n            x[ r ][ c ] = '*'\n            numMines += 1\n            numSpaces -= 1\n            bottomMines -= 1\n            if bottomMines <= 0:\n                break\n        \n    x[ R - 1][ C - 1 ] = 'c'\n    \n    if numMines != M and ( R * C ) - M != 1:\n        print (\"ERROR!!!!!!!!!!!!!!!!!!!!!!!!\")\n        print ( R * C ) - M\n    \n    \n    o = \"\"\n    \n    if Flip:\n        for c in xrange( 0, C ):\n            for r in xrange( 0, R ):\n                o += x[ r ][ c ]\n            o += '\\n'\n    else:\n        for r in xrange( 0, R ):\n            for c in xrange( 0, C ):\n                o += x[ r ][ c ]\n            o += '\\n'\n    \n    return o[:-1] #strip the extra newline\n \n \n \n \nnumCases = input()\nfor case in xrange( 1, numCases + 1 ):\n    R, C, M = [int(x) for x in raw_input().split()]\n \nOutput = None\n \nFlip = C > R\nif Flip:\n    temp = R\n    R = C\n    C = temp\n \nNonMines = ( R * C ) - M\n# Special cases first\nif ( NonMines == 0 ):\n    Output = \"Impossible\"\nelif ( C == 1 ):\n    gridMines = 0\n    extraMines = M - gridMines\n    Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )\nelif ( NonMines == 2 or  NonMines == 3 ):\n    Output = \"Impossible\"\nelse:\n    maxGridCols = max( 0, C - 2 )\n    maxGridRows = max( 0, R - 2 )\n    gridMines = min( M, maxGridCols * maxGridRows )\n    extraMines = M - gridMines\n    extraPairs = ( extraMines + 1 ) / 2\n    extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\n    extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\n    safeExtraPairs = extraPairsSide + extraPairsBottom\n    blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\n    blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\n    blockingPairs = blockingPairsSide + blockingPairsBottom\n    totalPairs = safeExtraPairs + blockingPairs\n \n     \n    if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\n        extraMines += 1\n        gridMines -= 1\n \n    if ( NonMines == 1 ):\n        if extraMines % 2 != 0:\n            extraMines += 1\n        blockingPairsSide += 1\n        blockingPairsBottom += 1\n     \n    if extraMines % 2 == 0:\n        sideMines = 2 * ( extraPairsSide + blockingPairsSide )\n        bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )\n        Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )\n    else:\n        Output = \"Impossible\"\n \noutput = \"\\n\" + Output\nprint ('Case #' + str( case ) + ': ' + str( output ))\n"}
{"author": "idahojacket", "index": 22, "filename": "2012_1460488_1595491.py", "code": "def build_table():\n\ttable = []\n\tfor i in range( 0, 31 ):\n\t\ttable.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )\n \n\treturn table\n \n \ndef get_max_score( i ):\n\treturn max( 0, min( 10, ( i + 2 ) / 3 ) )\n \ndef get_max_surprise_score( i ):\n\treturn min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )\n \ndef get_max( x, scores, score_needed, num_surprises ):\n\tscores = sorted( scores, reverse=True )\n\tnumPass = 0\n\ti = 0;\n\twhile ( i < len(scores) ):\n\t\tif ( x[scores[i]][0] >= score_needed ):\n\t\t\tnumPass += 1\n\t\telse:\n\t\t\tbreak\n\t\ti += 1\n \n\twhile ( i < len(scores) and num_surprises > 0 ):\n\t\tif ( x[scores[i]][1] >= score_needed ):\n\t\t\tnumPass += 1\n\t\t\tnum_surprises -= 1\n \t\t\t\n\t\ti += 1\n \n\treturn numPass\n \nx = build_table()\n \nnum_cases = input()\n \nfor i in range( 1, num_cases + 1 ):\n\tline = raw_input().split()\n\tnum_surprises = int(line[1])\n\tscore_needed = int(line[2])\n\tscores_raw = line[3:]\n \n\tscores = [ int(y) for y in scores_raw ]\n \n\tprint('Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) ))\n"}
{"author": "idahojacket", "index": 22, "filename": "2013_2270488_2453486.py", "code": "import sys\n \ndef get_winner( row ):\n\tif row.count( 'X' ) + row.count( 'T' )  == size:\n\t\treturn 'X won'\n\tif row.count( 'O' ) + row.count( 'T' )  == size:\n\t\treturn 'O won'\n\treturn 'Draw'\n \t\n \nnumCases = input()\nfor case in range( 1, numCases + 1 ):\n\tsize = 4\n\tboard = {}\n\tfull = True\n\twinner = 'Draw'\n \t\n\tfor row in range( 0, size ):\n\t\trow_raw = raw_input()\n\t\tboard[row] = row_raw\n\t\tif '.' in row_raw:\n\t\t\tfull = False\n \n\t\tif winner == 'Draw':\n\t\t\twinner = get_winner( row_raw )\n \t\n\traw_input()\n \n\tif winner == 'Draw':\n\t\tfor col in range( 0, size ):\n\t\t\trow_new = ''\n\t\t\tfor row in range( 0, size ):\n\t\t\t\trow_new += board[row][col]\n\t\t\twinner = get_winner( row_new )\n\t\t\tif winner != 'Draw':\n\t\t\t\tbreak\n \n\tif winner == 'Draw':\n\t\trow_new = ''\n\t\tfor z in range( 0, size ):\n\t\t\trow_new += board[z][z]\n\t\twinner = get_winner( row_new )\n\t\tif winner == 'Draw':\n\t\t\trow_new = ''\n\t\t\tfor z in range( 0, size ):\n\t\t\t\trow_new += board[z][size - z - 1]\n\t\t\twinner = get_winner( row_new )\n \t\t\n \n\tif winner == 'Draw' and not full:\n\t\twinner = 'Game has not completed'\n \n\tprint('Case #' + str( case ) + ': ' + winner)\n"}
{"author": "idahojacket", "index": 22, "filename": "2013_2270488_2449486.py", "code": "import sys\n \nnumCases = input()\nfor case in range( 1, numCases + 1 ):\n\tsizeX, sizeY = raw_input().split()\n\tsizeX = int(sizeX)\n\tsizeY = int(sizeY)\n\tboard = {}\n\trowMax = {}\n\tcolMax = {}\n \t\n\tfor row in range( 0, sizeX ):\n\t\trow_raw = raw_input()\n\t\tboard[ row ] = {}\n\t\tcol = 0\n\t\tfor value in row_raw.split():\n\t\t\tboard[ row ][ col ] = int(value)\n\t\t\tcolMax[ col ] = max( colMax.get(col, 0 ), board[row][col] )\n\t\t\tcol += 1\n \n\t\trowMax[row] = max( board[row].values() )\n \t\n\tpossible = True\n\tresult = 'YES'\n\tfor row in range( 0, sizeX ):\n\t\tfor col in range( 0, sizeY ):\n\t\t\tif board[ row ][ col ] != colMax[ col ] and board[ row ][ col ] != rowMax[ row ]:\n\t\t\t\tpossible = False\n\t\t\t\tbreak\n\t\tif not possible:\n\t\t\tresult = 'NO'\n\t\t\tbreak\n \n\tprint('Case #' + str( case ) + ': ' + result )\n"}
{"author": "idahojacket", "index": 22, "filename": "2012_1460488_1483485.py", "code": "import sys\n \ntranslation = { 'a' : 'y', 'b' : 'h', 'c' : 'e', 'd' : 's', 'e' : 'o', 'f' : 'c', 'g' : 'v', 'h' : 'x',\n'i' : 'd', 'j' : 'u', 'k' : 'i', 'l' : 'g', 'm' : 'l', 'n' : 'b', 'o' : 'k', 'p' : 'r', 'q' : 'z', 'r' : 't',\n's' : 'n', 't' : 'w', 'u' : 'j', 'v' : 'p', 'w' : 'f', 'x' : 'm', 'y' : 'a', 'z' : 'q', ' ' : ' ' }\n \n#words = 'ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv'\n \nnumCases = input()\nfor case in range( 1, numCases + 1 ):\n\twords = raw_input()\n\toutput = ''\n \t\n\tfor letter in words:\n\t\toutput = output + translation[letter]\n \n\tprint('Case #' + str( case ) + ': ' + output)\n"}
{"author": "idahojacket", "index": 22, "filename": "2013_2270488_2463486.py", "code": "import sys\n \ndef is_sym( number ):\n\tnum_str = str( number )\n\tnum_len = len( num_str )\n\thalf_len = int( num_len / 2 )\n\tend = num_str[-half_len:]\n\trev_end = end[::-1]\n\tstart = num_str[:half_len]\n\tequal = rev_end == start \n\treturn equal\n \nf = open( 'palindromes.out' )\n \nnumbers = [ int(x) for x in f.read().split() ]\n \nnumCases = input()\nfor case in range( 1, numCases + 1 ):\n\tmin, max = [ int(x) for x in raw_input().split() ]\n\tcount = 0\n\tfor number in numbers:\n\t\tif min <= number and max >= number:\n\t\t\tcount += 1\n \n\tprint('Case #' + str( case ) + ': ' + str( count ))\n"}
{"author": "idahojacket", "index": 22, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \nnumCases = input()\nfor case in range( 1, numCases + 1 ):\n    row1 = input()\ngrid1 = []\nfor i in range( 0, 4 ):\n    grid1.append( raw_input().split() )\n \ncards = grid1[ row1 - 1 ]\n \nrow2 = input()\ngrid2 = []\nfor i in range( 0, 4 ):\n    grid2.append( raw_input().split() )\n \nbad = True\n       \ncards2 = grid2[ row2 - 1 ]\n \nnumPossibleAnswers = 0\nfor card in cards:\n    for card2 in cards2:\n        if ( card == card2 ):\n            if numPossibleAnswers == 0:\n                output = card\n                numPossibleAnswers += 1\n                break\n \nif numPossibleAnswers == 0:\n    output = \"Volunteer cheated!\"\nelif numPossibleAnswers > 1:\n    output = \"Bad magician!\"\n \nprint ('Case #' + str( case ) + ': ' + str( output ))\n"}
{"author": "idolivneh", "index": 23, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\nimport time\nimport itertools #use combinations!\n \ndef iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tyield line_index, line.strip().split(' ')\n \ndef iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 1\n\t\tcase = []\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not line_index % n:\n\t\t\t\tyield case_counter, case\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n \ndef iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 0\n\t\tnew_case = True\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tif new_case:\n\t\t\t\tnew_case = False\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n\t\t\t\tassert len(line.strip().split(' ')) == 1\n\t\t\t\tlines_left = int(line.strip())\n\t\t\t\tif not lines_left:\n\t\t\t\t\tnew_case = True\n\t\t\t\t\tyield case_counter, case\n\t\t\t\tcontinue\n\t\t\tif lines_left:\n\t\t\t\tlines_left -= 1\n\t\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not lines_left:\n\t\t\t\tnew_case = True\n\t\t\t\tyield case_counter, case\n \t\t\t\ndef part_of_list_to_int(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(int(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_int(array):\n\treturn part_of_list_to_int(array, [True] * len(array))\n \ndef part_of_list_to_float(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(float(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_float(array):\n\treturn part_of_list_to_float(array, [True] * len(array))\n \ndef get_max_array_on_index(array, index):\n\telem_len = len(array[0])\n\tassert index < elem_len\n\tfor elem in array:\n\t\tassert elem_len == len(elem)\n\tmax_sub = array[0][index]\n\tmax_elem = array[0]\n\tfor elem in array:\n\t\tif elem[index] > max_sub:\n\t\t\tmax_sub = elem[index]\n\t\t\tmax_elem = elem\n\treturn max_elem\n \ndef list_index_in_sorted_with_position(a_list, value, pos):\n\tlist_len = len(a_list)\n\tif list_len == 1:\n\t\tif a_list[0] == value:\n\t\t\treturn pos\n\t\treturn -1\n\tif a_list[list_len/2] > value:\n\t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n\telse:\n\t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n \t\ndef list_index_in_sorted_list(a_list, value):\n\treturn list_index_in_sorted_with_position(a_list, value, 0)\n \ndef copy_list(list):\n\tres = []\n\tfor elem in list:\n\t\tres.append(elem)\n\treturn res\t\n \n############################################################\n#### add solution here \t\t\t\t\t\t\t\t\t####\n#### don't forget to change data from str to int/float  ####\n############################################################\n \ndef solve(C, F, X):\n\tfarms_num = 0\n\twaiting_for_farms = 0\n\tproduction_rate = 2\n\tfinal_run_time = X / production_rate\n\tresult = final_run_time + waiting_for_farms\n \t\n\tprint (\"%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f\" % (farms_num,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tproduction_rate,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfinal_run_time,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twaiting_for_farms,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult))\n \t\t\n \n \t\n\twhile True:\n\t\tfarms_num += 1\n\t\twaiting_for_farms += C / production_rate\n\t\tproduction_rate += F\n\t\tfinal_run_time = X / production_rate\n\t\tnew_result = final_run_time + waiting_for_farms\n\t\tprint (\"%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f\" % (farms_num,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tproduction_rate,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfinal_run_time,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twaiting_for_farms,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew_result))\n\t\tif new_result > result:\n\t\t\treturn result\n\t\tresult = new_result\n \t\ndef calc_result(case):\n\tresult = None\n \t\n\tC = float(case[0])\n\tF = float(case[1])\n\tX = float(case[2])\n\tprint (C, F, X)\n \t\n\tresult = solve(C, F, X)\n\tprint (result)\n \t\n\treturn result\n \ndef main(filepath):\n\tstart_time = time.time()\n\twith file('output.txt', 'wb') as f_out:\n \t\t\n\t\t######################################\n\t\t#### select input iteration type: ####\n\t\t####\t- iterate_cases_1lpc\t  ####\n\t\t####\t- iterate_cases_nlpc +n\t  ####\n\t\t####\t- iterate_cases_glpc\t  ####\n\t\t######################################\n\t\tfor case_index, case in iterate_cases_1lpc(filepath):\n \t\t\t\n\t\t\tprint (\"case #%d: time:%.02f\" % (case_index, time.time() - start_time))\n\t\t\tresult = calc_result(case)\n \t\t\t\n\t\t\t#######################\n\t\t\t#### format output ####\n\t\t\t#######################\n\t\t\tf_out.write(\"Case #%d: %.07f\\n\" % (case_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])\n"}
{"author": "idolivneh", "index": 23, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\nimport time\nimport itertools #use combinations!\nimport random\n \ndef iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tyield line_index, line.strip().split(' ')\n \ndef iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 1\n\t\tcase = []\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not line_index % n:\n\t\t\t\tyield case_counter, case\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n \ndef iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 0\n\t\tnew_case = True\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tif new_case:\n\t\t\t\tnew_case = False\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n\t\t\t\tassert len(line.strip().split(' ')) == 1\n\t\t\t\tlines_left = int(line.strip())\n\t\t\t\tif not lines_left:\n\t\t\t\t\tnew_case = True\n\t\t\t\t\tyield case_counter, case\n\t\t\t\tcontinue\n\t\t\tif lines_left:\n\t\t\t\tlines_left -= 1\n\t\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not lines_left:\n\t\t\t\tnew_case = True\n\t\t\t\tyield case_counter, case\n \t\t\t\ndef part_of_list_to_int(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(int(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_int(array):\n\treturn part_of_list_to_int(array, [True] * len(array))\n \ndef part_of_list_to_float(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(float(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_float(array):\n\treturn part_of_list_to_float(array, [True] * len(array))\n \ndef get_max_array_on_index(array, index):\n\telem_len = len(array[0])\n\tassert index < elem_len\n\tfor elem in array:\n\t\tassert elem_len == len(elem)\n\tmax_sub = array[0][index]\n\tmax_elem = array[0]\n\tfor elem in array:\n\t\tif elem[index] > max_sub:\n\t\t\tmax_sub = elem[index]\n\t\t\tmax_elem = elem\n\treturn max_elem\n \ndef list_index_in_sorted_with_position(a_list, value, pos):\n\tlist_len = len(a_list)\n\tif list_len == 1:\n\t\tif a_list[0] == value:\n\t\t\treturn pos\n\t\treturn -1\n\tif a_list[list_len/2] > value:\n\t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n\telse:\n\t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n \t\ndef list_index_in_sorted_list(a_list, value):\n\treturn list_index_in_sorted_with_position(a_list, value, 0)\n \ndef copy_list(list):\n\tres = []\n\tfor elem in list:\n\t\tres.append(elem)\n\treturn res\t\n \n############################################################\n#### add solution here \t\t\t\t\t\t\t\t\t####\n#### don't forget to change data from str to int/float  ####\n############################################################\n \ndef conj_mat(a):\n\tR = len(a)\n\tC = len(a[0])\n\tres = [['.' for _ in xrange(R)] for __ in xrange(C)]\n\tfor i in xrange(R):\n\t\tfor j in xrange(C):\n\t\t\tres[j][i] = a[i][j]\n\treturn res\n \ndef one_line_builder(R, C, M):\n\tres = []\n\tres.extend(['*'] * M)\n\tres.extend(['.'] * (C - M))\n\tres[-1] = 'c'\n\treturn [res]\n \t\ndef two_line_builder(R, C, M):\n\tline = []\n\tline.extend(['*'] * (M / 2))\n\tline.extend(['.'] * (C - M / 2))\n\tres = [line, copy_list(line)]\n\tres[1][-1] = 'c'\n\tif M%2 == 1:\n\t\tres[0][-1] = '*'\n\treturn res\n \t\ndef three_line_builder(R, C, M):\n\tres = [['.' for _ in xrange(C)] for __ in xrange(R)]\n\tres[-1][-1] = 'c'\n\tm = min([M, R * C - 9])\n\tstop_flag = False\n\tfor j in xrange(C):\n\t\tif stop_flag:\n\t\t\tbreak\n\t\tfor i in xrange(R):\n\t\t\tif m == 0:\n\t\t\t\tstop_flag = True\n\t\t\t\tbreak\n\t\t\tres[i][j] = '*'\n\t\t\tm -= 1\n\tprint(i,j)\n\tif i == 2:\n\t\tres[1][j-1] = '.'\n\t\tif j == C - 3:\n\t\t\tres[0][j] = '*'\n\t\telse:\n\t\t\tres[0][-1] = '*'\n \t\n\tif M <= R * C - 9:\n\t\treturn res\n\telse:\n\t\tm = M - (R * C - 9)\n\t\tassert m not in [2, 4, 6, 7, 9]\n\t\tassert m > 0\n\t\tassert m < 10\n \t\t\n\t\tres[-3][-3] = '*'\n\t\tm -= 1\n\t\tif m == 0: return res\n\t\tres[-2][-3] = '*'\n\t\tres[-1][-3] = '*'\n\t\tm -= 2\n\t\tif m == 0: return res\n\t\tres[-3][-2] = '*'\n\t\tres[-3][-1] = '*'\n\t\tm -= 2\n\t\tif m == 0: return res\n\t\tres[-2][-2] = '*'\n\t\tres[-2][-1] = '*'\n\t\tres[-1][-2] = '*'\n\t\tm -= 3\n\t\tif m == 0: return res\n\t\tassert False\n \t\n \t\n \t\ndef over_three_line_builder(R, C, M):\n\tif M <= (R - 3) * C:\n\t\tres = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\n\t\tflag = False\n\t\tif (M % C) != (C - 1):\n\t\t\tline = ['*' for _ in xrange(M % C)]\n\t\t\tline.extend(['.' for _ in xrange(C - (M % C))])\n\t\telse:\n\t\t\tline = ['*' for _ in xrange((M % C) - 1)]\n\t\t\tline.extend(['.' for _ in xrange((C - (M % C)) + 1)])\n\t\t\tflag = True\n\t\tres.append(line)\n\t\tindex = len(res)\n\t\tres.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\n\t\tif flag:\n\t\t\tres[index][0] = '*'\n\t\tres[-1][-1] = 'c'\n\t\tassert len(res) == R\n\t\tassert len(res[0]) == C\n\t\treturn res\n\telse:\n\t\tres = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\n\t\tM -= (R - 3) * C\n\t\ttmp = three_line_builder(3, C, M)\n\t\tif len(tmp) != 3: # error msg\n\t\t\treturn tmp\n\t\tres.extend(tmp)\n\t\treturn res\n \t\ndef solve(R, C, M):\n\tres = None\n \t\n\tif M == R * C:\n\t\treturn 'Impossible'\n\tif R >= 3 and C >= 3:\n\t\tif R*C - M in [7, 5, 3, 2]:\n\t\t\treturn 'Impossible'\n\t\treturn over_three_line_builder(R, C, M)\n \t\t\n\telif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\n\t\tif (R*C - M) % 2 == 1:\n\t\t\tif M < R*C - 1:\n\t\t\t\treturn 'Impossible'\n\t\tif M + 2 == R * C:\n\t\t\treturn 'Impossible'\n\t\telse:\n\t\t\tif R == 2:\n\t\t\t\treturn two_line_builder(R, C, M)\n\t\t\telse:\n\t\t\t\ttmp = two_line_builder(C, R, M)\n\t\t\t\treturn conj_mat(tmp)\n \t\n\telse:\t\t\t\t\t#which means one of them is 1\n\t\tif R == 1:\n\t\t\treturn one_line_builder(R, C, M)\n\t\telse:\n\t\t\ttmp = one_line_builder(C, R, M)\n\t\t\treturn conj_mat(tmp)\n \t\t\n\treturn res\n \ndef mat_to_str(a):\n\tif a in ['Impossible', 'Not Implemented']:\n\t\treturn a\n\tstr_out = ''\n\tfor row in a:\n\t\tfor elem in row:\n\t\t\tstr_out += elem\n\t\tstr_out += '\\n'\n\treturn str_out[:-1]\n \t\ndef calc_result(case):\n\tresult = None\n \t\n\tR = int(case[0])\n\tC = int(case[1])\n\tM = int(case[2])\n\tprint(R, C, M)\n \t\n\tresult = solve(R, C, M)\n \t\n\tstr_out = mat_to_str(result)\n\tm = str_out.count('*')\n\tassert (m==0 or m==M)\n\tprint(str_out)\n \t\n\treturn '\\n%s' % str_out\n \ndef main(filepath):\n\tstart_time = time.time()\n\twith file('output.txt', 'wb') as f_out:\n \t\t\n\t\t######################################\n\t\t#### select input iteration type: ####\n\t\t####\t- iterate_cases_1lpc\t  ####\n\t\t####\t- iterate_cases_nlpc +n\t  ####\n\t\t####\t- iterate_cases_glpc\t  ####\n\t\t######################################\n\t\tfor case_index, case in iterate_cases_1lpc(filepath):\n \t\t\t\n\t\t\tprint(\"case #%d: time:%.02f\" % (case_index, time.time() - start_time))\n\t\t\tresult = calc_result(case)\n \t\t\t\n\t\t\t#######################\n\t\t\t#### format output ####\n\t\t\t#######################\n\t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])\n"}
{"author": "idolivneh", "index": 23, "filename": "2012_1460488_1595491.py", "code": "import sys\n \nclass Triplet(object):\n\tdef __init__(self, i, j, k):\n\t\tself.i = i\n\t\tself.j = j\n\t\tself.k = k\n\t\tself.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))\n\t\tself.valid = self.max_diff <= 2\n\t\tself.surprise = self.max_diff == 2\n \t\n\tdef get_tuple(self):\n\t\treturn (self.i, self.j, self.k)\n \t\n\tdef get_redundancies(self):\n\t\treturn [(self.i, self.j, self.k),\n\t\t\t\t(self.i, self.k, self.j),\n\t\t\t\t(self.j, self.i, self.k),\n\t\t\t\t(self.j, self.k, self.i),\n\t\t\t\t(self.k, self.i, self.j),\n\t\t\t\t(self.k, self.j, self.i)]\n \nclass Googler(object):\n\tdef __init__(self, total_points):\n\t\tself.total_points = total_points\n\t\tself.regular_triplets = []\n\t\tself.surprise_triplets = []\n \t\t\n\t\tfor i in xrange(0, 11):\n\t\t\tif i > total_points:\n\t\t\t\tbreak\n\t\t\tfor j in xrange(i, 11):\n\t\t\t\tif i + j > total_points:\n\t\t\t\t\tbreak\n\t\t\t\tk = total_points - i - j\n\t\t\t\tif k > 10:\n\t\t\t\t\tbreak\n\t\t\t\ttriplet = Triplet(i, j, k)\n\t\t\t\tself.add(triplet)\n \t\t\n\t\tself.can_surprise = len(self.surprise_triplets) > 0\n\t\tself.actual_triplet = None\n\t\tself.best_result = -1\n \t\t\n\tdef add(self, triplet):\n\t\tif not triplet.valid:\n\t\t\treturn\n\t\tif triplet.surprise:\n\t\t\tself.add_uniquely(triplet, is_surprise=True)\n\t\telse:\n\t\t\tself.add_uniquely(triplet, is_surprise=False)\n \t\t\t\n\tdef add_uniquely(self, triplet, is_surprise):\n\t\tif is_surprise:\n\t\t\tinput_list = self.surprise_triplets\n\t\telse:\n\t\t\tinput_list = self.regular_triplets\n\t\tfor triplet_redundancy in triplet.get_redundancies():\n\t\t\tif triplet_redundancy in input_list:\n\t\t\t\treturn\n\t\tinput_list.append(triplet.get_tuple())\n \t\n\tdef __str__(self):\n\t\treturn \"regular: %s\\nsurprise: %s\" % (self.regular_triplets,\n\t\t\t\t\t\t\t\t\t\t\t  self.surprise_triplets)\n \t\n\tdef set_googler(self, is_surprise=False):\n\t\tif not is_surprise:\n\t\t\tself.actual_triplet = self.regular_triplets[0]\n\t\telse:\n\t\t\tself.actual_triplet = self.surprise_triplets[0]\n\t\tself.calc_best_result()\n \t\n\tdef calc_best_result(self):\n\t\tself.best_result = max(self.actual_triplet)\n \n \t\t\nclass Contest(object):\n\tdef __init__(self, num_of_googlers, results):\n\t\tself.num = num_of_googlers\n\t\tself.googlers = []\n\t\tfor i in xrange(self.num):\n\t\t\tself.googlers.append(Googler(results[i]))\n \t\n\tdef calc(self, num_of_surprises, p):\n\t\tmax_googlers_over_p = 0\n\t\tfor surprise_perm in self.get_permutations(num_of_surprises):\n\t\t\tif not self.validate_permutation(surprise_perm):\n\t\t\t\tcontinue\n\t\t\tcount = 0\n\t\t\tfor index, googler in enumerate(self.googlers):\n\t\t\t\tgoogler.set_googler(index in surprise_perm)\n\t\t\t\tif googler.best_result >= p:\n\t\t\t\t\tcount += 1\n\t\t\tif count >= max_googlers_over_p:\n\t\t\t\tmax_googlers_over_p = count\n\t\treturn max_googlers_over_p\n \t\n\tdef get_permutations(self, num_of_surprises):\n\t\tresults = get_perms(0, self.num, num_of_surprises)\n\t\tif not results:\n\t\t\treturn [[]]\n\t\treturn results\n \t\n\tdef validate_permutation(self, perm):\n\t\tfor googler_index in perm:\n\t\t\tif not self.googlers[googler_index].can_surprise:\n\t\t\t\treturn False\n\t\treturn True\n \ndef get_perms(start_index, finish_index, amount):\n\tif amount == 0:\n\t\treturn []\n\tresult_list = []\n\tfor i in xrange(start_index, finish_index):\n\t\tif amount == 1:\n\t\t\tresult_list.append([i])\n\t\t\tcontinue\n\t\tfor result in get_perms(i + 1, finish_index, amount - 1):\n\t\t\tnew_result = [i]\n\t\t\tnew_result.extend(result)\n\t\t\tresult_list.append(new_result)\n\treturn result_list\n \t\t\ndef main(filepath):\n\twith file('dancing_output.txt', 'wb') as f_out:\n\t\twith file(filepath, 'rb') as f_in:\n\t\t\tfor line_index, line in enumerate(f_in):\n\t\t\t\tif line_index == 0: #T\n\t\t\t\t\tcontinue\n\t\t\t\tinput_list = line.strip().split(' ')\n\t\t\t\tnum_of_googlers = int(input_list[0])\n\t\t\t\tnum_of_surprises = int(input_list[1])\n\t\t\t\tp = int(input_list[2])\n\t\t\t\tresults = []\n\t\t\t\tfor res in input_list[3:]:\n\t\t\t\t\tresults.append(int(res))\n\t\t\t\tcontest = Contest(num_of_googlers, results)\n\t\t\t\tresult = contest.calc(num_of_surprises, p)\n \t\t\t\t\n\t\t\t\tprint\n\t\t\t\tprint (line.strip())\n\t\t\t\tprint (result)\n \t\t\t\t\n\t\t\t\tf_out.write(\"Case #%d: %d\\n\" % (line_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])"}
{"author": "idolivneh", "index": 23, "filename": "2013_2270488_2453486.py", "code": "import sys\nimport time\nimport itertools #use combinations!\n \ndef iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tyield line_index, line.strip().split(' ')\n \ndef iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 1\n\t\tcase = []\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not line_index % n:\n\t\t\t\tyield case_counter, case\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n \ndef iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 0\n\t\tnew_case = True\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tif new_case:\n\t\t\t\tnew_case = False\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n\t\t\t\tassert len(line.strip().split(' ')) == 1\n\t\t\t\tlines_left = int(line.strip())\n\t\t\t\tif not lines_left:\n\t\t\t\t\tnew_case = True\n\t\t\t\t\tyield case_counter, case\n\t\t\t\tcontinue\n\t\t\tif lines_left:\n\t\t\t\tlines_left -= 1\n\t\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not lines_left:\n\t\t\t\tnew_case = True\n\t\t\t\tyield case_counter, case\n \t\t\t\ndef part_of_list_to_int(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(int(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_int(array):\n\treturn part_of_list_to_int(array, [True] * len(array))\n \ndef part_of_list_to_float(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(float(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_float(array):\n\treturn part_of_list_to_float(array, [True] * len(array))\n \ndef get_max_array_on_index(array, index):\n\telem_len = len(array[0])\n\tassert index < elem_len\n\tfor elem in array:\n\t\tassert elem_len == len(elem)\n\tmax_sub = array[0][index]\n\tmax_elem = array[0]\n\tfor elem in array:\n\t\tif elem[index] > max_sub:\n\t\t\tmax_sub = elem[index]\n\t\t\tmax_elem = elem\n\treturn max_elem\n \ndef list_index_in_sorted_with_position(a_list, value, pos):\n\tlist_len = len(a_list)\n\tif list_len == 1:\n\t\tif a_list[0] == value:\n\t\t\treturn pos\n\t\treturn -1\n\tif a_list[list_len/2] > value:\n\t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n\telse:\n\t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n \t\ndef list_index_in_sorted_list(a_list, value):\n\treturn list_index_in_sorted_with_position(a_list, value, 0)\n \t\n############################################################\n#### add solution here \t\t\t\t\t\t\t\t\t####\n#### don't forget to change data from str to int/float  ####\n############################################################\n \ndef check_row(row):\n\tif row.count('X') == 4:\n\t\treturn 'X'\n\tif row.count('O') == 4:\n\t\treturn 'O'\n\tif row.count('X') == 3 and row.count('T') == 1:\n\t\treturn 'X'\n\tif row.count('O') == 3 and row.count('T') == 1:\n\t\treturn 'O'\n\tif row.count('.') > 0:\n\t\treturn '.'\n\treturn 'F'\n \t\t\n \ndef calc_result(case):\n\tcase = case[:-1]\n\tprint(\"\\t%s\" % case)\n \t\n\trows = []\n\tfor row in case:\n\t\t#print(\"\\trow: '%s'\" % row[0])\n\t\trows.append(row[0])\n \t\n\tfor i in xrange(4):\n\t\tcolumn = \"\"\n\t\tfor j in xrange(4):\n\t\t\tcolumn += case[j][0][i]\n\t\t#print(\"\\trow: '%s'\" % column)\n\t\trows.append(column)\n \t\n\tdiag1 = \"\"\n\tdiag2 = \"\"\n\tfor i in xrange(4):\n\t\tdiag1 += case[i][0][i]\n\t\tdiag2 += case[3-i][0][i]\n\t#print(\"\\trow: '%s'\" % diag1)\n\t#print(\"\\trow: '%s'\" % diag2)\n\trows.append(diag1)\n\trows.append(diag2)\n \t\n\tres = []\n\tfor row in rows:\n\t\tres.append(check_row(row))\n \t\n\tif res.count('X'):\n\t\tif res.count('O'):\n\t\t\traise IOError('both X and O won')\n\t\telse:\n\t\t\tresult = \"X won\"\n\telse:\n\t\tif res.count('O'):\n\t\t\tresult = \"O won\"\n\t\telse:\n\t\t\tif res.count('.'):\n\t\t\t\tresult = \"Game has not completed\"\n\t\t\telse:\n\t\t\t\tresult = \"Draw\"\n \t\n\tprint(\"\\t%s\" % res)\n\tprint(\"\\t%s\" % result)\n \t\n\treturn result\n \ndef main(filepath):\n\tstart_time = time.time()\n\twith file('output.txt', 'wb') as f_out:\n \t\t\n\t\t######################################\n\t\t#### select input iteration type: ####\n\t\t####\t- iterate_cases_1lpc\t  ####\n\t\t####\t- iterate_cases_nlpc +n\t  ####\n\t\t####\t- iterate_cases_glpc\t  ####\n\t\t######################################\n\t\tfor case_index, case in iterate_cases_nlpc(filepath, 5):\n \t\t\t\n\t\t\tprint(\"case #%d: time:%.02f\" % (case_index, time.time() - start_time))\n\t\t\tresult = calc_result(case)\n \t\t\t\n\t\t\t#######################\n\t\t\t#### format output ####\n\t\t\t#######################\n\t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])\n"}
{"author": "idolivneh", "index": 23, "filename": "2013_2270488_2449486.py", "code": "import sys\nimport time\nimport itertools #use combinations!\n \ndef iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tyield line_index, line.strip().split(' ')\n \ndef iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 1\n\t\tcase = []\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not line_index % n:\n\t\t\t\tyield case_counter, case\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n \ndef iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 0\n\t\tnew_case = True\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tif new_case:\n\t\t\t\tnew_case = False\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n\t\t\t\tassert len(line.strip().split(' ')) == 2\n\t\t\t\tN = int(line.strip().split(' ')[0])\n\t\t\t\tM = int(line.strip().split(' ')[1])\n\t\t\t\tlines_left = N\n\t\t\t\tcase.append(N)\n\t\t\t\tcase.append(M)\n\t\t\t\tif not lines_left:\n\t\t\t\t\tnew_case = True\n\t\t\t\t\tyield case_counter, case\n\t\t\t\tcontinue\n\t\t\tif lines_left:\n\t\t\t\tlines_left -= 1\n\t\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not lines_left:\n\t\t\t\tnew_case = True\n\t\t\t\tyield case_counter, case\n \t\t\t\ndef part_of_list_to_int(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(int(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_int(array):\n\treturn part_of_list_to_int(array, [True] * len(array))\n \ndef part_of_list_to_float(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(float(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_float(array):\n\treturn part_of_list_to_float(array, [True] * len(array))\n \ndef get_max_array_on_index(array, index):\n\telem_len = len(array[0])\n\tassert index < elem_len\n\tfor elem in array:\n\t\tassert elem_len == len(elem)\n\tmax_sub = array[0][index]\n\tmax_elem = array[0]\n\tfor elem in array:\n\t\tif elem[index] > max_sub:\n\t\t\tmax_sub = elem[index]\n\t\t\tmax_elem = elem\n\treturn max_elem\n \ndef list_index_in_sorted_with_position(a_list, value, pos):\n\tlist_len = len(a_list)\n\tif list_len == 1:\n\t\tif a_list[0] == value:\n\t\t\treturn pos\n\t\treturn -1\n\tif a_list[list_len/2] > value:\n\t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n\telse:\n\t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n \t\ndef list_index_in_sorted_list(a_list, value):\n\treturn list_index_in_sorted_with_position(a_list, value, 0)\n \t\n############################################################\n#### add solution here \t\t\t\t\t\t\t\t\t####\n#### don't forget to change data from str to int/float  ####\n############################################################\ndef test_row(row, value):\n\tfor elem in row:\n\t\tif elem > value:\n\t\t\treturn False\n\treturn True\n \ndef calc_result(case):\n\t#print(\"\\t%s\" % case[2:])\n\tN = case[0]\n\tM = case[1]\n\trows = []\n\tfor str_row in case[2:]:\n\t\trows.append(list_to_int(str_row))\n\t#print(\"\\trows: %s\" % rows)\n\tcolumns = []\n\tfor i in xrange(M):\n\t\tcolumn = []\n\t\tfor j in xrange(N):\n\t\t\tcolumn.append(rows[j][i])\n\t\tcolumns.append(column)\n\t#print(\"\\tcolumns: %s\" % columns)\n \t\n\tfor i in xrange(N):\n\t\tfor j in xrange(M):\n\t\t\tif not (test_row(rows[i], rows[i][j]) or test_row(columns[j], rows[i][j])):\n\t\t\t\tprint(\"i,j: %d,%d\" % (i, j))\n\t\t\t\tresult = \"NO\"\n\t\t\t\tprint(\"\\t%s\" % result)\n\t\t\t\treturn result\n \t\n\tresult = \"YES\"\n\tprint(\"\\t%s\" % result)\n\treturn result\n \ndef main(filepath):\n\tstart_time = time.time()\n\twith file('output.txt', 'wb') as f_out:\n \t\t\n\t\t######################################\n\t\t#### select input iteration type: ####\n\t\t####\t- iterate_cases_1lpc\t  ####\n\t\t####\t- iterate_cases_nlpc +n\t  ####\n\t\t####\t- iterate_cases_glpc\t  ####\n\t\t######################################\n\t\tfor case_index, case in iterate_cases_glpc(filepath):\n \t\t\t\n\t\t\tprint(\"case #%d: time:%.02f\" % (case_index, time.time() - start_time))\n\t\t\tresult = calc_result(case)\n \t\t\t\n\t\t\t#######################\n\t\t\t#### format output ####\n\t\t\t#######################\n\t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])\n"}
{"author": "idolivneh", "index": 23, "filename": "2012_1460488_1483485.py", "code": "import sys\n \nclass Translation(object):\n\tdef __init__(self):\n\t\tself.letters = {}\n\t\tself.letters['z'] = 'q'\t# from text under 'Problem'\n\t\tself.letters['q'] = 'z'\n\t\tself.letters[' '] = ' '\\n\t\tself.count = 0\\n \t\\n\tdef update_letter(self, source, image):\\n\t\tif source in self.letters.keys():\\n\t\t\tif self.letters[source] != image:\\n\t\t\t\traise Exception('old: %s-->%s. new: %s-->%s' % (source, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself.letters[source],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timage))\n\t\telse:\n\t\t\tself.letters[source] = image\n \t\n\tdef update_word(self, source, image):\n\t\tfor char_index, _ in enumerate(source):\n\t\t\tself.update_letter(source[char_index], image[char_index])\n \t\n\tdef update_line(self, source, image):\n\t\tfor word_index, _ in enumerate(source.strip().split(' ')):\n\t\t\tself.update_word(source.strip().split(' ')[word_index],\n\t\t\t\t\t\t\t image.strip().split(' ')[word_index])\n \t\n\tdef print_dict(self):\n\t\tfor i in xrange(ord('a'), ord('z') + 1):\n\t\t\tprint (\"%s-->%s\" % (chr(i), self.letters.get(chr(i), 'None')))\n \t\n\tdef translate_line(self, line):\n\t\tout = \"\"\n\t\tfor char in line:\n\t\t\tout += self.letters[char]\n\t\treturn out\n \t\t\ndef main(filepath):\n\ttranslation = Translation()\n\tbefore = []\n\tafter = []\n\twith file('tounges_before.txt', 'rb') as f_before:\n\t\tfor line in f_before:\n\t\t\tbefore.append(line)\n \t\t\n\twith file('tounges_after.txt', 'rb') as f_after:\n\t\tfor line in f_after:\n\t\t\tafter.append(line)\n \t\n\tif len(before) != len(after):\n\t\traise Exception('the before and after files are not of the same size')\n \t\n\tfor line_index in xrange(len(before)):\n\t\ttranslation.update_line(before[line_index], after[line_index])\n \t\n\ttranslation.print_dict()\n \t\n\twith file('tounges_output.txt', 'wb') as f_out:\n\t\twith file(filepath, 'rb') as f_in:\n\t\t\tfor line_index, line in enumerate(f_in):\n\t\t\t\tif line_index == 0: #T\n\t\t\t\t\tcontinue\n\t\t\t\tresult = translation.translate_line(line.strip())\n\t\t\t\tprint\n\t\t\t\tprint (line.strip())\n\t\t\t\tprint (result)\n\t\t\t\tf_out.write(\"Case #%d: %s\\n\" % (line_index, result))\n \t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])"}
{"author": "idolivneh", "index": 23, "filename": "2013_2270488_2463486.py", "code": "import sys\nimport time\nimport itertools #use combinations!\nimport math\n \ndef iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tyield line_index, line.strip().split(' ')\n \ndef iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 1\n\t\tcase = []\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not line_index % n:\n\t\t\t\tyield case_counter, case\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n \ndef iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 0\n\t\tnew_case = True\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tif new_case:\n\t\t\t\tnew_case = False\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n\t\t\t\tassert len(line.strip().split(' ')) == 1\n\t\t\t\tlines_left = int(line.strip())\n\t\t\t\tif not lines_left:\n\t\t\t\t\tnew_case = True\n\t\t\t\t\tyield case_counter, case\n\t\t\t\tcontinue\n\t\t\tif lines_left:\n\t\t\t\tlines_left -= 1\n\t\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not lines_left:\n\t\t\t\tnew_case = True\n\t\t\t\tyield case_counter, case\n \t\t\t\ndef part_of_list_to_int(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(int(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_int(array):\n\treturn part_of_list_to_int(array, [True] * len(array))\n \ndef part_of_list_to_float(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(float(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_float(array):\n\treturn part_of_list_to_float(array, [True] * len(array))\n \ndef get_max_array_on_index(array, index):\n\telem_len = len(array[0])\n\tassert index < elem_len\n\tfor elem in array:\n\t\tassert elem_len == len(elem)\n\tmax_sub = array[0][index]\n\tmax_elem = array[0]\n\tfor elem in array:\n\t\tif elem[index] > max_sub:\n\t\t\tmax_sub = elem[index]\n\t\t\tmax_elem = elem\n\treturn max_elem\n \ndef list_index_in_sorted_with_position(a_list, value, pos):\n\tlist_len = len(a_list)\n\tif list_len == 1:\n\t\tif a_list[0] == value:\n\t\t\treturn pos\n\t\treturn -1\n\tif a_list[list_len/2] > value:\n\t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n\telse:\n\t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n \t\ndef list_index_in_sorted_list(a_list, value):\n\treturn list_index_in_sorted_with_position(a_list, value, 0)\n \t\n############################################################\n#### add solution here \t\t\t\t\t\t\t\t\t####\n#### don't forget to change data from str to int/float  ####\n############################################################\ndef check_palindrome(value):\n\tval_str = str(value)\n\tlength = len(val_str)\n\tfor i in xrange(length):\n\t\tif val_str[i] != val_str[length - 1 - i]:\n\t\t\treturn False\n\treturn True\n\t#print(\"\\t\\t%d: '%s'\" % (value, val_str))\n \ndef calc_result(case):\n\tA = int(case[0])\n\tB = int(case[1])\n \t\n\tA_sqrt = int(math.ceil(math.sqrt(A)))\n\tB_sqrt = int(math.floor(math.sqrt(B)))\n \t\n\tprint(\"\\tinterval: %s\" % [A, B])\n\tprint(\"\\tsqrt_int: %s\" % [A_sqrt, B_sqrt])\n \t\n\tcount = 0\n\tfor i in xrange(A_sqrt, B_sqrt + 1):\n\t\tif check_palindrome(i):\n\t\t\tif check_palindrome(i * i):\n\t\t\t\tcount += 1\n\t\t\t\tprint(\"\\tfound: %d, %d\" % (i, i * i))\n \t\n\tprint(\"\\ttot: %d\" % count)\n\tprint(result = \"%s\" % count)\n\treturn result\n \ndef main(filepath):\n\tstart_time = time.time()\n\twith file('output.txt', 'wb') as f_out:\n \t\t\n\t\t######################################\n\t\t#### select input iteration type: ####\n\t\t####\t- iterate_cases_1lpc\t  ####\n\t\t####\t- iterate_cases_nlpc +n\t  ####\n\t\t####\t- iterate_cases_glpc\t  ####\n\t\t######################################\n\t\tfor case_index, case in iterate_cases_1lpc(filepath):\n \t\t\t\n\t\t\tprint(\"case #%d: time:%.02f\" % (case_index, time.time() - start_time))\n\t\t\tresult = calc_result(case)\n \t\t\t\n\t\t\t#######################\n\t\t\t#### format output ####\n\t\t\t#######################\n\t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])\n"}
{"author": "idolivneh", "index": 23, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\nimport time\nimport itertools #use combinations!\n \ndef iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tyield line_index, line.strip().split(' ')\n \ndef iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 1\n\t\tcase = []\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not line_index % n:\n\t\t\t\tyield case_counter, case\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n \ndef iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n\twith file(filepath, 'rb') as f_in:\n\t\tcase_counter = 0\n\t\tnew_case = True\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tif new_case:\n\t\t\t\tnew_case = False\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n\t\t\t\tassert len(line.strip().split(' ')) == 1\n\t\t\t\tlines_left = int(line.strip())\n\t\t\t\tif not lines_left:\n\t\t\t\t\tnew_case = True\n\t\t\t\t\tyield case_counter, case\n\t\t\t\tcontinue\n\t\t\tif lines_left:\n\t\t\t\tlines_left -= 1\n\t\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not lines_left:\n\t\t\t\tnew_case = True\n\t\t\t\tyield case_counter, case\n \t\t\t\ndef part_of_list_to_int(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(int(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_int(array):\n\treturn part_of_list_to_int(array, [True] * len(array))\n \ndef part_of_list_to_float(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(float(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_float(array):\n\treturn part_of_list_to_float(array, [True] * len(array))\n \ndef get_max_array_on_index(array, index):\n\telem_len = len(array[0])\n\tassert index < elem_len\n\tfor elem in array:\n\t\tassert elem_len == len(elem)\n\tmax_sub = array[0][index]\n\tmax_elem = array[0]\n\tfor elem in array:\n\t\tif elem[index] > max_sub:\n\t\t\tmax_sub = elem[index]\n\t\t\tmax_elem = elem\n\treturn max_elem\n \ndef list_index_in_sorted_with_position(a_list, value, pos):\n\tlist_len = len(a_list)\n\tif list_len == 1:\n\t\tif a_list[0] == value:\n\t\t\treturn pos\n\t\treturn -1\n\tif a_list[list_len/2] > value:\n\t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n\telse:\n\t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n \t\ndef list_index_in_sorted_list(a_list, value):\n\treturn list_index_in_sorted_with_position(a_list, value, 0)\n \ndef copy_list(list):\n\tres = []\n\tfor elem in list:\n\t\tres.append(elem)\n\treturn res\t\n \n############################################################\n#### add solution here \t\t\t\t\t\t\t\t\t####\n#### don't forget to change data from str to int/float  ####\n############################################################\n \ndef intersect(arr_A, arr_B):\n\tprint ('\\t\\t%s\\n\\t\\t%s' % (arr_A, arr_B))\n\tres = []\n\tfor a in arr_A:\n\t\tif arr_B.count(a):\n\t\t\tres.append(a)\n\tprint ('\\t\\t%s' % res)\n\treturn res\n \ndef solve(row_A_selected, board_A,\n\t\t  row_B_selected, board_B):\n\tres = intersect(board_A[row_A_selected - 1], \n\t\t\t\t\tboard_B[row_B_selected - 1])\n\tif len(res) == 0:\n\t\treturn 'Volunteer cheated!'\n\tif len(res) == 1:\n\t\treturn res[0]\n\treturn 'Bad magician!'\n \t\ndef calc_result(case):\n\tresult = None\n \t\n\trow_A_selected = int(case[0][0])\n\trow_B_selected = int(case[5][0])\n\tboard_A = case[1:5]\n\tboard_B = case[6:10]\n \t\n\tprint (\"row_A_selected: %s\" % row_A_selected)\n\tprint (\"row_B_selected: %s\" % row_B_selected)\n\tprint \n\tprint (board_A)\n\tprint \n\tprint (board_B)\n\tprint\n \t\n\tresult = solve(row_A_selected, board_A,\n\t\t\t\t   row_B_selected, board_B)\n\tprint (result)\n \t\n \t\n\treturn result\n \ndef main(filepath):\n\tstart_time = time.time()\n\twith file('output.txt', 'wb') as f_out:\n \t\t\n\t\t######################################\n\t\t#### select input iteration type: ####\n\t\t####\t- iterate_cases_1lpc\t  ####\n\t\t####\t- iterate_cases_nlpc +n\t  ####\n\t\t####\t- iterate_cases_glpc\t  ####\n\t\t######################################\n\t\tfor case_index, case in iterate_cases_nlpc(filepath, 10):\n \t\t\t\n\t\t\tprint (\"case #%d: time:%.02f\" % (case_index, time.time() - start_time))\n\t\t\tresult = calc_result(case)\n \t\t\t\n\t\t\t#######################\n\t\t\t#### format output ####\n\t\t\t#######################\n\t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])\n"}
{"author": "greatlemer", "index": 24, "filename": "2014_2974486_5709773144064000.py", "code": "# Written for Python 2.7.5\n \nfrom optparse import OptionParser\nfrom StringIO import StringIO\nfrom math import ceil\nimport sys\n \n# Expected format of TEST_CASES is a list of tuples of (input, expected_output)\nTEST_CASES = [\n    (\"\"\"4\n30.0 1.0 2.0\n30.0 2.0 100.0\n30.50000 3.14159 1999.19990\n500.0 4.0 2000.0\n\"\"\",\"\"\"Case #1: 1.0000000\nCase #2: 39.1666667\nCase #3: 63.9680013\nCase #4: 526.1904762\n\"\"\")\n]\n \n\"\"\"\nZ is number of farms held\ntF(Z) is time to build a farm = C / (2+(F*Z))\ntX(Z) is time to win = X / (2+(F*Z))\nNo point incresing Z when tX(Z) < (tX(Z+1) + tF(Z)\n    == X / (2+(F*Z)) < (X / (2+(F*(Z+1))) + (C / (2+(F*Z)))\n    == (X - C) / (2+(F*Z)) < X / (2+(F*(Z+1)))\n    == (X - C) * (2+(F*Z)+F) < X * (2+(F*Z))\n    == 2X - 2C + XFZ - CFZ + XF - CF < 2X + XFZ\n    == XF - CF - 2C < CFZ\n    == (XF - CF - 2C) / CF < Z\n\"\"\"\n \ndef parse_input(input_reader):\n    case_count = int(input_reader.readline())\n    case_idx = 0\n    while case_count > case_idx:\n        case_idx += 1\n        input_line = input_reader.readline().rstrip(\"\\n\").split(\" \")\n        input_values = {\"C\": float(input_line[0]),\n                        \"F\": float(input_line[1]),\n                        \"X\": float(input_line[2]),\n                        \"case\": case_idx}\n        yield input_values\n \ndef solve_problem(output_writer=sys.stdout, **kwargs):\n    case = kwargs['case']\n    C_val = kwargs['C']\n    F_val = kwargs['F']\n    X_val = kwargs['X']\n \n    best_Z = ((X_val * F_val) - (C_val * F_val) - (2 * C_val)) / (C_val * F_val)\n    best_Z = int(ceil(best_Z))\n    if best_Z < 0:\n        best_Z = 0\n \n    tX = lambda z: (X_val / (2+(F_val * z)))\n    tF = lambda z: (C_val / (2+(F_val * z)))\n \n    total_time = reduce(lambda x,y: x + tF(y), range(best_Z), tX(best_Z))\n    print >> output_writer, \"Case #%d: %.7f\" % (case, total_time)\n \ndef solve_inputs(input_reader, output_writer):\n    \"\"\"\n    Loop through each problem input in input reader and solve it.\n \n    Outputs responses to output_writer.\n    \"\"\"\n    for input_values in parse_input(input_reader):\n        solve_problem(output_writer=output_writer, **input_values)\n \ndef run_tests():\n    idx = 0\n    all_pass = True\n    for problem_input, expected_output in TEST_CASES:\n        idx += 1\n        input_reader = StringIO(problem_input)\n        output_writer = StringIO()\n        solve_inputs(input_reader, output_writer)\n        problem_output = output_writer.getvalue()\n        if problem_output == expected_output:\n            print (\"Test %d: Success\" % idx)\n        else:\n            all_pass = False\n            print (\"Test %d: Failure\" % idx)\n        input_reader.close()\n        output_writer.close()\n    if all_pass:\n        print (\"All tests were successful!\")\n    else:\n        print (\"Something didn't match - try again.\")\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\",\n                    dest=\"filename_stem\",\n                    help=\"read input from FILE.in and write to FILE.out\",\n                    metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if options.filename_stem:\n        print (\"Running in file mode.\")\n        input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n        output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n        solve_inputs(input_reader, output_writer)\n    else:\n        print (\"Running in test mode.\")\n        run_tests()\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "greatlemer", "index": 24, "filename": "2014_2974486_5690574640250880.py", "code": "# Written for Python 2.7.5\n \nfrom optparse import OptionParser\nfrom StringIO import StringIO\nimport sys\n \n# Expected format of TEST_CASES is a list of tuples of (input, expected_output)\nTEST_CASES = [\n    (\"\"\"5\n5 5 23\n3 1 1\n2 2 1\n4 7 3\n10 10 82\n\"\"\",\"\"\"Case #1:\nImpossible\nCase #2:\nc\n.\n*\nCase #3:\nImpossible\nCase #4:\nc......\n.......\n.......\n....***\nCase #5:\nc........*\n.........*\n**********\n**********\n**********\n**********\n**********\n**********\n**********\n**********\n\"\"\"),\n    (\"\"\"3\n5 4 3\n5 3 8\n5 5 14\n\"\"\",\"\"\"Case #1:\nc...\n....\n....\n...*\n..**\nCase #2:\nImpossible\nCase #3:\nc...*\n....*\n...**\n*****\n*****\n\"\"\")\n]\n \nIMPOSSIBLE = \"Impossible\"\n \n\"\"\"\nS is number of safe squares = (R*C) - M\nIf S == 1 then always possible:\n    Assume click in top left, all else mines\nSpecial cases (R or C is small):\nIf R == 1 or C == 1 then always possible:\n    Assume click in top left and all safe squares in a line\nElse if R == 2 or C == 2 then possible iff S % 2 == 0:\n    Assume click in top left and all safe squares are in a 2 * X line\nElse if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\n    OR if S % 2 == 0 \n\"\"\"\n \ndef parse_input(input_reader):\n    case_count = int(input_reader.readline())\n    case_idx = 0\n    while case_count > case_idx:\n        case_idx += 1\n        input_line = [int(x) for x in input_reader.readline().split()]\n        input_values = {\"case\": case_idx,\n                        \"R\": input_line[0],\n                        \"C\": input_line[1],\n                        \"M\": input_line[2]}\n        yield input_values\n \n \ndef solve_problem(output_writer=sys.stdout, **kwargs):\n    case = kwargs['case']\n    rows = kwargs['R']\n    cols = kwargs['C']\n    mines = kwargs['M']\n    safe_squares = ((rows * cols) - mines)\n    print >> output_writer, \"Case #%d:\" % case\n    row_string = \"{:*<%ds}\" % cols\n    impossible = False\n    if safe_squares == 1:\n        print >> output_writer, row_string.format(\"c\")\n        for row in range(1, rows):\n            print >> output_writer, row_string.format(\"\")\n    elif rows == 1:\n        safe_string = \"c\" + (\".\" * (safe_squares - 1))\n        print >> output_writer, row_string.format(safe_string)\n    elif cols == 1:\n        for row in range(rows):\n            cell = \"\"\n            if row == 0:\n                cell = \"c\"\n            elif row < safe_squares:\n                cell = \".\"\n            print >> output_writer, row_string.format(cell)\n    elif safe_squares == 2:\n        impossible = True\n    elif rows == 2:\n        safe_cols, remainder = divmod(safe_squares, 2)\n        if remainder == 1:\n            impossible = True\n        else:\n            safe_string = \".\" * (safe_cols - 1)\n            print >> output_writer, row_string.format(\"c%s\" % safe_string)\n            print >> output_writer, row_string.format(\".%s\" % safe_string)\n    elif cols == 2:\n        safe_rows, remainder = divmod(safe_squares, 2)\n        if remainder == 1:\n            impossible = True\n        else:\n            for row in range(rows):\n                cells = \"\"\n                if row == 0:\n                    cells = \"c.\"\n                elif row < safe_rows:\n                    cells = \"..\"\n                print >> output_writer, row_string.format(cells)\n    else:\n        safe_rows, remainder = divmod(safe_squares, cols)\n        if remainder == 1 and cols == 3 and safe_rows == 2:\n            impossible = True\n        elif safe_rows > 1:\n            if remainder == 1 and safe_rows == 2:\n                mid_safe = \".\" * (cols-2)\n                for row in range(rows):\n                    cell_one = \".\"\n                    mid_cells = mid_safe\n                    last_cell = \".\"\n                    if row == 0:\n                        cell_one = \"c\"\n                    elif safe_rows == 0:\n                        cell_one = \".\"\n                        mid_cells = \".\" * (remainder + 1)\n                    elif safe_rows < 0:\n                        cell_one = \"\"\n                        mid_cells = \"\"\n                    if safe_rows < 3:\n                        last_cell = \"\"\n                    print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                    safe_rows -= 1\n            elif remainder == 1:\n                mid_safe = \".\" * (cols-2)\n                for row in range(rows):\n                    cell_one = \".\"\n                    mid_cells = mid_safe\n                    last_cell = \".\"\n                    if row == 0:\n                        cell_one = \"c\"\n                    elif safe_rows == 0:\n                        cell_one = \".\"\n                        mid_cells = \".\" * remainder\n                    elif safe_rows < 0:\n                        cell_one = \"\"\n                        mid_cells = \"\"\n                    if safe_rows < 2:\n                        last_cell = \"\"\n                    print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                    safe_rows -= 1\n            else:\n                full_safe = \".\" * cols\n                for row in range(rows):\n                    cells = full_safe\n                    if row == 0:\n                        cells = \"c\" + (\".\" * (cols - 1))\n                    elif row == safe_rows:\n                        cells = \".\" * remainder\n                    elif row > safe_rows:\n                        cells = \"\"\n                    print >> output_writer, row_string.format(cells)\n        else:\n            safe_cols, remainder = divmod(safe_squares, 2)\n            if remainder == 1 and safe_cols < 4:\n                impossible = True\n            elif remainder == 0:\n                print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                print >> output_writer, row_string.format(\".\" * safe_cols)\n                for row in range(2, rows):\n                    print >> output_writer, row_string.format(\"\")\n            else:\n                safe_cols -= 1\n                print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                print >> output_writer, row_string.format(\".\" * safe_cols)\n                print >> output_writer, row_string.format(\"...\")\n                for row in range(3, rows):\n                    print >> output_writer, row_string.format(\"\")\n    if impossible:\n        print >> output_writer, IMPOSSIBLE\n \ndef solve_inputs(input_reader, output_writer):\n    \"\"\"\n    Loop through each problem input in input reader and solve it.\n \n    Outputs responses to output_writer.\n    \"\"\"\n    for input_values in parse_input(input_reader):\n        solve_problem(output_writer=output_writer, **input_values)\n \ndef run_tests():\n    idx = 0\n    all_pass = True\n    for problem_input, expected_output in TEST_CASES:\n        idx += 1\n        input_reader = StringIO(problem_input)\n        output_writer = StringIO()\n        solve_inputs(input_reader, output_writer)\n        problem_output = output_writer.getvalue()\n        if problem_output == expected_output:\n            print (\"Test %d: Success\" % idx)\n        else:\n            all_pass = False\n            print (\"Test %d: Failure\" % idx)\n            print (problem_output)\n        input_reader.close()\n        output_writer.close()\n    if all_pass:\n        print (\"All tests were successful!\")\n    else:\n        print (\"Something didn't match - try again.\")\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\",\n                    dest=\"filename_stem\",\n                    help=\"read input from FILE.in and write to FILE.out\",\n                    metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if options.filename_stem:\n        print (\"Running in file mode.\")\n        input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n        output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n        solve_inputs(input_reader, output_writer)\n    else:\n        print (\"Running in test mode.\")\n        run_tests()\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "greatlemer", "index": 24, "filename": "2012_1460488_1595491.py", "code": "from optparse import OptionParser\n \ndef solve(N,S,p,t):\n    # Easy pickings, if p is 0 then all must win.\n    if p == 0:\n        return N\n    outright_wins = 0\n    potential_surprises = 0\n    win_cutoff = (p * 3) - 3\n    surprise_cutoff = win_cutoff - 2\n    for score in t:\n        if score == 0:\n            continue\n        elif score > win_cutoff:\n            outright_wins += 1\n        elif score > surprise_cutoff:\n            potential_surprises += 1\n    if potential_surprises < S:\n        return outright_wins + potential_surprises\n    else:\n        return outright_wins + S\n \ndef parse_case(data_line):\n    bits = data_line.split()\n    N = int(bits[0])\n    S = int(bits[1])\n    p = int(bits[2])\n    t = [int(x) for x in bits[3:]]\n    return N,S,p,t\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                    help=\"read input from FILE\", metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if not options.filename:\n        parser.error(\"Must provide a filename.\")\n    input_file = open(options.filename, \"r\")\n    total_cases = int(input_file.readline())\n    case_number = 0\n    while case_number < total_cases:\n    \tcase_number += 1\n    \tdata_args = parse_case(input_file.readline())\n    \tprint(\"Case #%d: %d\" % (case_number, solve(*data_args)))\n \nif __name__ == \"__main__\":\n\tmain()"}
{"author": "greatlemer", "index": 24, "filename": "2013_2270488_2453486.py", "code": "from optparse import OptionParser\nimport string\n \ndef solve(data):\n    GAME_INCOMPLETE = 0\n    GAME_DRAWN = 1\n    GAME_WON = 2\n    winner = None\n    state = GAME_DRAWN\n    for row in data:\n        if \".\" in row:\n            state = GAME_INCOMPLETE\n        elif \"X\" not in row:\n            winner = \"O\"\n            state = GAME_WON\n            break\n        elif \"O\" not in row:\n            winner = \"X\"\n            state = GAME_WON\n            break\n    if state == GAME_WON:\n        return \"%s won\" % winner\n    elif state == GAME_INCOMPLETE:\n        return \"Game has not completed\"\n    else:\n        return \"Draw\"\n \ndef parse_case(data):\n    data_line = \"\".join(data)\n    rows = []\n    for idx in range(4):\n        offset = idx * 4\n        # Pull rows\n        rows.append(data_line[offset:offset+4])\n        # Pull columns\n        rows.append(data_line[idx::4])\n    # Pull diagonals\n    rows.append(data_line[0::5])\n    rows.append(data_line[3:-1:3])\n    return (rows, )\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                    help=\"read input from FILE\", metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if not options.filename:\n        parser.error(\"Must provide a filename.\")\n    input_file = open(options.filename, \"r\")\n    total_cases = int(input_file.readline())\n    case_number = 0\n    while case_number < total_cases:\n        case_number += 1\n        data = []\n        for idx in range(4):\n            data.append(input_file.readline()[:4])\n        input_file.readline()\n        data_args = parse_case(data)\n        print(\"Case #%d: %s\" % (case_number, solve(*data_args)))\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "greatlemer", "index": 24, "filename": "2013_2270488_2449486.py", "code": "from optparse import OptionParser\nimport string\n \ndef solve(rows,cols,width,height):\n    # Calculate the lowest setting that can be used when cutting a row or col.\n    row_mins = [max(row) for row in rows]\n    col_mins = [max(col) for col in cols]\n    for row_idx in range(height):\n        for col_idx in range(width):\n            if row_mins[row_idx] > rows[row_idx][col_idx] \\\n                and col_mins[col_idx] > rows[row_idx][col_idx]:\n                return \"NO\"\n    return \"YES\"\n \n \ndef parse_case(data,width,height):\n    data_line = [int(entry) for entry in reduce(lambda x,y: x+y, data, [])]\n    rows = []\n    cols = []\n    for idx in range(height):\n        offset = idx * width\n        # Pull rows\n        rows.append(data_line[offset:offset+width])\n    for idx in range(width):\n        # Pull columns\n        cols.append(data_line[idx::width][:height])\n    return (rows, cols, width, height)\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                    help=\"read input from FILE\", metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if not options.filename:\n        parser.error(\"Must provide a filename.\")\n    input_file = open(options.filename, \"r\")\n    total_cases = int(input_file.readline())\n    case_number = 0\n    while case_number < total_cases:\n        case_number += 1\n        height,width = input_file.readline().split()\n        width = int(width)\n        height = int(height)\n        data = []\n        for idx in range(height):\n            data.append(input_file.readline().split())\n        data_args = parse_case(data, width, height)\n        print(\"Case #%d: %s\" % (case_number, solve(*data_args)))\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "greatlemer", "index": 24, "filename": "2012_1460488_1483485.py", "code": "from optparse import OptionParser\nimport string\n \ndef solve(data_line):\n    english, googlerese = generate_map()\n    transmap = string.maketrans(googlerese, english)\n    return string.translate(data_line, transmap, \"\\n\")\n \ndef parse_case(data_line):\n    return (data_line, )\n \ndef generate_map():\n    \"\"\" Use the known phrases we have to generate a translation map.  If\n        there's exactly one letter missing after analysing these phrases (which\n        there is) we can work it out by seeing what's left over.\"\"\"\n    known_mappings = {\"a zoo\": \"y qee\",\n                    \"our language is impossible to understand\": \"ejp mysljylc kd kxveddknmc re jsicpdrysi\",\n                    \"there are twenty six factorial possibilities\": \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\",\n                    \"so it is okay if you want to just give up\": \"de kr kd eoya kw aej tysr re ujdr lkgc jv\",\n                    }\n    all_letters = \"abcdefghijklmnopqrstuvwxyz\"\n    letter_map = {}\n    for english, googlerese in known_mappings.items():\n        pairs = zip(english, googlerese)\n        for e,g in pairs:\n            if e not in letter_map:\n                letter_map[e] = g\n    if len(letter_map) == 26:\n        e_letter = \"\"\n        g_letter = \"\"\n        for letter in all_letters:\n            if not e_letter and letter not in letter_map.keys():\n                e_letter = letter\n            if not g_letter and letter not in letter_map.values():\n                g_letter = letter\n        letter_map[e_letter] = g_letter\n    return \"\".join(letter_map.keys()), \"\".join(letter_map.values())\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                    help=\"read input from FILE\", metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if not options.filename:\n        parser.error(\"Must provide a filename.\")\n    input_file = open(options.filename, \"r\")\n    total_cases = int(input_file.readline())\n    case_number = 0\n    while case_number < total_cases:\n    \tcase_number += 1\n    \tdata_args = parse_case(input_file.readline())\n    \tprint(\"Case #%d: %s\" % (case_number, solve(*data_args)))\n \nif __name__ == \"__main__\":\n\tmain()"}
{"author": "greatlemer", "index": 24, "filename": "2013_2270488_2463486.py", "code": "from optparse import OptionParser\nimport string\nimport pickle\n \ndef solve(lower, upper, cache):\n    counter = 0\n    for item in cache:\n        if item > upper:\n            break\n        if item < lower:\n            continue\n        counter += 1\n    return counter\n \ndef is_palindrome(test_int):\n    str_arg = str(test_int)\n    return str_arg == str_arg[::-1]\n \ndef generate_cache():\n    \"\"\" Generates a list of 'fair and square' numbers between 1 and 10^100\n \n    By observation of generating the first few of these numbers it became\n    obvious that the 'roots' fitted a very specific pattern, they are either\n    single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;\n    multiple digits with a 2 at the beginning and end and 1s and 0s in the\n    middle or an odd number of digits with a single 2 in the centre and 1s and\n    0s elsewhere.\n \n    This function therefore only looks at these numbers to build a list of all\n    valid results. \"\"\"\n    # Put 9 in to start with as it's the only one that uses a 3.\n    cache = [9,]\n    counter = 1\n    if upper_bound is None:\n        upper_bound = pow(2,25)\n    while counter < upper_bound:\n        binary_part = \"{0:b}\".format(counter)\n        # Look for palindromes beginning with a 1\n        half_int = binary_part\n        # Check the odd length palindrome\n        pal_int = int(half_int + half_int[:-1][::-1])\n        pal_square = pal_int * pal_int\n        if is_palindrome(pal_square):\n            cache.append(pal_square)\n        # Check the even length palindrome\n        pal_int = int(half_int + half_int[::-1])\n        pal_square = pal_int * pal_int\n        if is_palindrome(pal_square):\n            cache.append(pal_square)\n        half_int = \"%s%s\" % (binary_part, 2)\n        # Check the odd length palindrome only when adding a 2\n        pal_int = int(half_int + half_int[:-1][::-1])\n        pal_square = pal_int * pal_int\n        if is_palindrome(pal_square):\n            cache.append(pal_square)\n        # Look for palindromes beginning with a 2\n        half_int = \"2%s\" % binary_part[1:]\n        # Check the odd length palindrome\n        pal_int = int(half_int + half_int[:-1][::-1])\n        pal_square = pal_int * pal_int\n        if is_palindrome(pal_square):\n            cache.append(pal_square)\n        # Check the even length palindrome\n        pal_int = int(half_int + half_int[::-1])\n        pal_square = pal_int * pal_int\n        if is_palindrome(pal_square):\n            cache.append(pal_square)\n        counter += 1\n    return sorted(cache)\n \n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                    help=\"read input from FILE\", metavar=\"FILE\")\n    parser.add_option(\"-c\", \"--cache\", dest=\"cache_filename\",\n                    help=\"read/write cache from/to CACHE_FILE\", metavar=\"CACHE_FILE\")\n    parser.add_option(\"-g\", \"--generate-cache\", dest=\"generate_cache\",\n                    help=\"generate the cache file\", action=\"store_true\")\n    cache = None\n    (options, args) = parser.parse_args()\n    if options.generate_cache:\n        # Generate a cache file before going through answers so that we don't\n        # waste precious time later.\n        cache = generate_cache()\n        if not options.cache_filename:\n            output_file = open(options.cache_filename, \"w\")\n            pickle.dump(cache, output_file)\n            output_file.close()\n    else:\n        cache_file = open(options.cache_filename, \"r\")\n        cache = pickle.load(cache_file)\n        cache_file.close()\n    if not options.filename:\n        parser.error(\"Must provide a filename.\")\n    input_file = open(options.filename, \"r\")\n    total_cases = int(input_file.readline())\n    case_number = 0\n    while case_number < total_cases:\n        case_number += 1\n        lower,upper = input_file.readline().split()\n        lower = int(lower)\n        upper = int(upper)\n        data_args = (lower, upper, cache)\n        print(\"Case #%d: %s\" % (case_number, solve(*data_args)))\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "greatlemer", "index": 24, "filename": "2014_2974486_5756407898963968.py", "code": "# Written for Python 2.7.5\n \nfrom optparse import OptionParser\nfrom StringIO import StringIO\nimport sys\n \n# Expected format of TEST_CASES is a list of tuples of (input, expected_output)\nTEST_CASES = [\n    (\"\"\"3\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 5 4\n3 11 6 15\n9 10 7 12\n13 14 8 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n\"\"\",\"\"\"Case #1: 7\nCase #2: Bad magician!\nCase #3: Volunteer cheated!\n\"\"\"),\n    (\"\"\"1\n1\n15 9 16 5\n6 10 1 3\n2 4 12 11\n13 14 8 7\n1\n5 10 9 6\n12 15 1 11\n14 16 4 2\n13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n\"\"\")\n]\n \nBAD_MAGIC = \"Bad magician!\"\nCHEATING = \"Volunteer cheated!\"\n \ndef parse_input(input_reader):\n    case_count = int(input_reader.readline())\n    case_idx = 0\n    while case_count > case_idx:\n        case_idx += 1\n        rows = []\n        for loop_idx in (1,2):\n            row_idx = int(input_reader.readline())\n            for idx in (1,2,3,4):\n                if idx == row_idx:\n                    rows.append(set(input_reader.readline().rstrip(\"\\n\").split(\" \")))\n                else:\n                    input_reader.readline()\n        input_values = {\"rows\":rows,\n                        \"case\":case_idx}\n        yield input_values\n \n \ndef solve_problem(output_writer=sys.stdout, **kwargs):\n    rows = kwargs['rows']\n    case = kwargs['case']\n    intersect = rows[0].intersection(rows[1])\n    if not intersect:\n        msg = CHEATING\n    elif len(intersect) == 1:\n        msg = intersect.pop()\n    else:\n        msg = BAD_MAGIC\n    print >>output_writer, \"Case #%d: %s\" % (case, msg)\n \ndef solve_inputs(input_reader, output_writer):\n    \"\"\"\n    Loop through each problem input in input reader and solve it.\n \n    Outputs responses to output_writer.\n    \"\"\"\n    for input_values in parse_input(input_reader):\n        solve_problem(output_writer=output_writer, **input_values)\n \ndef run_tests():\n    \"\"\"\n    Check the sample input and output match.\n    \"\"\"\n    idx = 0\n    all_pass = True\n    for problem_input, expected_output in TEST_CASES:\n        idx += 1\n        input_reader = StringIO(problem_input)\n        output_writer = StringIO()\n        solve_inputs(input_reader, output_writer)\n        problem_output = output_writer.getvalue()\n        if problem_output == expected_output:\n            print (\"Test %d: Success\" % idx)\n        else:\n            all_pass = False\n            print (\"Test %d: Failure\" % idx)\n        input_reader.close()\n        output_writer.close()\n    if all_pass:\n        print (\"All tests were successful!\")\n    else:\n        print (\"Something didn't match - try again.\")\n        print (problem_output)\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\",\n                    dest=\"filename_stem\",\n                    help=\"read input from FILE.in and write to FILE.out\",\n                    metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if options.filename_stem:\n        print (\"Running in file mode.\")\n        input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n        output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n        solve_inputs(input_reader, output_writer)\n    else:\n        print (\"Running in test mode.\")\n        run_tests()\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "fizu", "index": 25, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\n \ndef readint():\n    return int(sys.stdin.readline())\n \ndef readfloatarray():\n    return map(float, sys.stdin.readline().strip().split())\n \ndef readintarray():\n    return map(int, sys.stdin.readline().strip().split())\n \ndef readpairs(start=0):\n    elems = readintarray()[start:]\n    return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n \ndef readstring():\n    return sys.stdin.readline()[:-1]\n \n"}
{"author": "fizu", "index": 25, "filename": "2014_2974486_5690574640250880.py", "code": "import time\nimport itertools\n \nfrom codejam import *\n \n \ndirections = list(itertools.product([1, 0, -1], [1, 0, -1]))\ndef count_neighbors(table, r, c):\n    cols = len(table[0])\n    rows = len(table)\n    return sum(table[r + x][c + y] == \"*\" for x, y in directions \n                if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\n \ndef is_valid(table):\n    cols = len(table[0])\n    rows = len(table)\n    for r in xrange(rows):\n        for c in xrange(cols):\n            has_zero = any(table[r + x][c + y] == 0 for x, y in directions \n                            if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\n            if table[r][c] != \"*\" and not has_zero:\n                return False\n \n    return True\n \n \ndef draw_table(table, hide=False):\n    cols = len(table[0])\n    rows = len(table)\n    ascii_table = \"\"\n    for r in xrange(rows):\n        for c in xrange(cols):\n            if table[r][c] != \"*\":\n                ch = \"c\" if r == 0 and c == 0 else \".\"\n                table[r][c] = count_neighbors(table, r, c) if not hide else ch\n \n            ascii_table += str(table[r][c])\n \n        ascii_table += \"\\n\"\n \n    return ascii_table[:-1]\n \ndef solve(R, C, M):\n    r = c = 0\n    current_mines = R * C\n    table = [[\"*\"] * C for k in xrange(R)]\n    while M < current_mines:\n        if table[r][c] == '*':\n            table[r][c] = \".\"\n            current_mines -= 1\n \n        if current_mines > M and r + 1 < R and table[r+1][c] == \"*\":\n            table[r+1][c] = \".\"\n            current_mines -= 1\n \n        draw_table(table)\n        c += 1\n        if c >= C:\n            c = 0\n            r += 1\n \n    return table\n \nfor i in xrange(readint()):\n    R, C, M = readintarray()\n \n    print(\"Case #%d:\" % (i + 1))\n    if M < (R * C) - 1:\n        table = solve(R, C, M)\n        if is_valid(table):\n            print(draw_table(table, hide=True))\n        else:\n            table = solve(C, R, M)\n            rotated = [[\"*\"] * C for k in xrange(R)]\n            for r in xrange(R - 1, -1, -1):\n                for c in xrange(C):\n                    rotated[R - r - 1][c] = table[c][r]\n \n            print(draw_table(rotated, hide=True) if is_valid(rotated) else \"Impossible\")\n \n    elif M == R * C:\n        print(\"Impossible\")\n \n    else:\n        table = [[\"*\"] * C for k in xrange(R)]\n        table[0][0] = '.'\n        print(draw_table(table, hide=True))\n"}
{"author": "fizu", "index": 25, "filename": "2012_1460488_1595491.py", "code": "import sys\n \ndef readint():\n    return int(sys.stdin.readline())\n \ndef readintarray():\n    return map(int, sys.stdin.readline().strip().split())\n \ndef readpairs(start=0):\n    elems = readintarray()[start:]\n    return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n \ndef readstring():\n    return sys.stdin.readline()[:-1]\n \n"}
{"author": "fizu", "index": 25, "filename": "2013_2270488_2453486.py", "code": "import sys\n \ndef readint():\n    return int(sys.stdin.readline())\n \ndef readintarray():\n    return map(int, sys.stdin.readline().strip().split())\n \ndef readpairs(start=0):\n    elems = readintarray()[start:]\n    return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n \ndef readstring():\n    return sys.stdin.readline()[:-1]\n \n"}
{"author": "fizu", "index": 25, "filename": "2013_2270488_2449486.py", "code": "import sys\n \ndef readint():\n    return int(sys.stdin.readline())\n \ndef readintarray():\n    return map(int, sys.stdin.readline().strip().split())\n \ndef readpairs(start=0):\n    elems = readintarray()[start:]\n    return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n \ndef readstring():\n    return sys.stdin.readline()[:-1]\n \n"}
{"author": "fizu", "index": 25, "filename": "2012_1460488_1483485.py", "code": "from codejam import *\nfrom string import maketrans\n \ninp = \"ejp mysljylc kd kxveddknmc re jsicpdrysi\"\\\n    \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\"\\\n    \"de kr kd eoya kw aej tysr re ujdr lkgc jv zq\"\nout = \"our language is impossible to understand\"\\\n    \"there are twenty six factorial possibilities\"\\\n    \"so it is okay if you want to just give up qz\"\n \nfor case in xrange(readint()):\n    trantab = maketrans(inp, out)\n    line = readstring()\n    print(\"Case #%d: %s\" % (case + 1, line.translate(trantab)))\n"}
{"author": "fizu", "index": 25, "filename": "2013_2270488_2463486.py", "code": "import codejam\n \npossibles = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]\n \nfor case in xrange(codejam.readint()):\n    A, B = map(int, codejam.readstring().split())\n    count = 0\n    for possible in possibles:\n        if A > possible:\n            continue\n \n        if B < possible:\n            break\n \n        count += 1\n \n    print(\"Case #%d: %d\" % (case + 1, count))\n"}
{"author": "fizu", "index": 25, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \ndef readint():\n    return int(sys.stdin.readline())\n \ndef readintarray():\n    return map(int, sys.stdin.readline().strip().split())\n \ndef readpairs(start=0):\n    elems = readintarray()[start:]\n    return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n \ndef readstring():\n    return sys.stdin.readline()[:-1]\n \n"}
{"author": "anavaleije", "index": 26, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\n \ndef oneMoreFarm(C, F, nFarms):\n\treturn C/(2.0 + nFarms*F)\n \t\n \n##########################################################\n# Main\n \ninputFileName = sys.argv[1]\n \nf = file(inputFileName)\nfout = file(\"output.txt\", \"w\")\n \nT = int(f.readline().strip())\n \nfor case in xrange(T):\n \n\tdata = f.readline().split()\n\tC = eval(data[0])\n\tF = eval(data[1])\n\tX = eval(data[2])\n \n\ttmin = X/2.0\n\tfoundMin = False\n \n\tS = 0\n\tnFarms = 0\n \n\twhile not foundMin:\n\t\tnFarms += 1\n\t\tS += oneMoreFarm(C, F, nFarms - 1)\n\t\tt = S + X/(2.0 + nFarms*F)\n\t\tif t < tmin:\n\t\t\ttmin = t\n\t\telse:\n\t\t\tfoundMin = True\n \n\t##### Output writing\n\tfout.write(\"Case #%d: %.7f\\n\" %(case + 1, tmin))\n"}
{"author": "anavaleije", "index": 26, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\n \ndef transpose(result, R, C):\n\tresultSplitted = result.split(\"\\n\")\n\taux = R*[\"\"]\n\tfor i in xrange(R):\n\t\tfor j in xrange(C):\n\t\t    aux[i] += resultSplitted[j][i]\n\t\taux[i] += \"\\n\"\n\tresult = \"\"\n\tfor item in aux:\n\t\tresult += item + \"\\n\"\n\treturn result.strip()\n \n##########################################################\n# Main\n \ninputFileName = sys.argv[1]\n \nf = file(inputFileName)\nfout = file(\"output.txt\", \"w\")\n \nT = int(f.readline())\n \nfor case in xrange(T):\n\tdata = f.readline().strip().split(\" \")\n\tR = int(data[0])\n\tC = int(data[1])\n\tM = int(data[2])\n \n\tresult = \"\"\n \n\tx = min(R,C)\n\ty = max(R,C)\n \n\t#if x == 2 and M%2 == 1 and M < R*C - 1:\n\t#\tresult = \"Impossible\"\n\t#elif x == 3 and M > y and M != R*C - 1:\n#\t\tresult = \"Impossible\"\n\tif M > (y - 2)*x and M != y*x - 1:\n\t\tN = M - (y-2)*x\n\t\tif N%2 == 1 or y*x - M == 2:\n\t\t\tresult = \"Impossible\"\n\tif result != \"Impossible\":\n\t\ti = 0\n\t\twhile M > 0: # 2\n\t\t\tif i < y - 2:\n\t\t\t\tif M >= x:\n\t\t\t\t\tresult += x*\"*\" + \"\\n\"\n\t\t\t\t\tM -= x\n\t\t\t\t\ti += 1\n\t\t\t\telif M <= x - 2:\n\t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\\n\"\n\t\t\t\t\tM = 0\n\t\t\t\t\ti += 1\n\t\t\t\telif i + 2 < y - 1:\n\t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\\n\" + \"*\" + (x-1)*\".\" + \"\\n\"\n\t\t\t\t\tM = 0\n\t\t\t\t\ti += 2\n\t\t\t\telse:\n\t\t\t\t\tresult = \"Impossible\"\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tif M%2 != 0:\n\t\t\t\t\tresult += x*\"*\" + \"\\n\"\n\t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\n\t\t\t\telse:\n\t\t\t\t\tn = M/2\n\t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\\n\"\n\t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\n\t\t\t\tM = 0\n\t\t\t\ti += 2\n \t\t\t\t\t\n\t\twhile i <= y - 1 and result != \"Impossible\":\n\t\t\tif i == y - 1:\n\t\t\t\tresult += (x-1)*\".\" + \"c\"\n\t\t\telse:\n\t\t\t\tresult += x*\".\" + \"\\n\"\n\t\t\ti += 1\n \t\n\tif R < C and result != \"Impossible\":\n\t\tresult = transpose(result, R, C)\n \n\t##### Output writing\n\tfout.write(\"Case #%d:\\n%s\\n\" %(case + 1, result))\n"}
{"author": "anavaleije", "index": 26, "filename": "2012_1460488_1595491.py", "code": "arq = file(\"input.in\")\nn_cases = eval(arq.readline())\nout = file(\"output.txt\", \"w\")\n \nfor case in xrange(n_cases):\n \n\tdata = arq.readline()\n\tdata = data.strip()\n\tdata = data.split(\" \")\n \n\tn = eval(data[0])\n\ts = eval(data[1])\n\tp = eval(data[2])\n \n\tscores = []\n\tn_googlers_with_best_result = 0\n\tcandidates = 0\n \n\tfor j in data[3:]:\n\t\ti = eval(j)\n\t\tif i%3 == 0:\n\t\t\tscore = i/3\n\t\t\tscores.append([score, score, score])\n\t\telif (i+1)%3 == 0:\n\t\t\tscore = (i+1)/3\n\t\t\tscores.append([score-1, score, score])\n\t\telse: #(i+2)%3 == 0\n\t\t\tscore = (i+2)/3\n\t\t\tscores.append([score-1, score-1, score])\n \n\tfor score in scores:\n\t\tif score[2] >= p:\n\t\t\tn_googlers_with_best_result +=1\n\t\telif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n\t\t\tcandidates += 1\n \n\tn_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)\n \n\tout.write(\"Case #%d: %d\\n\" % (case+1, n_googlers_with_best_result))\n"}
{"author": "anavaleije", "index": 26, "filename": "2013_2270488_2453486.py", "code": "import sys\n \ndef testSymbol(symbol, game):\n\tif testLines(symbol, game):\n\t\treturn True\n\telif testColumns(symbol, game):\n\t\treturn True\n\telif testDiagonals(symbol, game):\n\t\treturn True\n\telse:\n\t\treturn False\n \ndef testLines(symbol, game):\n\ti = 0\n\twon = False\n\twhile (i < 4 and not won):\n\t\tline = game[i]\n\t\tc = line.count(symbol)\n\t\tif c == 4 or (c == 3 and \"T\" in line):\n\t\t\twon = True\n\t\ti += 1\n\treturn won\n \ndef transpose(game):\n\tfor i in xrange(3):\n\t\tfor j in xrange(i + 1, 4):\n\t\t\taux = game[i][j]\n\t\t\tgame[i][j] = game[j][i]\n\t\t\tgame[j][i] = aux\n\treturn game\n \ndef testColumns(symbol, game):\n\tgame = transpose(game)\n\treturn testLines(symbol, game)\n \ndef testDiagonals(symbol, game):\n\twon1 = True\n\twon2 = True\n\ti = 0\n\twhile i < 4 and (won1 or won2):\n\t\tif game[i][i] not in [symbol, \"T\"]:\n\t\t\twon1 = False\n\t\tif game[i][3 - i] not in [symbol, \"T\"]:\n\t\t\twon2 = False\n\t\ti += 1\n\treturn (won1 or won2)\t\t\n \ninputFileName = sys.argv[1]\n \nf = file(inputFileName)\nfout = file(\"output.txt\", \"w\")\n \nT = eval(f.readline())\n \nfor i in xrange(T):\n\tgame = []\n\tfor j in xrange(4):\n\t\tline = f.readline().strip()\n\t\tgameLine = 4*[None]\n\t\tfor k in xrange(4):\n\t\t\tgameLine[k] = line[k]\n\t\tgame.append(gameLine)\n\tf.readline()\n\tif testSymbol(\"X\", game):\n\t\tgameResult = \"X\"\n\telif testSymbol(\"O\", game):\n\t\tgameResult = \"O\"\n\telif \".\" not in game[0] and \".\" not in game[1] and \".\" not in game[2] and \".\" not in game[3]:\n\t\tgameResult = \"Draw\\n\"\n\telse:\n\t\tgameResult = \"Game has not completed\\n\"\n \n\tfout.write(\"Case #%d: \" %(i + 1))\n\tif gameResult in [\"X\", \"O\"]:\n\t\tfout.write(\"%s won\\n\" %(gameResult))\n\telse:\n\t\tfout.write(gameResult)\n"}
{"author": "anavaleije", "index": 26, "filename": "2013_2270488_2449486.py", "code": "import sys\n \ndef testLine(i, lawn):\n\treturn (2 not in lawn[i])\n \ndef testColumn(j, lawn):\n\tpossible = True\n\tfor line in lawn:\n\t\tif line[j] == 2:\n\t\t\tpossible = False\n\t\t\tbreak\n\treturn possible\n \n##########################################################\n# Main\n \ninputFileName = sys.argv[1]\n \nf = file(inputFileName)\nfout = file(\"output.txt\", \"w\")\n \nT = eval(f.readline())\n \nfor case in xrange(T):\n\tdata = f.readline().split()\n\tN = eval(data[0])\n\tM = eval(data[1])\n\tpossible = True\n\tif N == 1 or M == 1:\n\t\tfor i in xrange(N):\n\t\t\tf.readline()\n\telse:\n\t\tlawn = []\n\t\tfor i in xrange(N):\n\t\t\tline = f.readline().strip().split()\n\t\t\tfor j in xrange(M):\n\t\t\t\tline[j] = eval(line[j])\n\t\t\tlawn.append(line)\n\t\ti = 0\n\t\twhile i < N and possible:\n\t\t\tfor j in xrange(M):\n\t\t\t\tif lawn[i][j] == 1:\n\t\t\t\t\tif not testLine(i, lawn):\n\t\t\t\t\t\tif not testColumn(j, lawn):\n\t\t\t\t\t\t\tpossible = False\n\t\t\ti += 1\n \n\t##### Output writing\n\tfout.write(\"Case #%d: \" %(case + 1))\n\tif possible:\n\t\tfout.write(\"YES\\n\")\n\telse:\n\t\tfout.write(\"NO\\n\")\n"}
{"author": "anavaleije", "index": 26, "filename": "2012_1460488_1483485.py", "code": "# Making up a dictionary\n# Sample\ngooglerese = \"ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv\"\nenglish = \"our language is impossible to understand there are twenty six factorial possibilities so it is okay if you want to just give up\"\n# Hints\nd = {\"y\":\"a\", \"e\":\"o\", \"q\":\"z\"}\n \nfor i in xrange(len(googlerese)):\n\td[googlerese[i]] = english[i]\n \n# One letter still missing: z:q\nd[\"z\"] = \"q\"\n \ninp = file(\"input.in\")\nn = eval(inp.readline())\nout = file(\"output.txt\", \"w\")\n \nfor i in xrange(n):\n\tG = inp.readline().strip()\n\tS = \"\"\n\tfor letter in G:\n\t\tS += d[letter]\n\tout.write(\"Case #%d: \" %(i + 1) + S + \"\\n\")\n"}
{"author": "anavaleije", "index": 26, "filename": "2013_2270488_2463486.py", "code": "import sys, math\n \ndef isPalindrome(n):\n\tn = str(n)\t\n\tfor i in xrange(len(n)/2):\n\t\tif n[i] != n[(-i-1)]:\n\t\t\treturn False\n\treturn True\n \n##########################################################\n# Main\n \ninputFileName = sys.argv[1]\n \nf = file(inputFileName)\nfout = file(\"output.txt\", \"w\")\n \nT = eval(f.readline())\n \nfor case in xrange(T):\n\tdata = f.readline().split()\n\tA = eval(data[0])\n\tB = eval(data[1])\n \n\ti = A\n\tfound = []\n\twhile i <= B:\n\t\tif isPalindrome(i):\n\t\t\tsqrtI = math.sqrt(i)\n\t\t\tif sqrtI == int(sqrtI):\n\t\t\t\tif isPalindrome(int(sqrtI)):\n\t\t\t\t\tfound.append(i)\n\t\ti += 1\n \n\t##### Output writing\n\tfout.write(\"Case #%d: %d\\n\" %(case + 1, len(found)))\n"}
{"author": "anavaleije", "index": 26, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\t\n \ninputFileName = sys.argv[1]\n \nf = file(inputFileName)\nfout = file(\"output.txt\", \"w\")\n \nT = eval(f.readline())\n \nfor case in xrange(T):\n \n\t####First question\n\tA1 = int(f.readline().strip())\n \n\tfor i in xrange(4):\n\t\tif i == A1 - 1:\n\t\t\tpossibles1 = f.readline().strip().split(\" \")\n\t\telse:\n\t\t\tf.readline().strip().split(\" \")\n \n\t####Second question\n\tA2 = int(f.readline().strip())\n \n\tfor i in xrange(4):\n\t\tif i == A2 - 1:\n\t\t\tpossibles2 = f.readline().strip().split(\" \")\n\t\telse:\n\t\t\tf.readline().strip().split(\" \")\n \n\tfinal = []\n\tfor item in possibles2:\n\t\tif item in possibles1:\n\t\t\tfinal.append(item)\n \n\t##### Output writing\n\tif len(final) == 0:\t\n\t\tfout.write(\"Case #%d: Volunteer cheated!\\n\" %(case + 1))\n\telif len(final) == 1:\n\t\tfout.write(\"Case #%d: %s\\n\" %(case + 1, final[0]))\n\telse:\n\t\tfout.write(\"Case #%d: Bad magician!\\n\" %(case + 1))\n"}
{"author": "pyronimous", "index": 27, "filename": "2014_2974486_5709773144064000.py", "code": "\n \nINPUT = 'B-small-attempt1.in'\nOUTPUT = 'B-small-attempt1.out'\n \n \ndef solve(C, F, X):\n \n    cps = 2.0\n    farm_time = 0.0\n    time = X / cps\n     \n    while True:\n        farm_time += C / cps\n        cps += F\n        ntime = farm_time + X / cps\n        if ntime < time:\n            time = ntime\n        else:\n            break\n    return time\n \n \nif __name__ == '__main__':\n    inp = open(INPUT)\n    out = open(OUTPUT, 'w')\n     \n    T = int(inp.readline())\n \n    for case in range(T):\n        sol = solve(*map(float, inp.readline().split()))\n        out.write('Case #%i: %.7f\\n' % (case + 1, sol))"}
{"author": "pyronimous", "index": 27, "filename": "2014_2974486_5690574640250880.py", "code": "\n \nINPUT = 'C-small-attempt0.in'\nOUTPUT = 'C-small-attempt0.out'\n \n \ndef solve(R, C, M):\n    grid = [[0 for c in range(C)] for r in range(R)]\n \n    def get_cell(cell_r, cell_c):\n        if not(0 <= cell_r < R):\n            return None\n        if not(0 <= cell_c < C):\n            return None\n        return grid[cell_r][cell_c]\n \n    def for_each_neighbour(cell_r, cell_c, func):\n        ret = []\n        coords = (\n            (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\n            (cell_r, cell_c - 1), (cell_r, cell_c + 1),\n            (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\n        )\n        for nb in coords:\n            if get_cell(nb[0], nb[1]) is not None:\n                ret.append(func(nb[0], nb[1]))\n        return ret\n \n    def mark_dirty(cell_r, cell_c):\n        if grid[cell_r][cell_c] != '*':\n            grid[cell_r][cell_c] += 1\n     \n    def unmark_dirty(cell_r, cell_c):\n        if grid[cell_r][cell_c] != '*':\n            grid[cell_r][cell_c] -= 1\n \n    def check_empty_neighbours(cell_r, cell_c):\n        return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\n \n    def click():\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell != '*':\n                    if cell == 0 or ((R * C - M) == 1):\n                        grid[i][j] = 'c'\n                        return\n \n    def place_mine():\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell == '*':\n                    continue\n                prevstate = grid[i][j]\n                grid[i][j] = '*'\n                for_each_neighbour(i, j, mark_dirty)\n                if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\n                    grid[i][j] = prevstate\n                    for_each_neighbour(i, j, unmark_dirty)\n                else:\n                    return True\n        return False\n \n    for m in range(M):\n        if not place_mine():\n            return 'Impossible\\n'\n \n    click()\n \n    ret = ''\n    for row in grid:\n        ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\\n'\n \n    return ret\n \n \nif __name__ == '__main__':\n    inp = open(INPUT)\n    out = open(OUTPUT, 'w')\n     \n    T = int(inp.readline())\n \n    for case in range(T):\n        sol = solve(*map(int, inp.readline().split()))\n        out.write('Case #%i:\\n%s' % (case + 1, sol))"}
{"author": "pyronimous", "index": 27, "filename": "2012_1460488_1595491.py", "code": "input_file = 'B-small-attempt1.in'\noutput_file = 'b.out'\n \n \ndef solvecase(inp):\n\tdata = [int(n) for n in inp.split()]\n\tN, S, p = data[0:3]\n\tif p == 0:\n\t\treturn N\n\tt = data[3:]\n\tret = 0\n\tfor br in t:\n\t\td, r = br / 3, br % 3\n\t\tif br == 0 or p - d > 2:\n\t\t\tcontinue\n\t\tif (d >= p) or (r and (d + 1) >= p):\n\t\t\tret += 1\n\t\telif S and (d + max(r, 1)) >= p:\n\t\t\tret += 1\n\t\t\tS -= 1\n\treturn ret\n \nlines = open(input_file, 'r').readlines()\nout = open(output_file, 'w')\n \nfor i, l in enumerate(lines[1:]):\n\tsout = 'Case #%i: %i' % (i + 1, solvecase(l))\n\tprint(sout)\n\tout.write(sout + '\\n')\n \nout.close()\n"}
{"author": "pyronimous", "index": 27, "filename": "2013_2270488_2453486.py", "code": "\nfin = open('A-small-attempt0.in', 'r')\nfout = open('ass1.out', 'w')\n \nN = int(fin.readline())\n \nfor i in range(N):\n    field = []\n    for j in range(4):\n        field.append(fin.readline())\n    fin.readline()\n \n    for j in range(4):\n        field.append([field[ln][j] for ln in range(4)])\n    field.append([field[x][x] for x in range(4)])\n    field.append([field[x][3 - x] for x in range(4)])\n \n     \n    hasdot = False\n    winner = None\n    for ln in field:\n        if '.' in ln:\n            hasdot = True\n            continue\n        if 'X' in ln and not ('O' in ln):\n            winner = 'X'\n            break\n        if 'O' in ln and not ('X' in ln):\n            winner = 'O'\n            break\n    n = i + 1\n    if not (winner or hasdot):\n        fout.write('Case #%i: Draw\\n' % n)\n    elif not winner and hasdot:\n        fout.write('Case #%i: Game has not completed\\n' % n)\n    else:\n        fout.write('Case #%i: %s won\\n' % (n, winner))"}
{"author": "pyronimous", "index": 27, "filename": "2013_2270488_2449486.py", "code": "fin = open('B-small-attempt0.in', 'r')\nfout = open('ass2.out', 'w')\n \n \nT = int(fin.readline())\n \ndef check(lawn, r, c):\n    h, v = True, True\n    for i in range(len(lawn[0])):\n        if i == c:\n            continue\n        if lawn[r][i] > lawn[r][c]:\n            h = False\n            break\n    for i in range(len(lawn)):\n        if i == r:\n            continue\n        if lawn[i][c] > lawn[r][c]:\n            v = False\n    return (h or v)\n \nfor i in range(T):\n    N, M = map(int, fin.readline().split())\n    lawn = []\n    for j in range(N):\n        lawn.append( map(int, fin.readline().split()) )\n \n    n = i + 1\n    ret = True\n    for j in range(len(lawn)):\n        if not ret: break\n        for k in range(len(lawn[0])):\n            if not check(lawn, j, k):\n                ret = False\n                fout.write('Case #%i: NO\\n' % n)\n                break\n    if ret:\n        fout.write('Case #%i: YES\\n' % n)"}
{"author": "pyronimous", "index": 27, "filename": "2012_1460488_1483485.py", "code": "\ninput_file = 'A-small-attempt0.in'\noutput_file = 'a_out'\n \ngooglerese = ''.join([\n\t'ejp mysljylc kd kxveddknmc re jsicpdrysi',\n\t'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',\n\t'de kr kd eoya kw aej tysr re ujdr lkgc jv',\n\t'y qee', 'z'\n])\n \nenglish = ''.join([\n\t'our language is impossible to understand',\n\t'there are twenty six factorial possibilities',\n\t'so it is okay if you want to just give up',\n\t'a zoo', 'q'\n])\n \nalphabet = {}\n \nfor g, e in zip(googlerese, english):\n\talphabet[g] = e\n \nlines = open(input_file, 'r').readlines()\nout = open(output_file, 'w')\n \nfor i, l in enumerate(lines[1:]):\n\ttrans = 'Case #%i: %s' % (\n\t\ti + 1, \n\t\t''.join([alphabet[c] for c in l if c in alphabet]))\n\tprint(trans)\n\tout.write(trans + '\\n')\n \nout.close()\n \n \t\n \t\n \n"}
{"author": "pyronimous", "index": 27, "filename": "2013_2270488_2463486.py", "code": "import math\n \nfin = open('C-small-attempt0.in', 'r')\nfout = open('ass3.out', 'w')\n \nT = int(fin.readline())\n \ndef perfsq(n):\n    sq = int(math.sqrt(n))\n    if n == sq * sq:\n        return sq\n    return 0\n \ndef palindrome(n):\n    s = str(n)\n    return (s == s[::-1])\n \ndef getpal(n):\n    if n == 1:\n        for i in range(10):\n            yield i\n    else:\n        n2 = n / 2\n        for x in xrange(10 ** (n2 - 1), 10 ** n2):\n            s = str(x)\n            if n % 2:\n                for i in range(10):\n                    ns = s + str(i) + s[::-1]\n                    yield int(ns)\n            else:\n                ns = s + s[::-1]\n                yield int(ns)\n \nfor i in range(T):\n    A, B = map(int, fin.readline().split())\n \n    ret = 0\n    for j in range(len(str(A)), len(str(B)) + 1):\n        for x in getpal(j):\n            if x < A:\n                continue\n            if x > B:\n                break\n            sq = perfsq(x)\n            if sq and palindrome(sq):\n                ret += 1\n    fout.write('Case #%i: %i\\n' % (i + 1, ret))\n"}
{"author": "pyronimous", "index": 27, "filename": "2014_2974486_5756407898963968.py", "code": "\n \nINPUT = 'A-small-attempt0.in'\nOUTPUT = 'A-small-attempt0.out'\n \n \ndef solve(answer1, arr1, answer2, arr2):\n    ret = None\n \n    for card in arr1[answer1 - 1]:\n        if card in arr2[answer2 - 1]:\n            if ret is not None:\n                return 'Bad magician!'\n            else:\n                ret = card\n    if ret is None:\n        return 'Volunteer cheated!'\n    return ret\n \nif __name__ == '__main__':\n    inp = open(INPUT)\n    out = open(OUTPUT, 'w')\n     \n    T = int(inp.readline())\n \n    def read_answer_and_arr():\n        answer = int(inp.readline())\n        arr = []\n        for i in range(4):\n            arr.append( map(int, inp.readline().split()) )\n        return answer, arr\n \n    for case in range(T):\n        answer1, arr1 = read_answer_and_arr()\n        answer2, arr2 = read_answer_and_arr()\n \n        out.write('Case #%i: %s\\n' % \\\n                        (case + 1, solve(answer1, arr1, answer2, arr2)))\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2014_2974486_5709773144064000.py", "code": "__author__ = 'Jeffrey'\n \ninFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\B-small-attempt0.in\"\noutFileName = inFileName[ : -2] + \"out\"\n \n \ndef parseInput(f):\n    T = int(f.readline())\n    L = []\n \n    for i in range(T):\n        L.append([float(i) for i in f.readline().split()])\n \n    return T, L\n \n \ndef calculateWinTime(C, F, X):\n    R = 2.0 # rate of cookie profit (cookies/s)\n    totalTime = 0.0\n    while (X / R >= C/R + X/(R + F)):\n        totalTime += C / R\n        R += F\n    return totalTime + X / R\n \n \ndef playGame(T,L):\n    for i in range(T):\n        result = calculateWinTime(L[i][0], L[i][1], L[i][2])\n        yield \"Case #\" + str(i + 1) + \": \" + \"{:0.7f}\".format(result)\n \n \nif __name__==\"__main__\":\n    iF = open(inFileName, 'r')\n    T, L = parseInput(iF)\n    iF.close()\n \n    print(T)\n    print(L)\n \n    oF = open(outFileName, \"wb\")\n    for out in playGame(T, L):\n        print(out)\n        # print(bytes(out, 'utf-8'), file=oF)\n        oF.write(bytes(out + \"\\n\",'utf-8'))\n    oF.close()\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2014_2974486_5690574640250880.py", "code": "__author__ = 'Jeffrey'\n \n# inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-sample.in\"\ninFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\n# inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-large.in\"\n \noutFileName = inFileName[: -2] + \"out\"\n \n \ndef parseInput(f):\n    T = int(f.readline())\n    L = []\n \n    for i in range(T):\n        L.append([int(i) for i in f.readline().split()])\n \n    return T, L\n \n \ndef calculateOneClick(R, C, M):\n    size = R * C\n    if R == 1 or C == 1 and M < size:\n        return generateWinBoardBaseCase(R, C, M)\n    elif size - M == 1:\n        return generateWinBoardBaseCase(R, C, M)\n    elif size - M >= 4:\n        return generateWinBoard(R, C, M)\n    return \"Impossible\"\n \ndef generateWinBoard(R,C,M):\n    emptySpace = R * C - M - 4\n    out = \"c\"\n    if C > 1:\n        out += \".\"\n        for i in range(2,C):\n            if emptySpace > 0:\n                out += \".\"\n                emptySpace -= 1\n            else:\n                out += \"*\"\n                # out += '\\n'\n    if R > 1:\n        out += '\\n'\n        out += \".\"\n        if C > 1:\n            out += \".\"\n        for i in range(2,C):\n            if emptySpace > 0:\n                out += \".\"\n                emptySpace -= 1\n            else:\n                out += \"*\"\n    for r in range(2,R):\n        out += '\\n'\n        for c in range(C):\n            if emptySpace > 0:\n                out += \".\"\n                emptySpace -= 1\n            else:\n                out += \"*\"\n    return out\n \ndef generateWinBoardBaseCase(R,C,M):\n    emptySpace = R * C - M - 1\n    out = \"c\"\n    if C > 1:\n        for c in range(1,C):\n            if emptySpace > 0:\n                out += \".\"\n                emptySpace -= 1\n            else:\n                out += \"*\"\n    for r in range(1,R):\n        out += '\\n'\n        for c in range(C):\n            if emptySpace > 0:\n                out += \".\"\n                emptySpace -= 1\n            else:\n                out += \"*\"\n    return out\n \n \ndef playGame(T, L):\n    for i in range(T):\n        result = calculateOneClick(L[i][0], L[i][1], L[i][2])\n        yield \"Case #\" + str(i + 1) + \":\\n\" + str(result)\n \n \nif __name__ == \"__main__\":\n    iF = open(inFileName, 'r')\n    T, L = parseInput(iF)\n    iF.close()\n \n    print(T)\n    print(L)\n \n    oF = open(outFileName, \"wb\")\n    for out in playGame(T, L):\n        print(out)\n        # print(bytes(out, 'utf-8'), file=oF)\n        oF.write(bytes(out + \"\\n\", 'utf-8'))\n    oF.close()\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2012_1460488_1595491.py", "code": "data_dict = {}\ninit = False\n \n \ndef partB(infile=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt\",\\\n            outfile=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt\"):\n     \n    #Reading input\n    linesA = []\n    for line in open(infile, 'r'):\n        linesA.append(line.strip())\n \n    outA = []\n         \n    #Parsing Input\n    T = int(linesA[0])\n    for i in range(1, 1 + T):\n        caseA = linesA[i].split()\n        N = int(caseA[0])\n        S = int(caseA[1])\n        P = int(caseA[2])\n         \n        #these will be exclusive\n        over_norm = 0\n        over_supr = 0\n         \n        #Calculating answer\n        for t in [int(conv) for conv in caseA[3:3+N]]:\n            if data_dict[t][0] >= P:\n                over_norm += 1\n            elif data_dict[t][1] >= P:\n                over_supr += 1\n         \n        outA.append(over_norm + min(over_supr, S))\n             \n             \n         \n     \n    #Writing Output\n    out = open(outfile, 'w')\n    print(\"\\nOUTPUT\")\n    for i in range(1, 1 + T):\n        if i != 1:\n            out.write(\"\\n\")\n        print(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n        out.write(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n    out.close()\n \ndef dict_helper(total, depth=0, lowest=10):\n    pass\n \n#Brute forcing this because my girlfriend is in my bed right now waiting for me\n#Its also running fast enough that it doesnt seem worth being clever\ndef build_dict():\n    for i in range(31):\n        fullA = []\n        maxN = 0\n        maxS = 0\n        print(str(i) + \": \")\n        for a1 in range(0,11):\n            for a2 in range(0,11):\n                for a3 in range(0,11):\n                    if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):\n                        fullA.append((a1,a2,a3))\n                         \n                        print(\"\\t\", fullA[-1],)\n                        if max(a1,a2,a3)-min(a1,a2,a3) == 2:\n                            print(\"*\")\n                            maxS = max(maxN, max(a1,a2,a3))\n                        else:\n                            print(maxN = max(maxN, max(a1,a2,a3)))\n        data_dict[i]=[maxN, maxS]\n    init = True\n     \nif __name__ == \"__main__\":\n    build_dict()\n    partB()\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2013_2270488_2453486.py", "code": "def checkRow(r):\n\tc = r[0];\n \t\n\t# making sure it isnt an empty line\n\tif (c == '.'):\n\t\treturn (False, None)\n \t\t\n\tfor i in range(1,4):\n\t\tif not (r[i] == c or r[i] == 'T'):\n\t\t\treturn (False, None)\n \t\n\t# if it got this far it must be right\n\treturn (True, c)\n \ndef checkCol(L, col):\n\tc = L[0][col];\n \t\n\t# making sure it isnt an empty line\n\tif (c == '.'):\n\t\treturn (False, None)\n \t\t\n\tfor i in range(1,4):\n\t\tif not (L[i][col] == c or L[i][col] == 'T'):\n\t\t\treturn (False, None)\n \t\n\t# if it got this far it must be right\n\treturn (True, c)\n \t\ndef checkDiag(L):\n\tc = L[0][0];\n \t\n\tfor i in range(1,4):\n\t\tif not (L[i][i] == c or L[i][i] == 'T'):\n\t\t\tbreak\n\telse:\n\t\tif (c != '.'):\n\t\t\t# if it got this far it must be right\n\t\t\treturn (True, c)\n \t\n\t#first diag failed\n\tc = L[0][3];\n \t\n\t# making sure it isnt an empty line\n\tif (c == '.'):\n\t\treturn (False, None)\n \t\t\n\tfor i in range(1,4):\n\t\tif not (L[i][3-i] == c or L[i][3-i] == 'T'):\n\t\t\tbreak\n\telse:\n\t\t# if it got this far it must be right\n\t\treturn (True, c)\n \t\t\n\treturn (False, None)\n \t\t\ndef checkComplete(L):\n\tfor i in range(4):\n\t\tif '.' in L[i]:\n\t\t\treturn False\n\treturn True\n \ndef TicTacToeTomek(infile=\"A-small-attempt0.in\", outfile=\"A-small-attempt0.out\"):\n\tf = open(infile, 'r')\n\tout = open(outfile, 'w')\n \t\n\t# get the number of tests\n\tn = int(f.readline().strip())\n \t\n\tfor t in range(1, n + 1):\n\t\tL = []\n\t\t# loading game\n\t\tfor i in range(4):\n\t\t\tL.append(f.readline().strip());\n \t\t\n\t\t# checking game state\n\t\tfor i in range(4):\n\t\t\t#checking row\n\t\t\tresult = checkRow(L[i])\n\t\t\tif result[0]:\n\t\t\t\tout.write(\"Case #\" + str(t) + \": \" + result[1] + \" won\\n\")\n\t\t\t\tbreak\n\t\t\t#checking column\n\t\t\tresult = checkCol(L,i)\n\t\t\tif result[0]:\n\t\t\t\tout.write(\"Case #\" + str(t) + \": \" + result[1] + \" won\\n\")\n\t\t\t\tbreak\n\t\telse:\n\t\t\t#checking column\n\t\t\tresult = checkDiag(L)\n\t\t\tif result[0]:\n\t\t\t\tout.write(\"Case #\" + str(t) + \": \" + result[1] + \" won\\n\")\n\t\t\telse:\n\t\t\t\tif checkComplete(L):\n\t\t\t\t\tout.write(\"Case #\" + str(t) + \": Draw\\n\")\n\t\t\t\telse:\n\t\t\t\t\tout.write(\"Case #\" + str(t) + \": Game has not completed\\n\")\n \t\t\t\t\n\t\tf.readline() #skipping empty line\n \t\n\t#closing files\n\tf.close()\n\tout.close()\n \t\n\t#so I dont need to cat the file after\n\tf = open(outfile, 'r')\n\tprint(f.read())\n\tf.close()\n \t\n \t\nif __name__ == \"__main__\":\n    TicTacToeTomek()"}
{"author": "j3ffreysmith", "index": 28, "filename": "2013_2270488_2449486.py", "code": "from array import array\n \ndef Lawnmower(infile=\"B-small-attempt0.in\", outfile=\"B-small-attempt0.out\"):\n\tinF = open(infile, 'r')\n\toutF = open(outfile, 'w')\n \t\n\tfor t in range(1, int(inF.readline().strip()) + 1):\n\t\t#read grid size\n\t\ttemp = inF.readline().strip().split()\n\t\tN = int(temp[0])\n\t\tM = int(temp[1])\n\t\tL = []\n \t\t\n\t\tfor i in range(N):\n\t\t\tL.append(inF.readline().strip().split()) #using an array should speed up the lookups\n\t\t\tfor j in range(M):\n\t\t\t\tL[i][j] = int(L[i][j])\n \t\t\n\t\tfor y in range(N):\n\t\t\tfor x in range(M):\n\t\t\t\t# check horizontal\n\t\t\t\tfor i in range(M):\n\t\t\t\t\tif L[y][i] > L[y][x]:\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tcontinue\n \t\t\t\t\n\t\t\t\t# check vertical\n\t\t\t\tfor i in range(N):\n\t\t\t\t\tif L[i][x] > L[y][x]:\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tcontinue\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcontinue\n\t\t\tbreak\n\t\telse:\n\t\t\t#good\n\t\t\toutF.write(\"Case #\" + str(t) + \": YES\\n\")\n\t\t\tcontinue\n\t\t#bad\n\t\toutF.write(\"Case #\" + str(t) + \": NO\\n\")\n \t\n\t#closing files\n\tinF.close()\n\toutF.close()\n \t\n\t#so I dont need to cat the file after\n\tf = open(outfile, 'r')\n\tprint(f.read())\n\tf.close()\n \t\n \t\nif __name__ == \"__main__\":\n    Lawnmower()"}
{"author": "j3ffreysmith", "index": 28, "filename": "2012_1460488_1483485.py", "code": "from string import maketrans\n \nf = \"abcdefghijklmnopqrstuvwxyz\"\no = \"ynficwlbkuomxsevzpdrjgthaq\"\n         \ndef partAfile(infile=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/input.txt\",\\\n            outfile=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/output.txt\"):\n    tempF = open(infile, 'r')\n    tempA = []\n    for line in tempF:\n        tempA.append(line.strip())\n         \n    N = int(tempA[0])\n     \n    out = open(outfile, 'w')\n    for i in range(1, 1+N):\n        if i != 1:\n            out.write(\"\\n\")\n        print(\"Case #\" + str(i) + \": \" +tempA[i].translate(maketrans(o,f)))\n        out.write(\"Case #\" + str(i) + \": \" +tempA[i].translate(maketrans(o,f)))\n         \n     \nif __name__ == \"__main__\":\n    partAfile()\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2013_2270488_2463486.py", "code": "import math\n \n#wont help, runs out of memory for 10^100\n# palindromeCache = {} #ideally this is precalculated\n \n# def isPalindrome(S):\n\t# s = str(S) #so I dont need to make sure its a string\n\t# if s in palindromeCache:\n\t\t# return palindromeCache[s]\n \t\t\n\t# palindromeCache[s] = True\n\t# for i in range(len(s)//2):\n\t\t# if not s[i] == s[-1 - i]:\n\t\t\t# palindromeCache[s] = False\n\t\t\t# break\n\t# return palindromeCache[s]\n \t\ndef isPalindrome(S):\n\ts = str(S) #so I dont need to make sure its a string\n\tfor i in range(len(s)//2):\n\t\tif not s[i] == s[-1 - i]:\n\t\t\treturn False\n\treturn True\n \ndef FairAndSquare(infile=\"C-small-attempt0.in\", outfile=\"C-small-attempt0.out\"):\n\tinF = open(infile, 'r')\n\toutF = open(outfile, 'w')\n \t\n\tfor t in range(1, int(inF.readline().strip()) + 1):\n\t\ttemp = inF.readline().strip().split()\n\t\tA = long(temp[0])\n\t\tB = long(temp[1])\n\t\tcount = long(0)\n \t\t\n\t\ti = long(math.ceil(math.sqrt(A)))\n\t\tm = long(math.floor(math.sqrt(B)))\n\t\twhile i <= m:\n\t\t\tif isPalindrome(i):\n\t\t\t\tif isPalindrome(i**2):\n\t\t\t\t\tcount += 1\n\t\t\ti += 1\n \t\t\t\t\t\n\t\toutF.write(\"Case #\" + str(t) + \": \" + str(count) + \"\\n\")\n \t\n\t#closing files\n\tinF.close()\n\toutF.close()\n \t\n\t#so I dont need to cat the file after\n\tf = open(outfile, 'r')\n\tprint(f.read())\n\tf.close()\n \t\n \t\nif __name__ == \"__main__\":\n    FairAndSquare()"}
{"author": "j3ffreysmith", "index": 28, "filename": "2014_2974486_5756407898963968.py", "code": "__author__ = 'Jeffrey'\n \ninFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\noutFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\n \n \ndef parseInput(f):\n    T = int(f.readline())\n    L = []\n \n    for i in range(T):\n        picks = []\n        cards = []\n        for j in range(2):\n            picks.append( int(f.readline()))\n            tempL = []\n            for k in range(4):\n                tempL.append( [int(j) for j in f.readline().split()])\n            cards.append(tempL)\n        L.append((picks, cards))\n \n    return T, L\n \n \ndef performTrick(picks, cards):\n    matchFound = False\n    matchedCard = None\n    for card in cards[0][picks[0] - 1]:\n        possibleMatch = card in cards[1][picks[1] - 1]\n        if possibleMatch and matchFound:\n            return \"Bad magician!\"\n        elif possibleMatch:\n            matchFound = True\n            matchedCard = card\n    if matchFound:\n        return matchedCard\n    else:\n        return \"Volunteer cheated!\"\n \n \ndef playGame(T,L):\n    for i in range(T):\n        result = performTrick(L[i][0], L[i][1])\n        yield \"Case #\" + str(i + 1) + \": \" + str(result)\n \n \nif __name__==\"__main__\":\n    iF = open(inFileName, 'r')\n    T, L = parseInput(iF)\n    iF.close()\n \n    oF = open(outFileName, \"wb\")\n    for out in playGame(T, L):\n        # print(out)\n        # print(bytes(out, 'utf-8'), file=oF)\n        oF.write(bytes(out + \"\\n\",'utf-8'))\n    oF.close()\n"}
{"author": "yoba", "index": 29, "filename": "2014_2974486_5709773144064000.py", "code": "for i in range(int(input())):\n \n    c, f, x = tuple(map(float, str.split(input())))\n \n    base_time = 0.0\n    base_rate = 2.0\n    farms_count = 0\n    best_time = None\n \n    current_time = base_time + x / (base_rate + farms_count * f)\n \n    while best_time is None or best_time > current_time:\n \n        best_time = current_time\n        base_time += c / (base_rate + farms_count * f)\n        farms_count += 1\n \n        current_time = base_time + x / (base_rate + farms_count * f)\n \n    print(str.format(\"Case #{}: {}\", i + 1, best_time))\n"}
{"author": "yoba", "index": 29, "filename": "2014_2974486_5690574640250880.py", "code": "import itertools\n \n \n'''\n...\n...\n...\n...\n...\n'''\n \nfor i in range(int(input())):\n \n    r, c, m = tuple(map(int, str.split(input())))\n    count = r * c - m\n    field = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\n    answer = \"Impossible\"\n \n    if m == 0:\n \n        answer = field\n \n    elif 1 in (r, c):\n \n        for p in itertools.islice(itertools.product(range(c), range(r)), count):\n \n            field[p] = \".\"\n \n        answer = field\n \n    elif count in (0, 2, 3, 5, 7):\n \n        pass\n \n    elif count == 1:\n \n        answer = field\n \n    elif count // 2 < c or count == c * 2 + 1:\n \n        if count % 2 != 0:\n \n            tail = 3\n            ncount = count - 3\n \n        else:\n \n            tail = 0\n            ncount = count\n \n        for x in range(ncount // 2):\n \n            field[(x, 0)] = field[(x, 1)] = \".\"\n \n        for x in range(tail):\n \n            field[(x, 2)] = \".\"\n \n        answer = field\n \n    elif not (c == 2 and count % c == 1):\n \n        for x in range(c):\n \n            field[(x, 0)] = field[(x, 1)] = \".\"\n \n        count -= 2 * c\n        tail = 0\n        if count % c == 1:\n \n            tail = 2\n            count -= 1\n \n        y = 2\n        while count > 0:\n \n            rx = min(count, c)\n            for x in range(rx):\n \n                field[(x, y)] = \".\"\n \n            count -= rx\n            y += 1\n \n        for x in range(tail):\n \n            field[(x, y)] = \".\"\n \n        answer = field\n \n    field[(0, 0)] = \"c\"\n    print(str.format(\"Case #{}:\", i + 1))\n    if isinstance(answer, dict):\n \n        for y in range(r):\n \n            print(str.join(\"\", map(lambda x: field[(x, y)], range(c))))\n \n    else:\n \n        print(answer)\n"}
{"author": "yoba", "index": 29, "filename": "2012_1460488_1595491.py", "code": "def passes(p, t): #normal, surprising\n    q, r = divmod(t, 3)\n    if r == 0:\n        return q >= p, q + 1 >= p and q\n    elif r == 1:\n        return q + 1 >= p, q + 1 >= p and q\n    elif r == 2:\n        return q + 1 >= p, q + 2 >= p\n \nfor case in range(int(input())):\n    st = input().strip().split()\n    n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))\n    result = 0\n    for i in t:\n        normal, surprising = passes(p, i)\n        if normal:\n            result += 1\n        elif surprising and s != 0:\n            result += 1\n            s -= 1\n    print(\"Case #{}: {}\".format(case + 1, result))\n"}
{"author": "yoba", "index": 29, "filename": "2013_2270488_2453486.py", "code": "def yoba(s, ch):\n    lines = [True] * 10\n    for i in range(4):\n        for j in range(4):\n            lines[j] = lines[j] and (s[i][j] in (ch, \"T\"))\n            lines[j + 4] = lines[j + 4] and (s[j][i] in (ch, \"T\"))\n        lines[8] = lines[8] and (s[i][i] in (ch, \"T\"))\n        lines[9] = lines[9] and (s[3 - i][i] in (ch, \"T\"))\n    return any(lines)\n \nfor i in range(int(input())):\n    s = tuple(map(lambda _: input(), range(4)))\n \n    if yoba(s, \"X\"):\n        ans = \"X won\"\n    elif yoba(s, \"O\"):\n        ans = \"O won\"\n    elif \".\" not in \"\".join(s):\n        ans = \"Draw\"\n    else:\n        ans = \"Game has not completed\"\n \n    input()\n    print(\"Case #{}: {}\".format(i + 1, ans))\n"}
{"author": "yoba", "index": 29, "filename": "2013_2270488_2449486.py", "code": "from itertools import chain\n \n \nfor i in range(int(input())):\n    n, m = tuple(map(int, input().split()))\n    l = dict(chain.from_iterable(map(lambda j: zip(zip([j] * m, range(m)), map(int, input().split())), range(n))))\n    ans = \"YES\"\n \n    while len(l):\n        ly, lx = min(l, key=l.get)\n        lowest = l[(ly, lx)]\n \n        if all(map(lambda j: l.get((ly, j), lowest) == lowest, range(m))):\n            for j in range(m):\n                l.pop((ly, j), None)\n \n        elif all(map(lambda j: l.get((j, lx), lowest) == lowest, range(n))):\n            for j in range(n):\n                l.pop((j, lx), None)\n \n        else:\n            ans = \"NO\"\n            break\n \n    print(\"Case #{}: {}\".format(i + 1, ans))\n"}
{"author": "yoba", "index": 29, "filename": "2012_1460488_1483485.py", "code": "for case in range(int(input())):\n    a, b = tuple(map(int, input().split()))\n    result = 0\n    ast, bst = str(a), str(b)\n    for x in range(a, b + 1):\n        xst = str(x)\n        added = list()\n        for j in range(len(xst)):\n            xstr = xst[j:] + xst[:j]\n            if xstr < ast or xstr > bst:\n                continue\n            elif xst < xstr and xstr not in added:\n                added.append(xstr)\n                result += 1\n    print(\"Case #{}: {}\".format(case + 1, result))\n"}
{"author": "yoba", "index": 29, "filename": "2013_2270488_2463486.py", "code": "def sqrt(x, ge):\n    if x == 1:\n        return 1\n    sx = x >> 1\n    step = sx >> 1\n \n    while step:\n        if sx ** 2 >= x:\n            sx = sx - step\n        else:\n            sx = sx + step\n        step = step >> 1\n \n    if ge:\n        while not sx ** 2 < x:\n            sx = sx - 1\n        while not sx ** 2 >= x:\n            sx = sx + 1\n    else:\n        while not sx ** 2 > x:\n            sx = sx + 1\n        while not sx ** 2 <= x:\n            sx = sx - 1\n \n    return sx\n \n \ndef get_start_pali(a):\n    s = str(a)\n    ls = len(s)\n    if ls == 1:\n        return s, True\n    elif ls & 1:\n        return s[:ls >> 1 + 1], True\n    else:\n        return s[:ls >> 1], False\n \n \ndef get_next_pali(p, m):\n    if len(p) == p.count(\"9\"):\n        if m:\n            return \"1\" + \"0\" * (len(p) - 1), False\n        else:\n            return \"1\" + \"0\" * len(p), True\n    else:\n        return str(int(p) + 1), m\n \n \ndef pali_to_num(p, m):\n    if m:\n        return int(p + p[-2::-1])\n    else:\n        return int(p + p[::-1])\n \n \ndef is_pali(a):\n    s = str(a)\n    hls = len(s) >> 1\n    return s[:hls] == s[:-hls - 1:-1]\n \nfor i in range(int(input())):\n    a, b = tuple(map(int, input().split()))\n    sqa, sqb = sqrt(a, True), sqrt(b, False)\n \n    p, m = get_start_pali(sqa)\n    while pali_to_num(p, m) < sqa:\n        p, m = get_next_pali(p, m)\n \n    count = 0\n \n    while True:\n        curr = pali_to_num(p, m)\n        if curr > sqb:\n            break\n        if is_pali(curr ** 2):\n            count = count + 1\n        p, m = get_next_pali(p, m)\n \n    print(\"Case #{}: {}\".format(i + 1, count))\n"}
{"author": "yoba", "index": 29, "filename": "2014_2974486_5756407898963968.py", "code": "def read_case():\n \n    answer = int(input())\n    lines = tuple(map(lambda _: set(str.split(input())), range(4)))\n    return lines[answer - 1]\n \n \nfor i in range(int(input())):\n \n    intersection = read_case() & read_case()\n    count = len(intersection)\n    if count == 1:\n \n        answer = intersection.pop()\n \n    elif count > 1:\n \n        answer = \"Bad magician!\"\n \n    elif count < 1:\n \n        answer = \"Volunteer cheated!\"\n \n    print(str.format(\"Case #{}: {}\", i + 1, answer))\n"}
{"author": "eko", "index": 30, "filename": "2014_2974486_5709773144064000.py", "code": "import unittest\n \nimport sys\n \n \n \n#tCase = sys.stdin.readline().split()\ntCase = int(sys.stdin.readline())\n \ndef calcTemp(taxa, X):\n\treturn X/taxa;\n \ndef main(C, F, X):\n \n\ttaxa = 2.0\n\tresp = 0\n \t\n \t\n\twhile True:\n\t\t#print(calcTemp(taxa, X), C/taxa + calcTemp(taxa + F, X), resp)\n\t\tif C/taxa + calcTemp(taxa + F, X) < calcTemp(taxa, X):\n\t\t\tresp += C/taxa\n\t\t\ttaxa += F\t\t\t\n\t\telse:\n\t\t\tresp += calcTemp(taxa, X)\n\t\t\treturn resp\n \t\n \t\n\treturn 0\n \t\t\n  \nif __name__ == '__main__':\n\t#unittest.main()\n\tfor i in xrange(tCase):\t\n\t\t#frase = [str(x) for x in sys.stdin.readline().split(' ')]\t\n\t\t#print(\"Case #%d: %s\" % (i + 1, main(frase[0])))\n \t\t\n\t\t##Numbers\n\t\tC, F, X = [float(x) for x in sys.stdin.readline().split(' ')]\n\t\t#print(A, B, NList, BList)\n\t\tprint(\"Case #%d: %s\" % (i + 1, main(C, F, X)))"}
{"author": "eko", "index": 30, "filename": "2014_2974486_5690574640250880.py", "code": "import os, re, sys\nimport unittest\n \n \n#tCase = sys.stdin.readline().split()\ntCase = int(sys.stdin.readline())\n \n \ndef map(R, C, Bombs):\n\tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n\tprint (Bombs)\n\tm[R-1][C-1] = 'c'\n\tlastSkip = False\n\t#for b in xrange(Bombs):\n\tfor i in xrange(R):\n\t\tfor j in xrange(C):\n\t\t\tif Bombs == 0:\n\t\t\t\tbreak\n \t\t\t\n\t\t\tif lastSkip:\n\t\t\t\tm[i][j] = 'f'\n\t\t\t\tcontinue\n \t\t\t\n\t\t\tif R - i == 2 or C - j == 2:\n\t\t\t\tif Bombs == 1:\n\t\t\t\t\tm[i][j] = 'f'\n\t\t\t\t\tlastSkip = True\n\t\t\t\t\tcontinue\n \t\t\t\n \t\t\t\t\n\t\t\tm[i][j] = '*'\n\t\t\tBombs -= 1\n\t\t\tlastSkip = False\n\t\tlastSkip = False\n \t\t\t\t\n \t\n \t\n\tfor line in m:\n\t\tfor c in line:\n\t\t\tprint (c,)\n\t\tprint\n \t\t\n \t\t\ndef imprimir(m):\n\tfor line in m:\n\t\tfor c in line:\n\t\t\tprint (c,)\n\t\tprint\n \t\t\ndef map2(R, C, Bombs):\n\tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n\t#print Bombs\n\tm[R-1][C-1] = 'c'\n\tlastSkip = False\n\t#for b in xrange(Bombs):\n \t\n\tii = 0\n\tjj = 0\n\twhile Bombs > 0:\n\t\tfor j in xrange(jj, C):\n\t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n\t\t\t\tm[ii][j] = '*'\n\t\t\t\tBombs -= 1\n\t\t\telse:\n\t\t\t\tcontinue\n \t\t\n \t\t\n\t\tfor i in xrange(ii+1, R):\n\t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n\t\t\t\tm[i][jj] = '*'\n\t\t\t\tBombs -= 1\n\t\t\telse:\n\t\t\t\tif Bombs > 0:\n\t\t\t\t\tprint (\"Impossible\")\n\t\t\t\t\t#imprimir(m)\n\t\t\t\t\treturn\n\t\t\t\tcontinue\n\t\tjj += 1\n\t\tii += 1\n\t#print \"b\", Bombs\n\timprimir(m)\n \t\n \t\t\t\t\n \t\n \t\n \n \t\t\ndef main(R, C, M):\n\tvazios = R * C - M\n \n\tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n\t\tmap2(R, C, M)\n\telse:\n\t\tprint (\"Impossible\")\n \n\t#print vazios\n\treturn \"\"\n \t\t\n  \nif __name__ == '__main__':\n\t#unittest.main()\n\tfor i in xrange(tCase):\t\n\t\t#frase = [str(x) for x in sys.stdin.readline().split(' ')]\t\n\t\t#print \"Case #%d: %s\" % (i + 1, main(frase[0]))\n \t\t\n\t\t##Numbers\n\t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n\t\t#YList = [float(x) for x in sys.stdin.readline().split(' ')]\n\t\t#ZList = [float(x) for x in sys.stdin.readline().split(' ')]\n\t\t#print E,R,N, NList\n\t\tprint (\"Case #%d:\" % (i + 1))\n\t\tmain(R, C, M)"}
{"author": "eko", "index": 30, "filename": "2012_1460488_1595491.py", "code": "import sys, os\nimport re\n \ntCase = int(sys.stdin.readline())\n \ndef alien(frases,case):\n \t\n\tcase = case.replace('(','[')\n\tcase = case.replace(')',']')\n\t#print(frases,case)\n \t\n\tER1 = re.compile(case, re.I)\n\tcount = 0\n\tfor frase in frases:\n\t\t#print(ER1.search(frase))\n\t\tif ER1.search(frase):\n\t\t\tcount += 1\n\treturn count\n \n \nfor i in xrange(tCase):\t\n\tlinha = sys.stdin.readline().split()\n\t#S = linha[0]\n\tP = int(linha[1])\n\tT = int(linha[2])\n\tlist = []\n\tfor j in range (3,len(linha)):\n\t\tlist.append(int(linha[j]))\n\tlist.sort(reverse=True)\n\t#print(S,P,T,list)\n\trealT = T*3 - 2\n\tsupT = realT - 2\n \t\n\tcount = 0\n\tfor item in list:\n\t\tif item >= realT:\n\t\t\tcount += 1\n\t\telif P > 0 and item >= supT and T >= 2:\n\t\t\tcount += 1\n\t\t\tP -= 1\n\t\telif P > 0 and item >= realT and T == 1:\n\t\t\tcount += 1\n\t\t\tP -= 1\n\t\telif T == 0:\n\t\t\tcount += 1\n\t\telse:\n\t\t\tbreak\n \t\t\n\t#case.append(frase)\n\tprint(\"Case #%d: %d\" % (i+1, count))\n \t\n \t\n \n"}
{"author": "eko", "index": 30, "filename": "2013_2270488_2453486.py", "code": "import os, re, sys\nimport unittest\n \nclass Test(unittest.TestCase):\n\tdef test_1(self):\n\t\tself.assertEqual(main('XXXT', '....', 'OO..', '....'), 'X won')\n\tdef test_2(self):\n\t\tself.assertEqual(main('XOXT', 'XXOO', 'OXOX', 'XXOO'), 'Draw')\n\tdef test_3(self):\n\t\tself.assertEqual(main('XOX.', 'OX..', '....', '....'), 'Game has not completed')\n\tdef test_4(self):\n\t\tself.assertEqual(main('OOXX', 'OXXX', 'OX.T', 'O..O'), 'O won')\n\tdef test_5(self):\n\t\tself.assertEqual(main('XXXO', '..O.', '.O..', 'T...'), 'O won')\n\tdef test_6(self):\n\t\tself.assertEqual(main('OXXX', 'XO..', '..O.', '...O'), 'O won')\n \n#tCase = sys.stdin.readline().split()\ntCase = int(sys.stdin.readline())\n \ndef main(l1, l2, l3, l4):\n \t\n\tresul = ganhador(l1[0], l1[1], l1[2], l1[3])\n \t\n\tif resul == 0:\n\t\treturn 'X won'\n\telif resul == 1:\n\t\treturn 'O won'\n \t\t\n\tresul = ganhador(l2[0], l2[1], l2[2], l2[3])\n \t\n\tif resul == 0:\n\t\treturn 'X won'\n\telif resul == 1:\n\t\treturn 'O won'\n \t\t\n\tresul = ganhador(l3[0], l3[1], l3[2], l3[3])\n \t\n\tif resul == 0:\n\t\treturn 'X won'\n\telif resul == 1:\n\t\treturn 'O won'\n \t\t\n\tresul = ganhador(l4[0], l4[1], l4[2], l4[3])\n \t\n\tif resul == 0:\n\t\treturn 'X won'\n\telif resul == 1:\n\t\treturn 'O won'\n \t\t\n\t# coluna\n\tresul = ganhador(l1[0], l2[0], l3[0], l4[0])\n \t\n\tif resul == 0:\n\t\treturn 'X won'\n\telif resul == 1:\n\t\treturn 'O won'\n \n\tresul = ganhador(l1[1], l2[1], l3[1], l4[1])\n \t\n\tif resul == 0:\n\t\treturn 'X won'\n\telif resul == 1:\n\t\treturn 'O won'\n \n\tresul = ganhador(l1[2], l2[2], l3[2], l4[2])\n \t\n\tif resul == 0:\n\t\treturn 'X won'\n\telif resul == 1:\n\t\treturn 'O won'\n \n\tresul = ganhador(l1[3], l2[3], l3[3], l4[3])\n \t\n\tif resul == 0:\n\t\treturn 'X won'\n\telif resul == 1:\n\t\treturn 'O won'\n \n\t# /\n\tresul = ganhador(l1[3], l2[2], l3[1], l4[0])\n \t\n\tif resul == 0:\n\t\treturn 'X won'\n\telif resul == 1:\n\t\treturn 'O won'\n \n\t# \\\n\tresul = ganhador(l1[0], l2[1], l3[2], l4[3])\n \t\n\tif resul == 0:\n\t\treturn 'X won'\n\telif resul == 1:\n\t\treturn 'O won'\n \t\n\tif '.' in l1 or '.' in l2 or '.' in l3 or '.' in l4:\n\t\treturn 'Game has not completed'\n\telse:\n\t\treturn 'Draw'\n \t\n \t\ndef ganhador(a, b, c, d):\n\tx = 0\n\to = 0\n\tp = 0\n\tif a == 'X':\n\t\tx += 1\n\t\tp += 1\n\tif a == 'O':\n\t\to += 1\n\t\tp += 1\n\tif a == 'T':\n\t\tx += 1\n\t\to += 1\n\t\tp += 1\n\tif b == 'X':\n\t\tx += 1\n\t\tp += 1\n\tif b == 'O':\n\t\to += 1\n\t\tp += 1\n\tif b == 'T':\n\t\tx += 1\n\t\to += 1\n\t\tp += 1\n\tif c == 'X':\n\t\tx += 1\n\t\tp += 1\n\tif c == 'O':\n\t\to += 1\n\t\tp += 1\n\tif c == 'T':\n\t\tx += 1\n\t\to += 1\n\t\tp += 1\n\tif d == 'X':\n\t\tx += 1\n\t\tp += 1\n\tif d == 'O':\n\t\to += 1\n\t\tp += 1\n\tif d == 'T':\n\t\tx += 1\n\t\to += 1\n\t\tp += 1\t\n\tif x == 4:\n\t\treturn 0\n\telif o == 4:\n\t\treturn 1\n\telif p == 4:\n\t\treturn 2\n\telse: # incompleto\n\t\treturn 3\n  \nif __name__ == '__main__':\n\t#unittest.main()\n\tfor i in xrange(tCase):\t\n\t\tl1 = [str(x) for x in sys.stdin.readline().split(' ')]\n\t\tl2 = [str(x) for x in sys.stdin.readline().split(' ')]\t\n\t\tl3 = [str(x) for x in sys.stdin.readline().split(' ')]\t\n\t\tl4 = [str(x) for x in sys.stdin.readline().split(' ')]\n\t\tnulo = [str(x) for x in sys.stdin.readline().split(' ')]\t\t\n\t\tprint(\"Case #%d: %s\" % (i + 1, main(l1[0], l2[0], l3[0], l4[0])))\n \t\t\n\t\t##Numbers\n\t\t#N,M = [int(x) for x in sys.stdin.readline().split(' ')]\t\n\t\t#print(\"Case #%d: %d\" % (i + 1, main(N,M)))"}
{"author": "eko", "index": 30, "filename": "2013_2270488_2449486.py", "code": "import os, re, sys, math\nimport unittest\nfrom numpy import *\n \nclass Test(unittest.TestCase):\n\tdef test_1(self):\n\t\tself.assertEqual(main(1, 4), 2)\n\tdef test_2(self):\n\t\tself.assertEqual(main(10, 120), 0)\n\tdef test_3(self):\n\t\tself.assertEqual(main(100, 100000000000000), 2)\n \ntCase = int(sys.stdin.readline())\n \n \ndef main(matriz, M, N):\n\t#print(matriz)\n \t\n\tfor i in xrange(M):\n\t\tfor j in xrange(N):\n\t\t\tana = matriz[i + 1, j + 1]\n\t\t\t#print(ana)\n\t\t\tmaiores_linha = 0\n\t\t\tfor x in xrange(M + 2):\n\t\t\t\tif matriz[x, j + 1] > ana:\n\t\t\t\t\tmaiores_linha += 1\n \t\t\t\n\t\t\tif maiores_linha == 0:\n\t\t\t\tcontinue\n \t\t\t\n\t\t\tmaiores_coluna = 0 \n\t\t\tfor y in xrange(N + 2):\n\t\t\t\tif matriz[i + 1, y] > ana:\n\t\t\t\t\tmaiores_coluna += 1\n \t\t\t\t\t\n\t\t\tif maiores_linha >= 1 and maiores_coluna >= 1:\n\t\t\t\t#print(ana, maiores_linha, maiores_coluna)\n\t\t\t\treturn 'NO'\n \t\t\t\t\n\treturn 'YES'\n \t\n \n \n \t\nif __name__ == '__main__':\n\t#unittest.main()\n\tfor i in xrange(tCase):\t\n\t\t##Numbers\n\t\tN,M = [int(x) for x in sys.stdin.readline().split(' ')]\n \t\t\n\t\tmatriz = zeros((N + 2, M + 2), dtype=int)\n \t\t\n\t\tfor j in xrange(N + 2):\n\t\t\tmatriz[j][0] = 0\n\t\t\tmatriz[j][M + 1] = 0\n \t\t\t\n\t\tfor j in xrange(M + 2):\n\t\t\tmatriz[0][j] = 0\n\t\t\tmatriz[N + 1][j] = 0\n \t\t\n\t\tfor k in xrange(N):\n\t\t\tj = 1\n\t\t\tline = [str(x) for x in sys.stdin.readline().split(' ')]\n\t\t\tfor n in line:\n\t\t\t\tmatriz[k + 1][j] = n\t\t\n\t\t\t\tj += 1\n\t\t#matriz = zeros((N + 2, M + 2), dtype=int)\n \t\t\n\t\tprint(\"Case #%d: %s\" % (i + 1, main(matriz, N, M)))"}
{"author": "eko", "index": 30, "filename": "2012_1460488_1483485.py", "code": "import sys, os\nimport re\n \nfLine = sys.stdin.readline().split()\ntCase = int(fLine[0])\n \n \ndic = {\t\t'a':'y',\n\t\t\t'b':'h',\n\t\t\t'c':'e',\n\t\t\t'd':'s',\n\t\t\t'e':'o',\n\t\t\t'f':'c',\n\t\t\t'g':'v',\n\t\t\t'h':'x',\n\t\t\t'i':'d',\n\t\t\t'j':'u',\n\t\t\t'k':'i',\n\t\t\t'l':'g',\n\t\t\t'm':'l',\n\t\t\t'n':'b',\n\t\t\t'o':'k',\n\t\t\t'p':'r',\n\t\t\t'q':'z',\n\t\t\t'r':'t',\n\t\t\t's':'n',\n\t\t\t't':'w',\n\t\t\t'u':'j',\n\t\t\t'v':'p',\n\t\t\t'w':'f',\n\t\t\t'x':'m',\n\t\t\t'y':'a',\n\t\t\t'z':'q',\n\t\t\t'\\n':'',\n\t\t\t' ':' '}\\n \\n \\ndef alien(frase):\\n\tresul = \"\"\n\tfor c in frase:\n\t\tresul += dic[c]\n \n\treturn resul\n \n \n \nfrases = []\nfor i in xrange(tCase):\n\tfrase = sys.stdin.readline().replace(\"\\n\",\"\")\n\tfrases.append(frase)\n \t\n \nfor i in xrange(tCase):\t\n\t#case.append(frase)\n\tprint(\"Case #%d: %s\" % (i+1, alien(frases[i])))\n \t\n \t\n \n"}
{"author": "eko", "index": 30, "filename": "2013_2270488_2463486.py", "code": "import os, re, sys, math\nimport unittest\n \nclass Test(unittest.TestCase):\n\tdef test_1(self):\n\t\tself.assertEqual(main(1, 4), 2)\n\tdef test_2(self):\n\t\tself.assertEqual(main(10, 120), 0)\n\tdef test_3(self):\n\t\tself.assertEqual(main(100, 100000000000000), 2)\n \n#tCase = sys.stdin.readline().split()\ntCase = int(sys.stdin.readline())\n \n \ndef main(M, N):\n\tfns = 0\n\tnum = M\n\tmaior = math.sqrt(N)\n\tint_maior = 0\n \t\n\tif maior.is_integer():\n\t\tint_maior = int(maior) - 1\n\t\tif fair(N):\n\t\t\tif fair(int(maior)):\n\t\t\t\tfns += 1\n\telse:\n\t\tint_maior = int(maior)\n \t\t\n\twhile int_maior >= 1:\n\t\tif fair(int_maior):\n\t\t\tquadrado = int_maior * int_maior\n\t\t\tif quadrado >= M:\n\t\t\t\tif fair(quadrado):\n\t\t\t\t\tfns += 1\n\t\tint_maior -= 1\n\treturn fns\n \ndef main2(M, N):\n\tfns = 0\n\tnum = M\n\t#for num in xrange(M, N + 1):\n\twhile num <= N:\n\t\tresult = raiz(num)\n\t\tif result:\n\t\t\tif fair(num):\n \t\t\t\n\t\t\t\tif fair(result):\n\t\t\t\t\tfns += 1\n\t\t\t\t\t#print(num)\n\t\t#yield i\n\t\tnum += 1\n\t\t#print(raiz(num))\n\treturn fns\n \t\ndef fair(num):\n\treturn str(num) == str(num)[::-1]\n\t#return True\n \t\ndef raiz(num):\n\tresult = math.sqrt(num)\n\t#result = 1.0\n\tif result.is_integer():\n\t\treturn int(result)\n\telse:\n\t\treturn False\n \t\nif __name__ == '__main__':\n\t#unittest.main()\n\tfor i in xrange(tCase):\t\n\t\t#l1 = [str(x) for x in sys.stdin.readline().split(' ')]\t\t\n\t\t#print(\"Case #%d: %s\" % (i + 1, main(l1[0], l2[0], l3[0], l4[0])))\n \t\t\n\t\t##Numbers\n\t\tN,M = [int(x) for x in sys.stdin.readline().split(' ')]\t\n\t\tprint(\"Case #%d: %d\" % (i + 1, main(N,M)))"}
{"author": "eko", "index": 30, "filename": "2014_2974486_5756407898963968.py", "code": "import unittest\n \nimport sys\n \n \nclass Test(unittest.TestCase):\n\tdef test_1(self):\n\t\tself.assertEqual(main(5, 2, 2, [2,1]), 12)\n\tdef test_2(self):\n\t\tself.assertEqual(main(5,2,2,[1,2]), 12)\n\tdef test_3(self):\n\t\tself.assertEqual(main(3,3,4,[4,1,3,5]), 39)\n\tdef test_4(self):\n\t\tself.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\n \n \n#tCase = sys.stdin.readline().split()\ntCase = int(sys.stdin.readline())\n \ndef main(A, B, AList, BList):\n\tresp = 0\n\tA = A - 1\n\tB = B - 1\n\tAlist = AList[A*4:A*4+4]\n\tBList = BList[B*4:B*4+4]\n\tcont = 0\n\t#print(Alist, BList)\n\tfor aa in Alist:\n\t\tif aa in BList:\n\t\t\tresp = aa\n\t\t\tcont += 1\n \t\t\n\tif cont == 1:\n\t\treturn resp\n\telif cont == 0:\n\t\treturn \"Volunteer cheated!\"\n\telse:\n\t\treturn \"Bad magician!\"\n \t\t\n  \nif __name__ == '__main__':\n\t#unittest.main()\n\tfor i in xrange(tCase):\t\n\t\t#frase = [str(x) for x in sys.stdin.readline().split(' ')]\t\n\t\t#print(\"Case #%d: %s\" % (i + 1, main(frase[0])))\n \t\t\n\t\t##Numbers\n\t\tA = [int(x) for x in sys.stdin.readline().split(' ')][0]\n\t\tNList = [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tB = [int(x) for x in sys.stdin.readline().split(' ')][0]\n\t\tBList = [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\t#print(A, B, NList, BList)\n\t\tprint(\"Case #%d: %s\" % (i + 1, main(A, B, NList, BList)))"}
{"author": "shishkander", "index": 31, "filename": "2014_2974486_5709773144064000.py", "code": "def CASE(IN):\n    def rstr(): return IN.readline().strip()\n    def rint(): return int(rstr())\n    def rints(): return map(int, rstr().split())\n    def rfs(): return map(float, rstr().split())\n    c, f, x = rfs()\n    b = 2.0\n    if x <= c:\n        return x/b\n    t = 0\n    while True:\n        # we can buy a farm now, should we?\n        tf = x/(b+f) + c/b\n        tn = x/b\n        if tn <= tf:\n            return t + tn\n        t += c/b\n        b += f\n \n \ndef RUN(IN, OUT):\n    t = int(IN.readline().strip())\n    for i in xrange(1,t+1):\n        OUT.write(\"Case #%i: %.7f\\n\" % (i, CASE(IN)))\n \nif __name__ == \"__main__\":\n    import sys\n    RUN(sys.stdin, sys.stdout)\n"}
{"author": "shishkander", "index": 31, "filename": "2014_2974486_5690574640250880.py", "code": "def get_a(r, c, f='.'):\n    A = []\n    for i in xrange(r):\n        A.append([f] * c)\n    return A\n \n \ndef apply(A, r, c, B):\n    for i, b in enumerate(B):\n        for j, v in enumerate(b):\n            A[r + i][c + j] = v\n \n \ndef draw(A):\n    if A is None:\n        return '\\nImpossible'\n    res = ['']\n    for a in A:\n        res.append(''.join(a))\n    return '\\n'.join(res)\n \n \ndef trans(A):\n    if not A:\n        return None\n    B = get_a(len(A[0]), len(A))\n    for i, a in enumerate(A):\n        for j, v in enumerate(a):\n            B[j][i] = v\n    return B\n \n \ndef check(A, m, r, c):\n    if A is None:\n        return True\n    cnts = {'c': 0, '*': 0, '.': 0}\n    #print(draw(A))\n    #print(assert len(A) == r)\n    for i in xrange(r):\n        assert len(A[i]) == c\n        for j in xrange(c):\n            cnts[A[i][j]] += 1\n    #print(m, r, c, \"=>\", cnts)\n    assert cnts['*'] == m\n    assert cnts['c'] == 1\n    assert cnts['.'] == r * c - m - 1\n \n \ndef CASE(IN):\n    def rstr():\n        return IN.readline().strip()\n \n    def rint():\n        return int(rstr())\n \n    def rints():\n        return map(int, rstr().split())\n    r, c, m = rints()\n    A = solve(m, r, c)\n    if A:\n        A[-1][-1] = 'c'\n    check(A, m, r, c)\n    return draw(A)\n \n \ndef solve(m, r, c):\n    if r > c:\n        return trans(solve(m, c, r))\n    assert r <= c\n    assert m != r * c\n    e = r * c - m\n    # we click always in the right bottom corner\n    if e == 1:\n        A = get_a(r, c, '*')\n        return A\n    if r == 1:\n        A = get_a(1, c, '.')\n        for i in xrange(m):\n            A[0][i] = '*'\n        return A\n    if r == 2:\n        if e == 2 or e % 2 == 1:\n            return None\n        A = get_a(2, c, '.')\n        assert m % 2 == 0\n        for i in xrange(m / 2):\n            A[0][i] = A[1][i] = '*'\n        return A\n    assert r >= 3\n    A = get_a(r, c, '*')\n    if e in (2, 3, 5, 7):\n        return None\n    E = [c] * (e / c) + ([e % c] if e % c else [])\n    if sum(E) < e:\n        E.append(e % c)\n        assert sum(E) == e\n    if len(E) == 1:\n        E = [e / 2] * 2\n        if sum(E) < e:\n            e.append(1)\n    if E[0] != E[1]:\n        s = sum(E[:2])\n        E[0] = E[1] = s / 2\n        if sum(E[:2]) != s:\n            assert len(E) == 2\n            E.append(1)\n    if E[-1] == 1:\n        if len(E) > 3:\n            E[-2] -= 1\n            E[-1] += 1\n        else:\n            E[0] -= 1\n            E[1] -= 1\n            E[2] += 2\n    for i in xrange(len(E)):\n        for j in xrange(E[i]):\n            A[-i - 1][-j - 1] = '.'\n    return A\n \n \ndef RUN(IN, OUT):\n    t = int(IN.readline().strip())\n    for i in xrange(1, t + 1):\n        OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\n \nif __name__ == \"__main__\":\n    import sys\n    RUN(sys.stdin, sys.stdout)\n"}
{"author": "shishkander", "index": 31, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/env python\n \n \nimport cPickle\n \nD1 = {} # no suprize\nD2 = {} # surprize\nfor i in xrange(0, 31):\n    D1[i] = D2[i] = -1\n \ndef precompute():\n    for a in xrange(0, 11):\n        for b in xrange(a, min(a+3,11)):\n            for c in xrange(b, min(a+3,11)):\n                t = a+b+c\n                assert a <= b <= c <= a+2 and c <= 11\n                if c < a+2:\n                    D1[t] = max(D1[t], c)\n                else: # that is, c == a+2, we have a suprize\n                    D2[t] = max(D2[t], c)\n \n#    for k in D1:\n#        print(k, D2[k] - D1[k])\n \nprecompute()\n#import cPickle\n#with open(\"prec\",\"wb\") as f:\n#    cPickle.dump((D1, D2), f )\n#print(D1, D2)\n \ndef case(S, P, ts):\n    res_n = 0\n    res_s = 0\n    for t in ts:\n        if D1[t] >= P:\n            res_n+=1\n        elif D2[t]>=P:\n            res_s+=1\n    return (res_n + min(res_s, S))\n \n \ndef solve(fin, fout):\n    T = int(fin.readline())\n    for t in xrange(T):\n        nums = map(int, fin.readline().strip().split(\" \"))\n        N, S, P = nums[:3]\n        ts = nums[3:]\n        assert len(ts) == N    \n        fout.write(\"Case #%i: %i\\n\" % (t+1, case(S,P,ts)) )\n    return True\n \nif __name__ == \"__main__\":\n    import sys\n    with open(sys.argv[1],'r') as fin:\n        with open(sys.argv[2], 'w') as fout:\n            solve(fin, fout)\n"}
{"author": "shishkander", "index": 31, "filename": "2013_2270488_2453486.py", "code": "def test_win(M, c):\n    N = len(M)\n    def yielder():\n        for row in M:\n            yield row, 'row'\n        for i in xrange(N):\n            yield [row[i] for row in M], 'col'\n        yield [M[i][i] for i in xrange(N)], 'd1'\n        yield [M[i][N-i-1] for i in xrange(N)], 'd2'\n    for lst, typ in yielder():\n        if all(l == c or l == 'T' for l in lst):\n            #print(\"won at %s %s\" % (lst, typ))\n            return True\n    return False\n \ndef CASE(IN):\n    def rstr(): return IN.readline().strip()\n    def rint(): return int(rstr())\n    def rints(): return map(int, rstr().split())\n    M = [rstr() for i in xrange(4)]\n    rstr()\n    #print(M)\n    if test_win(M, 'X'):\n        return 'X won'\n    if test_win(M, 'O'):\n        return 'O won'\n    if any('.' in row for row in M):\n        return 'Game has not completed'\n    return 'Draw'\n \ndef RUN(IN, OUT):\n    t = int(IN.readline().strip())\n    for i in xrange(1,t+1):\n        OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\n \nif __name__ == \"__main__\":\n    import sys\n    RUN(sys.stdin, sys.stdout)\n"}
{"author": "shishkander", "index": 31, "filename": "2013_2270488_2449486.py", "code": "from itertools import izip\n \ndef CASE(IN):\n    def rstr(): return IN.readline().strip()\n    def rint(): return int(rstr())\n    def rints(): return map(int, rstr().split())\n    def nrints(N): return [rints() for i in xrange(N)]\n    N, M = rints()\n    A = nrints(N)\n    R = [max(row) for row in A]\n    C = [max(col) for col in izip(*A)]\n    for i, r in enumerate(R):\n        for j, c in enumerate(C):\n            if A[i][j] != min(r,c):\n                return \"NO\"\n    return \"YES\"\n \ndef RUN(IN, OUT):\n    t = int(IN.readline().strip())\n    for i in xrange(1,t+1):\n        OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\n \nif __name__ == \"__main__\":\n    import sys\n    RUN(sys.stdin, sys.stdout)\n"}
{"author": "shishkander", "index": 31, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/env python\n \nIN = \"\"\"\nejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv\"\"\"\nOUT =\"\"\"\nCase #1: our language is impossible to understand\nCase #2: there are twenty six factorial possibilities\nCase #3: so it is okay if you want to just give up\"\"\"\n \nins = IN.strip().split(\"\\n\")\nouts = OUT.strip().split(\"\\n\")\nassert len(ins) == len(outs) == 3\n \nD = {}\nD['a'] = 'y'\nD['o'] = 'e'\nD['z'] = 'q'\n \nfor case, s in enumerate(ins):\n    out = outs[case][9:] # skip \"Case #?: \"\n    assert len(out) == len(s)\n    for i, o in enumerate(out):\n        if o == ' ': continue\n        D[s[i]] = o\n \nif len(D) == 25:\n    chars = map(chr, xrange(97, 123))\n    key = set(chars).difference( set(D.keys()) ).pop()\n    value = set(chars).difference( set(D.values()) ).pop()\n    D[key] = value\nassert len(D) == 26\nD[' '] = ' '\\n \\n \\ndef solve(fin, fout):\\n    T = int(fin.readline())\\n    for t in xrange(T):\\n        fout.write(\"Case #%i: \" % (t+1) )\\n        for c in fin.readline().strip():\\n            fout.write(D[c])\\n        fout.write('\\n')\n    return True\n \nif __name__ == \"__main__\":\n    import sys\n    with open(sys.argv[1],'r') as fin:\n        with open(sys.argv[2], 'w') as fout:\n            solve(fin, fout)\n"}
{"author": "shishkander", "index": 31, "filename": "2013_2270488_2463486.py", "code": "import itertools, sys, os\nfrom itertools import *\nimport time, heapq\n \ndef pal(s):\n    for i in xrange(len(s)/2):\n        if s[i] != s[-i-1]:\n            return False\n    return True\n \ndef pal2(x, s):\n    return pal(s) and pal(str(x*x))\n \ndef E(k):\n    return 10**k\n \n \ndef CREATE_DATABASE(MAX):\n    def init():\n        yield 1\n        yield 2\n        yield 3\n        yield 11\n        yield 22\n        for i in xrange(1, MAX):\n            yield 1*E(2*i) + 1\n            yield 1*E(2*i+1) + 1\n            #yield 1*E(2*i + 1) + 1\n            #yield 1*E(2*i) + 1 + 2*E(i)\n            yield 2*E(2*i) + 2\n            yield 2*E(2*i) + 2 + 1*E(i)\n            yield 2*E(2*i+1) + 2\n             \n             \n    heap = list(sorted(set(init())))\n    for i in heap:\n        print(i)\n    heapq.heapify(heap)\n    RES = []\n    try:\n        MAX_X = E(MAX)\n        print(\"MAX_X\", MAX_X)\n        while True:\n            x = heapq.heappop(heap)\n            #print(x)\n            RES.append(x)\n            if x == 3:\n                continue\n            if x > MAX_X:\n                break\n            s = str(x)\n            j = len(s) / 2\n            shift = 1 if len(s) == 2*j else 0\n            for i in xrange(j+1, MAX):\n                n = E(2*i-shift) + 1 + E(i-j) * x\n                if pal2(n,str(n)):\n                    #print((\"{:^%i} => {:^%i}\" % (2*MAX, 2*MAX)).format(x, n))\n                    heapq.heappush(heap, n)\n                 \n    except KeyboardInterrupt:\n        print(\"stopped while x is\", x)\n    with open(\"c.database\", 'w') as f:\n        for i in sorted(RES + heap):\n            f.write(\"%i\\n\"%i)\n \ndef READ_DATABASE():\n    with open(\"c.database\", 'r') as f:\n        return sorted(map(lambda x: int(x.strip())**2, f))\nDB = READ_DATABASE()\n \nfrom bisect import bisect_left, bisect_right\ndef CASE(IN):\n    def rstr(): return IN.readline().strip()\n    def rint(): return int(rstr())\n    def rints(): return map(int, rstr().split())\n    def nrints(N): return [rints() for i in xrange(N)]\n    A, B = rints()\n    i = bisect_left(DB, A) \n    j = bisect_right(DB, B)\n    return j-i\n \ndef RUN(IN, OUT):\n    t = int(IN.readline().strip())\n    for i in xrange(1,t+1):\n        OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\n \nif __name__ == \"__main__\":\n    # CREATE_DATABASE(52)\n    import sys\n    RUN(sys.stdin, sys.stdout)\n"}
{"author": "shishkander", "index": 31, "filename": "2014_2974486_5756407898963968.py", "code": "def CASE(IN):\n    def rstr(): return IN.readline().strip()\n    def rint(): return int(rstr())\n    def rints(): return map(int, rstr().split())\n    def rr():\n        x = rint()\n        m = [rints() for i in xrange(4)]\n        return set(m[x-1])\n    s = rr().intersection(rr())\n    if not s:\n        return \"Volunteer cheated!\"\n    if len(s) == 1:\n        return s.pop()\n    return \"Bad magician!\"\n \n \ndef RUN(IN, OUT):\n    t = int(IN.readline().strip())\n    for i in xrange(1,t+1):\n        OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\n \nif __name__ == \"__main__\":\n    import sys\n    RUN(sys.stdin, sys.stdout)\n"}
{"author": "caethan", "index": 32, "filename": "2014_2974486_5709773144064000.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n#for the Google Code Jam programming contest\n \n###############################################################################\n# Imports go here\n###############################################################################\n \n#For faster numerical analysis\nimport numpy as np\n \nimport sys\n \n#Needed for the memoization decorator\nimport collections\nimport functools\n \n###############################################################################\n# Global variables (for caching, etc.) go here\n###############################################################################\n \n###############################################################################\n# Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\n###############################################################################\n \nclass memoize(object):\n    \"\"\"Decorator. Caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned\n    (not reevaluated).\n    \"\"\"\n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n    def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n            # uncacheable. a list, for instance.\n            # better to not cache than blow up.\n            return self.func(*args)\n        if args in self.cache:\n            return self.cache[args]\n        else:\n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n    def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n    def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n \n###############################################################################\n# Functions\n###############################################################################\n \ndef precalculate():\n    \"\"\"Perform any calculations that need to be performed before the main path\n    (e.g., preparing lookup tables, etc.)\n     \n    N.B. Make sure you make any important variables global so that other\n    functions can access them.\n    \"\"\"\n    pass\n \ndef read_input(infile):\n    \"\"\"This function should take an open input file, load in all of the\n    relevant information for a single case of the problem, and output it\n    as a single object.    \n    \"\"\"\n    #Some utility functions to read in particular types of input\n    def read_int():\n        return int(infile.readline().strip())\n    def read_ints():\n        return np.array(infile.readline().split(), dtype=int)\n    def read_bigints(): #For ints that won't fit directly in an int32 array\n        line = infile.readline().split()\n        return np.array(map(lambda x: int(x), line))\n    def read_float():\n        return float(infile.readline().strip())\n    def read_floats():\n        return np.array(infile.readline().split(), dtype=float)\n    def read_string():\n        return infile.readline().strip()\n    def read_strings():\n        return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n     \n    C, F, X = read_floats()\n     \n    case = (C, F, X)\n     \n    return case\n \ndef solve_case(case):\n    \"\"\"Take the input data (structured in case) and perform any necessary\n    calculations to obtain the desired output, formatted as the appropriate\n    string.    \n    \"\"\"\n    C, F, X = case\n     \n    rate = 2.0\n    cookies = 0.0\n    time = 0.0\n     \n    #If it takes more cookies to buy a farm than we need to win, just wait and win:\n    if C >= X:\n        return X / rate\n     \n    while cookies < X:\n        #If we don't have enough cookies to buy a farm, we have to wait until we do\n        if cookies < C:\n            wait_time = (C - cookies) / rate\n            time += wait_time\n            cookies = C\n        #Now we do have enough cookies to buy a farm. Should we keep waiting or buy?\n        time_if_wait = (X - C) / rate\n        time_if_buy = X / (rate + F)\n        if time_if_wait < time_if_buy:\n            return time + time_if_wait\n        else:\n            rate += F\n            cookies = 0.0\n \n###############################################################################\n# Main execution path\n###############################################################################\n \nif __name__ == \"__main__\":\n    #Do any pre-calculations required\n    precalculate()\n     \n    #Open up the input & output files based on the provided input file\n    assert len(sys.argv) == 2 #only one argument\n    assert sys.argv[1][-3:] == \".in\" #input must end with .in\n    infile = open(\"%s\" % sys.argv[1], 'r')\n    outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n     \n    #Read in the number of cases (the first input line) to iterate through\n    cases = int(infile.readline().strip('\\n'))\n    for i in range(cases):\n         \n        #Read in the input data for this case\n        case = read_input(infile)\n         \n        #Solve the problem for this case\n        output = solve_case(case)\n         \n        #Write out the output of this case\n        outfile.write('Case #%i: %s\\n' % (i+1, output))\n        print ('Case #%i: %s\\n' % (i+1, output))\n     \n    #Close files\n    infile.close()\n    outfile.close()"}
{"author": "caethan", "index": 32, "filename": "2014_2974486_5690574640250880.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n#for the Google Code Jam programming contest\n \n###############################################################################\n# Imports go here\n###############################################################################\n \n#For faster numerical analysis\nimport numpy as np\n \nimport sys\n \n#Needed for the memoization decorator\nimport collections\nimport functools\n \n###############################################################################\n# Global variables (for caching, etc.) go here\n###############################################################################\n \n###############################################################################\n# Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\n###############################################################################\n \nclass memoize(object):\n    \"\"\"Decorator. Caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned\n    (not reevaluated).\n    \"\"\"\n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n    def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n            # uncacheable. a list, for instance.\n            # better to not cache than blow up.\n            return self.func(*args)\n        if args in self.cache:\n            return self.cache[args]\n        else:\n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n    def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n    def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n \n###############################################################################\n# Functions\n###############################################################################\n \ndef precalculate():\n    \"\"\"Perform any calculations that need to be performed before the main path\n    (e.g., preparing lookup tables, etc.)\n     \n    N.B. Make sure you make any important variables global so that other\n    functions can access them.\n    \"\"\"\n    pass\n \ndef read_input(infile):\n    \"\"\"This function should take an open input file, load in all of the\n    relevant information for a single case of the problem, and output it\n    as a single object.    \n    \"\"\"\n    #Some utility functions to read in particular types of input\n    def read_int():\n        return int(infile.readline().strip())\n    def read_ints():\n        return np.array(infile.readline().split(), dtype=int)\n    def read_bigints(): #For ints that won't fit directly in an int32 array\n        line = infile.readline().split()\n        return np.array(map(lambda x: int(x), line))\n    def read_float():\n        return float(infile.readline().strip())\n    def read_floats():\n        return np.array(infile.readline().split(), dtype=float)\n    def read_string():\n        return infile.readline().strip()\n    def read_strings():\n        return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n     \n    R, C, M = read_ints()\n     \n    return R, C, M\n \ndef solve_case(case):\n    \"\"\"Take the input data (structured in case) and perform any necessary\n    calculations to obtain the desired output, formatted as the appropriate\n    string.    \n    \"\"\"\n    R, C, M = case\n     \n    free = R * C - M\n    assert free >= 1\n     \n    board = np.zeros((R, C), dtype=int) - 1\n     \n    def write_board(board):\n        d = {0:'.', 1:'c', 2:'*'}\n        s = \"\\n\"\n        for row in board:\n            for num in row:\n                try:\n                    s += d[num]\n                except KeyError:\n                    #s += \"X\"\n                    raise ValueError(\"Board not filled in!\")\n            s += \"\\n\"\n        return s\n     \n    #Clicking in the corner is always optimal!\n    board[0,0] = 1\n     \n    #Always possible with no mines!\n    if M == 0:\n        board[board == -1] = 0\n        return write_board(board)\n     \n    #Always possible with one free square, if you click on the free square.\n    if free == 1:\n        #Fill all the empty squares in with mines\n        board[board == -1] = 2\n        return write_board(board)\n         \n     \n    #Fill in the shortest sides while we have enough mines to do so:\n    while min(R, C) <= M:\n        if R < C:\n            board[:,C-1] = 2\n            C -= 1\n            M -= R\n        elif C <= R:\n            board[R-1,:] = 2\n            R -= 1\n            M -= C\n     \n    def cascades(board, r, c):\n        rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\n        cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\n        for r in rows:\n            for c in cols:\n                if board[r,c] == 2: #Mine next to given position\n                    return False\n        return True\n     \n    #If we have no mines left, we win as long as the initial click cascades:\n    if M == 0:\n        board[board == -1] = 0\n        if cascades(board, 0, 0):\n            return write_board(board)\n        else:\n            return \"\\nImpossible\"\n     \n    #Now we have a rectangular free space with less than a full row or column\n    #to fill.\n     \n    #If there's so many mines that we fill in all but one square on either\n    #the row or column, it can't be done.\n    if M > (R + C - 5):\n        return \"\\nImpossible\"\n         \n    if M > 0 and (R <= 2 or C <= 2):\n        return \"\\nImpossible\"\n         \n    #Otherwise, we fill in mines from the corner opposite to the click\n    print (M, R + C - 5)\n    fill_num = min(M, R - 2)\n    print (M, fill_num)\n    board[(R - fill_num):,C-1] = 2\n    M -= fill_num\n     \n    fill_num = min(M, C - 3)\n    print (M, fill_num)\n    board[R-1,(C - fill_num - 1):] = 2\n    M -= fill_num\n    #assert M == 0\n     \n    board[board == -1] = 0\n    return write_board(board)\n \n###############################################################################\n# Main execution path\n###############################################################################\n \nif __name__ == \"__main__\":\n    #Do any pre-calculations required\n    precalculate()\n     \n    #Open up the input & output files based on the provided input file\n    assert len(sys.argv) == 2 #only one argument\n    assert sys.argv[1][-3:] == \".in\" #input must end with .in\n    infile = open(\"%s\" % sys.argv[1], 'r')\n    outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n     \n    #Read in the number of cases (the first input line) to iterate through\n    cases = int(infile.readline().strip('\\n'))\n    for i in range(cases):\n         \n        #Read in the input data for this case\n        case = read_input(infile)\n         \n        #Solve the problem for this case\n        output = solve_case(case)\n         \n        #Write out the output of this case\n        outfile.write('Case #%i: %s\\n' % (i+1, output))\n        print ('Case #%i: %s\\n' % (i+1, output))\n     \n    #Close files\n    infile.close()\n    outfile.close()"}
{"author": "caethan", "index": 32, "filename": "2012_1460488_1595491.py", "code": "#Code copyright Brett Olsen, 2012\n \n#Standard imports\nimport numpy as N\n \n#Some switching behavior to set standard input/output files\n#Set these three variables to adjust behavior\ncase = 1\nproblem = \"B\"\npractice = False\n \nif practice:\n    practice = \"-practice\"\nelse:\n    practice = \"-attempt0\"\nif case == 0:\n    infile = open(\"%s-%s%s.in\" % (problem, \"sample\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (problem, \"sample\", practice), 'w')        \nelif case == 1:\n    infile = open(\"%s-%s%s.in\" % (problem, \"small\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (problem, \"small\", practice), 'w')    \nelif case == 2:\n    infile = open(\"%s-%s%s.in\" % (problem, \"large\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (problem, \"large\", practice), 'w')   \nelse:\n    raise (ValueError, 'Invalid case')\n     \n#Hash table:  -1 is never, +1 is always, 0 is sometimes\nlookup = {}\n \ndef check_total(total, p):\n    assert type(total) == int\n    resid = total % 3\n \n    min_nosurprise = (total / 3)    \n    max_nosurprise = (total / 3) + min(1, resid)\n     \n    #print min_nosurprise, max_nosurprise\n     \n    #If the residual is 1, then being surprising won't change the max value\n    #similarly, if we're already at the maximum, it can't change\n    #similarly, if residual is 0 and the min value is already 0, it can't change\n    if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):\n        if max_nosurprise >= p:\n            return 1\n        else:\n            return -1\n \n    if max_nosurprise >= p:\n        return 1\n    elif max_nosurprise == p-1:\n        return 0\n    else:\n        return -1\n     \n#Read in the number of cases (the first input line) we need to iterate through\ncases = int(infile.readline().strip('\\n'))\nfor i in range(cases):\n    print ('case %i of %i' % (i+1, cases))\n##################NEW CODE GOES HERE###########################################    \n    #Read in all relevant data for each case\n    line = infile.readline().split()\n    N = int(line[0])\n    S = int(line[1])\n    p = int(line[2])\n    points = []\n    for item in line[3:]:\n        points.append(int(item))\n    assert N == len(points)\n    assert p <= 10\n    assert p >= 0\n    assert S >= 0\n    assert S <= N\n     \n    always = 0\n    possible = 0\n     \n    for total in points:\n        if (total, p) in lookup:\n            depends = lookup[total, p]\n        else:\n            depends = check_total(total, p)\n         \n        if depends == 1:\n            always += 1\n        elif depends == 0:\n            possible += 1\n     \n    #Do calculations to generate the output\n    output = '%i' % (always + min(possible, S))\n     \n##################NEW CODE GOES HERE###########################################    \n    #Write out the results for this case\n    outfile.write('Case #%i: %s\\n' % (i+1, output))\n     \n#Close files\ninfile.close()\noutfile.close()"}
{"author": "caethan", "index": 32, "filename": "2013_2270488_2453486.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n#for the Google Code Jam programming contest\n \n###############################################################################\n# Imports go here\n###############################################################################\n \nfrom __future__ import division\nimport numpy as np\n \n###############################################################################\n# Global variables (for caching, etc.) go here\n###############################################################################\n \n#Set up the input/output files: problem-tagsuffix.in / *.out\nproblem = \"A\"\ntag = \"small\" #commonly sample, small, or large\nsuffix = \"-attempt1\" #used sometimes for indexing later input files\n \n###############################################################################\n# Helper functions go here\n###############################################################################\n \ndef read_input(infile):\n    \"\"\"This function should take an open input file, load in all of the\n    relevant information for a single case of the problem, and output it\n    as a single object.    \n    \"\"\"\n    #Some utility functions to read in particular types of input\n    def read_int():\n        return int(infile.readline().strip())\n    def read_ints():\n        return np.array(infile.readline().split(), dtype=int)\n    def read_float():\n        return float(infile.readline().strip())\n    def read_floats():\n        return np.array(infile.readline().split(), dtype=float)\n    def read_string():\n        return infile.readline().strip()\n    def read_strings():\n        return np.array(infile.readline().split(), dtype=object) #change the dtype?\n     \n    board = np.empty((4,4), dtype=int)\n     \n    dic = {'X': 1, 'T': 2, 'O': 3, '.': 4}\n     \n    #Read in rows\n    for i in range(4):\n        line = read_string()\n        for j in range(4):\n            board[i,j] = dic[line[j]]\n    infile.readline()\n     \n    return board\n \ndef iswin(row):\n    if 4 in row:\n        return None #gap\n    if (row <= 2).all():\n        return \"X won\"\n    if (row >= 2).all():\n        return \"O won\"\n    return None\n \ndef solve_case(case):\n    \"\"\"Take the input data (structured in case) and perform any necessary\n    calculations to obtain the desired output, formatted as the appropriate\n    string.    \n    \"\"\"\n     \n    board = case\n \n    #Look for win conditions\n    for i in range(4):\n        row = board[i,:]\n        if iswin(row) is not None:\n            return iswin(row)\n         \n    for i in range(4):\n        col = board[:,i]\n        if iswin(col) is not None:\n            return iswin(col)\n         \n    vals = np.arange(4)\n    diag = board[vals,vals]\n    if iswin(diag) is not None:\n        return iswin(diag)\n     \n    diag = board[vals, vals[::-1]]\n    if iswin(diag) is not None:\n        return iswin(diag)\n \n    #Check if the board is completed (has empty squares left)\n    if 4 in board:\n        return \"Game has not completed\"\n     \n    return \"Draw\"\n \n###############################################################################\n# Main execution path\n###############################################################################\n \nif __name__ == \"__main__\":\n    #Open up the input & output files\n    infile = open(\"%s-%s%s.in\" % (problem, tag, suffix), 'r')\n    outfile = open(\"%s-%s%s.out\" % (problem, tag, suffix), 'w')\n     \n    #Read in the number of cases (the first input line) to iterate through\n    cases = int(infile.readline().strip('\\n'))\n    for i in range(cases):\n         \n        #Read in the input data for this case\n        case = read_input(infile)\n         \n        #Solve the problem for this case\n        output = solve_case(case)\n         \n        #Write out the output of this case\n        outfile.write('Case #%i: %s\\n' % (i+1, output))\n        print('Case #%i: %s\\n' % (i+1, output))\n     \n    #Close files\n    infile.close()\n    outfile.close()"}
{"author": "caethan", "index": 32, "filename": "2013_2270488_2449486.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n#for the Google Code Jam programming contest\n \n###############################################################################\n# Imports go here\n###############################################################################\n \nfrom __future__ import division\nimport numpy as np\n \n###############################################################################\n# Global variables (for caching, etc.) go here\n###############################################################################\n \n#Set up the input/output files: problem-tagsuffix.in / *.out\nproblem = \"B\"\ntag = \"small\" #commonly sample, small, or large\n#tag = \"large\"\n#tag = \"sample\"\nsuffix = \"-attempt0\" #used sometimes for indexing later input files\n#suffix = \"\"\n \n###############################################################################\n# Helper functions go here\n###############################################################################\n \n \ndef read_input(infile):\n    \"\"\"This function should take an open input file, load in all of the\n    relevant information for a single case of the problem, and output it\n    as a single object.    \n    \"\"\"\n    #Some utility functions to read in particular types of input\n    def read_int():\n        return int(infile.readline().strip())\n    def read_ints():\n        return np.array(infile.readline().split(), dtype=int)\n    def read_float():\n        return float(infile.readline().strip())\n    def read_floats():\n        return np.array(infile.readline().split(), dtype=float)\n    def read_string():\n        return infile.readline().strip()\n    def read_strings():\n        return np.array(infile.readline().split(), dtype=object) #change the dtype?\n     \n    N, M = read_ints()\n     \n    lawn = np.empty((N, M), dtype=int)\n    for i in range(N):\n        row = read_ints()\n        assert len(row) == M\n        lawn[i,:] = row\n     \n    return lawn\n \ndef solve_case(case):\n    \"\"\"Take the input data (structured in case) and perform any necessary\n    calculations to obtain the desired output, formatted as the appropriate\n    string.    \n    \"\"\"\n     \n    lawn = case\n    undefined = np.zeros(lawn.shape, dtype=bool)\n     \n    colvals, rowvals = np.meshgrid(range(lawn.shape[1]), range(lawn.shape[0]))\n     \n    while not undefined.all():\n        #Find the lowest still-defined point in the lawn\n        valid = undefined == False\n        minval = lawn[valid].min()\n     \n        minindex = np.where(lawn[valid] == minval)[0][0]\n        minrow = rowvals[valid][minindex]\n        mincol = colvals[valid][minindex]\n        #Check to see if this point's row could have been mowed\n        if (lawn[minrow,:][valid[minrow,:]] == minval).all():\n            #Undefine this row\n            undefined[minrow,:] = True\n            continue\n         \n        #Otherwise, check to see if this point's column could have been mowed\n        if (lawn[:,mincol][valid[:,mincol]] == minval).all():\n            #Undefine this column\n            undefined[:,mincol] = True\n            continue\n         \n        #Otherwise, it's invalid!\n        return \"NO\"\n     \n    return \"YES\"\n \n###############################################################################\n# Main execution path\n###############################################################################\n \nif __name__ == \"__main__\":\n    #Open up the input & output files\n    infile = open(\"%s-%s%s.in\" % (problem, tag, suffix), 'r')\n    outfile = open(\"%s-%s%s.out\" % (problem, tag, suffix), 'w')\n     \n    #Read in the number of cases (the first input line) to iterate through\n    cases = int(infile.readline().strip('\\n'))\n    for i in range(cases):\n         \n        #Read in the input data for this case\n        case = read_input(infile)\n         \n        #Solve the problem for this case\n        output = solve_case(case)\n         \n        #Write out the output of this case\n        outfile.write('Case #%i: %s\\n' % (i+1, output))\n        print('Case #%i: %s\\n' % (i+1, output))\n     \n    #Close files\n    infile.close()\n    outfile.close()"}
{"author": "caethan", "index": 32, "filename": "2012_1460488_1483485.py", "code": "#Code copyright Brett Olsen, 2012\n \n#Standard imports\nimport numpy as N\nfrom string import translate, maketrans\n \n#Some switching behavior to set standard input/output files\n#Set these three variables to adjust behavior\ncase = 1\nproblem = \"A\"\npractice = False\n \nif practice:\n    practice = \"-practice\"\nelse:\n    practice = \"-attempt0\"\nif case == 0:\n    infile = open(\"%s-%s%s.in\" % (problem, \"sample\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (problem, \"sample\", practice), 'w')        \nelif case == 1:\n    infile = open(\"%s-%s%s.in\" % (problem, \"small\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (problem, \"small\", practice), 'w')    \nelif case == 2:\n    infile = open(\"%s-%s%s.in\" % (problem, \"large\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (problem, \"large\", practice), 'w')   \nelse:\n    raise (ValueError, 'Invalid case')\n     \nalpha = 'abcdefghijklmnopqrstuvwxyz '\ntrans = 'ynficwlbkuomxsevzpdrjgthaq '\ntable = maketrans(trans, alpha)\n     \n#Read in the number of cases (the first input line) we need to iterate through\ncases = int(infile.readline().strip('\\n'))\nfor i in range(cases):\n##################NEW CODE GOES HERE###########################################    \n    #Read in all relevant data for each case\n    instr = infile.readline().strip('\\n')\n     \n    #Do calculations to generate the output\n     \n    output = translate(instr, table)\n     \n     \n##################NEW CODE GOES HERE###########################################    \n    #Write out the results for this case\n    outfile.write('Case #%i: %s\\n' % (i+1, output))\n     \n#Close files\ninfile.close()\noutfile.close()"}
{"author": "caethan", "index": 32, "filename": "2013_2270488_2463486.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n#for the Google Code Jam programming contest\n \n###############################################################################\n# Imports go here\n###############################################################################\n \nfrom __future__ import division\nimport numpy as np\nimport math\n \n###############################################################################\n# Global variables (for caching, etc.) go here\n###############################################################################\n \n#Set up the input/output files: problem-tagsuffix.in / *.out\nproblem = \"C\"\ntag = \"small\" #commonly sample, small, or large\n#tag = \"large\"\n#tag = \"sample\"\nsuffix = \"-attempt0\" #used sometimes for indexing later input files\n#suffix = \"\"\n#From http://oeis.org/A002779/b002779.txt\n#Lazy route for the first two sets!\n#Numbers that are both squares and palindromes\ntable_of_fairs = np.array([0, 1, 4, 9, 121, 484, 676, 10201, 12321, 14641, \n40804, 44944, 69696, 94249, 698896, 1002001, 1234321, 4008004, 5221225, 6948496, \n100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, \n404090404, 522808225, 617323716, 942060249, 10000200001, 10221412201, 12102420121, \n12345654321, 40000800004, 637832238736, 1000002000001, 1002003002001, 1004006004001, \n1020304030201, 1022325232201, 1024348434201, 1086078706801, 1210024200121, \n1212225222121, 1214428244121, 1230127210321, 1232346432321, 1234567654321, \n1615108015161, 4000008000004, 4004009004004, 4051154511504, 5265533355625, \n9420645460249, 100000020000001, 100220141022001, 102012040210201, 102234363432201, \n121000242000121, 121242363242121, 123212464212321, 123456787654321, \n123862676268321, 144678292876441, 165551171155561, 400000080000004, \n900075181570009, 4099923883299904, 10000000200000001, 10002000300020001, \n10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, \n10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, \n10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, \n12120030703002121, 12122232623222121, 12124434743442121, 12321024642012321, \n12323244744232321, 12341234943214321, 12343456865434321, 12345678987654321, \n40000000800000004, 40004000900040004, 94206450305460249, 1000000002000000001, \n1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, \n1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, \n1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, \n1232344458544432321, 1234323468643234321, 4000000008000000004, 4253436912196343524, \n6158453974793548516, 100000000020000000001, 100002000030000200001, 100004000060000400001, \n100020201040102020001, 100022201252102220001, 100024201484102420001, \n100200120040021002001, 100202122050221202001, 100204124080421402001, \n100220341262143022001, 100222343474343222001, 102010002040200010201, \n102012022050220210201, 102014042080240410201, 102030405060504030201, \n102032425272524230201, 102132537636735231201, 102210100272001012201, 102212122262221212201, \n102214144272441412201, 102230523292325032201, 102232545484545232201, 102234567696765432201, \n104190107303701091401, 121000000242000000121, 121002200252002200121, 121004400282004400121, \n121020021070120020121, 121022221262122220121, 121024421474124420121, 121220122262221022121, \n121222324272423222121, 121240161292161042121, 121242363484363242121, 121244565696565442121, \n123210002464200012321, 123212222474222212321, 123230205292502032321, 123232425484524232321, \n123234645696546432321, 123432124686421234321, 123434346696643434321, 184398883818388893481, \n400000000080000000004, 400004000090000400004, 522815090696090518225, 906086675171576680609, \n942064503484305460249, 6916103777337773016196, 10000000000200000000001, 10000220001410002200001, \n10002002100400120020001, 10002222123632122220001, 10020010200400201002001, 10020230421612403202001, \n10022014302620341022001, 10022234545854543222001, 10201000020402000010201, 10201222221612222210201, \n10203022140604122030201, 10203244363836344230201, 10221210222622201212201, 10221432643834623412201, \n10223234344844343232201, 10224609234443290642201, 12100000002420000000121, 12100242003630024200121,\n12102202302620320220121, 12102444325852344420121, 12122010222622201022121, 12122252443834425222121, \n12124214524842541242121, 12321000024642000012321, 12321244225852244212321, 12323222344844322232321, \n12343210246864201234321, 12384043938083934048321, 12599536942224963599521, 16593841302620314839561, \n40000000000800000000004, 1000000000002000000000001, 1000002000003000002000001, \n1000004000006000004000001, 1000020200104010020200001, 1000022200125210022200001, 1000024200148410024200001, 1000200030004000300020001, 1000202030205020302020001, 1000204030408040304020001, 1000220232126212320220001, 1000222232347432322220001, 1002001002004002001002001, 1002003004005004003002001, 1002005006008006005002001, 1002021222306032221202001, 1002023224327234223202001, 1002201232026202321022001, 1002203234227224323022001, 1002221454348434541222001, 1002223456569656543222001, 1020100000204020000010201, 1020102020205020202010201, 1020104040208020404010201, 1020120402306032040210201, 1020122422327232242210201, 1020300010207020100030201, 1020302030406040302030201, 1020304050607060504030201, 1020320414309034140230201, 1020322434528254342230201, 1020324454749474544230201, 1022121002226222001212201, 1022123024227224203212201, 1022141424528254241412201, 1022143446549456443412201, 1022321210249420121232201, 1022323232448442323232201, 1022325254649464525232201, 1210000000024200000000121, 1210002200025200022000121, 1210004400028200044000121, 1210020020107010200200121, 1210022220126210222200121, 1210024420147410244200121, 1210220032026202300220121, 1210222232227222322220121, 1210242254148414522420121, 1210244454369634544420121, 1212201002226222001022121, 1212203204227224023022121, 1212221040509050401222121, 1212223242528252423222121, 1212225444549454445222121, 1212421234248424321242121, 1212423436449446343242121, 1232100000246420000012321, 1232102220247420222012321, 1232120202329232020212321, 1232122422348432242212321, 1232124642369632464212321, 1232322032448442302232321, 1232324252649462524232321, 1234321002468642001234321, 1234323224469644223234321, 1821056104269624016501281, 4000000000008000000000004, 4000004000009000004000004, 4618627222542452227268164, 6942236477330337746322496, 9420645034800084305460249, 40460195511188111559106404, 100000000000020000000000001, 100000220000141000022000001, 100002002010040010200200001, 100002222012363210222200001, 100020001200040002100020001, 100020221222161222122020001, 100022003410262014300220001, 100022223434585434322220001, 100200100020040020001002001, 100200320240161042023002001, 100202104032060230401202001, 100202324254383452423202001, 100220121220262022121022001, 100220341462383264143022001, 100222125432484234521222001, 102010000002040200000010201, 102010222202161202222010201, 102012022032060230220210201, 102012244234383432442210201, 102030201204060402102030201, 102030423426181624324030201, 102032223434282434322230201, 102212100022262220001212201, 102212322442383244223212201, 102214124054282450421412201, 102232321224484422123232201, 121000000000242000000000121, 121000242000363000242000121, 121002202210262012202200121, 121002444212585212444200121, 121022001220262022100220121, 121022243242383242342220121, 121024203630484036302420121, 121220100022262220001022121, 121220342242383242243022121, 121222304234282432403222121, 121242121242484242121242121, 123210000002464200000012321, 123210244202585202442012321, 123212222232484232222212321, 123232201224484422102232321, 123432100024686420001234321, 400000000000080000000000004, 923860899791363197998068329, 4872133543202112023453312784, 9658137819052882509187318569, 10000000000000200000000000001, 10000002000000300000020000001, 10000004000000600000040000001, 10000020200010401000202000001, 10000022200012521000222000001, 10000024200014841000242000001, 10000200021000400012000200001, 10000202021020502012020200001, 10000204021040804012040200001, 10000220221212621212202200001, 10000222221234743212222200001, 10002000102000400020100020001, 10002002102200500220120020001, 10002004102400800420140020001, 10002020304030603040302020001, 10002022304232723240322020001, 10002200143002620034100220001, 10002202143222722234120220001, 10002220345234843254302220001, 10002222345456965454322220001, 10020010000200400200001002001, 10020012002200500220021002001, 10020014004200800240041002001, 10020030220410601402203002001, 10020032222412721422223002001, 10020210221220602212201202001, 10020212223240704232221202001, 10020230441632823614403202001, 10020232443654945634423202001, 10022010100002720000101022001, 10022012102202620220121022001, 10022014104402720440141022001, 10022030322230903222303022001, 10022032324432823442323022001, 10022034326634943662343022001, 10022210341004940014301222001, 10022212343224842234321222001, 10022214345444944454341222001, 10201000000020402000000010201, 10201002020020502002020010201, 10201004040020802004040010201, 10201020402030603020402010201, 10201022422032723022422010201, 10201200001200700210000210201, 10201202021220602212020210201, 10201204041240704214040210201, 10201220403410901430402210201, 10201222423432823432422210201, 10201224443454945434442210201, 10203020102040604020102030201, 10203022122240704222122030201, 10203040506070807060504030201, 10203042526272927262524030201, 10203220123022922032102230201, 10203222143242824234122230201, 10203224163462926436142230201, 10221210000222622200001212201, 10221212022222722222021212201, 10221230422432823422403212201, 10221232444434943444423212201, 10221412221442824412221412201, 10221414243462926434241412201, 10223232102244844220123232201, 10223234124444944442143232201, 12100000000002420000000000121, 12100002200002520000220000121, 12100004400002820000440000121, 12100020020010701002002000121, 12100022220012621002222000121, 12100024420014741002442000121, 12100220023002620032002200121, 12100222223022722032222200121, 12100242243214841234224200121, 12100244443236963234444200121, 12102200102202620220100220121, 12102202302402720420320220121, 12102220124030903042102220121, 12102222324232823242322220121, 12102224524434943442542220121, 12102420145204840254102420121, 12102422345424942454322420121, 12122010000222622200001022121, 12122012202222722220221022121, 12122032240432823404223022121, 12122034442434943424443022121, 12122230223242824232203222121, 12122232425262926252423222121, 12124212102424842420121242121, 12124214304624942640341242121, 12321000000024642000000012321, 12321002220024742002220012321, 12321020202032923020202012321, 12321022422034843022422012321, 12321024642036963024642012321, 12321222023224842232022212321, 12321224243244944234242212321, 12323220102244844220102232321, 12323222322444944422322232321, 12343210000246864200001234321, 12343212222246964222221234321, 16799008923862526832980099761, 40000000000000800000000000004, 40000004000000900000040000004, 44431002775280908257720013444, 98693567900935453900976539689, 1000000000000002000000000000001, 1000000220000014100000220000001, 1000002002001004001002002000001, 1000002222001236321002222000001, 1000020000300004000030000200001, 1000020220302216122030220200001, 1000022002321026201232002200001, 1000022222323458543232222200001, 1000200010020004000200100020001, 1000200230042016102400320020001, 1000202012221206021222102020001, 1000202232243438343422322020001, 1000220012320026200232100220001, 1000220232344238324432320220001, 1000222014541248421454102220001, 1002001000002004002000001002001, 1002001220222016102220221002001, 1002003004005006005004003002001, 1002003224225238325224223002001, 1002021020302206022030201202001, 1002021240524418144250421202001, 1002023024325228225234203202001, 1002201210022026202200121022001, 1002201430264038304620341022001, 1002203214225228225224123022001, 1002221232322248422232321222001, 1020100000000204020000000010201, 1020100222200216120022220010201, 1020102022021206021202202010201, 1020102244221438341224422010201, 1020120200302206022030020210201, 1020120422504418144052240210201, 1020122222343228223432222210201, 1020302010020406040200102030201, 1020302232242418142422322030201, 1020304032241608061422304030201, 1020322212322428242232122230201, 1022121000002226222000001212201, 1022121222422238322242221212201, 1022123024025228225204203212201, 1022141220304428244030221412201, 1022323210022448442200123232201, 1210000000000024200000000000121, 1210000242000036300002420000121, 1210002202201026201022022000121, 1210002444201258521024442000121, 1210022000320026200230002200121, 1210022242322238322232422200121, 1210024202541048401452024200121, 1210220010022026202200100220121, 1210220252044038304402520220121, 1210222212423228223242122220121, 1210242012342048402432102420121, 1212201000002226222000001022121, 1212201242222238322222421022121, 1212203204205228225024023022121, 1212223020322428242230203222121, 1212421210024248424200121242121, 1232100000000246420000000012321, 1232100244200258520024420012321, 1232102222221248421222222012321, 1232122200322248422230022212321, 1232322010022448442200102232321, 1234321000002468642000001234321, 4000000000000008000000000000004, 4844486878939076709398786844484, 6574372239019762679109322734756, 9403095533541415141453355903049, 9659504223792743472973224059569, 9848294822582726272852284928489\n])\n \n#and here we've filtered the table\nfiltered_table = np.array([0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001,\n        1234321, 4008004, 100020001, 102030201, 104060401, 121242121,\n        123454321, 125686521, 400080004, 404090404, 10000200001,\n        10221412201, 12102420121, 12345654321, 40000800004, 1000002000001,\n        1002003002001, 1004006004001, 1020304030201, 1022325232201,\n        1024348434201, 1210024200121, 1212225222121, 1214428244121,\n        1232346432321, 1234567654321, 4000008000004, 4004009004004,\n        100000020000001, 100220141022001, 102012040210201, 102234363432201,\n        121000242000121, 121242363242121, 123212464212321, 123456787654321,\n        400000080000004, 10000000200000001, 10002000300020001,\n        10004000600040001, 10020210401202001, 10022212521222001,\n        10024214841242001, 10201020402010201, 10203040504030201,\n        10205060806050201, 10221432623412201, 10223454745432201,\n        12100002420000121, 12102202520220121, 12104402820440121,\n        12122232623222121, 12124434743442121, 12321024642012321,\n        12323244744232321, 12343456865434321, 12345678987654321,\n        40000000800000004, 40004000900040004, 1000000002000000001,\n        1000220014100220001, 1002003004003002001, 1002223236323222001,\n        1020100204020010201, 1020322416142230201, 1022123226223212201,\n        1022345658565432201, 1210000024200000121, 1210242036302420121,\n        1212203226223022121, 1212445458545442121, 1232100246420012321,\n        1232344458544432321, 1234323468643234321, 4000000008000000004,\n        100000000020000000001, 100002000030000200001, 100004000060000400001,\n        100020201040102020001, 100022201252102220001, 100024201484102420001,\n        100200120040021002001, 100202122050221202001, 100204124080421402001,\n        100220341262143022001, 100222343474343222001, 102010002040200010201,\n        102012022050220210201, 102014042080240410201, 102030405060504030201,\n        102032425272524230201, 102212122262221212201, 102214144272441412201,\n        102232545484545232201, 102234567696765432201, 121000000242000000121,\n        121002200252002200121, 121004400282004400121, 121022221262122220121,\n        121024421474124420121, 121220122262221022121, 121222324272423222121,\n        121242363484363242121, 121244565696565442121, 123210002464200012321,\n        123212222474222212321, 123232425484524232321, 123234645696546432321,\n        123432124686421234321, 123434346696643434321, 400000000080000000004,\n        400004000090000400004, 10000000000200000000001,\n        10000220001410002200001, 10002002100400120020001,\n        10002222123632122220001, 10020010200400201002001,\n        10020230421612403202001, 10022014302620341022001,\n        10022234545854543222001, 10201000020402000010201,\n        10201222221612222210201, 10203022140604122030201,\n        10203244363836344230201, 10221210222622201212201,\n        10221432643834623412201, 10223234344844343232201,\n        12100000002420000000121, 12100242003630024200121,\n        12102202302620320220121, 12102444325852344420121,\n        12122010222622201022121, 12122252443834425222121,\n        12124214524842541242121, 12321000024642000012321,\n        12321244225852244212321, 12323222344844322232321,\n        12343210246864201234321, 40000000000800000000004,\n        1000000000002000000000001, 1000002000003000002000001,\n        1000004000006000004000001, 1000020200104010020200001,\n        1000022200125210022200001, 1000024200148410024200001,\n        1000200030004000300020001, 1000202030205020302020001,\n        1000204030408040304020001, 1000220232126212320220001,\n        1000222232347432322220001, 1002001002004002001002001,\n        1002003004005004003002001, 1002005006008006005002001,\n        1002021222306032221202001, 1002023224327234223202001,\n        1002201232026202321022001, 1002203234227224323022001,\n        1002221454348434541222001, 1002223456569656543222001,\n        1020100000204020000010201, 1020102020205020202010201,\n        1020104040208020404010201, 1020120402306032040210201,\n        1020122422327232242210201, 1020302030406040302030201,\n        1020304050607060504030201, 1020322434528254342230201,\n        1020324454749474544230201, 1022121002226222001212201,\n        1022123024227224203212201, 1022141424528254241412201,\n        1022143446549456443412201, 1022323232448442323232201,\n        1022325254649464525232201, 1210000000024200000000121,\n        1210002200025200022000121, 1210004400028200044000121,\n        1210022220126210222200121, 1210024420147410244200121,\n        1210220032026202300220121, 1210222232227222322220121,\n        1210242254148414522420121, 1210244454369634544420121,\n        1212201002226222001022121, 1212203204227224023022121,\n        1212223242528252423222121, 1212225444549454445222121,\n        1212421234248424321242121, 1212423436449446343242121,\n        1232100000246420000012321, 1232102220247420222012321,\n        1232122422348432242212321, 1232124642369632464212321,\n        1232322032448442302232321, 1232324252649462524232321,\n        1234321002468642001234321, 1234323224469644223234321,\n        4000000000008000000000004, 4000004000009000004000004,\n        100000000000020000000000001, 100000220000141000022000001,\n        100002002010040010200200001, 100002222012363210222200001,\n        100020001200040002100020001, 100020221222161222122020001,\n        100022003410262014300220001, 100022223434585434322220001,\n        100200100020040020001002001, 100200320240161042023002001,\n        100202104032060230401202001, 100202324254383452423202001,\n        100220121220262022121022001, 100220341462383264143022001,\n        100222125432484234521222001, 102010000002040200000010201,\n        102010222202161202222010201, 102012022032060230220210201,\n        102012244234383432442210201, 102030201204060402102030201,\n        102030423426181624324030201, 102032223434282434322230201,\n        102212100022262220001212201, 102212322442383244223212201,\n        102214124054282450421412201, 102232321224484422123232201,\n        121000000000242000000000121, 121000242000363000242000121,\n        121002202210262012202200121, 121002444212585212444200121,\n        121022001220262022100220121, 121022243242383242342220121,\n        121024203630484036302420121, 121220100022262220001022121,\n        121220342242383242243022121, 121222304234282432403222121,\n        121242121242484242121242121, 123210000002464200000012321,\n        123210244202585202442012321, 123212222232484232222212321,\n        123232201224484422102232321, 123432100024686420001234321,\n        400000000000080000000000004, 10000000000000200000000000001,\n        10000002000000300000020000001, 10000004000000600000040000001,\n        10000020200010401000202000001, 10000022200012521000222000001,\n        10000024200014841000242000001, 10000200021000400012000200001,\n        10000202021020502012020200001, 10000204021040804012040200001,\n        10000220221212621212202200001, 10000222221234743212222200001,\n        10002000102000400020100020001, 10002002102200500220120020001,\n        10002004102400800420140020001, 10002020304030603040302020001,\n        10002022304232723240322020001, 10002200143002620034100220001,\n        10002202143222722234120220001, 10002220345234843254302220001,\n        10002222345456965454322220001, 10020010000200400200001002001,\n        10020012002200500220021002001, 10020014004200800240041002001,\n        10020030220410601402203002001, 10020032222412721422223002001,\n        10020210221220602212201202001, 10020212223240704232221202001,\n        10020230441632823614403202001, 10020232443654945634423202001,\n        10022012102202620220121022001, 10022014104402720440141022001,\n        10022032324432823442323022001, 10022034326634943662343022001,\n        10022212343224842234321222001, 10022214345444944454341222001,\n        10201000000020402000000010201, 10201002020020502002020010201,\n        10201004040020802004040010201, 10201020402030603020402010201,\n        10201022422032723022422010201, 10201202021220602212020210201,\n        10201204041240704214040210201, 10201222423432823432422210201,\n        10201224443454945434442210201, 10203020102040604020102030201,\n        10203022122240704222122030201, 10203040506070807060504030201,\n        10203042526272927262524030201, 10203222143242824234122230201,\n        10203224163462926436142230201, 10221210000222622200001212201,\n        10221212022222722222021212201, 10221230422432823422403212201,\n        10221232444434943444423212201, 10221412221442824412221412201,\n        10221414243462926434241412201, 10223232102244844220123232201,\n        10223234124444944442143232201, 12100000000002420000000000121,\n        12100002200002520000220000121, 12100004400002820000440000121,\n        12100022220012621002222000121, 12100024420014741002442000121,\n        12100220023002620032002200121, 12100222223022722032222200121,\n        12100242243214841234224200121, 12100244443236963234444200121,\n        12102200102202620220100220121, 12102202302402720420320220121,\n        12102222324232823242322220121, 12102224524434943442542220121,\n        12102420145204840254102420121, 12102422345424942454322420121,\n        12122010000222622200001022121, 12122012202222722220221022121,\n        12122032240432823404223022121, 12122034442434943424443022121,\n        12122230223242824232203222121, 12122232425262926252423222121,\n        12124212102424842420121242121, 12124214304624942640341242121,\n        12321000000024642000000012321, 12321002220024742002220012321,\n        12321022422034843022422012321, 12321024642036963024642012321,\n        12321222023224842232022212321, 12321224243244944234242212321,\n        12323220102244844220102232321, 12323222322444944422322232321,\n        12343210000246864200001234321, 12343212222246964222221234321,\n        40000000000000800000000000004, 40000004000000900000040000004,\n        1000000000000002000000000000001, 1000000220000014100000220000001,\n        1000002002001004001002002000001, 1000002222001236321002222000001,\n        1000020000300004000030000200001, 1000020220302216122030220200001,\n        1000022002321026201232002200001, 1000022222323458543232222200001,\n        1000200010020004000200100020001, 1000200230042016102400320020001,\n        1000202012221206021222102020001, 1000202232243438343422322020001,\n        1000220012320026200232100220001, 1000220232344238324432320220001,\n        1000222014541248421454102220001, 1002001000002004002000001002001,\n        1002001220222016102220221002001, 1002003004005006005004003002001,\n        1002003224225238325224223002001, 1002021020302206022030201202001,\n        1002021240524418144250421202001, 1002023024325228225234203202001,\n        1002201210022026202200121022001, 1002201430264038304620341022001,\n        1002203214225228225224123022001, 1002221232322248422232321222001,\n        1020100000000204020000000010201, 1020100222200216120022220010201,\n        1020102022021206021202202010201, 1020102244221438341224422010201,\n        1020120200302206022030020210201, 1020120422504418144052240210201,\n        1020122222343228223432222210201, 1020302010020406040200102030201,\n        1020302232242418142422322030201, 1020304032241608061422304030201,\n        1020322212322428242232122230201, 1022121000002226222000001212201,\n        1022121222422238322242221212201, 1022123024025228225204203212201,\n        1022141220304428244030221412201, 1022323210022448442200123232201,\n        1210000000000024200000000000121, 1210000242000036300002420000121,\n        1210002202201026201022022000121, 1210002444201258521024442000121,\n        1210022000320026200230002200121, 1210022242322238322232422200121,\n        1210024202541048401452024200121, 1210220010022026202200100220121,\n        1210220252044038304402520220121, 1210222212423228223242122220121,\n        1210242012342048402432102420121, 1212201000002226222000001022121,\n        1212201242222238322222421022121, 1212203204205228225024023022121,\n        1212223020322428242230203222121, 1212421210024248424200121242121,\n        1232100000000246420000000012321, 1232100244200258520024420012321,\n        1232102222221248421222222012321, 1232122200322248422230022212321,\n        1232322010022448442200102232321, 1234321000002468642000001234321,\n        4000000000000008000000000000004], dtype=object)\n \n###############################################################################\n# Helper functions go here\n###############################################################################\n \ndef read_input(infile):\n    \"\"\"This function should take an open input file, load in all of the\n    relevant information for a single case of the problem, and output it\n    as a single object.    \n    \"\"\"\n    #Some utility functions to read in particular types of input\n    def read_int():\n        return int(infile.readline().strip())\n    def read_ints():\n        return np.array(infile.readline().split(), dtype=int)\n    def read_bigints():\n        line = infile.readline().split()\n        return np.array(map(lambda x: int(x), line))\n    def read_float():\n        return float(infile.readline().strip())\n    def read_floats():\n        return np.array(infile.readline().split(), dtype=float)\n    def read_string():\n        return infile.readline().strip()\n    def read_strings():\n        return np.array(infile.readline().split(), dtype=object) #change the dtype?\n     \n    A, B = read_bigints()\n     \n    return (A, B)\n \ndef is_palindrome(num):\n    digits = []\n    num = int(num)\n    while num > 0:\n        digits.append(num % 10)\n        num = num / 10 #n.b. int division (discard remainder)\n \n    return digits == digits[::-1]\n \n    for i in range(len(digits) / 2): #n.b. int division (skips center)\n        if digits[i] != digits[-i+1]:\n            return False\n    return True\n \ndef solve_case_simple(case):\n    A, B = case\n     \n    if B > table_of_fairs[-1]:\n        raise (ValueError, \"Ranges too big for lookup table!\")\n     \n    valid = (A <= filtered_table) * (filtered_table <= B)\n    return valid.sum()\n \ndef solve_case(case):\n    \"\"\"Take the input data (structured in case) and perform any necessary\n    calculations to obtain the desired output, formatted as the appropriate\n    string.    \n    \"\"\"\n     \n    output = solve_case_simple(case)\n    return output\n \n###############################################################################\n# Main execution path\n###############################################################################\n \nif __name__ == \"__main__\":\n    #Open up the input & output files\n    infile = open(\"%s-%s%s.in\" % (problem, tag, suffix), 'r')\n    outfile = open(\"%s-%s%s.out\" % (problem, tag, suffix), 'w')\n     \n    #Read in the number of cases (the first input line) to iterate through\n    cases = int(infile.readline().strip('\\n'))\n    for i in range(cases):\n         \n        #Read in the input data for this case\n        case = read_input(infile)\n         \n        #Solve the problem for this case\n        output = solve_case(case)\n         \n        #Write out the output of this case\n        outfile.write('Case #%i: %s\\n' % (i+1, output))\n        print ('Case #%i: %s\\n' % (i+1, output))\n     \n    #Close files\n    infile.close()\n    outfile.close()"}
{"author": "caethan", "index": 32, "filename": "2014_2974486_5756407898963968.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n#for the Google Code Jam programming contest\n \n###############################################################################\n# Imports go here\n###############################################################################\n \n#For faster numerical analysis\nimport numpy as np\n \nimport sys\n \n#Needed for the memoization decorator\nimport collections\nimport functools\n \n###############################################################################\n# Global variables (for caching, etc.) go here\n###############################################################################\n \n###############################################################################\n# Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\n###############################################################################\n \nclass memoize(object):\n    \"\"\"Decorator. Caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned\n    (not reevaluated).\n    \"\"\"\n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n    def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n            # uncacheable. a list, for instance.\n            # better to not cache than blow up.\n            return self.func(*args)\n        if args in self.cache:\n            return self.cache[args]\n        else:\n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n    def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n    def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n \n###############################################################################\n# Functions\n###############################################################################\n \ndef precalculate():\n    \"\"\"Perform any calculations that need to be performed before the main path\n    (e.g., preparing lookup tables, etc.)\n     \n    N.B. Make sure you make any important variables global so that other\n    functions can access them.\n    \"\"\"\n    pass\n \ndef read_input(infile):\n    \"\"\"This function should take an open input file, load in all of the\n    relevant information for a single case of the problem, and output it\n    as a single object.    \n    \"\"\"\n    #Some utility functions to read in particular types of input\n    def read_int():\n        return int(infile.readline().strip())\n    def read_ints():\n        return np.array(infile.readline().split(), dtype=int)\n    def read_bigints(): #For ints that won't fit directly in an int32 array\n        line = infile.readline().split()\n        return np.array(map(lambda x: int(x), line))\n    def read_float():\n        return float(infile.readline().strip())\n    def read_floats():\n        return np.array(infile.readline().split(), dtype=float)\n    def read_string():\n        return infile.readline().strip()\n    def read_strings():\n        return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n     \n    ans1 = read_int()\n    grid1 = np.zeros((4,4), dtype=int)\n    for i in range(4):\n        grid1[i] = read_ints()\n     \n    ans2 = read_int()\n    grid2 = np.zeros((4,4), dtype=int)\n    for i in range(4):\n        grid2[i] = read_ints()\n     \n     \n    case = (ans1, grid1, ans2, grid2)\n     \n    return case\n \ndef solve_case(case):\n    \"\"\"Take the input data (structured in case) and perform any necessary\n    calculations to obtain the desired output, formatted as the appropriate\n    string.    \n    \"\"\"\n     \n    ans1, grid1, ans2, grid2 = case\n     \n    valid = set(grid1[ans1-1]) & set(grid2[ans2-1])\n     \n    #print valid\n    #print ans1, grid1, ans2, grid2\n    #print grid1[ans1], grid2[ans2]\n     \n    if len(valid) == 1:\n        output = valid.pop()\n    elif len(valid) > 1:\n        output = \"Bad magician!\"\n    elif len(valid) < 1:\n        output = \"Volunteer cheated!\"\n    return output\n \n###############################################################################\n# Main execution path\n###############################################################################\n \nif __name__ == \"__main__\":\n    #Do any pre-calculations required\n    precalculate()\n     \n    #Open up the input & output files based on the provided input file\n    assert len(sys.argv) == 2 #only one argument\n    assert sys.argv[1][-3:] == \".in\" #input must end with .in\n    infile = open(\"%s\" % sys.argv[1], 'r')\n    outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n     \n    #Read in the number of cases (the first input line) to iterate through\n    cases = int(infile.readline().strip('\\n'))\n    for i in range(cases):\n         \n        #Read in the input data for this case\n        case = read_input(infile)\n         \n        #Solve the problem for this case\n        output = solve_case(case)\n         \n        #Write out the output of this case\n        outfile.write('Case #%i: %s\\n' % (i+1, output))\n        print ('Case #%i: %s\\n' % (i+1, output))\n     \n    #Close files\n    infile.close()\n    outfile.close()"}
{"author": "rainmayecho", "index": 33, "filename": "2014_2974486_5709773144064000.py", "code": "f = open('Bsmall.in', 'r')\n##f = open('test.txt', 'r')\ng = open('outputB.txt', 'w')\n \ndata = [[float(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\nT = int(data.pop(0)[0])\n \nfor i, case in enumerate(data):\n    C, F, X = case[0], case[1], case[2]\n    n = 1\n    t = X/2\n    t_next = X/(2 + F) + C/2\n    metric = (t_next < t)\n    while metric:\n        n += 1\n        t = t_next\n        t_next = t_next - X/(2 + F*(n-1)) + C/(2 + F*(n-1)) + X/(2 + F*n)\n        metric = (t_next < t)\n    g.write('Case #%i: %f\\n' %(i+1, t))\nf.close()\ng.close()\n"}
{"author": "rainmayecho", "index": 33, "filename": "2014_2974486_5690574640250880.py", "code": "def make_string(R, C, M):\n    grid = [['.' for j in xrange(C)] for i in xrange(R)]\n    grid[-1][-1] = 'c'\n    t = M\n    for i in xrange(R):\n        for j in xrange(C):\n            if M:\n                if forbidden(R, C, t, i, j):\n                    continue\n                grid[i][j] = '*'\n                M -= 1\n            else:\n                break\n    s = ''\n    if M:\n        return 'Impossible'\n    for r in grid:\n        s += ''.join(r)+'\\n'\n    return s[:-1]\n \ndef forbidden(R, C, M, i, j):\n    a = M / C\n    b = M % C\n    if (R*C - M == 1):\n        return False\n \n    if i >= (R-2) and j >= (C-2):\n        return True\n \n    if i >= (R-2) and b:\n        if b % 2:\n            return True\n        if j < b/2:\n            return False\n        else:\n            return True\n    return False\n         \n \nf = open('Csmall.in', 'r')\n##f = open('test.txt', 'r')\ng = open('outputC.txt', 'w')\n \ndata = [[int(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\nT = int(data.pop(0)[0])\nfor i, case in enumerate(data):\n    R, C, M = case[0], case[1], case[2]\n    num_cells = R*C\n    if (R-1) == 0 or (C-1) == 0:\n        s = make_string(R, C, M)\n        g.write('Case #%i:\\n%s\\n' %(i+1,s))\n        continue\n    else:\n        s = make_string(R, C, M)\n        g.write('Case #%i:\\n%s\\n' %(i+1, s))\n         \n \nf.close()\ng.close()\n"}
{"author": "rainmayecho", "index": 33, "filename": "2012_1460488_1595491.py", "code": "f = open('cj2.in','r')\nout = open('out1.txt','w')\ninp = [[int(n) for n in s.split()] for s in f.readlines()]\n \ndef score_partition(score):\n    poss = []\n    if score == 0:\n        return [[0,0,0]]\n    if score == 1:\n        return [[0,0,1]]\n    if score % 3 == 0:\n        poss.append([score/3,score/3,score/3])\n        poss.append([score/3-1,score/3,score/3+1])\n    if score % 3 == 1:\n        poss.append([score/3, score/3,score/3+1])\n        poss.append([score/3-1,score/3+1,score/3+1])\n    if score % 3 == 2:\n        poss.append([score/3,score/3+1,score/3+1])\n        poss.append([score/3,score/3,score/3+2])\n \n    return poss\n \n \ns = 0\nc = 1\nfor e in inp[1:len(inp)]:\n    count = 0\n    surprises = e[1]\n    s = 0\n    p = e[2]\n    for i in e[3:len(e)]:\n        scores = score_partition(i)\n        for j in scores: \n            if max(j) >= p:\n                if max(j)-min(j) == 2:\n                    if s < surprises:\n                        s +=1\n                        count +=1\n                        break\n                else:\n                    count += 1\n                    break\n                 \n    out.write('Case #'+str(c)+': '+str(count)+'\\n')\n    c += 1\n \nout.close()\nf.close()\n                 \n         \n     \n     \n \n     \n"}
{"author": "rainmayecho", "index": 33, "filename": "2013_2270488_2453486.py", "code": "\ndef checkRow(d, t):\n    g = 0\n    for row in d:\n        a = list(row)\n        a.sort()\n        a = ''.join(a)\n        if 'TXXX' in a or 'XXXX' in a:\n            print('Case #%i: X won' %(t/4+1))\n            return 1\n        if 'OOOT' in a or 'OOOO' in a:\n            print('Case #%i: O won' %(t/4+1))\n            return 1\n        if '.' in a:\n            g = 10\n    return g\n \ndef checkCol(d, t):\n    for j in range(4):\n        col = []\n        for row in d:\n            col.append(row[j])\n        a = list(col)\n        a.sort()\n        a = ''.join(a)\n        if 'TXXX' in a or 'XXXX' in a:\n            print('Case #%i: X won' %(t/4+1))\n            return 1\n        if 'OOOT' in a or 'OOOO' in a:\n            print('Case #%i: O won' %(t/4+1))\n            return 1\n    return 0\n \ndef checkDiag(d1, d2, t):\n    a = list(d1)\n    b = list(d2)\n    a.sort()\n    b.sort()\n    a = ''.join(a)\n    b = ''.join(b)\n \n    if 'TXXX' in a or 'XXXX' in a:\n        print('Case #%i: X won' %(t/4+1))\n        return 1\n    if 'OOOT' in a or 'OOOO' in a:\n        print('Case #%i: O won' %(t/4+1))\n        return 1\n \n    if 'TXXX' in b or 'XXXX' in b:\n        print('Case #%i: X won' %(t/4+1))\n        return 1\n    if 'OOOT' in b or 'OOOO' in b:\n        print('Case #%i: O won' %(t/4+1))\n        return 1\n    return 0\n \ndat = raw_input()\n \ndata = dat.split()\nc = int(data.pop(0))\n \nfor t in range(0, 4*c, 4):\n    a = checkRow(data[t:t+4],t)\n    if a == 1:\n        continue\n    b = checkCol(data[t:t+4],t)\n    if b:\n        continue\n    d1 = data[t][0]+data[t+1][1]+data[t+2][2]+data[t+3][3]\n    d2 = data[t][3]+data[t+1][2]+data[t+2][1]+data[t+3][0]\n    c = checkDiag(d1, d2,t)\n    if c:\n        continue\n    if (a+b+c) == 0:\n        print('Case #%i: Draw' %(t/4+1))\n    if a == 10:\n        print('Case #%i: Game has not completed' %(t/4+1)   )\n"}
{"author": "rainmayecho", "index": 33, "filename": "2013_2270488_2449486.py", "code": "\ndef check(grid, n, m):\n    for i in range(n):\n        for j in range(m):\n            if neighbor(grid,i,j,n,m):\n                return False\n    return True\n \ndef neighbor(grid,i,j,n,m):\n    u = not i\n    d = not (n-i-1)\n    l = not j\n    r = not (m-j-1)\n    if n == 1:\n        return False\n    if m == 1:\n        return False\n    if i > 0:\n        for k in range(i,-1,-1):\n            if grid[k][j] > grid[i][j]:\n                u = 1\n             \n    if i < n-1:\n        for k in range(i,n):\n            if grid[k][j] > grid[i][j]:\n                d = 1\n         \n    if j > 0:\n        for k in range(j,-1,-1):\n            if grid[i][k] > grid[i][j]:\n                l = 1\n         \n    if j < m-1:\n        for k in range(j,m):\n            if grid[i][k] > grid[i][j]:\n                r = 1\n    return (u*d*l*r)\n         \n \ndat = raw_input().split()\nc = int(dat.pop(0))\ndata = [int(e) for e in dat]\nindex = 0\nt = 0\nwhile t < c:\n    n = data[index]\n    m = data[index+1]\n    index += 2\n    grid = []\n    for i in range(n):\n        grid.append(data[index:index+m])\n        index += m\n    if check(grid, n, m):\n        print('Case #%i: YES'%(t+1))\n    else:\n        print('Case #%i: NO'%(t+1))\n    t += 1\n"}
{"author": "rainmayecho", "index": 33, "filename": "2012_1460488_1483485.py", "code": "mapping = {'y':'a','n':'b','f':'c','i':'d','c':'e','w':'f','l':'g','b':'h','k':'i','u':'j','o':'k','m':'l','x':'m','s':'n','e':'o','v':'p','p':'r','d':'s','r':'t','j':'u','g':'v','t':'w','h':'x','a':'y','q':'z','z':'q',' ':' ','\\n':'\\n'}\n \nf = open('cj.in','r')\nout = open('out.txt','w')\ninp = [line for line in f]\n \ni = 1\nfor G in inp[1:len(inp)]:\n    string = ''\n    for e in G:\n        string+=mapping[e]\n    out.write('Case #'+str(i)+': '+string)\\n    i+=1\\n \\nf.close()\\nout.close()\\n"}
{"author": "rainmayecho", "index": 33, "filename": "2013_2270488_2463486.py", "code": "def check(a,b):\n    c = 0\n    n = 1\n    for i in range(1,4):\n        if i**2 >= a and i**2 <=b:\n            c += 1\n    if 44944 >= a and 44944 <= b:\n        c += 1\n    while n < 10:\n        p1 = int('1'+'1'*n)**2\n        if p1 >= a and p1 <=b:\n            c += 1\n        n += 1\n \n \n    if 484 >= a and 484 <= b:\n        c += 1\n \n    n = 1\n    while True:\n        p2 = int('1'+'0'*n+'1')**2\n        p3 = int('2'+'0'*n+'2')**2\n        if p2 >= a and p2 <= b:\n            c += 1\n        else:\n            break\n        if p3 >= a and p3 <= b:\n            c += 1\n        else:\n            continue\n        n += 1\n \n    n = 1\n    while True:\n        t = False\n        for m in range(2,5):\n            p4 = int('1'*m+'0'*n+'1'*m)**2\n            if p4 >= a and p4 <= b:\n                c += 1\n            else:\n                t = True\n                break\n        if t:\n            break\n             \n        n += 1\n    return c\n                 \ndat = raw_input().split()\nn = int(dat.pop(0))\ndata = [int(e) for e in dat]\n \nfor i in range(0, n*2, 2):\n    a, b = data[i], data[i+1]\n    print('Case #%i: '%(i/2+1) + str(check(a,b)) )\n \n     \n"}
{"author": "rainmayecho", "index": 33, "filename": "2014_2974486_5756407898963968.py", "code": "f = open('A.in', 'r')\ng = open('outputA.txt', 'w')\ndata = [[int(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\nT = data[0][0]\nc = 0\nfor i in xrange(1, T*10 + 1, 10):\n    c += 1\n    choice1 = data[i][0]\n    choice2 = data[i+5][0]\n    grid1, grid2 = [], []\n    for j in xrange(1,5):\n        grid1.append(data[i+j])\n \n    for j in xrange(6, 10):\n        grid2.append(data[i+j])\n \n    s1 = set(grid1[choice1-1])\n    s2 = set(grid2[choice2-1])\n \n    s = s1 & s2\n    if len(s) == 1:\n        g.write(\"Case #%i: %i\\n\" %(c, s.pop()))\n    elif not s:\n        g.write(\"Case #%i: Volunteer cheated!\\n\" %(c))\n    else:\n        g.write(\"Case #%i: Bad magician!\\n\" %(c))\n \nf.close()\ng.close()\n     \n"}
{"author": "bigonion", "index": 34, "filename": "2014_2974486_5709773144064000.py", "code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/B/'\n \n \n \ndef solve (f_in, f_out):\n    T = int(f_in.readline())\n    for testcase in range(1,T+1):\n        line = f_in.readline()\n        C,F,X = [float(q) for q in line.split()]\n        result = compute (C,F,X)\n        f_out.write('Case #' + str(testcase) + ': ' + str(result) + '\\n')\n \n \ndef compute(C,F,X):\n    cps = 2\n    farms = 0\n    timespent = 0\n    while X / cps > C/cps + X/(cps+F):\n        farms += 1\n        timespent += C/cps\n        cps += F\n \n    return timespent + X/cps\n \n \n \n \n \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (directory)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', directory))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    f_in = open(directory+chosen_filename+'.in')\n    f_out = open(directory+chosen_filename+'.out', 'w')\n    solve(f_in,f_out)\n    f_in.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n"}
{"author": "bigonion", "index": 34, "filename": "2014_2974486_5690574640250880.py", "code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\n \nfrom copy import deepcopy\nimport itertools\n \n \ndef solve_one_case (R,C,M):\n        l = []\n        for i in range(R):\n            for j in range(C):\n                l.append((i,j))\n \n        empty_mat = []\n        for i in range(R):\n            empty_mat.append(['.']*C)\n \n        found = False\n \n        assert (0,0) in l\n        l = l[1:]\n        l = l[::-1]\n        assert (0,0) not in l\n         \n        output = ''\n         \n        for mine_placement in itertools.combinations(l,M):\n            mat = deepcopy(empty_mat)\n            for cell in mine_placement:\n                mat[cell[0]][cell[1]] = '*'\n            if isOneClick(mat, R, C, M):\n                mat[0][0] = 'c'\n                for line in mat:\n                    output += ''.join(line) + '\\n'\n                found = True\n                return output\n             \n        if not found:\n            return 'Impossible\\n'\n         \n        assert ValueError()\n         \ndef solve (f_in, f_out):\n    T = int(f_in.readline())\n    for testcase in range(1,T+1):\n        line = f_in.readline()\n        R,C,M = [int(q) for q in line.split()]\n        print((testcase,R,C,M))\n \n        output = solve_one_case (R,C,M)\n        f_out.write('Case #' + str(testcase) + ':\\n')\n        f_out.write(output)\n \n         \n \n \ndef isOneClick (mat, R, C, M):\n##    if mat[0][0] != '.':\n##        return False\n##    assert len(mat) == R\n##    lens = [len(l) for l in mat]\n##    assert min(lens) == C\n##    assert max(lens) == C\n##    assert sum([l.count('*') for l in mat]) == M\n \n    mat_cpy = deepcopy(mat)\n    oneclickcells = [(0,0)]\n    while oneclickcells:\n        node = oneclickcells.pop()\n        mat_cpy[node[0]][node[1]] = 'v'\n        if noNearbyMines(mat_cpy,node):\n            oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\n \n    #print((mat_cpy))\n    return sum([l.count('.') for l in mat_cpy]) == 0\n     \n \ndef getNearbyUnvisited(mat, node):\n    R = len(mat)\n    C = len(mat[0])\n    deltas_r = [0]\n    deltas_c = [0]\n    if node[0] > 0:\n        deltas_r.append(-1)\n    if node[1] > 0:\n        deltas_c.append(-1)\n    if node[0] < R-1:\n        deltas_r.append(1)\n    if node[1] < C-1:\n        deltas_c.append(1)\n \n    ret_list = []\n    for delta_r in deltas_r:\n        for delta_c in deltas_c:\n            next_node = (node[0]+delta_r, node[1] + delta_c)\n            if mat[next_node[0]][next_node[1]] not in ['*','v']:\n                ret_list.append((next_node[0],next_node[1]))\n \n    return ret_list\n \ndef noNearbyMines(mat,node):\n    R = len(mat)\n    C = len(mat[0])\n    deltas_r = [0]\n    deltas_c = [0]\n    if node[0] > 0:\n        deltas_r.append(-1)\n    if node[1] > 0:\n        deltas_c.append(-1)\n    if node[0] < R-1:\n        deltas_r.append(1)\n    if node[1] < C-1:\n        deltas_c.append(1)\n \n    for delta_r in deltas_r:\n        for delta_c in deltas_c:\n            if mat[node[0] + delta_r][node[1] + delta_c] == '*':\n                return False\n    return True\n     \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (directory)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', directory))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    f_in = open(directory+chosen_filename+'.in')\n    f_out = open(directory+chosen_filename+'.out', 'w')\n    solve(f_in,f_out)\n    f_in.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n \n##bads = []\n##goods = []\n##\n##for R in range(1,6):\n##    for C in range(1,6):\n##        for M in range(1,R*C+1):\n##            print((R,C,M))\n##            output = solve_one_case (R,C,M)\n##            if output[0] == 'I':\n##                bads.append((R,C,M))\n##            else:\n##                goods.append((R,C,M))\n##\n"}
{"author": "bigonion", "index": 34, "filename": "2012_1460488_1595491.py", "code": "directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'\n \n \ndef solve (f_in, f_out):\n    T = int(f_in.readline())\n    print(('Test cases : ',T))\n    for i in range(1,T+1):\n        line = f_in.readline()\n        nnn = [int(x) for x in line.split()]\n        S = nnn[1]\n        p = nnn[2]\n        t = nnn[3:]\n        if p > 1:\n            A = 0\n            B = 0\n            for t_i in t:\n                if t_i >=3*p-2:\n                    A += 1\n                elif t_i >= 3*p-4:\n                    B += 1\n            result = A + min(B,S)\n        if p == 1:\n            result = len([x for x in t if x>=1])\n        if p == 0:\n            result=  len(t)\n        f_out.write('Case #' + str(i) + ': ' + str(result) + '\\n')\n \n \n \n \n \n \n \n \n \n \ndef main_run():\n    import os\n    filenames = [x for x in os.listdir (directory)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', directory))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    f_in = open(directory+chosen_filename+'.in')\n    f_out = open(directory+chosen_filename+'.out', 'w')\n    solve(f_in,f_out)\n    f_in.close()\n    f_out.close()\n \n \n \n \nmain_run()\n"}
{"author": "bigonion", "index": 34, "filename": "2013_2270488_2453486.py", "code": "directory = 'C:/users/hai/my projects/google code jam/2013/qualification/A/'\n \n \ndef solve (f_in, f_out):\n    N = int(f_in.readline())\n    for testcase in range(1,N+1):\n        sqr = []\n        for i in range(4):\n            sqr.append(list(f_in.readline().split()[0]))\n        assert len(f_in.readline().split()) == 0\n \n        f_out.write('Case #' + str(testcase) + ': ' + get_square_winner(sqr) +'\\n')\n     \n \ndef get_all_lines(sqr):\n    lines = []\n    for line in sqr:\n        lines.append(list(line))\n    for column in range(4):\n        line = []\n        for row in range(4):\n            line.append(sqr[row][column])\n        lines.append(list(line))\n \n    diag1 = []\n    diag2 = []\n    for  i in range(4):\n        diag1.append(sqr[i][i])\n        diag2.append(sqr[i][3-i])\n    lines.append(diag1)\n    lines.append(diag2)\n \n    return lines\n     \ndef get_square_winner (sqr):\n    for line in get_all_lines(sqr):\n        if get_line_winner (line):\n            return get_line_winner (line)\n \n    for row in sqr:\n        if '.' in row:\n            return \"Game has not completed\"\n    return \"Draw\"\n \n \n \n \ndef get_line_winner (line):\n    if line.count('X') == 4:\n        return \"X won\"\n    if line.count('X') == 3 and 'T' in line:\n        return \"X won\"\n     \n    if line.count('O') == 4:\n        return \"O won\"\n    if line.count('O') == 3 and 'T' in line:\n        return \"O won\"\n \n \n    return None\n \n \n \n \n \n \n \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (directory)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', directory))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    f_in = open(directory+chosen_filename+'.in')\n    f_out = open(directory+chosen_filename+'.out', 'w')\n    solve(f_in,f_out)\n    f_in.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n"}
{"author": "bigonion", "index": 34, "filename": "2013_2270488_2449486.py", "code": "directory = 'C:/users/hai/my projects/google code jam/2013/qualification/B/'\n \n \nfrom copy import deepcopy\n \ndef solve (f_in, f_out):\n    T = int(f_in.readline())\n    for testcase in range(1,T+1):\n        print((testcase))\n        N,M = [int(x) for x in f_in.readline().split()]\n        sqr = []\n        for i in range(N):\n            sqr.append([int(x) for x in f_in.readline().split()])\n        res = get_result(sqr)\n        f_out.write('Case #' + str(testcase) + ': ' + res + '\\n')\n \n \ndef get_result (sqr):\n    while len(sqr) > 1 and len(sqr[0]) > 1:\n        print((sqr))\n        r,c = 0,0\n        for row in range(len(sqr)):\n            for col in range(len(sqr[0])):\n                if sqr[row][col] < sqr[r][c]:\n                    r,c = row, col\n        min_val = sqr[r][c]\n        whole_row = list(sqr[r])\n        whole_col = []\n        for row in range(len(sqr)):\n            whole_col.append(sqr[row][c])\n        assert min(whole_row) == min_val\n        assert min(whole_col) == min_val\n        if max(whole_row) == min_val:\n            sqr = remove_row(sqr,r)\n        elif max(whole_col) == min_val:\n            sqr = remove_col(sqr,c)\n        else:\n            return 'NO'\n \n    return 'YES'\n     \n \n \n \n \n \ndef remove_row (sqr, row):\n    cpy = deepcopy(sqr)\n    del cpy[row]\n    return cpy\n \ndef remove_col (sqr,col):\n    cpy = deepcopy(sqr)\n    for row in cpy:\n        del row[col]\n    return cpy\n \n \n \n \n \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (directory)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', directory))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    f_in = open(directory+chosen_filename+'.in')\n    f_out = open(directory+chosen_filename+'.out', 'w')\n    solve(f_in,f_out)\n    f_in.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n"}
{"author": "bigonion", "index": 34, "filename": "2012_1460488_1483485.py", "code": "directory = 'C:/users/hai/my projects/google code jam/2012/qualification/A/'\n \n \nt= '''ay\nbh\nce\nds\neo\nfc\ngv\nhx\nid\nju\nki\nlg\nml\nnb\nok\npr\nqz\nrt\nsn\ntw\nuj\nvp\nwf\nxm\nya\nzq'''\n \ntable = {}\nfor line in t.split():\n    table[line[0]] = line[1]\n \ndef translate (line):\n    l = list(line)\n    for i in range(len(l)):\n        if l[i] in table:\n            l[i] = table[l[i]]\n    return ''.join(l)\n \ndef solve (f_in, f_out):\n    T = int(f_in.readline())\n    for i in range(1,T+1):\n        line = f_in.readline()\n        out_line = translate(line)\n        f_out.write('Case #' + str(i) + ': ' + out_line)\n \n \n \n \n \n \n \n \n \n \ndef main_run():\n    import os\n    filenames = [x for x in os.listdir (directory)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', directory))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    f_in = open(directory+chosen_filename+'.in')\n    f_out = open(directory+chosen_filename+'.out', 'w')\n    solve(f_in,f_out)\n    f_in.close()\n    f_out.close()\n \n \n \n \nmain_run()\n"}
{"author": "bigonion", "index": 34, "filename": "2013_2270488_2463486.py", "code": "directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'\n \n \ndef is_palindrome (n):\n    l = list(str(n))\n    return list(reversed(l)) == l\n \ndef prepare ():\n    global fair_and_squares\n    fair_and_squares = []\n     \n    for i in range(1,10**7):\n        if is_palindrome(i):\n            sqr = i**2\n            if is_palindrome(sqr):\n                fair_and_squares.append(sqr)\n    return\n \n         \ndef solve (f_in, f_out):\n    prepare()\n    T = int(f_in.readline())\n    for testcase in range(1,T+1):\n        A,B = [int(x) for x in f_in.readline().split()]\n        count = len([x for x in fair_and_squares if (x>=A and x<=B)])\n        f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\\n')\n \n \n \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (directory)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', directory))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    f_in = open(directory+chosen_filename+'.in')\n    f_out = open(directory+chosen_filename+'.out', 'w')\n    solve(f_in,f_out)\n    f_in.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n"}
{"author": "bigonion", "index": 34, "filename": "2014_2974486_5756407898963968.py", "code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'\n \n \n \ndef solve (f_in, f_out):\n    T = int(f_in.readline())\n    for testcase in range(1,T+1):\n         \n        c1 = int(f_in.readline())\n        l1 = []\n        for i in range(4):\n            l1.append(f_in.readline())\n         \n        c2 = int(f_in.readline())\n        l2 = []\n        for i in range(4):\n            l2.append(f_in.readline())\n \n        d1 = l1[c1-1].split()\n        d2 = l2[c2-1].split()\n \n        foundFlag = False\n        chosenCard = None\n        badMagician = False\n        for card in d1:\n            if card in d2:\n                if not foundFlag:\n                    foundFlag = True\n                    chosenCard = card\n                else:\n                    badMagician = True\n \n        f_out.write('Case #' + str(testcase) + ': ')\n        if badMagician:\n            f_out.write('Bad magician!\\n')\n        elif not foundFlag:\n            f_out.write('Volunteer cheated!\\n')\n        else:\n            f_out.write(chosenCard + '\\n')\n \n \n \n \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (directory)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', directory))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    f_in = open(directory+chosen_filename+'.in')\n    f_out = open(directory+chosen_filename+'.out', 'w')\n    solve(f_in,f_out)\n    f_in.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n"}
{"author": "sickmath", "index": 35, "filename": "2014_2974486_5709773144064000.py", "code": "f = open('input.in')\ng = open('output', 'w')\n \nT = int(f.readline()[:-1])\n \ndef tot(n) :\n    if n == 0 : return X / 2\n    else :\n        s = 0\n        for i in range(0, n) : s += C / (2 + i*F)\n        return s + X / (2 + n*F)\n \nfor case in xrange(T) :\n    C, F, X = map(float, f.readline()[:-1].split())\n    N =  int(X/C) + 1\n    s, e = 0, N\n    if tot(0) >= tot(1) : \n        while True :\n            m = (s+e)/2\n            if tot(m) <= tot(m-1) and tot(m) <= tot(m+1) : break\n            elif tot(m-1) <= tot(m) <= tot(m+1) : e = m\n            elif tot(m-1) >= tot(m) >= tot(m+1) : s = m\n            else : 1/0\n    else : m = 0\n    output = 'Case #' + str(case + 1) + ': ' + str(tot(m))\n    g.write(output + '\\n')\n    print(output)\n \nf.close()\ng.close()\n"}
{"author": "sickmath", "index": 35, "filename": "2014_2974486_5690574640250880.py", "code": "f = open('input.in')\ng = open('output', 'w')\n \nT = int(f.readline()[:-1])\n \nfor case in xrange(T) :\n    R, C, M = map(int, f.readline()[:-1].split())\n    FREE = R*C - M\n    if FREE == 0 : res = '\\nImpossible'\n    elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\\nImpossible'\n    elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\\nImpossible'\n    else :\n        MAP = [['.' for c in range(C)] for r in range(R)]\n        MAP[0][0] = 'c'\n        if R == 1 :\n            for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\n        elif C == 1 :\n            for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\n        elif R == 2 :\n            for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\n            if FREE == 1 : MAP[1][0] = '*'\n        elif C == 2 :\n            for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\n            if FREE == 1 : MAP[0][1] = '*'\n        else :\n            com = M / C\n            for i in range(R-1, max(R-com-1, 2), -1) :\n                MAP[i] = ['*' for j in range(C)]\n                M -= C\n            I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\n            if I == 2 :\n                com = M / 3\n                if com == 0 : i = C\n                for i in range(C-1, C-com-1, -1) :\n                    MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\n                    M -= 3\n                if M >= 1 : MAP[2][i-1] = '*'\n                if M >= 2 :\n                    if i != 1 : MAP[2][i-2] = '*'\n                    else : MAP[1][0] = '*'\n            else :\n                for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\n                if i == 1 :\n                    MAP[I][i] = '.'\n                    MAP[I-1][C-1] = '*'\n        res = '\\n' + '\\n'.join([''.join(i) for i in MAP])\n    output = 'Case #' + str(case + 1) + ': ' + str(res)\n    g.write(output + '\\n')\n    print(output)\n \nf.close()\ng.close()\n"}
{"author": "sickmath", "index": 35, "filename": "2012_1460488_1595491.py", "code": "fin = open('B-small-attempt0.in', 'r')\nfout = open('B-output.txt', 'w')\n \ncases = int(fin.readline()[:-1])\n \nfor case in range(cases) :\n    line = map(int, fin.readline()[:-1].split(' '))\n    N, S, p = line[:3]\n    T = line[3:]\n    okLimit = p + 2*max(p-1,0)\n    okIfSLimit = p + 2*max(p-2,0)\n    ok = len(filter(lambda x : x >= okLimit, T))\n    okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))\n    res = ok + min(okIfS, S)\n    # print('Case #' + str(case+1) + ': ' + str(res))\n    fout.write('Case #' + str(case+1) + ': ' + str(res) + '\\n')\n     \nfin.close()\nfout.close()\n"}
{"author": "sickmath", "index": 35, "filename": "2013_2270488_2453486.py", "code": "def detectResults() :\n    for sym in ('X', 'O') :\n        for line in board :\n            if all(elem in (sym, 'T') for elem in line) :\n                return sym + ' won'\n        for column in range(4) :\n            if all(board[i][column] in (sym, 'T') for i in range(4)) :\n                return sym + ' won'\n        if all(board[i][i] in (sym, 'T') for i in range(4)) or all(board[3-i][i] in (sym, 'T') for i in range(4)) :\n            return sym + ' won'\n    for sym in ('X', 'O') :\n        for line in board :\n            if all(elem in (sym, 'T', '.') for elem in line) :\n                return 'Game has not completed'\n        for column in range(4) :\n            if all(board[i][column] in (sym, 'T', '.') for i in range(4)) :\n                return 'Game has not completed'\n        if all(board[i][i] in (sym, 'T', '.') for i in range(4)) or all(board[3-i][i] in (sym, 'T', '.') for i in range(4)) :\n            return 'Game has not completed'\n    return 'Draw'\n \nf = open('A-small-attempt0.in', 'r')\ng = open('output', 'w')\n \nT = int(f.readline()[:-1])\n \nfor case in range(T) :\n    board = []\n    for i in range(4) : board.append([i for i in f.readline()[:-1]])\n    outString = 'Case #' + str(case+1) + ': ' + detectResults() + '\\n'\n    print(outString[:-1])\n    g.write(outString)\n    useless = f.readline()[:-1]\n \nf.close()\ng.close()\n"}
{"author": "sickmath", "index": 35, "filename": "2013_2270488_2449486.py", "code": "f = open('B-small-attempt0.in', 'r')\ng = open('output', 'w')\n \nT = int(f.readline()[:-1])\n \nfor case in range(T) :\n    A = []\n    N, M = map(int, f.readline()[:-1].split())\n    for i in range(N) : A.append(map(int, f.readline()[:-1].split()))\n    for line in A : print(line)\n    maxPerRow = map(max, A)\n    maxPerColumn = map(max, zip(*A))\n    res = all(A[i][j] in (maxPerRow[i], maxPerColumn[j]) for i in range(N) for j in range(M))\n    outString = 'Case #' + str(case+1) + ': ' + ('YES' if res else 'NO') + '\\n'\n    print(outString[:-1])\n    g.write(outString)\n \nf.close()\ng.close()\n"}
{"author": "sickmath", "index": 35, "filename": "2012_1460488_1483485.py", "code": "fin = open('A-small-attempt0.in', 'r')\nfout = open('A-output.txt', 'w')\n \ntranslation = {'y': 'a', 'e': 'o', 'q': 'z'}\n \nknownresults = {\n    'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',\n    'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',\n    'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up'\n    }\n \nfor key in knownresults :\n    for letter in range(len(key)) :\n        translation[key[letter]] = knownresults[key][letter]\n \nmissingkey = [i for i in translation.values() if i not in translation.keys()][0]\nmissingvalue = [i for i in translation.keys() if i not in translation.values()][0]\n \ntranslation[missingkey] = missingvalue\n \ncases = int(fin.readline()[:-1])\n \nfor case in range(cases) :\n    line = fin.readline()[:-1]\n    res = [translation[line[i]] for i in range(len(line))]\n    res = ''.join(res)\n    fout.write('Case #' + str(case+1) + ': ' + res + '\\n')\n     \nfin.close()\nfout.close()\n"}
{"author": "sickmath", "index": 35, "filename": "2013_2270488_2463486.py", "code": "import math\n \ndef isPalindrome(n) :\n    return str(n) == str(n)[::-1]\n \ndef findPalindrome(n) :\n    if n % 2 == 0 : return [start*(10**(n/2)) + int(str(start)[::-1]) for start in range(10**(n/2-1),10**(n/2))]\n    if n == 1 : return range(1,10)\n    return [start*(10**(n/2)) + int(str(start)[:-1][::-1]) for start in range(10**(n/2),10**((n+1)/2))]\n \ndef findPalindromeInRange(a, b) :\n    num = range(len(str(a)), len(str(b)) + 1)\n    allPalindrome = []\n    for n in num : allPalindrome += findPalindrome(n)\n    return filter(lambda x : a <= x <= b, allPalindrome)\n \nf = open('C-small-attempt0.in', 'r')\ng = open('output', 'w')\n \nT = int(f.readline()[:-1])\n \nfor case in range(T) :\n    A, B = map(int, f.readline()[:-1].split())\n    a = int(math.ceil(A**0.5))\n    b = int(B**0.5)\n    res = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(a, b)))\n    outString = 'Case #' + str(case+1) + ': ' + str(res) + '\\n'\n    print(outString[:-1])\n    g.write(outString)\n \nf.close()\ng.close()\n"}
{"author": "sickmath", "index": 35, "filename": "2014_2974486_5756407898963968.py", "code": "f = open('input.in')\ng = open('output', 'w')\n \nT = int(f.readline()[:-1])\n \nfor case in xrange(T) :\n    a1 = int(f.readline()[:-1])\n    M1 = [map(int, f.readline()[:-1].split()) for i in range(4)]\n    a2 = int(f.readline()[:-1])\n    M2 = [map(int, f.readline()[:-1].split()) for i in range(4)]\n    r1 = M1[a1-1]\n    r2 = M2[a2-1]\n    res = set(r1).intersection(set(r2))\n    if len(res) == 1 : res = res.pop()\n    elif len(res) == 0 : res = 'Volunteer cheated!'\n    else : res = 'Bad magician!'\n    output = 'Case #' + str(case + 1) + ': ' + str(res)\n    g.write(output + '\\n')\n    print(output)\n \nf.close()\ng.close()\n"}
{"author": "tamaeguchi", "index": 36, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem B. Cookie Clicker Alpha\n# https://code.google.com/codejam/contest/2974486/dashboard#s=p1\n#\n \nimport sys\nimport itertools\n \n \ndef solve(C, F, X):\n    def needtime(cookies, farm):\n        speed = 2.0 + F * farm\n        return cookies / speed\n \n    farm = 0\n    pasttime = 0\n    while True:\n        complete = needtime(X, farm)\n        nextfarm = needtime(C, farm)\n        nextchallenge = needtime(X, farm + 1)\n        if complete <= nextfarm + nextchallenge:\n            return pasttime + complete\n        pasttime += nextfarm\n        farm += 1\n \n \ndef main(IN, OUT):\n    T = int(IN.readline())\n    for index in range(T):\n        C, F, X = map(float, IN.readline().split())\n        OUT.write('Case #%d: %.7f\\n' % (index + 1, solve(C, F, X)))\n \n \ndef makesample(maxC=500, maxF=4, maxX=2000, T=100):\n    import random\n    print(T)\n    for index in range(T):\n        print(' '.join('{0}'.format(random.randint(10000, maxvalue * 10000) / 10000.0))\n                        for maxvalue in (maxC, maxF, maxX))\n \n \nif __name__ == '__main__':\n    if '-makesample' in sys.argv[1:]:\n        makesample()\n    else:\n        main(sys.stdin, sys.stdout)\n \n"}
{"author": "tamaeguchi", "index": 36, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem C. Minesweeper Master\n# https://code.google.com/codejam/contest/2974486/dashboard#s=p2\n#\n \nimport sys\n \n \ndef check(R, C, M, _board):\n    # deepcopy\n    board = [line[:] for line in _board]\n \n    pos = [(0, 0)]\n    while pos:\n        row, col = pos.pop()\n        # neighbor cell list\n        neighbor = []\n        for r in (-1, 0, 1):\n            r += row\n            for c in (-1, 0, 1):\n                c += col\n                if r >= 0 and r < R and c >= 0 and c < C:\n                    neighbor.append((r, c))\n        # count bomb\n        count = len([1 for r, c in neighbor if board[r][c] == '*'])\n        board[row][col] = str(count)\n        # push next cell\n        if count == 0:\n            for r, c in neighbor:\n                if board[r][c] == '.':\n                    pos.append((r, c))\n \n    flat = ''.join(''.join(line) for line in board)\n    result = not flat.count('.')\n    if not result and False: # for DEBUG\n        print('-' * 20)\n        print(R, C, M)\n        print('\\n'.join(''.join(line) for line in _board))\n        print('-' * 20)\n    assert flat.count('*') == M\n    return result\n \n \ndef solve(R, C, M):\n    # initialize\n    board = [['.'] * C for row in range(R)]\n    board[0][0] = 'c'\n    row = R\n    col = C\n    mine = M\n \n    # phase 1: right edge, bottom edge\n    while mine:\n        if 0 < row <= col and mine >= row:\n            for r in range(row):\n                board[row - r - 1][col - 1] = '*'\n            mine -= row\n            col -= 1\n        elif 0 < col <= row and mine >= col:\n            for c in range(col):\n                board[row - 1][col - c - 1] = '*'\n            mine -= col\n            row -= 1\n        else:\n            break\n \n    # phase 2:\n    if mine:\n        #print('\\n'.join(''.join(line) for line in board))\n        #print('left', mine)\n        while mine and row > 2:\n            for r in range(min(mine, row - 2)):\n                board[row - r - 1][col - 1] = '*'\n                mine -= 1\n            col -= 1\n        while mine and col > 2:\n            for c in range(min(mine, col - 2)):\n                board[row - 1][col - c - 1] = '*'\n                mine -= 1\n            row -= 1\n \n    # phase 3\n    if mine:\n        # col == row == 2\n        if mine:\n            board[1][1] = '*'\n            mine -= 1\n        if mine:\n            board[1][0] = '*'\n            mine -= 1\n        if mine:\n            board[0][1] = '*'\n            mine -= 1\n \n    assert mine == 0\n    return '\\n'.join(''.join(line) for line in board) if check(R, C, M, board) else 'Impossible'\n \n \ndef main(IN, OUT):\n    T = int(IN.readline())\n    for index in range(T):\n        R, C, M = map(int, IN.readline().split())\n        OUT.write('Case #%d:\\n%s\\n' % (index + 1, solve(R, C, M)))\n \n \ndef makesample(maxSize=5, T=230):\n    import random\n    print(T)\n    for index in range(T):\n        R = random.randint(1, maxSize)\n        C = random.randint(1, maxSize)\n        print(R, C, random.randint(0, R * C - 1))\n \n \ndef makesample():\n    pattern = []\n    for R in range(1, 5+1):\n        for C in range(1, 5+1):\n            for M in range(R * C):\n                pattern.append((R, C, M))\n    print(len(pattern))\n    for R, C, M in pattern:\n        print(R, C, M)\n \n \nif __name__ == '__main__':\n    if '-makesample' in sys.argv[1:]:\n        makesample()\n    else:\n        main(sys.stdin, sys.stdout)\n \n"}
{"author": "tamaeguchi", "index": 36, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem B. Dancing With the Googlers\n# http://code.google.com/codejam/contest/1460488/dashboard#s=p1\n#\n \nimport sys\nimport string\n \n# 通常\n# t が 3 の倍数のとき ⇒ (t/3, t/3, t/3)\n# t が 3 の倍数 +1 のとき ⇒ (t//3 + 1, t//3, t//3)\n# t が 3 の倍数 +2 のとき ⇒ (t//3 + 1, t//3 + 1, t//3)\n \n# surprising の場合\n# t が 3 の倍数のとき ⇒ (t/3 + 1, t/3, t/3 - 1)\n# t が 3 の倍数 +1 のとき ⇒ (t//3 + 1, t//3 + 1, t//3 - 1)\n# t が 3 の倍数 +2 のとき ⇒ (t//3 + 2, t//3, t//3)\n \n \ndef solve(S, p, tlist):\n\t# 確実に p を超える\n\tabove = 0\n\t# surprising で超えるかもしれない\n\tconsider = 0\n \n\tfor t in tlist:\n\t\tavg = t / 3\n\t\tmod = t % 3\n \n\t\tif mod == 0:\n\t\t\t# t が 3 の倍数 ⇒ (t/3, t/3, t/3)\n\t\t\tif avg >= p:\n\t\t\t\tabove += 1\n\t\t\telif avg + 1 >= p and t > 0:\n\t\t\t\t# surprising ⇒ (t/3 + 1, t/3, t/3 - 1)\n\t\t\t\tconsider += 1\n \n\t\telif mod == 1:\n\t\t\t# t が 3 の倍数 +1 ⇒ (t//3+1, t//3, t//3)\n\t\t\tif avg + 1 >= p:\n\t\t\t\tabove += 1\n\t\t\t# surprising ⇒ (t//3 + 1, t//3 + 1, t//3 - 1)\n\t\t\t# +1 で変わらないのでNOP\n \n\t\telif mod == 2:\n\t\t\t# t が 3 の倍数 +2 ⇒ (t//3+1, t//3+1, t//3)\n\t\t\tif avg + 1 >= p:\n\t\t\t\tabove += 1\n\t\t\telif avg + 2 >= p:\n\t\t\t\t# surprising ⇒ (t//3 + 2, t//3, t//3)\n\t\t\t\tconsider += 1\n \n\treturn above + min(S, consider)\n \n \ndef main(IN, OUT):\n\tN = int(IN.readline())\n\tfor index in range(N):\n\t\tdata = map(int, IN.readline().strip().split())\n\t\t(N, S, p), tlist = data[:3], data[3:]\n\t\tOUT.write('Case #%d: %d\\n' % (index + 1, solve(S, p, tlist)))\n \n \nif __name__ == '__main__':\n\tmain(sys.stdin, sys.stdout)\n \n"}
{"author": "tamaeguchi", "index": 36, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem A. Tic-Tac-Toe-Tomek\n# https://code.google.com/codejam/contest/2270488/dashboard#s=p0\n#\n \nimport sys\nimport string\n \n \ndef solve(board):\n    rows = [board[n:][:4] for n in range(0, len(board), 4)]\n    cols = [''.join(board[step+n*4] for n in range(4)) for step in range(4)]\n    corners = [''.join(board[n] for n in range(0, len(board), 5)),\n                ''.join(board[n] for n in range(3, len(board)-1, 3))]\n    lines = rows + cols + corners\n \n    for line in lines:\n        if line.replace('T', 'X') == 'XXXX':\n            return 'X won'\n        if line.replace('T', 'O') == 'OOOO':\n            return 'O won'\n    return 'Game has not completed' if '.' in board else 'Draw'\n \n \ndef main(IN, OUT):\n    T = int(IN.readline())\n    for index in range(T):\n        board = ''.join([IN.readline().strip() for row in range(4)])\n        OUT.write('Case #%d: %s\\n' % (index + 1, solve(board)))\n        # empty line\n        IN.readline()\n \n \ndef makesample(T=1000):\n    import random\n    print (T)\n    for index in range(T):\n        board = []\n        for row in range(4):\n            board.append(''.join(random.choice('XO.') for col in range(4)))\n        tcol = random.randint(0, 3)\n        trow = random.randint(0, 3)\n        board[trow] = board[trow][:tcol] + 'T' + board[trow][tcol+1:]\n        print ('\\n'.join(board))\n        print\n \n \nif __name__ == '__main__':\n    if '-makesample' in sys.argv[1:]:\n        makesample()\n    else:\n        main(sys.stdin, sys.stdout)\n \n"}
{"author": "tamaeguchi", "index": 36, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem B. Lawnmower\n# https://code.google.com/codejam/contest/2270488/dashboard#s=p1\n#\n \nimport sys\n \n \ndef solve(board):\n    vboard = []\n    for m in range(len(board[0])):\n        vboard.append([board[n][m] for n in range(len(board))])\n \n    for n in range(len(board)):\n        for m in range(len(board[n])):\n            h = board[n][m]\n            if h < max(board[n]) and h < max(vboard[m]):\n                return 'NO'\n    return 'YES'\n \n \ndef main(IN, OUT):\n    T = int(IN.readline())\n    for index in range(T):\n        N, M = map(int, IN.readline().split())\n        field = [map(int, IN.readline().split()) for n in range(N)]\n        OUT.write('Case #%d: %s\\n' % (index + 1, solve(field)))\n \n \ndef makesample(NMmax=100, amax=100, T=100):\n    import random\n    print(T)\n    for index in range(T):\n        N = random.randint(1, NMmax)\n        M = random.randint(1, NMmax)\n        print(N, M)\n        for n in range(N):\n            print(' '.join(str(random.randint(1, amax)) for m in range(M)))\n \n \nif __name__ == '__main__':\n    if '-makesample' in sys.argv[1:]:\n        makesample()\n    else:\n        main(sys.stdin, sys.stdout)\n \n"}
{"author": "tamaeguchi", "index": 36, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem A. Speaking in Tongues\n# http://code.google.com/codejam/contest/1460488/dashboard#s=p0\n#\n \nimport sys\nimport string\n \nINPUT = '''ejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv'''\nOUTPUT = '''our language is impossible to understand\nthere are twenty six factorial possibilities\nso it is okay if you want to just give up'''\n \n \nclass Table(dict):\n\tTARGET = string.ascii_lowercase\n \n\tdef translate(self, msg):\n\t\treturn ''.join((self[c] if c in self.TARGET else c) for c in msg)\n \n\t@classmethod\n\tdef maketable(cls, src, dst):\n\t\ttable = cls()\n\t\tleft = set(cls.TARGET)\n\t\tfor s, d in zip(src, dst):\n\t\t\tif s in table:\n\t\t\t\tif table[s] != d:\n\t\t\t\t\traise Exception('BAD MAPPING \"%s\" => \"%s\"/\"%s\"' % (s, table[s], d))\n\t\t\telif s in cls.TARGET:\n\t\t\t\ttable[s] = d\n\t\t\t\tleft.remove(s)\n\t\tif left:\n\t\t\tif len(left) != 2:\n\t\t\t\traise Exception('left letter incorrect')\n\t\t\tl1, l2 = left\n\t\t\ttable[l1] = l2\n\t\t\ttable[l2] = l1\n\t\treturn table\n \n \ndef main():\n\ttable = Table.maketable(INPUT, OUTPUT)\n\tN = int(sys.stdin.readline())\n\tfor index in range(N):\n\t\tline = sys.stdin.readline().strip()\n\t\tprint('Case #%d:' % (index + 1), table.translate(line))\n \n \nif __name__ == '__main__':\n\tmain()\n \n"}
{"author": "tamaeguchi", "index": 36, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem C. Fair and Square\n# https://code.google.com/codejam/contest/2270488/dashboard#s=p2\n#\n \nimport sys\nimport math\n \n \ndef ispalindrome(n):\n    return str(n) == str(n)[::-1]\n \n \ndef solve(A, B):\n    solution = []\n    for n in range(int(math.sqrt(A)), int(math.sqrt(B))+1):\n        if ispalindrome(n):\n            m = n ** 2\n            if ispalindrome(m) and A <= m <= B:\n                solution.append(n)\n    return len(solution)\n \n \ndef main(IN, OUT):\n    T = int(IN.readline())\n    for index in range(T):\n        A, B = map(int, IN.readline().split())\n        OUT.write('Case #%d: %s\\n' % (index + 1, solve(A, B)))\n \n \ndef makesample(T=100, ABmax=1000):\n    import random\n    print(T)\n    for index in range(T):\n        A = random.randint(1, ABmax)\n        B = random.randint(A, ABmax)\n        print(A, B)\n \n \nif __name__ == '__main__':\n    if '-makesample' in sys.argv[1:]:\n        makesample()\n    else:\n        main(sys.stdin, sys.stdout)\n \n"}
{"author": "tamaeguchi", "index": 36, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem *. \n# https://code.google.com/codejam/contest/***\n#\n \nimport sys\n \n \ndef solve(arrange):\n    board, row = arrange[0]\n    before = board[row - 1]\n    board, row = arrange[1]\n    after = board[row - 1]\n    dup = set(before) & set(after)\n    if len(dup) == 1:\n        return dup.pop()\n    elif len(dup) >= 2:\n        return 'Bad magician!'\n    else:\n        return 'Volunteer cheated!'\n \n \ndef main(IN, OUT):\n    T = int(IN.readline())\n    for index in range(T):\n        arrange = []\n        for n in range(2):\n            row = int(IN.readline())\n            board = []\n            for line in range(4):\n                board.append(map(int, IN.readline().split()))\n            arrange.append((board, row))\n        OUT.write('Case #%d: %s\\n' % (index + 1, solve(arrange)))\n \n \ndef makesample(T=100):\n    import random\n    print(T)\n    for index in range(T):\n        for n in range(2):\n            print(random.randint(1, 4))\n            board = list(range(1, 16+1))\n            random.shuffle(board)\n            while board:\n                print(' '.join(map(str, board[:4])))\n                board = board[4:]\n \n \nif __name__ == '__main__':\n    if '-makesample' in sys.argv[1:]:\n        makesample()\n    else:\n        main(sys.stdin, sys.stdout)\n \n"}
{"author": "anb", "index": 37, "filename": "2014_2974486_5709773144064000.py", "code": "from sys import stdin\n \ndef read_str(): return stdin.readline().rstrip('\\n')\ndef read_int(): return int(stdin.readline())\ndef read_ints(): return map(int, stdin.readline().split())\ndef read_floats(): return map(float, stdin.readline().split())\n \n \ndef solve_case():\n    C, F, X = read_floats()\n    rate = 2\n    current = 0\n    best = X / rate\n     \n    while True:\n        current += C / rate\n        rate += F\n        next = current + X / rate\n        if next < best:\n            best = next\n        else:\n            break\n     \n    return best\n \n     \ndef main():\n    cases = read_int()\n    for case in range(1, cases + 1):\n        print('Case #{}: {:.7f}'.format(case, solve_case()))\n \n         \nmain()\n"}
{"author": "anb", "index": 37, "filename": "2014_2974486_5690574640250880.py", "code": "from sys import stdin\n \n \ndef read_str(): return stdin.readline().rstrip('\\n')\ndef read_int(): return int(stdin.readline())\ndef read_ints(): return map(int, stdin.readline().split())\ndef read_floats(): return map(float, stdin.readline().split())\n \n \ndef atos(A):\n    return '\\n'.join([''.join(row) for row in A])\n     \n \ndef get_field(r, c):\n    field = [['.'] * c for i in range(r)]\n    field[0][0] = 'c'\n    return field\n     \n     \ndef is_forbidden(i, j):\n    return i == 0 and j == 0 or i == 0 and j == 1 or \\\n        i == 1 and j == 0 or i == 1 and j == 1\n     \n     \ndef fill(field, r, c, m):\n    left = m\n    for ii in range(r - 1, -1, -1):\n        i = ii\n        j = c - 1\n        while i < r and j >= 0:\n            if is_forbidden(i, j):\n                i += 1\n                j -= 1\n                continue\n            if left == 0:\n                return 0\n            field[i][j] = '*'\n            left -= 1\n             \n            i += 1\n            j -= 1\n             \n        if ii == 0:\n            for jj in range(c - 2, 1, -1):\n                i = ii\n                j = jj\n                while i < r and j >= 0:\n                    if is_forbidden(i, j):\n                        i += 1\n                        j -= 1\n                        continue\n                    if left == 0:\n                        return 0\n                    field[i][j] = '*'\n                    left -= 1\n                     \n                    i += 1\n                    j -= 1\n             \n    if r * c == m + 1:\n        if r > 1:\n            field[1][0] = '*'\n        if c > 1:\n            field[0][1] = '*'\n        if r > 1 and c > 1:\n            field[1][1] = '*'\n        return 0\n             \n    return left\n \n     \ndef solve_case():\n    r, c, m = read_ints()\n    #print('\\n', r, c, m)\n     \n    field = get_field(r, c)\n         \n    left = fill(field, r, c, m)\n         \n    return 'Impossible' if left != 0 else atos(field)\n     \n     \ndef main():\n    cases = read_int()\n    for case in range(1, cases + 1):\n        print('Case #{}:\\n{}'.format(case, solve_case()))\n \n         \nmain()\n"}
{"author": "anb", "index": 37, "filename": "2012_1460488_1595491.py", "code": "from sys import stdin\n \ndef program():\n\tT = int(stdin.readline())\n\tfor Ti in xrange(T):\n\t\tnumbers = a = map(int, stdin.readline().rstrip().split(' '))\n\t\tN, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]\n \t\t\n\t\tm = 0\n\t\tcurr_S = S\n\t\tfor i in xrange(N):\n\t\t\tt = totals[i]\n \t\t\t\n\t\t\tif t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):\n\t\t\t\tm += 1\n\t\t\telif curr_S > 0 and t > 0:\n\t\t\t\tif (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):\n\t\t\t\t\tm += 1\n\t\t\t\t\tcurr_S -= 1\n \t\t\n\t\tprint('Case #%d: %d' % (Ti + 1, m)\t)\n \t\nif __name__ == '__main__':\n\tprogram()"}
{"author": "anb", "index": 37, "filename": "2013_2270488_2453486.py", "code": "from sys import stdin\n \ndef won(x, o, t):\n    if x == 4 or (x == 3 and t == 1):\n        return 1\n    elif o == 4 or (o == 3 and t == 1):\n        return 2\n \ndef check(board, BOARD_SIZE, RESULTS):\n    d = 0\n    for i in xrange(BOARD_SIZE):\n        x = board[i].count('X')\n        o = board[i].count('O')\n        t = board[i].count('T')\n        d += board[i].count('.')\n        w = won(x, o, t)\n        if w:\n            return w\n    for i in xrange(BOARD_SIZE):\n        vertical = [ board[j][i] for j in xrange(BOARD_SIZE) ]\n        x = vertical.count('X')\n        o = vertical.count('O')\n        t = vertical.count('T')\n        w = won(x, o, t)\n        if w:\n            return w\n    x, o, t = 0, 0, 0\n    for i in xrange(BOARD_SIZE):\n        if board[i][i] == 'X':\n            x += 1\n        elif board[i][i] == 'O':\n            o += 1\n        elif board[i][i] == 'T':\n            t += 1\n    w = won(x, o, t)\n    if w:\n        return w    \n    x, o, t = 0, 0, 0\n    for i in xrange(BOARD_SIZE):\n        if board[i][BOARD_SIZE - i - 1] == 'X':\n            x += 1\n        elif board[i][BOARD_SIZE - i - 1] == 'O':\n            o += 1\n        elif board[i][BOARD_SIZE - i - 1] == 'T':\n            t += 1\n    w = won(x, o, t)\n    if w:\n        return w\n    if d == 0:\n        return 3\n    else:\n        return 4\n     \ndef main():\n    BOARD_SIZE = 4\n    RESULTS = 'X won', 'O won', 'Draw', 'Game has not completed'\n \n    T = int(stdin.readline())\n    for Ti in xrange(T):\n        board = []\n        for i in xrange(BOARD_SIZE):\n            board.append(list(stdin.readline().rstrip()))\n        print('Case #{}: {}'.format(Ti + 1, RESULTS[check(board, BOARD_SIZE, RESULTS) - 1])    )\n        stdin.readline()\n         \nmain()\n"}
{"author": "anb", "index": 37, "filename": "2013_2270488_2449486.py", "code": "from sys import stdin\n \ndef read_ints():\n    return map(int, stdin.readline().rstrip().split(' '))\n \ndef print_lawn(lawn):\n    for row in lawn:\n        print(row)\n         \ndef is_higher(a, i, j, N, M):\n    s = a[i][j]\n    v, h = False, False\n    for ii in xrange(N):\n        if a[ii][j] > s:\n            v = True\n            break\n    for jj in xrange(M):\n        if a[i][jj] > s:\n            h = True\n            break\n    return v and h\n     \ndef check(a, N, M):\n    if N == 1 or M == 1:\n        return True\n    else:\n        for i in xrange(N):\n            for j in xrange(M):\n                h = is_higher(a, i, j, N, M)\n                if h:\n                    return False\n        return True\n     \ndef main():\n    T = int(stdin.readline())\n    for Ti in xrange(T):\n        N, M = read_ints()\n        a = []\n        for i in xrange(N):\n            a.append(read_ints())\n        answer = 'YES' if check(a, N, M) else 'NO'\n        #print_lawn(a)\n        print('Case #{}: {}'.format(Ti + 1, answer))\n         \nmain()\n"}
{"author": "anb", "index": 37, "filename": "2012_1460488_1483485.py", "code": "from sys import stdin\n \ndef get_mapping():\n\td = ord('a')\n\tmapping = [ None ] * 26\n\tinputs = [ 'ejp mysljylc kd kxveddknmc re jsicpdrysi', \n\t\t'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', \n\t\t'de kr kd eoya kw aej tysr re ujdr lkgc jv' ]\n\toutputs = [ 'our language is impossible to understand', \n\t\t'there are twenty six factorial possibilities', \n\t\t'so it is okay if you want to just give up' ]\n \t\n\tfor i in xrange(len(inputs)):\n\t\tinput = inputs[i]\n\t\toutput = outputs[i]\n\t\tfor j in xrange(len(input)):\n\t\t\tif input[j] == ' ':\n\t\t\t\tcontinue\n\t\t\tk = ord(input[j]) - d\n\t\t\tif mapping[k] is None:\n\t\t\t\tmapping[k] = output[j]\n\tmapping[ord('q') - d] = 'z'\n\tmapping[ord('z') - d] = 'q'\n \t\t\t\t\n\treturn mapping\n \t\t\t\n \ndef program():\n\tT = int(stdin.readline())\n\tmapping = get_mapping()\n\td = ord('a')\n\tfor i in xrange(T):\n\t\ts = stdin.readline().rstrip()\n\t\tt = ''\n \t\t\n\t\tfor ss in s:\n\t\t\tif ss == ' ':\n\t\t\t\tt += ' '\n\t\t\telse:\n\t\t\t\tt += mapping[ord(ss) - d]\n\t\tprint('Case #%d: %s' % (i + 1, t))\n \t\nif __name__ == '__main__':\n\tprogram()"}
{"author": "anb", "index": 37, "filename": "2013_2270488_2463486.py", "code": "from sys import stdin\n \ndef read_ints():\n    return map(int, stdin.readline().rstrip().split(' '))\n \ndef is_palin(n):\n    s = str(n)\n    return s == s[::-1]\n     \ndef find(n, fas):\n    for i in xrange(len(fas)):\n        if fas[i] >= n:\n            return i\n    return len(fas)\n     \ndef gen_fas(max):\n    fas = []\n    fasappend = fas.append\n    square, base, d = 1, 1, 3\n    while square < max:\n        if is_palin(square) and is_palin(base):\n            fasappend(square)\n        square += d\n        d += 2\n        base += 1\n    return fas\n     \ndef main():\n    MAX = 1000\n    fas = gen_fas(MAX)\n     \n    T = int(stdin.readline())\n    for Ti in xrange(T):\n        A, B = read_ints()\n        answer = find(B + 1, fas) - find(A, fas)\n        print('Case #{}: {}'.format(Ti + 1, answer))\n         \nmain()\n"}
{"author": "anb", "index": 37, "filename": "2014_2974486_5756407898963968.py", "code": "from sys import stdin\n \ndef read_str(): return stdin.readline().rstrip('\\n')\ndef read_int(): return int(stdin.readline())\ndef read_ints(): return map(int, stdin.readline().split())\n \ndef read_cards():\n    cards = []\n    for i in range(4):\n        cards.append(read_ints())\n    return cards\n \ndef main():\n    cases = read_int()\n    for case in range(1, cases + 1):\n        row = read_int() - 1\n        cards = read_cards()\n        candidates1 = set(cards[row])\n         \n        row = read_int() - 1\n        cards = read_cards()\n        candidates2 = set(cards[row])\n         \n        candidates = candidates1.intersection(candidates2)\n        if len(candidates) == 1:\n            ans = list(candidates)[0]\n        elif len(candidates) == 0:\n            ans = 'Volunteer cheated!'\n        else:\n            ans = 'Bad magician!'\n         \n        print('Case #{}: {}'.format(case, ans))\n         \nmain()\n"}
{"author": "kawasaki", "index": 38, "filename": "2014_2974486_5709773144064000.py", "code": "# -*- coding: utf-8 -*-\n \nT = int(raw_input())\nfor test_case in xrange(1, T + 1):\n    C, F, X = map(float, raw_input().split())\n    answer = X / 2\n    i = 0\n    last_tc = 0\n    while True:\n        tc = last_tc + C / (2 + (i * F))\n        if answer < tc:\n            break\n        answer = min(tc + X / (2 + (i + 1) * F), answer)\n \n        i += 1\n        last_tc = tc\n    print('Case #{}: {:.7f}'.format(test_case, answer))\n"}
{"author": "kawasaki", "index": 38, "filename": "2014_2974486_5690574640250880.py", "code": "# -*- coding: utf-8 -*-\n \nT = int(raw_input())\nfor test_case in xrange(1, T + 1):\n    R, C, M = map(int, raw_input().split())\n    N = R * C\n    B = N - M\n \n    W, H = (C, R) if R <= C else (R, C)\n \n    if H == 1:\n        answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\n    elif M == N - 1:\n        answer = [['*'] * W for r in xrange(H)]\n        answer[0][0] = 'c'\n    elif B < 4 or B in (5, 7):\n        answer = None\n    elif H == 2:\n        if M % 2 == 0:\n            bw = B / 2\n            answer = [\n                ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\n                ['.'] * bw + ['*'] * (W - bw),\n            ]\n        else:\n            answer = None\n    else:\n        answer = [['*'] * W for y in xrange(H)]\n        answer[0][0] = 'c'\n        answer[0][1] = answer[1][0] = answer[1][1] = '.'\n        left = B - 4\n        if 2 <= left:\n            answer[0][2] = answer[1][2] = '.'\n            left -= 2\n        if 2 <= left:\n            answer[2][0] = answer[2][1] = '.'\n            left -= 2\n \n        x = y = 3\n        while (x < W or y < H) and 2 <= left:\n            if x < W and 2 <= left:\n                answer[0][x] = answer[1][x] = '.'\n                left -= 2\n                x += 1\n            if y < H and 2 <= left:\n                answer[y][0] = answer[y][1] = '.'\n                left -= 2\n                y += 1\n \n        y = 2\n        while 0 < left and y < H:\n            x = 2\n            while 0 < left and x < W:\n                answer[y][x] = '.'\n                left -= 1\n                x += 1\n            y += 1\n \n    if answer is None:\n        answer = 'Impossible'\n    else:\n        if W == R:\n            answer = map(list, zip(*answer))\n        assert len(answer) == R\n        assert len(answer[0]) == C\n        assert sum(row.count('*') for row in answer) == M\n#        # DEBUG\n#        h = len(answer)\n#        w = len(answer[0])\n#        for y in xrange(h):\n#            for x in xrange(w):\n#                if answer[y][x] in '.c':\n#                    count = 0\n#                    for dy in (-1, 0, 1):\n#                        for dx in (-1, 0, 1):\n#                            if (\n#                                0 <= x + dx < w and\n#                                0 <= y + dy < h and\n#                                answer[y + dy][x + dx] == '*'\n#                            ):\n#                                count += 1\n#                    answer[y][x] = str(count)\n        answer = '\\n'.join([''.join(row) for row in answer])\n    print('Case #{}:\\n{}'.format(test_case, answer))\n"}
{"author": "kawasaki", "index": 38, "filename": "2012_1460488_1595491.py", "code": "# -*- coding: utf-8 -*-\n \nimport itertools\n \nposs = dict([(i, {}) for i in xrange(0, 30 + 1)])\nfor a, b, c in itertools.product(range(10 + 1), repeat=3):\n    if a <= b <= c and c - a <= 2:\n        n = a + b + c\n        if c - a == 2:\n            poss[n]['s'] = tuple(sorted((a, b, c)))\n        else:\n            poss[n]['n'] = tuple(sorted((a, b, c)))\n \n \nT = int(raw_input())\nfor case in xrange(1, T + 1):\n    div = map(int, raw_input().split())\n    N, S, p = div[:3]\n    t = div[3:]\n \n    ans = 0\n    t.sort(reverse=True)\n    for i in xrange(len(t)):\n        na, nb, nc = poss[t[i]]['n']\n        sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))\n        if p <= nc:\n            ans += 1\n        elif 0 < S and p <= sc:\n            ans += 1\n            S -= 1\n \n    print('Case #%d: %d' % (case, ans))\n \n"}
{"author": "kawasaki", "index": 38, "filename": "2013_2270488_2453486.py", "code": "# -*- coding: utf-8 -*-\n \nT = int(raw_input())\nfor test_case_id in xrange(1, T + 1):\n    cells = []\n    for i in xrange(4):\n        cells.append(raw_input())\n    raw_input()\n \n    R = range(4)\n    for c in 'XO':\n        if (\n            any(all(cells[i][j] in (c, 'T') for j in R) for i in R) or\n            any(all(cells[i][j] in (c, 'T') for i in R) for j in R) or\n            all(cells[i][i] in (c, 'T') for i in R) or\n            all(cells[i][3 - i] in (c, 'T') for i in R)\n        ):\n            print('Case #{}: {} won'.format(test_case_id, c))\n            break\n    else:\n        if '.' in ''.join(cells):\n            print('Case #{}: Game has not completed'.format(test_case_id))\n        else:\n            print('Case #{}: Draw'.format(test_case_id))\n"}
{"author": "kawasaki", "index": 38, "filename": "2013_2270488_2449486.py", "code": "# -*- coding: utf-8 -*-\n \nT = int(raw_input())\nfor test_case_id in xrange(1, T + 1):\n    N, M = map(int, raw_input().split())\n    A = []\n    for i in xrange(N):\n        A.append(map(int, raw_input().split()))\n \n    heights = reduce(lambda a, b: a | b, (set(row) for row in A))\n    for y in xrange(N):\n        for x in xrange(M):\n            if (\n                any(A[y][j] > A[y][x] for j in xrange(M)) and\n                any(A[i][x] > A[y][x] for i in xrange(N))\n            ):\n                # Found a region surrounded by higher regions.\n                print('Case #{}: NO'.format(test_case_id))\n                break\n        else:\n            continue\n        break\n    else:\n        print('Case #{}: YES'.format(test_case_id))\n"}
{"author": "kawasaki", "index": 38, "filename": "2012_1460488_1483485.py", "code": "# -*- coding: utf-8 -*-\n \nimport string\n \n \nstr_to = '''\nejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv\n'''.replace(' ', '').replace('\\n', '')\n \nstr_from = '''\nour language is impossible to understand\nthere are twenty six factorial possibilities\nso it is okay if you want to just give up\n'''.replace(' ', '').replace('\\n', '')\n \nconv = {}\nfor i, c in enumerate(str_from):\n    assert c not in conv or conv[c] == str_to[i]\n    conv[c] = str_to[i]\nconv['z'] = 'q'\nconv['q'] = 'z'\n \nassert len(set(conv.keys())) == 26\nassert len(set(conv.values())) == 26\nmat = ['', '']\nfor k, v in conv.items():\n    mat[0] += v\n    mat[1] += k\n \nT = int(raw_input())\nfor case in xrange(1, T + 1):\n    line = raw_input()\n    ans = string.translate(line, string.maketrans(*mat))\n    print('Case #%d: %s' % (case, ans))\n \n"}
{"author": "kawasaki", "index": 38, "filename": "2013_2270488_2463486.py", "code": "# -*- coding: utf-8 -*-\n \nN_MAX = 10 ** 7  # for First large dataset\n \n \ndef is_palindrome(n):\n    s = str(n)\n    for i in xrange(len(s) / 2):\n        if s[i] != s[-1 - i]:\n            return False\n    return True\n \npalindromes = [x for x in xrange(N_MAX) if is_palindrome(x)]\npalindrome_squares = [x ** 2 for x in palindromes]\nfair_and_square_palindromes = filter(is_palindrome, palindrome_squares)\n \n \nT = int(raw_input())\nfor test_case_id in xrange(1, T + 1):\n    A, B = map(int, raw_input().split())\n    answer = len([x for x in fair_and_square_palindromes if A <= x <= B])\n    print('Case #{}: {}'.format(test_case_id, answer))\n"}
{"author": "kawasaki", "index": 38, "filename": "2014_2974486_5756407898963968.py", "code": "# -*- coding: utf-8 -*-\n \nT = int(raw_input())\nfor test_case in xrange(1, T + 1):\n    N1 = int(raw_input())\n    for i in xrange(4):\n        if i + 1 == N1:\n            R1 = map(int, raw_input().split(' '))\n        else:\n            raw_input()\n    N2 = int(raw_input())\n    for i in xrange(4):\n        if i + 1 == N2:\n            R2 = map(int, raw_input().split(' '))\n        else:\n            raw_input()\n    assert 1 <= N1 <= 4\n    assert 1 <= N2 <= 4\n    assert len(R1) == len(R2) == 4\n \n    num = set(R1) & set(R2)\n    if len(num) == 1:\n        answer = num.pop()\n    elif 1 < len(num):\n        answer = 'Bad magician!'\n    else:\n        answer = 'Volunteer cheated!'\n    print('Case #{}: {}'.format(test_case, answer))\n"}
{"author": "michael", "index": 39, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\n \ndef read_line():\n    return sys.stdin.readline().rstrip( '\\n' )\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_float():\n    return float( read_line() )\n \ndef read_floats():\n    return [ float( x ) for x in read_line().split() ]\n \nT = read_integer()\nfor t in range( T ):\n    C, F, X = read_floats()\n    rate = 2\n    cookies = 0\n    s = 0\n    while True:\n        t1 = X/rate\n        t2 = C/rate + X/( rate + F )\n        if t1 < t2:\n            s += t1\n            break\n        s += C/rate\n        rate += F\n    print('Case #%i: %.7f' % ( t + 1, s ))\n"}
{"author": "michael", "index": 39, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\n \ndef read_line():\n    return sys.stdin.readline().rstrip( '\\n' )\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( x ) for x in read_line().split() ]\n \ndef flip( grid ):\n    return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n \ndef grow( R, C, M ):\n    grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n    b = R*C - M\n    if C > R:\n        R, C, grid = C, R, flip( grid )\n        flipped = True\n    else:\n        flipped = False\n    if b < 2*C:\n        if b == 1:\n            grid[ 0 ][ 0 ] = 'c'\n        elif b == 3 and C >= 3:\n            grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n        elif b % 2:\n            return\n        else:\n            grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n            grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n            grid[ 0 ][ 0 ] = 'c'\n    else:\n        r = 0\n        while b >= C:\n            grid[ r ] = bytearray( C*[ '.' ] )\n            b -= C\n            r += 1\n        if b:\n            if b >= 2:\n                grid[ r ][ : b ] = b*'.'\n            elif C > 2 and r > 2:\n                grid[ r - 1 ][ -1 ] = '*'\n                grid[ r ][ : 2 ] = '..'\n            else:\n                return\n        grid[ 0 ][ 0 ] = 'c'\n    return flip( grid ) if flipped else grid\n     \nT = read_integer()\nfor t in range( T ):\n    print('Case #%i:' % ( t + 1 ))\n    R, C, M = read_integers()\n    grid = grow( R, C, M )\n    print('\\n'.join( str( row ) for row in grid ) if grid else 'Impossible')\n"}
{"author": "michael", "index": 39, "filename": "2012_1460488_1595491.py", "code": "def read_line():\n    return raw_input().strip()\n \ndef read_words():\n    return read_line().split()\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( x ) for x in read_words() ]\n \nT = read_integer()\nfor t in range( T ):\n    print('Case #%i:' % ( t + 1 ),)\n    line = iter( read_integers() )\n    N = line.next()\n    S = line.next()\n    p = line.next()\n    t = sorted( line )\n    count = 0\n    while t and ( t[ -1 ] + 2 )/3 >= p:\n        t.pop()\n        count += 1\n    if p > 1:\n        while S and t and ( t[ -1 ] + 4 )/3 >= p:\n            t.pop()\n            S -= 1\n            count += 1\n    print(count)\n"}
{"author": "michael", "index": 39, "filename": "2013_2270488_2453486.py", "code": "def read_line():\n    return raw_input().strip()\n \ndef read_integer():\n    return int( read_line() )\n \nT = read_integer()\nfor t in range( T ):\n    board = [ read_line() for index in range( 4 ) ]\n    read_line()\n    print('Case #%i:' % ( t + 1 ),)\n    blank_count = 0\n    for row, column, row_increment, column_increment in ( ( 0, 0, 0, 1 ),\n                                                        ( 1, 0, 0, 1 ),\n                                                        ( 2, 0, 0, 1 ),\n                                                        ( 3, 0, 0, 1 ),\n                                                        ( 0, 0, 1, 0 ),\n                                                        ( 0, 1, 1, 0 ),\n                                                        ( 0, 2, 1, 0 ),\n                                                        ( 0, 3, 1, 0 ),\n                                                        ( 0, 0, 1, 1 ),\n                                                        ( 0, 3, 1, -1 ) ):\n        O_count = 0\n        X_count = 0\n        for index in range( 4 ):\n            value = board[ row ][ column ]\n            if value == 'O':\n                O_count += 1\n            elif value == 'X':\n                X_count += 1\n            elif value == 'T':\n                O_count += 1\n                X_count += 1\n            else:\n                blank_count += 1\n            row += row_increment\n            column += column_increment\n        result = 'O' if O_count == 4 else 'X' if X_count == 4 else None\n        if result:\n            break\n    else:\n        print('Game has not completed' if blank_count else 'Draw')\n        continue\n    print(result, 'won')\n"}
{"author": "michael", "index": 39, "filename": "2013_2270488_2449486.py", "code": "from numpy import *\n \ndef read_line():\n    return raw_input().strip()\n \ndef read_words():\n    return read_line().split()\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( x ) for x in read_words() ]\n \nT = read_integer()\nfor t in range( T ):\n    N, M = read_integers()\n    lawn = array( [ read_integers() for n in range( N ) ] )\n    valid = zeros( lawn.shape, bool )\n    for row in range( N ):\n        valid[ row ][ lawn[ row ] == amax( lawn[ row ] ) ] = True\n    for column in range( M ):\n        valid[ :, column ][ lawn[ :, column ] == amax( lawn[ :, column ] ) ] = 1\n    print('Case #%i:' % ( t + 1 ), 'YES' if all( valid ) else 'NO')\n"}
{"author": "michael", "index": 39, "filename": "2012_1460488_1483485.py", "code": "def read_line():\n    return raw_input().strip()\n \ndef read_words():\n    return read_line().split()\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( x ) for x in read_words() ]\n \n \nciphers = 'y qee', 'ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv'\nplaintexts = 'a zoo', 'our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up'\n \nmapping = {}\nfor cipher, plaintext in zip( ciphers, plaintexts ):\n    for key, value in zip( cipher, plaintext ):\n        mapping[ key.lower() ] = value.lower()\nmapping[ 'z' ] = 'q'\n \nT = read_integer()\nfor t in range( T ):\n    print('Case #%i:' % ( t + 1 ), ''.join( mapping[ key.lower() ].upper() if key.isupper() else mapping[ key ] for key in read_line() ))\n"}
{"author": "michael", "index": 39, "filename": "2013_2270488_2463486.py", "code": "from math import *\n \ndef read_line():\n    return raw_input().strip()\n \ndef read_words():\n    return read_line().split()\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( x ) for x in read_words() ]\n \nT = read_integer()\nfor t in range( T ):\n    A, B = read_integers()\n    A_root = int( ceil( sqrt( A ) ) )\n    B_root = int( floor( sqrt( B ) ) )\n    count = 0\n    for root in range( A_root, B_root + 1 ):\n        word = str( root )\n        if word == word[ : : -1 ]:\n            word = str( root*root )\n            if word == word[ : : -1 ]:\n                count += 1\n    print('Case #%i:' % ( t + 1 ), count)\n"}
{"author": "michael", "index": 39, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \ndef read_line():\n    return sys.stdin.readline().rstrip( '\\n' )\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( x ) for x in read_line().split() ]\n \ndef read_string():\n    return read_line().strip()\n \ndef read_strings():\n    return read_line().split()\n \ndef input_string_stack():\n    data = []\n    for line in sys.stdin.readlines():\n        data.extend( line.split() )\n    data.reverse()\n    return data\n \ndef input_integer_stack():\n    return [ int( x ) for x in read_string_stack() ]\n \nclass memoized( object ):\n    def __init__( self, function ):\n        self.function = function\n        self.cache = {}\n    def __call__( self, *arguments ):\n        try:\n            return self.cache[ arguments ]\n        except KeyError:\n            value = self.function( *arguments )\n            self.cache[ arguments ] = value\n            return value\n \nT = read_integer()\nfor t in range( T ):\n    row = read_integer()\n    candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n    row = read_integer()\n    candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n    print ('Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!')\n"}
{"author": "xoxie", "index": 40, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\nimport heapq\n \nf = open( sys.argv[1] )\nf.readline()\n \nnumcases = 1\ninput = f.readline()\nwhile input != \"\":\n\tinC,inF,inX = [float(x) for x in input.split()]\n \n\tstart = (0.0,0.0,2.0)\n\th = [start]\n\tchecked =set()\n \n\twhile h[0][1] < inX:\n\t\tx = heapq.heappop(h)\n \n\t\tif x in checked:\n\t\t\tcontinue\n\t\telse:\n\t\t\tchecked.add(x)\t\n \n\t\ttime,numCookies,rate = x\n\t\t#time to win\n\t\ttimeW = (inX - numCookies) / rate\n\t\theapq.heappush( h,(time+timeW,numCookies+rate*timeW,rate) )\n \n\t\t#time to new farm\n\t\ttimeF = (inC - numCookies) / rate\n\t\tnewC = numCookies + rate*timeF\n\t\tnewT = time + timeF\n\t\theapq.heappush( h,(newT,(newC - inC),rate+inF) )\n\t\theapq.heappush( h,(newT,newC,rate) )\n\t\t#print(h)\n \n\toutput = \"{:.7f}\".format(h[0][0])\n \n\tprint(\"Case #\"+str(numcases)+\": \"+output)\\n\tinput = f.readline()\\n\tnumcases += 1\\n \t"}
{"author": "xoxie", "index": 40, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\nfrom collections import deque\n \ndef makeBoardR(b):\n\tnumR, numC, numMines, filledR, filledC = b\n\tq = numMines / numR\n\tr = numMines % numR\n \n\tif q <= numC-2 and r == 0:\n\t\tboard = [\"*\"*(filledC + numC) for x in range (filledR)]\n\t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q) )\n\t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q-1)+\"c\" )\n\t\toutput = \"\\n\".join(board)\n\telif numMines == numR * numC - 1:\n\t\tboard = [\"*\"*(filledC + numC) for x in range (filledR+1)]\n\t\tboard.append( \"*\"*(filledC+numC-1)+\"c\" )\n\t\toutput = \"\\n\".join(board)\n\telse:\n\t\toutput = \"Impossible\"\n \n\treturn output\n \ndef makeBoardC(b):\n\tnumR, numC, numMines, filledR, filledC = b\n\tq = numMines / numC\n\tr = numMines % numC\n \n\tif q <= numR-2 and r == 0:\n\t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+q)]\n\t\tfor x in range( numR-1-q ):\n\t\t\tboard.append( \"*\"*filledC + \"..\" )\n\t\tboard.append( \"*\"*filledC + \".c\" )\n\t\toutput = \"\\n\".join(board)\n\telif numMines == numR * numC - 1:\n\t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+numR-1)]\n\t\tboard.append( \"*\"*(filledC+numC-1) + \"c\" )\n\t\toutput = \"\\n\".join(board)\n\telse:\n\t\toutput = \"Impossible\"\n\treturn output\n \ndef makeBoard(b):\n\tnumR, numC, numMines, filledR, filledC = b\n\tq = numMines / (numC-2)\n\tr = numMines % (numC-2)\n \n\tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\n\tfor x in range(q):\n\t\tboard.append( \"*\"*(numC-2+filledC)+\"..\" )\n\tboard.append( \"*\"*(r+filledC)+\".\"*(numC-r) )\n\tfor x in range(numR-q-2):\n\t\tboard.append( \"*\"*filledC+\".\"*numC )\n\tboard.append( \"*\"*filledC + \".\"*(numC-1) + \"c\" )\n\treturn \"\\n\".join(board)\n \ndef makeBoard0(b):\n\tnumR,numC,numMines,filledR,filledC = b\n\tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\n\tfor x in range(numR-1):\n\t\tboard.append( \"*\"*(filledC)+\".\"*numC )\n\tboard.append( \"*\"*(filledC) + \".\"*(numC-1) + \"c\" )\n\treturn \"\\n\".join(board)\n \nf = open( sys.argv[1] )\nf.readline()\n \nnumCase = 1\nl = f.readline()\nwhile l != \"\":\n\tnumR, numC, numMines = [int(x) for x in l.split()]\n \n\tboards = deque()\n\tif numR == 1:\n\t\tif numC == 1 and numMines == 0:\n\t\t\toutput = \"c\"\n\t\telif numC == 1 and numMines > 0:\n\t\t\toutput = \"Impossible\"\n\t\telse:\n\t\t\toutput = \"*\"*numMines + \".\"*(numC-numMines-1) + \"c\"\n\telif numC == 1:\n\t\toutput = \"\\n\".join(\"*\"*numMines + \".\"*(numR-numMines-1) + \"c\")\n\telse:\n\t\tboards.append( (numR,numC,numMines,0,0) )\n\t\toutput = \"Impossible\"\n \n\twhile output == \"Impossible\" and len(boards) > 0:\n\t\tb = boards.popleft()\n\t\t#print(b)\n\t\tnumR,numC,numMines,filledR,filledC = b\n\t\tif numMines == 0:\n\t\t\toutput = makeBoard0(b)\n\t\t\tbreak\n \n\t\tif numMines >= numC and numR > 2:\n\t\t\tboards.append( (numR-1,numC,numMines-numC,filledR+1,filledC) )\n\t\tif numMines >= numR and numC > 2:\n\t\t\tboards.append( (numR,numC-1,numMines-numR,filledR,filledC+1) )\n \n\t\tif numMines <= (numR-2)*(numC-2):\n\t\t\toutput = makeBoard(b)\n \n\t\tif numR == 2:\n\t\t\toutput = makeBoardR(b)\n \n\t\tif numC == 2:\n\t\t\toutput = makeBoardC(b)\n \t\t\n\tprint(\"Case #\"+str(numCase)+\":\\n\"+output)\n\t#print(\"Case #\"+str(numCase)+\": \" +l+output)\\n\tl = f.readline()\\n\tnumCase += 1\\n"}
{"author": "xoxie", "index": 40, "filename": "2012_1460488_1595491.py", "code": "import sys\nfrom collections import deque\n \n##all_trips = {}\n##\n##for i in range(10+1):\n##    for j in range(i,min(i+3,10+1)):\n##        for k in range(i,min(i+3,10+1)):\n##            trip = [i,j,k]\n##            trip.sort()\n##            trip = tuple(trip)\n##            isSurp = 0\n##            if max(trip)-min(trip) > 2:\n##                sys.stderr.write( \"Err in trip.\")\n##                break\n##            if max(trip)-min(trip) == 2:\n##                isSurp = 1\n##            points = sum(trip)\n##            try:\n##                all_trips[points].add( (max(trip),isSurp,trip) )\n##            except KeyError:\n##                all_trips[points] = set()\n##                all_trips[points].add( (max(trip),isSurp,trip) )\n##\n##for x in all_trips:\n##    all_trips[x] = list(all_trips[x])\n##    all_trips[x].sort()\n##    print(x, (x+2)/3, (x+2)%3, all_trips[x])\n \nif __name__ == \"__main__\":\n \n    f = open( \"B-small-attempt1.in.txt\" )\n    g = open( \"output_small.txt\", \"w\" )\n \n    f.readline()\n    line = f.readline()\n    caseI = 1\n    while line != \"\":\n        line = [ int(x) for x in line.split() ]\n        N = line[0]\n        surprise = line[1]\n        p = line[2]\n        points = line[3:]\n        points.sort()\n        points.reverse()\n \n        maxp = 0\n        either = 0\n        make_surprise = 0\n        for x in points:\n            this_p = (x+2)/3\n            if x in [0,1,29,30]:\n                if this_p >= p:\n                    maxp += 1\n            elif this_p >= p:\n                either += 1\n                maxp += 1\n            elif this_p == p-1 and (x+2)%3 > 0:\n                make_surprise += 1\n            else:\n                either += 1\n \n        if make_surprise >= surprise:\n            make_surprise -= surprise\n            maxp += surprise\n            make_surprise = 0\n        else:\n            maxp += make_surprise\n \n        g.write( \"Case #%s: %s\\n\"%(caseI,maxp) )\n \n        line = f.readline()\n        caseI += 1\n \n    f.close()\n    g.close()\n     \n"}
{"author": "xoxie", "index": 40, "filename": "2013_2270488_2453486.py", "code": "import sys\n \nf = open( sys.argv[1] )\nt = f.readline()\n \nt = 1\nline = f.readline()\nwhile line != \"\":\n    board = [line.strip(),\n            f.readline().strip(),\n            f.readline().strip(),\n            f.readline().strip()]\n \n    output = \"\"\n \n    cols = [ \"\".join([x[y] for x in board]) for y in range(4)]\n    diags = [\"\".join([x[y] for x,y in zip(board,range(4))]),\n            \"\".join([x[y] for x,y in zip(board,range(-1,-5,-1))])]\n     \n    rows = board + cols + diags\n \n    for row in rows:\n        x = [1 for z in row if z is \"X\" or z is \"T\"]\n        if sum(x) == 4:\n            output = \"X won\"\n            break\n        o = [1 for z in row if z is \"O\" or z is \"T\"]\n        if sum(o) == 4:\n            output = \"O won\"\n            break\n    if output == \"\":\n        finished = sum([ y.count(\".\") for y in board ])\n        if finished == 0:\n            output = \"Draw\"\n        else:\n            output = \"Game has not completed\"\n     \n    print(\"Case #%s: %s\"%(t,output))\n    t += 1\n    line = f.readline()\n    line = f.readline()\n"}
{"author": "xoxie", "index": 40, "filename": "2013_2270488_2449486.py", "code": "import sys\n \nf = open( sys.argv[1] )\nt = int(f.readline())\n \nt = 1\nl = f.readline()\nwhile l != \"\":\n    n,m = [int(x) for x in l.split()]\n    lawn = [ [int(x) for x in f.readline().split()] for y in range(n)]\n \n    rowMax = [ max(x) for x in lawn ]\n    colMax = [ max([x[y] for x in lawn]) for y in range(m) ]\n \n    output = \"YES\"\n \n    for i in range(n):\n        for j in range(m):\n            if lawn[i][j] < rowMax[i]:\n                if lawn[i][j] < colMax[j]:\n                    output = \"NO\"\n     \n    print(\"Case #%s: %s\"%(t,output))\n    t += 1\n    l = f.readline()\n"}
{"author": "xoxie", "index": 40, "filename": "2012_1460488_1483485.py", "code": "import string\n \ns1 = \"ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jvyeqz\"\ns2 = \"our language is impossible to understand there are twenty six factorial possibilitiesso it is okay if you want to just give upaozq\"\n \nmapd = string.maketrans(s1,s2)\n#print(\"abcdefghijklmnopqrstuvwxyz\")\n#print(\"abcdefghijklmnopqrstuvwxyz\".translate(mapd))\n \nf = open( \"A-small-attempt0.in.txt\" )\ng = open( \"output_small.txt\",\"w\")\n \nf.readline()\nl = f.readline()\ncaseI = 1\nwhile l != \"\":\n    output = l.translate(mapd)\n \n    g.write( \"Case #%s: %s\"%(caseI,output) )\n    l = f.readline()\n    caseI += 1\nf.close()\ng.close()\n"}
{"author": "xoxie", "index": 40, "filename": "2013_2270488_2463486.py", "code": "import sys\nimport numpy as np\n \ndef isPalindrome(x):\n    x = str(x)\n    if x[0] != x[-1]:\n        return 0\n    y = x[::-1]\n    if x == y:\n        return 1\n    return 0\n \ndef generate():\n    digits = [str(x) for x in range(0,10)]\n    dplus = digits + [\"\"]\n \n    for x in range(1,10):\n        y = x**2\n        if isPalindrome(y):\n            print(y)\n \n    for x in range(1,10**4):\n        x = str(x)\n        y = x[::-1]\n        pals = [ int(x+z+y)**2 for z in dplus ]\n        for p in pals:\n            if isPalindrome(p):\n                print(p)\n \nif __name__ == \"__main__\":\n    #generate()\n    #break\n    f = open( sys.argv[1] )\n    sqpals = np.array([int(l) for l in f])\n    sqpals.sort()\n    f.close()\n \n    f = open( sys.argv[2] )\n    t = int(f.readline())\n    t = 1\n    for l in f:\n        a,b = [int(x) for x in l.split()]\n        mt = sqpals >= a\n        lt = sqpals <= b\n        output = sum( mt&lt )\n        print(\"Case #%s: %s\"%(t,output))\n        t += 1\n     \n"}
{"author": "xoxie", "index": 40, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \nif __name__ == \"__main__\":\n\tf = open( sys.argv[1] )\n\tint(f.readline())\n \t\t\n\tnum = 1\n\tl = f.readline()\n\twhile l != \"\":\n\t\trow1 = int(l)\n\t\trows = [ f.readline() for x in range(4) ]\n\t\trow1 = [int(x) for x in rows[row1-1].split()]\n \n\t\trow2 = int(f.readline())\n\t\trows = [f.readline() for x in range(4)]\n\t\trow2 = [int(x) for x in rows[row2-1].split()]\n \n\t\tresult = set(row1) & set(row2)\n\t\tif len(result) == 1:\n\t\t\toutput = str(result.pop())\n\t\telif len(result) > 1:\n\t\t\toutput = \"Bad magician!\"\n\t\telse:\n\t\t\toutput = \"Volunteer cheated!\"\n \n\t\tprint(\"Case #\"+str(num)+\": \"+output)\\n\t\tnum += 1\\n\t\tl = f.readline()\\n \t\t"}
{"author": "oonishi", "index": 41, "filename": "2014_2974486_5709773144064000.py", "code": "# coding: cp932\n \n \nlines = iter('''\n5\n30.0 1.0 2.0\n30.0 2.0 100.0\n30.50000 3.14159 1999.19990\n500.0 4.0 2000.0\n100.0 1.0 100000.0\n'''.splitlines(False)[1:])\n \nlines = iter(open(r'B-small-attempt0.in').readlines(False))\n \ncaseCnt = int(next(lines))\n \nfor case in range(1, caseCnt+1):\n\tC, F, X = map(float, next(lines).split())\n \t\n\tv = 2.0\n\ttotal = 0.0\n\tgoal = X/v\n\twhile 1:\n\t\tfarm = C/v + total\n\t\tif farm >= goal:\n\t\t\tanswer = goal\n\t\t\tbreak\n\t\tv += F\n\t\ttotal = farm\n\t\tif goal > X/v + total:\n\t\t\tgoal = X/v + total\t\n\tprint('Case #%d: %0.6lf'%(case, answer))\n\t#import pdb;pdb.set_trace()\n \t\n \n"}
{"author": "oonishi", "index": 41, "filename": "2014_2974486_5690574640250880.py", "code": "# coding: cp932\n \nlines = iter('''\n13\n5 5 23\n3 1 1\n1 3 1\n2 2 1\n4 7 3\n10 10 82\n10 1 4\n1 10 5\n2 10 8\n10 2 8\n2 10 9\n10 2 7\n5 3 3\n'''.splitlines(False)[1:])\nimport sys\nout = sys.stdout\n \nsys.setrecursionlimit(1500)\n \n \nclass MyException(Exception):\n\tpass\nlines = iter(open(r'C-small-attempt7.in').readlines(False))\nout = open('c-small.answer', 'w')\n \n#lines = iter(open(r'C-large.in').readlines(False))\n#out = open('c-large.answer', 'w')\ndef solve(C, R, M):\n\tboard = [['.']*C for _ in range(R)]\n\tboard[-1][-1] = 'c'\n\ttry:\n\t\tfor r in range(R-2):\n\t\t\tfor c in range(C-2):\n\t\t\t\tif r == R-3 and c == C-3:\n\t\t\t\t\traise StopIteration()\n\t\t\t\tboard[r][c] = '*'\n\t\t\t\tM -= 1\n\t\t\t\tif M == 0:\n\t\t\t\t\treturn board \n\texcept StopIteration:\n\t\tpass\n \t\t\n\tif M % 2 == 0:\n\t\tfor r in range(R-3):\n\t\t\tboard[r][C-1] = '*'\n\t\t\tboard[r][C-2] = '*'\n\t\t\tM -= 2\n\t\t\tif M == 0:\n\t\t\t\treturn board\n\t\tfor c in range(C-3):\n\t\t\tboard[R-1][c] = '*'\n\t\t\tboard[R-2][c] = '*'\n\t\t\tM -= 2\n\t\t\tif M == 0:\n\t\t\t\treturn board\n \t\t\n \t\t\n\t\traise MyException()\n\telse:\n\t\tboard[R-3][C-3] = '*'\n\t\tM -= 1\n\t\tif M == 0:\n\t\t\treturn board\n\t\tfor r in range(R-2):\n\t\t\tboard[r][C-1] = '*'\n\t\t\tboard[r][C-2] = '*'\n\t\t\tM -= 2\n\t\t\tif M == 0:\n\t\t\t\treturn board\n\t\tfor c in range(C-2):\n\t\t\tboard[R-1][c] = '*'\n\t\t\tboard[R-2][c] = '*'\n\t\t\tM -= 2\n\t\t\tif M == 0:\n\t\t\t\treturn board\n \t\t\n\t\traise MyException()\n \t\t\n \t\ncaseCnt = int(next(lines))\n \nfor case in range(1, caseCnt+1):\n\tR,C,M = map(int, next(lines).split())\n \t\n\tprint('Case #%d:'%case, file=out)\n\tif M == 0:\n\t\tprint('c' + '.'*(C-1), file=out)\n\t\tfor _ in range(R-1):\n\t\t\tprint('.'*C, file=out)\n\telif R*C==M+1:\n\t\tprint('c' + '*'*(C-1), file=out)\n\t\tfor _ in range(R-1):\n\t\t\tprint('*'*C, file=out)\n\telif C == 1 and R == 1:\n\t\tprint('Impossible', file=out)\n\telif C == 1:\n\t\tif M > R-1:\n\t\t\tprint('Impossible', file=out)\n\t\telse:\n\t\t\tprint('c', file=out)\n\t\t\tfor _ in range(R-M-1):\n\t\t\t\tprint('.', file=out)\n\t\t\tfor _ in range(M):\n\t\t\t\tprint('*', file=out)\n\telif R == 1:\n\t\tif M > C-1:\n\t\t\tprint('Impossible', file=out)\n\t\telse:\n\t\t\tprint('c' + '.'*(C-M-1) + '*'*M, file=out)\n\telif C == 2:\n\t\tif M %2 or M//2 > R-2:\n\t\t\tprint('Impossible', file=out)\n\t\telse:\n\t\t\tprint('c.', file=out)\n\t\t\tfor _ in range(R-M//2-1):\n\t\t\t\tprint('..', file=out)\n\t\t\tfor _ in range(M//2):\n\t\t\t\tprint('**', file=out)\n\telif R == 2:\n\t\tif M %2 or M//2 > C-2:\n\t\t\tprint('Impossible', file=out)\n\t\telse:\n\t\t\tprint('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\n\t\t\tprint(      '.'*(C-M//2)   + '*'*(M//2), file=out)\n\telif M > R*C-4:\n\t\tprint('Impossible', file=out)\n\telse:\n\t\ttry:\n\t\t\tboard = solve(C, R, M)\n\t\t\tfor line in board:\n\t\t\t\tprint(''.join(line), file=out)\n\t\texcept MyException:\n\t\t\tprint('Impossible', file=out)\n\t# if C == 1:\n\t\t# if N[0] > K[0]:\n\t\t\t# print('Case #%d: 1 1'%case, file=out)\n\t\t# else:\n\t\t\t# print('Case #%d: 0 0'%case, file=out)\n\t\t# continue\n \t\n\t#import pdb;pdb.set_trace()\n \t\n"}
{"author": "oonishi", "index": 41, "filename": "2012_1460488_1595491.py", "code": "# coding: shift-jis\n \nimport sys\nf = file(\"B-small-attempt0.in\")\n#f = file(\"test.in\")\n#w = sys.stdout\nw = file(\"answer.txt\", \"w\")\ncnt = int(f.readline()[:-1])\nfor no in range(cnt):\n\tl = f.readline()[:-1].split()\n\tT, s, p = map(int, l[:3])\n\tts = map(int, l[3:])\n\tns = p*3-2 if p*3-2 > 0 else 0\n\tss = p*3-4 if p*3-4 > 0 else 31\n\tl = filter(lambda x: x<ns, ts)\n\tc = min([len(filter(lambda x: x>=ss, l)), s])\n \t\n\tprint>>w, \"Case #%d:\"%(no+1), T-len(l)+c\n \n \n"}
{"author": "oonishi", "index": 41, "filename": "2013_2270488_2453486.py", "code": "# coding: cp932\nimport sys\nf   = file(sys.argv[1])\nout = file(sys.argv[2], 'w')\n \ncaseCnt = int(f.readline())\n \nfor case in range(1, caseCnt+1):\n\tboard = [\n\t\tf.readline()[:4],\n\t\tf.readline()[:4],\n\t\tf.readline()[:4],\n\t\tf.readline()[:4],\n\t]\n\tf.readline()\n\txwin = False\n\towin = False\n\trest = False\n\t# \n\tfor row in board:\n\t\tif row.replace('T', 'X') == 'XXXX':\n\t\t\txwin = True\n\t\telif row.replace('T', 'O') == 'OOOO':\n\t\t\towin = True\n\t\tif '.' in row: rest = True\n\t# c\n\tfor i in range(4):\n\t\tcol = ''.join([row[i] for row in board])\n\t\tif col.replace('T', 'X') == 'XXXX':\n\t\t\txwin = True\n\t\telif col.replace('T', 'O') == 'OOOO':\n\t\t\towin = True\n\t# ȂȂ\n\tup = ''.join([row[i] for i, row in enumerate(board)])\n\tif up.replace('T', 'X') == 'XXXX':\n\t\txwin = True\n\telif up.replace('T', 'O') == 'OOOO':\n\t\towin = True\n\tdown = ''.join([row[3-i] for i, row in enumerate(board)])\n\tif down.replace('T', 'X') == 'XXXX':\n\t\txwin = True\n\telif down.replace('T', 'O') == 'OOOO':\n\t\towin = True\n \t\n\tassert not (xwin==owin==True)\n \t\n\tif xwin:\n\t\tresult = 'X won'\n\telif owin:\n\t\tresult = 'O won'\n\telif rest:\n\t\tresult = 'Game has not completed'\n\telse:\n\t\tresult = 'Draw'\n \t\t\n\tprint>>out, 'Case #%d:'%case, result\n \nout.close()\n"}
{"author": "oonishi", "index": 41, "filename": "2013_2270488_2449486.py", "code": "# coding: cp932\nimport sys\nf   = file(sys.argv[1])\nout = file(sys.argv[2], 'w')\n \ncaseCnt = int(f.readline())\n \nfor case in range(1, caseCnt+1):\n\tV, H = f.readline().split()\n\tV = int(V); H = int(H)\n \t\n\tfield = [map(int, list(f.readline().split())) for _ in range(V)]\n\t#print(field)\n \t\n\trowMax = [max(row) for row in field]\n\tcolMax = [max([row[i] for row in field]) for i in range(H)]\n\t#print(rowMax, colMax)\n \t\t\n\tresult = 'YES'\n\tfor row in range(V):\n\t\tfor col in range(H):\n\t\t\tif field[row][col] < rowMax[row] and field[row][col] < colMax[col]:\n\t\t\t\tresult = 'NO'\n\t\t\t\tbreak\n\t\telse:\n\t\t\tcontinue\n\t\tbreak\n\tprint>>out, 'Case #%d:'%case, result\n \nout.close()\n"}
{"author": "oonishi", "index": 41, "filename": "2012_1460488_1483485.py", "code": "# coding: shift-jis\n \na = \"abcdefghijklmnopqrstuvwxyz\"\nd = {}\nfor c in a:\n\td[c] = \"*\"\n \ni = \"ejp mysljylc kd kxveddknmc re jsicpdrysi\"\no = \"our language is impossible to understand\"\nfor k, v in zip(i, o):\n\td[k] = v\ni = \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\"\no = \"there are twenty six factorial possibilities\"\nfor k, v in zip(i, o):\n\td[k] = v\ni = \"de kr kd eoya kw aej tysr re ujdr lkgc jv\"\no = \"so it is okay if you want to just give up\"\nfor k, v in zip(i, o):\n\td[k] = v\n \n \ni = \"y qee\"\no = \"a zoo\"\nfor k, v in zip(i, o):\n\td[k] = v\nd['z'] = 'q'\nimport sys\nf = file(\"A-small-attempt1.in\")\n#w = sys.stdout\nw = file(\"answer.txt\", \"w\")\ncnt = int(f.readline()[:-1])\nfor no in range(cnt):\n\ti = f.readline()[:-1]\n\to = \"\"\n\tfor k in i:\n\t\to += d[k]\n\tprint>>w, \"Case #%d:\"%(no+1), o\n \n \n"}
{"author": "oonishi", "index": 41, "filename": "2013_2270488_2463486.py", "code": "# coding: cp932\nimport sys\nf   = file(sys.argv[1])\nout = file(sys.argv[2], 'w')\n \ncaseCnt = int(f.readline())\n \nNum = [\n\t0,\n\t1,\n\t4,\n\t9,\n\t121,\n\t484,\n\t10201,\n\t12321,\n\t14641,\n\t40804,\n\t44944,\n\t1002001,\n\t1234321,\n\t4008004,\n\t100020001,\n\t102030201,\n\t104060401,\n\t121242121,\n\t123454321,\n\t125686521,\n\t400080004,\n\t404090404,\n\t10000200001,\n\t10221412201,\n\t12102420121,\n\t12345654321,\n\t40000800004,\n\t1000002000001,\n\t1002003002001,\n\t1004006004001,\n\t1020304030201,\n\t1022325232201,\n\t1024348434201,\n\t1210024200121,\n\t1212225222121,\n\t1214428244121,\n\t1232346432321,\n\t1234567654321,\n\t4000008000004,\n\t4004009004004,\n]\n \nfor case in range(1, caseCnt+1):\n\tL, H = f.readline().split()\n\tL = int(L); H = int(H)\n\tassert L <= H\n \t\n\tfor i in range(len(Num)):\n\t\tif L <= Num[i]:\n\t\t\tbreak\n\telse:\n\t\tprint>>out, 'Case #%d:'%case, 0\n\t\tcontinue\n \n\tlb = i - 1\n \n\tfor i in range(1, len(Num)+1):\n\t\tif H >= Num[len(Num)-i]:\n\t\t\tbreak\n\telse:\n\t\tprint>>out, 'Case #%d:'%case, 0\n\t\tcontinue\n\tub = len(Num)-i\n \t\t\n\tprint>>out, 'Case #%d:'%case, ub - lb\n \nout.close()\n"}
{"author": "oonishi", "index": 41, "filename": "2014_2974486_5756407898963968.py", "code": "# coding: cp932\n \n#input = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\a.sample')\ninput = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\A-small-attempt0.in')\ncaseCnt = int(input.readline())\nfor caseNo in range(1, caseCnt+1):\n\tans1 = int(input.readline())\n\tfor i in range(1, 5):\n\t\tline = input.readline()\n\t\tif ans1 == i:\n\t\t\tcandidates = set(map(int, line.split()))\n \t\t\n\tans2 = int(input.readline())\n\tfor i in range(1, 5):\n\t\tline = input.readline()\n\t\tif ans2 == i:\n\t\t\tanswers = candidates.intersection(set(map(int, line.split())))\n \t\t\n\tif len(answers) == 0:\n\t\tprint('Case #%d: Volunteer cheated!'%caseNo)\n\telif len(answers) > 1:\n\t\tprint('Case #%d: Bad magician!'%caseNo)\n\telif len(answers) == 1:\n\t\tanswer = answers.pop()\n\t\tprint('Case #%d: %d'%(caseNo, answer))\n"}
{"author": "maxbublis", "index": 42, "filename": "2014_2974486_5709773144064000.py", "code": "\"\"\"\nGoogle Code Jam 2014 Qualification Problem B\nUsage:\n    python b.py < input.txt > output.txt\n\"\"\"\nimport sys\n \n \ndef solve_problem(farm_cost, farm_rate, target):\n    rate = 2.0\n    farms = 0.0\n \n    while (farms + target / rate) > (farms + farm_cost / rate + target / (rate + farm_rate)):\n        farms = farms + farm_cost / rate\n        rate = rate + farm_rate\n \n    return farms + target / rate\n \n \nif __name__ == \"__main__\":\n    num_of_cases = int(sys.stdin.readline().strip())\n    for i in xrange(1, num_of_cases + 1):\n        farm_cost, farm_rate, target = map(float, sys.stdin.readline().strip().split())\n        print(\"Case #{0}: {1:9.7f}\".format(i, solve_problem(farm_cost, farm_rate, target)))\n"}
{"author": "maxbublis", "index": 42, "filename": "2014_2974486_5690574640250880.py", "code": "\"\"\"\nGoogle Code Jam 2014 Qualification Problem C\nUsage:\n    python c.py < input.txt > output.txt\n\"\"\"\nimport copy\nimport itertools\nimport sys\n \n \ndef iter_neighbors(x, y, cells):\n    columns = len(cells[0])\n    rows = len(cells)\n \n    if y > 0:\n        if x > 0:\n            yield x - 1, y - 1\n        yield x, y - 1\n \n        if x + 1 < columns:\n            yield x + 1, y - 1\n \n    if x > 0:\n        yield x - 1, y\n \n    if x + 1 < columns:\n        yield x + 1, y\n \n    if y + 1 < rows:\n        if x > 0:\n            yield x - 1, y + 1\n \n        yield x, y + 1\n \n        if x + 1 < columns:\n            yield x + 1, y + 1\n \n \ndef try_to_click(x, y, cells, remaining):\n    if remaining == 0:\n        return cells\n \n    recent = []\n \n    opened = 0\n \n    for n_x, n_y in iter_neighbors(x, y, cells):\n        if cells[n_y][n_x] == \"?\":\n            cells[n_y][n_x] = \".\"\n            opened += 1\n            recent.append((n_x, n_y))\n \n    if opened == remaining:\n        return cells\n \n    if opened > remaining:\n        return []\n \n    for n_x, n_y in recent:\n        solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)\n        if solution:\n            return solution\n \n    return []\n \n \ndef solve_problem(rows, columns, mines):\n \n    for x in xrange(columns):\n        for y in xrange(rows):\n            cells = [[\"?\" for i in xrange(columns)] for j in xrange(rows)]\n            cells[y][x] = \"c\"\n            solution = try_to_click(x, y, cells, rows * columns - mines - 1)\n \n            if solution:\n                return \"\\n\".join([\"\".join(row) for row in solution]).replace(\"?\", \"*\")\n \n    return \"Impossible\"\n \n \nif __name__ == \"__main__\":\n    num_of_cases = int(sys.stdin.readline().strip())\n    for i in xrange(1, num_of_cases + 1):\n \n        rows, columns, mines = map(int, sys.stdin.readline().strip().split())\n \n        print(\"Case #{0}:\\n{1}\".format(i, solve_problem(rows, columns, mines)))\n"}
{"author": "maxbublis", "index": 42, "filename": "2012_1460488_1595491.py", "code": "\"\"\"\nGoogle Code Jam 2012 Problem B\nUsage:\n    python problem_b.py < input.txt > output.txt\n\"\"\"\nimport itertools\nimport sys\n \n \ndef calc_possible(n):\n    combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores\n    return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)\n \n \ndef calc_surprising(n):\n    results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))\n    return results[0] if results else None\n \n \ndef calc_normal(n):\n    results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))\n    return results[0] if results else None\n \n \ndef solve_problem():\n    number_of_cases = int(sys.stdin.readline())\n \n    for i in xrange(1, number_of_cases + 1):\n \n        case = sys.stdin.readline().strip()\n        result = 0\n        num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)\n        num_of_googlers = int(num_of_googlers)\n        num_of_surprising = int(num_of_surprising)\n        desired_score = int(desired_score)\n        scores = map(int, scores.split())\n \n        possible_scores = []\n \n        for k in xrange(num_of_googlers):\n \n            normal = calc_normal(scores[k])\n            surprising = calc_surprising(scores[k])\n \n            possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))\n \n        possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))\n        result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))\n \n        sys.stdout.write('Case #{0}: {1}\\n'.format(i, result))\n \n \nif __name__ == '__main__':\n    solve_problem()\n"}
{"author": "maxbublis", "index": 42, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\nimport sys\nimport itertools\n \n \nWINNING = (\n    set(['X']),\n    set(['O']),\n    set(['X', 'T']),\n    set(['O', 'T']),\n)\n \n \ndef solve_problem(matrix):\n    game_completed = True\n \n    lines_combo = (matrix[i] for i in xrange(4))\n    rows_combo = ((matrix[k][i] for k in xrange(4)) for i in xrange(4))\n    diagonals = ((matrix[i][i] for i in xrange(4)),\n                (matrix[i][3 - i] for i in xrange(4)))\n \n    for combo in itertools.chain(lines_combo, rows_combo, diagonals):\n        combo_set = set(combo)\n        if combo_set in WINNING:\n            if 'X' in combo_set:\n                return 'X won'\n            if 'O' in combo_set:\n                return 'O won'\n        if '.' in combo_set:\n            game_completed = False\n \n    # we have no winner, check game status\n \n    if game_completed:\n        return 'Draw'\n    else:\n        return 'Game has not completed'\n \n    return 0\n \ndef read_matrix(stdin):\n    matrix = [[], [], [], []]\n    for i in xrange(4):\n        line = stdin.readline().strip()\n        for k in line:\n            matrix[i].append(k)\n    return matrix\n \n \nif __name__ == '__main__':\n    num_of_cases = int(sys.stdin.readline())\n    for i in xrange(1, num_of_cases + 1):\n        matrix = read_matrix(sys.stdin)\n        print('Case #{0}: {1}'.format(i, solve_problem(matrix)))\n        sys.stdin.readline() # separator\n"}
{"author": "maxbublis", "index": 42, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/env python\nimport sys\n \n \ndef solve_problem(lawn, size_x, size_y):\n    for i in xrange(size_x):\n        for k in xrange(size_y):\n            elem = lawn[i][k]\n            if max(lawn[i]) > elem and max([lawn[j][k] for j in xrange(size_x)]) > elem:\n                return 'NO'\n \n    return 'YES'\n \ndef read_lawn(stdin, size_x, size_y):\n    lawn = []\n    for i in xrange(size_x):\n        line = map(int, sys.stdin.readline().strip().split(' '))\n        lawn.append(line)\n    return lawn\n \n \nif __name__ == '__main__':\n    num_of_cases = int(sys.stdin.readline())\n    for i in xrange(1, num_of_cases + 1):\n        size_x, size_y = map(int, sys.stdin.readline().strip().split(' '))\n        lawn = read_lawn(sys.stdin, size_x, size_y)\n        print('Case #{0}: {1}'.format(i, solve_problem(lawn, size_x, size_y)))\n"}
{"author": "maxbublis", "index": 42, "filename": "2012_1460488_1483485.py", "code": "\"\"\"\nGoogle Code Jam 2012 Problem A\nUsage:\n    python problem_a.py < input.txt > output.txt\n\"\"\"\nimport sys\n \nhints = {\n    'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',\n    'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',\n    'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up',\n}\n \nmapping = {'q': 'z', 'z': 'q'}\n \nfor k, v in hints.items():\n    for from_char, to_char in zip(k, v):\n        mapping[from_char] = to_char\n \ndef solve_problem():\n    number_of_cases = int(sys.stdin.readline())\n    for i in xrange(1, number_of_cases + 1):\n        case = sys.stdin.readline().strip()\n        translated = ''.join(map(lambda c: mapping.get(c, c), case))\n        sys.stdout.write('Case #{0}: {1}\\n'.format(i, translated))\n \nif __name__ == '__main__':\n    solve_problem()\n"}
{"author": "maxbublis", "index": 42, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/env python\nimport math\nimport sys\n \n \ndef is_palindrome(a):\n    return str(a) == ''.join(reversed(str(a)))\n \n \ndef solve_problem(min_num, max_num):\n    count = 0\n    for i in xrange(min_num, max_num + 1):\n        if is_palindrome(i):\n            sqrt = math.sqrt(i)\n            if int(sqrt) == sqrt and is_palindrome(int(sqrt)):\n                count += 1\n    return count\n \n \nif __name__ == '__main__':\n    num_of_cases = int(sys.stdin.readline())\n    for i in xrange(1, num_of_cases + 1):\n        min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))\n        print('Case #{0}: {1}'.format(i, solve_problem(min_num, max_num)))\n"}
{"author": "maxbublis", "index": 42, "filename": "2014_2974486_5756407898963968.py", "code": "\"\"\"\nGoogle Code Jam 2014 Qualification Problem A\nUsage:\n    python a.py < input.txt > output.txt\n\"\"\"\nimport sys\n \n \ndef solve_problem(first, first_rows, second, second_rows):\n    intersection = set(first_rows[first - 1]) & set(second_rows[second - 1])\n \n    if not intersection:\n        return \"Volunteer cheated!\"\n    elif len(intersection) > 1:\n        return \"Bad magician!\"\n    else:\n        return intersection.pop()\n \n \n \nif __name__ == \"__main__\":\n    num_of_cases = int(sys.stdin.readline().strip())\n \n    for i in xrange(1, num_of_cases + 1):\n        first_answer = int(sys.stdin.readline().strip())\n        first_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n \n        second_answer = int(sys.stdin.readline().strip())\n        second_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n \n        print(\"Case #{0}: {1}\".format(i, solve_problem(first_answer, first_arrangement, second_answer, second_arrangement)))\n"}
{"author": "ronnodas", "index": 43, "filename": "2014_2974486_5709773144064000.py", "code": "from decimal import Decimal\n \nT = int(input())\nfor case in range(1,T+1):\n    C,F,X = (Decimal(x) for x in input().split())\n     \n    ans = X/2\n    time,rate = 0,2\n    while True:\n        if time >= ans:\n            break\n        ans = min(ans,(X/rate)+time)\n        time,rate = time+(C/rate),rate+F\n    print(\"Case #\",case,\": \",ans,sep = '')\n"}
{"author": "ronnodas", "index": 43, "filename": "2014_2974486_5690574640250880.py", "code": "T = int(input())\n \ndef solve(R,C,M):\n    # print('solving',R,C,M)\n    if R>C:\n        flipboard = solve(C,R,M)\n        if flipboard:\n            return [[flipboard[j][i] for j in range(C)] for i in range(R)]\n        else:\n            return\n    if M==0:\n        board = [['.']*C for i in range(R)]\n        board[-1][-1] = 'c'\n        return board\n    if R == 1:\n        board = ['*' if i<M else '.' for i in range(R*C)]\n        board[-1] = 'c'\n        return [board]\n    if R == 2:\n        if R*C==M+1:\n            board = [['*']*C for i in range(R)]\n            board[-1][-1] = 'c'\n            return board\n        if (M%2) or (M+2)==(R*C):\n            return\n        board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\n        board[-1][-1] = 'c'\n        return board\n    if M>=R:\n        subboard = solve(R,C-1,M-R)\n        if subboard:\n            return [['*']+r for r in subboard]\n        return\n    if (R,C,M) == (3,3,2):\n        return\n    k = min(M,C-2)\n    board = [['*']*k+['.']*(C-k)]\n    for i in range(M-k):\n        board.append(['*']+['.']*(C-1))\n    while len(board)<R:\n        board.append(['.']*(C))\n    board[-1][-1] = 'c'\n    return board\n     \n          \n     \n \nfor case in range(1,T+1):\n    print(\"Case #\",case,\": \",sep='')\n    R,C,M = (int(x) for x in input().split())\n    ans = solve(R,C,M)\n    if ans:\n        for r in ans:\n            print(''.join(r))\n    else:\n        print('Impossible')\n \n \n# for M in range(36):\n#     ans = solve(6,6,M)\n#     if ans:\n#         for r in ans:\n#             print(''.join(r))\n#     else:\n#         print('Impossible')\n"}
{"author": "ronnodas", "index": 43, "filename": "2012_1460488_1595491.py", "code": "T=int(input())\nfor t in range(T):\n    l = [int(x) for x in input().split()]\nn,huh,p = l[:3]\nss = l[3:]\nnice, maybe = 0,0\nfor s in ss:\n    if s>= p+2*max(p-1,0):\n        nice += 1\n    elif s>= p+2*max(p-2,0):\n        maybe += 1\ny = nice + min(maybe,huh)\nprint('Case #',t+1,': ',y,sep = '')\n \n \n"}
{"author": "ronnodas", "index": 43, "filename": "2013_2270488_2453486.py", "code": "T = int(input().strip())\n \ndef check(s,ans):\n    #print(s,ans)\n    if '.' in s:\n        return ans if ans < 2 else 3\n    if 'O' not in s:\n        return 0\n    if 'X' not in s:\n        return 1\n    return ans\n \nfor case in range(1,T+1):\n    ans = 2\n    answers = [\"X won\", \"O won\", \"Draw\", \"Game has not completed\"]\n    board = [0]*4\n    for r in range(4):\n        board[r] = input().strip()\n    input()\n    for row in board:\n        ans = check(row,ans)\n    for c in range(4):\n        col = ''.join(board[r][c] for r in range(4))\n        ans = check(col,ans)\n    diag = ''.join(board[r][r] for r in range(4))\n    ans = check(diag,ans)\n    diag = ''.join(board[r][3-r] for r in range(4))\n    ans = check(diag,ans)\n    print(\"Case #\",case,\": \",answers[ans],sep = '')\n"}
{"author": "ronnodas", "index": 43, "filename": "2013_2270488_2449486.py", "code": "T = int(input().strip())\n \nfor case in range(1,T+1):\n    N,M = [int(x) for x in input().strip().split()]\n    lawn = []\n    for r in range(N):\n        lawn.append([int(x) for x in input().strip().split()])\n    rmax = [max(row) for row in lawn]\n    cmax = [max(lawn[r][c] for r in range(N)) for c in range(M)]\n    ans = all(lawn[r][c] == min(rmax[r],cmax[c]) for r in range(N) for c in range(M))\n    ans = \"YES\" if ans else \"NO\"\n    print(\"Case #\",case,\": \",ans,sep = '')\n"}
{"author": "ronnodas", "index": 43, "filename": "2012_1460488_1483485.py", "code": "sub = {}\nsub['y']='a'\nsub['e']='o'\nsub['q']='z'\nsub[' ']=' '\\nsub['z'] = 'q'\n \npairs = [('ejp mysljylc kd kxveddknmc re jsicpdrysi','our language is impossible to understand'), ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd','there are twenty six factorial possibilities'), ('de kr kd eoya kw aej tysr re ujdr lkgc jv','so it is okay if you want to just give up')]\n \nfor (j,(a,b)) in enumerate(pairs):\n    for i in range(len(a)):\n        sub[a[i]] = b[i]\n        #print(a[i],b[i])\n \n#print(''.join(sorted(sub.keys())))\n#print(''.join(sorted(sub.values())))\n \nT=int(input())\nfor i in range(T):\n    s = input().strip()\nnew = ''.join([sub[c] for c in s])\nprint('Case #',i+1,': ',new,sep = '')\n \n \n"}
{"author": "ronnodas", "index": 43, "filename": "2013_2270488_2463486.py", "code": "def checkpalin(s):\n    k = len(s)//2\n    for i in range(k):\n        if s[i]!= s[-1-i]:\n            return False\n    return True\n \ngoods = [1,2,3]\n \nfor i in range(1000):\n    for j in ['']+list(range(10)):\n        test = str(i)+str(j)+(str(i)[::-1])\n        if checkpalin(str(int(test)**2)):\n            goods.append(int(test))\ngoods = list(set(goods))\ngoods.sort()\n \nT = int(input())\n \nfor case in range(1,T+1):\n    A,B = [int(x) for x in input().split()]\n    ans = 0\n    for n in goods:\n        if A <= n*n <= B:\n            ans += 1\n    print(\"Case #\",case,\": \",ans,sep='')\n"}
{"author": "ronnodas", "index": 43, "filename": "2014_2974486_5756407898963968.py", "code": "T = int(input())\nfor case in range(1,T+1):\n    row1 = int(input())\n    for i in range(1,5):\n        l = input()\n        if i==row1:\n            first = set(int(x) for x in l.split())\n    row2 = int(input())\n    for i in range(1,5):\n        l = input()\n        if i==row2:\n            second = set(int(x) for x in l.split())\n    poss = first & second\n    if len(poss) ==0:\n        ans = 'Volunteer cheated!'\n    elif len(poss) >1:\n        ans = 'Bad magician!'\n    else:\n        ans = min(poss)\n    print(\"Case #\",case,\": \",ans,sep = '')\n"}
{"author": "taichino", "index": 44, "filename": "2014_2974486_5709773144064000.py", "code": "# -*- coding: utf-8 -*-\n \nimport sys\n \nN = int(sys.stdin.readline())\n \nfor T in range(1, N+1):\n    C, F, X = map(float, sys.stdin.readline().split(' '))\n \n    # find N\n    N = 0\n    for i in range(int(X)):\n        diff = (2 + F * i) * C - F * X\n        if diff >= 0: break\n        N = i\n \n    # calc seconds\n    total = 0\n    for i in range(N):\n        val = C / (2 + i * F)\n        total += val\n    val = X / (2.0 + N * F)\n    total += val\n         \n    ans = '%s' % (total)\n    print('Case #%(T)s: %(ans)s' % locals())\n"}
{"author": "taichino", "index": 44, "filename": "2014_2974486_5690574640250880.py", "code": "# -*- coding: utf-8 -*-\n \nimport sys\n \n \ndef show_board(board):\n    for row in board:\n        print(''.join(row))\n \n \nN = int(sys.stdin.readline())\n \nfor T in range(1, N+1):\n    (R, C, M) = map(int, sys.stdin.readline().split(' '))\n    E = R*C-M # empty\n    possible, reverse, need_adjust, column_base = (False, False, False, False)\n    if C > R:\n        (R, C) = (C, R)\n        reverse = True\n \n    #\n    # judgement\n    #\n    W = 0\n    lastRow = 0\n    if E == 0:\n        pass\n    elif E == 1 or M == 0:\n        W = C\n        possible = True\n    elif C == 1:\n        W = 1\n        if E > 0:\n            possible = True\n    elif C == 2:\n        W = 2\n        lastRow = int(E / 2) + 1   # 1 base\n        if E % 2 == 0 and E >= 4:\n            possible = True\n    elif C >= 3:\n        for w in range(2, C+1):\n            lastRow = int(E / w) + 1   # 1 base\n            if lastRow > R: continue\n            lastRowNum = E % w\n             \n            if lastRow == 2 and lastRowNum == 0:\n                pass\n            elif lastRow == 2:   # lastRow == 1 => impossible\n                if lastRowNum == 0:\n                    W = w\n                    possible = True\n                    break\n            elif lastRow >= 3:\n                if lastRowNum >= 2 or lastRowNum == 0:\n                    W = w\n                    possible = True\n                    break\n                elif C >= 4 and lastRowNum == 1 and R >= 3:\n                    W = w\n                    possible = True\n                    need_adjust = True\n                    break\n        if not possible:\n            for w in range(2, R+1):\n                lastRow = int(E / w) + 1   # 1 base\n                if lastRow > R: continue\n                lastRowNum = E % w\n                if lastRow == 2 and lastRowNum == 0:\n                    pass\n                elif lastRow == 2:   # lastRow == 1 => impossible\n                    if lastRowNum == 0:\n                        W = w\n                        possible = True\n                        column_base = True\n                        break\n                elif lastRow >= 3:\n                    if lastRowNum >= 2 or lastRowNum == 0:\n                        W = w\n                        possible = True\n                        column_base = True\n                        break\n                    elif C >= 4 and lastRowNum == 1 and R >= 3:\n                        W = w\n                        possible = True\n                        need_adjust = True\n                        column_base = True\n                        break\n                                 \n    if not possible:\n        if reverse:\n            R, C = (C, R)        \n        ans = 'Impossible %sx%s M=%s' % (R, C, M)\n        # ans = 'Impossible'\n        print('Case #%(T)s: %(ans)s' % locals())\n        continue\n \n    #\n    # make board\n    #\n    board = [['*'] * C for i in range(R)]\n    for i in range(E):\n        if not column_base:\n            c = i % W\n            r = i / W\n        else:\n            r = i % W\n            c = i / W            \n        board[r][c] = '.'\n    if need_adjust:\n        board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]\n    if reverse:\n        board = map(list, zip(*board))\n        R, C = (C, R)\n \n    clicked = False\n    for r in range(R):\n        if clicked: break\n        for c in range(C):\n            cell = board[r][c]\n            if cell != '.': continue\n            if E == 1:\n                board[r][c] = 'c'\n                clicked = True\n                break\n             \n            if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\n            if r >= 1              and board[r-1][c]   == '*': continue\n            if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\n            if             c >= 1  and board[r][c-1]   == '*': continue\n            if             c < C-1 and board[r][c+1]   == '*': continue\n            if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\n            if r < R-1             and board[r+1][c]   == '*': continue\n            if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\n            board[r][c] = 'c'\n            clicked = True\n            break\n \n    #\n    # show answer\n    #\n    ans = 'Possible' if possible else 'Impossible'\n    print('Case #%(T)s:' % locals())\n    show_board(board)\n"}
{"author": "taichino", "index": 44, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n \nimport sys\n \nfor i, line in enumerate(sys.stdin):\n    if i == 0:\n        continue\n \n    params = [int(n) for n in line.split(' ')]\n    (N, S, p) = params[:3]\n    scores = params[3:]\n \n    (clear, possible) = (0, 0)\n    normal_min = max(p * 3 - 2, 0)\n    suprising_min = max(p * 3 - 4, 0)\n    for score in scores:\n        if p > score:\n            continue\n        elif score >= normal_min:\n            clear += 1\n        elif score >= suprising_min:\n            possible += 1\n \n    ans = clear + min(possible, S)\n    print('Case #%(i)s: %(ans)s' % locals())\n"}
{"author": "taichino", "index": 44, "filename": "2013_2270488_2453486.py", "code": "# -*- coding: utf-8 -*-\n \nimport sys\n \nN = int(sys.stdin.readline())\n \nfor T in range(1, N+1):\n    lines = []\n    completed = True\n    for i in range(4):\n        line = sys.stdin.readline().strip()\n        if '.' in line:\n            completed = False\n        lines.append(line)\n    sys.stdin.readline() # empty line\n \n    ans = 'Draw' if completed else 'Game has not completed'\n    # horizontal\n    for row in range(4):\n        X, O = 0, 0\n        for col in range(4):\n            spot = lines[row][col]\n            if spot == 'O':\n                O += 1\n            elif spot == 'X':\n                X += 1\n            if spot == 'T':\n                O += 1\n                X += 1\n        if X == 4:\n            ans = 'X won'\n        elif O == 4:\n            ans = 'O won'\n \n    # vertical\n    for col in range(4):\n        X, O = 0, 0\n        for row in range(4):\n            spot = lines[row][col]\n            if spot == 'O':\n                O += 1\n            elif spot == 'X':\n                X += 1\n            if spot == 'T':\n                O += 1\n                X += 1\n        if X == 4:\n            ans = 'X won'\n        elif O == 4:\n            ans = 'O won'\n \n    # diagonal\n    X1, X2, O1, O2 = 0, 0, 0, 0\n    for i in range(4):\n        spot1 = lines[i][i]\n        spot2 = lines[4-i-1][i]\n \n        if spot1 == 'O':\n            O1 += 1\n        elif spot1 == 'X':\n            X1 += 1\n        elif spot1 == 'T':\n            O1 += 1\n            X1 += 1\n \n        if spot2 == 'O':\n            O2 += 1\n        elif spot2 == 'X':\n            X2 += 1\n        elif spot2 == 'T':\n            O2 += 1\n            X2 += 1\n \n    if X1 == 4 or X2 == 4:\n        ans = 'X won'\n    elif O1 == 4 or O2 == 4:\n        ans = 'O won'\n     \n     \n    print('Case #%(T)s: %(ans)s' % locals())\n"}
{"author": "taichino", "index": 44, "filename": "2013_2270488_2449486.py", "code": "# -*- coding: utf-8 -*-\n \nimport sys\nimport copy\n \ndef next_pos(grass, goal, elems):\n    while elems:\n        val = elems[0]\n        for n in range(len(goal)):\n            for m in range(len(goal[0])):\n                if goal[n][m] == val and goal[n][m] < grass[n][m]:\n                    return (n, m)\n        elems.remove(val)\n    return None\n \ndef check(grass, goal):\n    possible = True\n    completed = True\n    for n in range(len(grass)):\n        for m in range(len(grass[0])):\n            if grass[n][m] > goal[n][m]:\n                completed = False\n            elif grass[n][m] < goal[n][m]:\n                possible = False\n \n    return possible, completed\n \ndef cut(grass, goal, pos, h, elems):\n     \n    def _cut(grass, goal, pos, h, is_horizontal):\n        if is_horizontal:\n            for m in range(len(grass[0])):\n                grass[pos[0]][m] = h\n        else:\n            for n in range(len(grass)):\n                grass[n][pos[1]] = h\n        possible, completed = check(grass, goal)\n        if completed and possible:\n            return 'YES'\n        elif not completed and possible:\n            pos = next_pos(grass, goal, elems)\n            if not pos:\n                return 'NO'\n            h = goal[pos[0]][pos[1]]\n            return cut(grass, goal, pos, h, elems)\n        elif not possible:\n            return 'NO'\n \n    ans1 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=True)\n    if ans1 == 'YES':\n        return 'YES'\n    ans2 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=False)\n    if ans2 == 'YES':\n        return 'YES'\n    return 'NO'\n \n \ndef calc(grass, goal):\n    def _elems(goal):\n        elems = set()\n        for n in range(len(goal)):\n            for m in range(len(goal[0])):\n                elems.add(goal[n][m])\n        return sorted(list(elems), reverse=True)\n \n    elems = _elems(goal)\n    pos = next_pos(grass, goal, elems)\n    h = goal[pos[0]][pos[1]]\n    return cut(grass, goal, pos, h, elems)\n \n \nN = int(sys.stdin.readline())\nfor T in range(1, N+1):\n    N, M = map(int, sys.stdin.readline().strip().split())\n \n    goal = []\n    for i in range(N):\n        goal.append(map(int, sys.stdin.readline().strip().split()))\n \n    grass = []\n    for i in range(N):\n        line = [100] * M\n        grass.append(line)\n \n    ans = calc(grass, goal)\n    print('Case #%(T)s: %(ans)s' % locals())\n"}
{"author": "taichino", "index": 44, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n \nimport sys\n \nalphabet = 'abcdefghijklmnopqrstuvwxyz'\ngog = 'ejp mysljylc kd kxveddknmc re jsicpdrysi' + \\\n    'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' + \\\n    'de kr kd eoya kw aej tysr re ujdr lkgc jv' + \\\n    'y qee'\n \neng = 'our language is impossible to understand' + \\\n    'there are twenty six factorial possibilities' + \\\n    'so it is okay if you want to just give up' + \\\n    'a zoo'\n \nrule = {}\nfor i, c in enumerate(gog):\n    rule[c] = eng[i]\n \ngog_alphabet = rule.keys()\neng_alphabet = rule.values()\nmissing_key = None\nmissing_val = None\nfor c in alphabet:\n    if not c in gog_alphabet:\n        missing_key = c\n    if not c in eng_alphabet:\n        missing_val = c\nrule[missing_key] = missing_val\n \nfor i, line in enumerate(sys.stdin):\n    if i == 0:\n        continue\n \n    orig = line.strip()\n    ans = ''.join([rule[c] for c in orig])\n    print('Case #%(i)s: %(ans)s' % locals())\n \n"}
{"author": "taichino", "index": 44, "filename": "2013_2270488_2463486.py", "code": "# -*- coding: utf-8 -*-\n \nimport sys\n \ndef is_palindrome(num):\n    s1 = str(num)\n    s2 = s1[::-1]\n    return s1 == s2\n \nfair_numbers = []\nfor i in range(pow(10, 7)+1):\n    if is_palindrome(i):\n        num = i*i\n        if is_palindrome(num):\n            fair_numbers.append(num)\n \nN = int(sys.stdin.readline())\nfor T in range(1, N+1):\n    min_val, max_val = map(int, sys.stdin.readline().strip().split())\n \n    ans = 0\n    for num in fair_numbers:\n        if num < min_val:\n            continue\n        if num > max_val:\n            break\n        ans += 1\n    print('Case #%(T)s: %(ans)s' % locals())\n"}
{"author": "taichino", "index": 44, "filename": "2014_2974486_5756407898963968.py", "code": "# -*- coding: utf-8 -*-\n \nimport sys\n \nN = int(sys.stdin.readline())\n \nfor T in range(1, N+1):\n    first_ans = int(sys.stdin.readline())\n    first_grid = []\n    for i in range(4):\n        row = [int(v) for v in sys.stdin.readline().split(' ')]\n        first_grid.append(row)\n    first_list = set(first_grid[first_ans-1])\n     \n    second_ans = int(sys.stdin.readline())\n    second_grid = []\n    for i in range(4):\n        row = [int(v) for v in sys.stdin.readline().split(' ')]\n        second_grid.append(row)\n    second_list = set(second_grid[second_ans-1])\n \n    intersection = first_list.intersection(second_list)\n \n    if len(intersection) == 1:\n        ans = intersection.pop()\n    elif len(intersection) == 0:\n        ans = 'Volunteer cheated!'\n    else:\n        ans = 'Bad magician!'\n \n    print('Case #%(T)s: %(ans)s' % locals())\n"}
{"author": "coconutbig", "index": 45, "filename": "2014_2974486_5709773144064000.py", "code": "def solve_case(t):\n    c, f, x = [float(num) for num in raw_input().strip().split()]\n    current_time_usage = x / 2.0\n \n    n = 1\n    build_farm_time = c / (2.0 + float((n - 1) * f))\n    attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time\n \n    while attemp_time_usage < current_time_usage:\n        current_time_usage = attemp_time_usage\n \n        n += 1\n        build_farm_time += c / (2.0 + float((n - 1) * f))\n        attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time\n \n    print('Case #%d: %.7f' % (t, current_time_usage,))\n \ndef main():\n    t = int(raw_input().strip())\n    for i in range(1, t + 1):\n        solve_case(i)\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "coconutbig", "index": 45, "filename": "2014_2974486_5690574640250880.py", "code": "class Sweeper(object):\n    def __init__(self, r, c, m):\n        self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]\n        self.matrix[0][0] = 'c'\n \n        self.r = r\n        self.c = c\n        self.m = m\n        self.current_r = r\n        self.current_c = c\n        self.current_m = m\n \n    def fill_row(self):\n        if self.current_r >= 3 and self.current_m >= self.current_c:\n            for i in range(0, self.current_c):\n                self.matrix[self.current_r - 1][i] = '*'\n            self.current_r -= 1\n            self.current_m -= self.current_c\n            return True\n        return False\n \n    def fill_col(self):\n        if self.current_c >= 3 and self.current_m >= self.current_r:\n            for i in range(0, self.current_r):\n                self.matrix[i][self.current_c - 1] = '*'\n            self.current_c -= 1\n            self.current_m -= self.current_r\n            return True\n        return False\n \n    def fill_partial(self):\n        if self.current_r >= 3:\n            fill_num = min(self.current_m, self.current_c - 2)\n            for i in range(0, fill_num):\n                self.matrix[self.current_r - 1][self.current_c - 1 - i] = '*'\n            self.current_m -= fill_num\n            if fill_num > 0:\n                self.current_r -= 1\n        if self.current_c >= 3:\n            fill_num = min(self.current_m, self.current_r - 2)\n            for i in range(0, fill_num):\n                self.matrix[self.current_r - 1 - i][self.current_c - 1] = '*'\n            self.current_m -= fill_num\n            if fill_num > 0:\n                self.current_c -= 1\n        if self.current_m > 0:\n            return False\n        else:\n            return True\n \n    def fill_special_one(self):\n        if self.current_r * self.current_c == self.current_m + 1:\n            for i in range(0, self.current_r):\n                for j in range(0, self.current_c):\n                    self.matrix[i][j] = '*'\n            self.matrix[0][0] = 'c'\n            self.current_r = 0\n            self.current_c = 0\n            self.current_m = 0\n            return True\n        return False\n \n    def fill_special_col(self):\n        if self.current_c == 1 and self.current_r > self.current_m:\n            for i in range(0, self.current_m):\n                self.matrix[self.current_r - 1 - i][0] = '*'\n            self.matrix[0][0] = 'c'\n            self.current_m = 0\n            self.current_r = 0\n            self.current_c = 0\n            return True\n        return False\n \n    def fill_special_row(self):\n        if self.current_r == 1 and self.current_c > self.current_m:\n            for i in range(0, self.current_m):\n                self.matrix[0][self.current_c - 1 - i] = '*'\n            self.matrix[0][0] = 'c'\n            self.current_m = 0\n            self.current_r = 0\n            self.current_c = 0\n            return True\n        return False\n \ndef print_matrix(matrix):\n    for row in matrix:\n        s = ''\n        for col in row:\n            s += col\n        print(s)\n \n#def check_matrix(matrix, m):\n#    for row in matrix:\n#        for col in row:\n#            if col == '*':\n#                m -= 1\n#    if m > 0 or matrix[0][0] != 'c':\n#        print('>>>>>>>>>>>> BUG <<<<<<<<<<<')\n     \ndef solve_case(t):\n    r, c, m = [int(num) for num in raw_input().strip().split()]\n    sweeper = Sweeper(r, c, m)\n    print('Case #%d:' % (t,))\n    if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():\n        #check_matrix(sweeper.matrix, m)\n        print_matrix(sweeper.matrix)\n        return\n    f_result = True\n    while sweeper.current_m > 0 and f_result:\n        f_result = False\n        f_result |= sweeper.fill_row()\n        f_result |= sweeper.fill_col()\n    if sweeper.current_m > 0:\n        sweeper.fill_partial()\n    if sweeper.current_m > 0:\n        print('Impossible')\n    else:\n        #check_matrix(sweeper.matrix, m)\n        print_matrix(sweeper.matrix)\n \ndef main():\n    t = int(raw_input().strip())\n    for i in range(1, t + 1):\n        solve_case(i)\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "coconutbig", "index": 45, "filename": "2012_1460488_1595491.py", "code": "t = int(raw_input().strip())\nt_count = 1\nwhile t_count <= t:\n\tline = raw_input().strip().split()\n\tn = int(line[0])\n\ts = int(line[1])\n\tp = int(line[2])\n\tti_list = line[3:]\n\tp_min = max(p * 3 - 2, p)\n\tp_min_surprise = max(p * 3 - 4, p)\n\tresult = 0\n\tfor ti in ti_list:\n\t\tti = int(ti)\n\t\tif ti >= p_min:\n\t\t\tresult += 1\n\t\telif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:\n\t\t\tresult += 1\n\t\t\ts -= 1\n\tprint('Case #%d: %d' % (t_count, result,))\n\tt_count += 1\n"}
{"author": "coconutbig", "index": 45, "filename": "2013_2270488_2453486.py", "code": "def get_number_of_test_case():\n    return int(raw_input().strip())\n \ndef solve_case(t):\n    lines = [list(raw_input().strip()) for i in range(4)]\n    raw_input()\n \n    i = 0\n    j = 0\n \n    p_list = list()\n    while i < 4:\n        j = 0\n        s = ''\n        while j < 4:\n            s += lines[i][j]\n            j += 1\n        p_list.append(s.replace('T', 'X'))\n        p_list.append(s.replace('T', 'O'))\n        i += 1\n \n    j = 0\n    while j < 4:\n        i = 0\n        s = ''\n        while i < 4:\n            s += lines[i][j]\n            i += 1\n        p_list.append(s.replace('T', 'X'))\n        p_list.append(s.replace('T', 'O'))\n        j += 1\n     \n    s = lines[0][0] + lines[1][1] + lines[2][2] + lines[3][3]\n    p_list.append(s.replace('T', 'X'))\n    p_list.append(s.replace('T', 'O'))\n \n    s = lines[0][3] + lines[1][2] + lines[2][1] + lines[3][0]\n    p_list.append(s.replace('T', 'X'))\n    p_list.append(s.replace('T', 'O'))\n \n    has_empty = False\n    outcome = ''\n    for p in p_list:\n        has_empty |= '.' in p\n        if p == 'XXXX':\n            outcome = 'X won'\n            break\n        elif p == 'OOOO':\n            outcome = 'O won'\n            break\n    if not outcome:\n        if has_empty:\n            outcome = 'Game has not completed'\n        else:\n            outcome = 'Draw'\n     \n    print('Case #%d: %s' % (t, outcome,))\n \nT = get_number_of_test_case()\nt = 1\nwhile t <= T:\n    solve_case(t)\n    t += 1\n \n"}
{"author": "coconutbig", "index": 45, "filename": "2013_2270488_2449486.py", "code": "def get_number_of_test_case():\n    return int(raw_input().strip())\n \ndef solve_case(t):\n    N, M = [int(x) for x in raw_input().strip().split()]\n     \n    matrix = [[int(x) for x in raw_input().strip().split()] for y in range(N)]\n \n    s_list = list()\n    for i in range(N):\n        for j in range(M):\n            s_list.append([matrix[i][j], i, j,])\n    s_list.sort(cmp = lambda x, y: x[0] - y[0])\n \n    outcome = 'YES'\n    for s in s_list:\n        if matrix[s[1]][s[2]] == 0:\n            continue\n \n        row, col = s[1], s[2]\n \n        can_do = True\n        for i in range(N):\n            can_do &= matrix[i][col] <= s[0]\n        if can_do:\n            for i in range(N):\n                matrix[i][col] = 0\n            continue\n \n        can_do = True\n        for j in range(M):\n            can_do &= matrix[row][j] <= s[0]\n        if can_do:\n            for j in range(M):\n                matrix[row][j] = 0\n        else:\n            outcome = 'NO'\n            break\n     \n    print('Case #%d: %s' % (t, outcome,))\n \n \nT = get_number_of_test_case()\nt = 1\nwhile t <= T:\n    solve_case(t)\n    t += 1\n \n"}
{"author": "coconutbig", "index": 45, "filename": "2012_1460488_1483485.py", "code": "\"\"\"\nnum = int(raw_input('num: ').strip())\n \nc_map = [None for x in range(0, 26)]\n \nwhile num > 0:\n\tgoogleres = raw_input('googleres: ').strip()\n\toriginal = raw_input('original: ').strip()\n \n \n\tord_a = ord('a')\n\tord_z = ord('z')\n \n\ti = 0\n\tfor c in googleres:\n\t\tord_c = ord(c)\n\t\tif ord_a <= ord_c and ord_c <= ord_z:\n\t\t\tc_map[ord_c - ord_a] = ord(original[i]) - ord_c\n\t\ti += 1\n \t\n\tnum -= 1\n \nprint(c_map)\n\"\"\"\n \n\"\"\"\nc_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]\ni = 0\noriginal_list = list()\nwhile i < 25:\n\toriginal_list.append(c_map[i] + i)\n\ti += 1\noriginal_list.sort()\nprint(original_list)\n\"\"\"\n \nc_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]\n \nt = int(raw_input().strip())\nt_count = 1\nwhile t_count <= t:\n\tord_a = ord('a')\n\tord_z = ord('z')\n\tgoogleres = raw_input().strip()\n\toriginal = ''\n\tfor c in googleres:\n\t\tord_c = ord(c)\n\t\tif ord_a <= ord_c and ord_c <= ord_z:\n\t\t\toriginal += chr(c_map[ord_c - ord_a] + ord_c)\n\t\telse:\n\t\t\toriginal += c\n\tprint('Case #%d: %s' % (t_count, original,))\n\tt_count += 1\n \n"}
{"author": "coconutbig", "index": 45, "filename": "2013_2270488_2463486.py", "code": "import math\n \ndef get_number_of_test_case():\n    return int(raw_input().strip())\n \ndef solve_case(t):\n    A, B = [int(x) for x in raw_input().strip().split()]\n \n    print('Case #%d: %d' % (t, get_number_of_palindrome(B) - get_number_of_palindrome(A - 1),))\n \ndef get_number_of_palindrome(n):\n    ret = 0\n \n    nt = int(math.floor(math.sqrt(n)))\n    total_column = int(math.ceil(math.ceil(math.log10(nt + 1)) / 2.0))\n    upper_limit = 10 ** total_column\n \n    counter = 0\n    while counter < upper_limit:\n        c_str = [c for c in str(counter)]\n        c_str.reverse()\n \n        number = str(counter)\n        for c in c_str:\n            number += c\n        number = int(number)\n        number = number ** 2\n        if number <= n and is_palindrome(number):\n            ret += 1\n \n        number = str(counter)\n        for c in c_str[1:]:\n            number += c\n        number = int(number)\n        number = number ** 2\n        if number <= n and is_palindrome(number):\n            ret += 1\n         \n        counter += 1\n \n    return ret\n \ndef is_palindrome(n):\n    if n == 0:\n        return False\n    num = str(n)\n    check_len = len(num) / 2\n    ret = True\n    for i in range(check_len):\n        ret &= num[i] == num[-i - 1]\n    return ret\n \nT = get_number_of_test_case()\nt = 1\nwhile t <= T:\n    solve_case(t)\n    t += 1\n \n"}
{"author": "coconutbig", "index": 45, "filename": "2014_2974486_5756407898963968.py", "code": "def solve_case(t):\n    interested_row = int(raw_input().strip())\n    i = 1\n    while i <= 4:\n        row = raw_input()\n        if i == interested_row:\n            first_set = set(row.strip().split())\n        i += 1\n    interested_row = int(raw_input().strip())\n    i = 1\n    while i <= 4:\n        row = raw_input()\n        if i == interested_row:\n            second_set = set(row.strip().split())\n        i += 1\n    ans_set = first_set & second_set\n    if len(ans_set) == 1:\n        print('Case #%d: %s' % (t, ans_set.pop(),))\n    elif len(ans_set) > 1:\n        print('Case #%d: Bad magician!' % (t,))\n    else:\n        print('Case #%d: Volunteer cheated!' % (t,))\n \ndef main():\n    t = int(raw_input().strip())\n    for i in range(1, t + 1):\n        solve_case(i)\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "kmod", "index": 46, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    T = int(f.readline())\n    for _T in xrange(T):\n        C, F, X = map(float, f.readline().split())\n \n        cps = 2.0\n        t = 0.0\n        best_t = X / cps\n \n        while True:\n            t += C / cps\n            if t >= best_t:\n                break\n \n            cps += F\n            best_t = min(best_t, t + X / cps)\n \n        print(\"Case #%d: %.7f\" % (_T+1, best_t))\n"}
{"author": "kmod", "index": 46, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    T = int(f.readline())\n    for _T in xrange(T):\n        R, C, M = map(int, f.readline().split())\n \n        # print(R, C, M)\n        print(\"Case #%d:\" % (_T+1))\n \n        left = R * C - M\n \n        if R == 1:\n            s = 'c'\n            s += '.' * (left - 1)\n            s += '*' * M\n            print(s)\n            continue\n        if C == 1:\n            print('c')\n            for i in xrange(left - 1):\n                print('.')\n            for i in xrange(M):\n                print('*')\n            continue\n \n        if left == 1:\n            print('c' + '*' * (C-1))\n            for i in xrange(R-1):\n                print('*' * C)\n            continue\n \n        if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n            print(\"Impossible\")\n            continue\n        if R == 2:\n            assert left not in (2, 3, 5, 7)\n            assert left >= 4\n            print('c' + '.' * (left/2 - 1) + '*' * (M/2))\n            print('.' + '.' * (left/2 - 1) + '*' * (M/2))\n            continue\n        if C == 2:\n            assert left >= 4\n            assert left not in (2, 3, 5, 7)\n            print('c.')\n            left -= 2\n            R -= 1\n            while left:\n                print('..')\n                left -= 2\n                R -= 1\n            assert R >= 0\n            while R:\n                print('**')\n                R -= 1\n            continue\n \n        assert R >= 3\n        assert C >= 3\n \n        if left == 4:\n            print('c.' + '*' * (C-2))\n            print('..' + '*' * (C-2))\n            for i in xrange(R-2):\n                print('*' * C)\n            continue\n \n        if left in (2, 3, 5, 7):\n            print(\"Impossible\")\n            continue\n \n        assert left >= 6\n \n        cols = max(3, (left + R-1) // R)\n \n        if left % cols == 1:\n            assert left >= 10\n \n            print('c' + '.' * (cols - 1) + '*' * (C - cols))\n            left -= cols\n            R -= 1\n \n            while left > cols + 1:\n                print('.' * cols + '*' * (C - cols))\n                left -= cols\n                R -= 1\n            assert left == cols + 1\n            print('.' * (cols - 1) + '*' * (C - cols + 1))\n            print('.' * (2) + '*' * (C - 2))\n            R -= 2\n \n            assert R >= 0\n \n            while R:\n                print('*' * C)\n                R -= 1\n            continue\n        else:\n            assert left >= 6\n \n            print('c' + '.' * (cols - 1) + '*' * (C - cols))\n            left -= cols\n            R -= 1\n \n            while left > cols:\n                print('.' * cols + '*' * (C - cols))\n                left -= cols\n                R -= 1\n            assert left >= 2\n            print('.' * (left) + '*' * (C - left))\n            R -= 1\n \n            assert R >= 0\n \n            while R:\n                print('*' * C)\n                R -= 1\n            continue\n \n        1/0\n"}
{"author": "kmod", "index": 46, "filename": "2012_1460488_1595491.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in xrange(t):\n        ns = map(int, f.readline().split())\n        n = ns[0]\n        s = ns[1]\n        p = ns[2]\n        assert len(ns) == n + 3\n        scores = ns[3:3+n]\n \n        sure = 0\n        if_surprising = 0\n        for x in scores:\n            not_surprising = (x + 2) / 3\n            is_surprising = (x + 4) / 3\n            if not_surprising >= p:\n                sure += 1\n            elif (2 <= x <= 28) and is_surprising >= p:\n                if_surprising += 1\n        print(\"Case #%d: %d\" % (_t+1, sure + min(if_surprising, s)))\n"}
{"author": "kmod", "index": 46, "filename": "2013_2270488_2453486.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in xrange(t):\n        m = []\n        for i in xrange(4):\n            l = f.readline().strip()\n            assert len(l) == 4\n            m.append(l)\n        f.readline()\n \n        def check(x, y, dx, dy):\n            s = set()\n            for i in xrange(4):\n                s.add(m[x][y])\n                x += dx\n                y += dy\n            # print(x, y, dx, dy, s)\n            if 'T' in s:\n                s.remove('T')\n            if '.' in s:\n                return None\n            if len(s) == 1:\n                return list(s)[0]\n            return None\n \n        winner = None\n        for i in xrange(4):\n            winner = winner or check(0, i, 1, 0)\n            winner = winner or check(i, 0, 0, 1)\n        winner = winner or check(0, 0, 1, 1)\n        winner = winner or check(0, 3, 1, -1)\n \n        print(\"Case #%d:\" % (_t+1),)\n        if winner:\n            print(\"%s won\" % winner)\n        elif any('.' in l for l in m):\n            print(\"Game has not completed\")\n        else:\n            print(\"Draw\")\n"}
{"author": "kmod", "index": 46, "filename": "2013_2270488_2449486.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in xrange(t):\n        n, m = map(int, f.readline().split())\n        b = []\n        for i in xrange(n):\n            b.append(map(int, f.readline().split()))\n            assert len(b[-1]) == m\n        # print(b)\n \n        max_h = [0] * n\n        max_v = [0] * m\n \n        for i in xrange(n):\n            for j in xrange(m):\n                t = b[i][j]\n                max_h[i] = max(max_h[i], t)\n                max_v[j] = max(max_v[j], t)\n        can = True\n        for i in xrange(n):\n            if not can:\n                break\n            for j in xrange(m):\n                t = b[i][j]\n                if max_h[i] > t and max_v[j] > t:\n                    can = False\n                    break\n \n        print(\"Case #%d: %s\" % (_t+1, \"YES\" if can else \"NO\"))\n"}
{"author": "kmod", "index": 46, "filename": "2012_1460488_1483485.py", "code": "import sys\n \nd = {\n        'a':'y',\n        'o':'e',\n        'z':'q',\n        ' ':' ',\\n        'r':'p',\n        'l':'m',\n        'n':'s',\n        'g':'l',\n        'u':'j',\n        'e':'c',\n        'i':'k',\n        's':'d',\n        'm':'x',\n        'p':'v',\n        't':'r',\n        'd':'i',\n        'b':'n',\n        'h':'b',\n        'w':'t',\n        'y':'a',\n        'x':'h',\n        'f':'w',\n        'c':'f',\n        'k':'o',\n        'j':'u',\n        'v':'g',\n        'q':'z',\n        '\\n':'\\n',\n        }\n \nr = dict((v,k) for (k,v) in d.items())\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    f.readline()\n    i = 1\n    for l in f:\n        sys.stdout.write(\"Case #%d: \" % i)\n        for c in l:\n            # sys.stdout.write(r.get(c, '?'))\n            sys.stdout.write(r[c])\n        i += 1\n \n"}
{"author": "kmod", "index": 46, "filename": "2013_2270488_2463486.py", "code": "import math\nimport sys\n \ndef ispal(n):\n    s = str(n)\n    return s == s[::-1]\n \ndef ispalsq(n):\n    sqrt = int(math.sqrt(n) + .01)\n    if sqrt ** 2 != n:\n        return False\n    return ispal(n) and ispal(sqrt)\n \ndef search(s, l, idx):\n    if l % 2 == 0:\n        m = s + s[::-1]\n    else:\n        m = s[:-1] + s[::-1]\n    assert ispal(m)\n    n = int(m) ** 2\n    if not ispal(n):\n        # print(m, False)\n        return 0\n    # print(m, int(m)**2)\n \n    r = 1 if (a <= n <= b) else 0\n    for i in xrange(idx, len(s)):\n        s2 = list(s)\n        s2[i] = str(int(s2[i])+1)\n        s2 = ''.join(s2)\n        r += search(s2, l, i)\n    return r\n \n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in xrange(t):\n        a, b = map(int, f.readline().split())\n \n        total = 0\n        for l in xrange(1, 150):\n            if 10 ** (l-1) > b:\n                break\n            total += search(\"1\" + \"0\" * ((l-1)/2), l, 0)\n        print(\"Case #%d: %d\" % (_t+1, total))\n \n"}
{"author": "kmod", "index": 46, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    T = int(f.readline())\n    for _T in xrange(T):\n        a1 = int(f.readline())\n        l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n        a2 = int(f.readline())\n        l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n \n        poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n \n        print(\"Case #%d:\" % (_T + 1),)\n        if len(poss) == 0:\n            print(\"Volunteer cheated!\")\n        elif len(poss) == 1:\n            print(poss[0])\n        else:\n            print(\"Bad magician!\")\n"}
{"author": "lookingfor", "index": 47, "filename": "2014_2974486_5709773144064000.py", "code": "T = int(raw_input())\n \ndef solve(C, F, X):\n    best = x/2\n    buildTime, speed = 0, 2\n    while True:\n        buildTime += C/speed\n        if buildTime > best:\n            break\n        speed += F\n        best = min(best, buildTime + X/speed)\n    return best\n \nfor z in xrange(T):\n    c, f, x = map(float, raw_input().split())\n    print(\"Case #%d: %.7f\" % (z+1, solve(c, f, x)))"}
{"author": "lookingfor", "index": 47, "filename": "2014_2974486_5690574640250880.py", "code": "from cStringIO import StringIO\n \nT = int(raw_input())\n \ndef generate(R, C, a, sw):\n    if sw:\n        R, C = C, R\n    res = [['*']*C for i in xrange(R)]\n    for i in xrange(len(a)):\n        for j in xrange(a[i]):\n            if sw:\n                res[j][i] = '.'\n            else:\n                res[i][j] = '.'\n    res[0][0] = 'c'\n    return str(res)[2:-2].replace(' ', '').replace(\"'\",'').replace('[', '').replace('],','\\n').replace(',', '')\n \n \ndef solveEq(k, s, x1):\n    if 2*(x1 + k - 2) > s or k*x1 < s:\n        return None\n    r = [0]*k\n    r[0] = r[1] = x1\n    s -= 2*x1\n    for i in xrange(k-2, 0, -1):\n        t = min(x1, s - 2*i + 2)\n        r[k-i] = t\n        s -= t\n    return r\n \ndef solve(R, C, M):\n    S = R*C\n    nm = S - M\n    if R == 1 or C == 1:\n        if R == 1:\n            return '*'*M + '.'*(S-M-1) + 'c'\n        else:\n            return '*\\n'*M + '.\\n'*(S-M-1) + 'c'\n    else:\n        sw = False\n        if R > C:\n            R, C = C, R\n            sw = True\n        if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):\n            return \"Impossible\"\n        if nm == 1:\n            return generate(R, C, [1], sw)\n        for k in xrange(2, R+1):\n            for x1 in xrange(2, C+1):\n                r = solveEq(k, nm, x1)\n                if r != None:\n                    return generate(R, C, r, sw)\n        return \"Something wrong\"\n \nfor z in xrange(T):\n    c, f, x = map(int, raw_input().split())\n    print(\"Case #%d:\\n%s\" % (z+1, solve(c, f, x)))"}
{"author": "lookingfor", "index": 47, "filename": "2012_1460488_1595491.py", "code": "T = int(raw_input())\n \nfor z in xrange(1, T+1):\n    a = map(int, raw_input().split())\n    s, p = a[1:3]\n    a = a[3:]\n    A = 0 if p == 0 else 3*p - 2\n    B = 0 if p == 0 else 1 if p == 1 else 3*p-4\n    x = len(filter(lambda x: x >= A, a))\n    y = len(filter(lambda x: x >= B, a)) - x\n    res = x + min(s, y)\n    print(\"Case #%d:\" % z, res)"}
{"author": "lookingfor", "index": 47, "filename": "2013_2270488_2453486.py", "code": "n = int(raw_input())\n \nd = {'X':2, 'O': 0, 'T':1, '.':-10}\n \ndef readGame():\n    return [map(lambda c:d[c], raw_input().strip()) for i in xrange(4)]\n \ndef check(game):\n    s = []\n    for i in xrange(4): # horizontal\n        s.append(sum(game[i]))\n    for i in xrange(4): # vertical\n        s.append(sum(map(lambda li: li[i], game)))\n    d1 = d2 = 0 # diagonal\n    for i in xrange(4):\n        d1 += game[i][i]\n        d2 += game[i][3-i]\n    s.append(d1)\n    s.append(d2)\n    if max(s) >= 7:\n        return \"X won\";\n    gr0 = filter(lambda n: n >= 0, s)\n    if len(gr0) > 0 and min(gr0) <= 1:\n        return \"O won\"\n    if min(s) < 0:\n        return \"Game has not completed\"\n    return \"Draw\"\n \nfor i in xrange(n):\n    game = readGame()\n    if i + 1 < n:\n        raw_input()\n \n    print(\"Case #%d: %s\" % (i+1, check(game)))"}
{"author": "lookingfor", "index": 47, "filename": "2013_2270488_2449486.py", "code": "T = int(raw_input())\n \ndef readMatrix(nlines):\n    return [map(int, raw_input().split(' ')) for i in xrange(nlines)]\n \ndef transpose(A):\n    return map(lambda i: map(lambda line: line[i], A), xrange(len(A[0])))\n \nfor z in xrange(T):\n    M, N = map(int, raw_input().split(' '))\n    A = readMatrix(M)\n    b = map(max, A)\n    c = map(max, transpose(A))\n    fl = True\n    for i in xrange(M):\n        for j in xrange(N):\n            if A[i][j] != min(b[i], c[j]):\n                fl = False\n    print(\"Case #%d: %s\" % (z+1, \"YES\" if fl else \"NO\"))"}
{"author": "lookingfor", "index": 47, "filename": "2012_1460488_1483485.py", "code": "inps = [\"ejp mysljylc kd kxveddknmc re jsicpdrysi\", \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\", \"de kr kd eoya kw aej tysr re ujdr lkgc jv\"]\nouts = [\"our language is impossible to understand\",\"there are twenty six factorial possibilities\", \"so it is okay if you want to just give up\"]\n \nd = {'z':'q', 'q':'z'}\n \nfor i in xrange(3):\n    inp, out = inps[i], outs[i]\n    for j in xrange(len(inp)):\n        d[inp[j]] = out[j]\n \nn = int(raw_input())\nfor i in xrange(n):\n    s = raw_input()\n    print(\"Case #%d:\" % (i+1), \"\".join(map(lambda c: d[c], s)))"}
{"author": "lookingfor", "index": 47, "filename": "2013_2270488_2463486.py", "code": "from bisect import bisect_right\n \ndef generateTable(N):\n    msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]\n    nums = revnums = [1, 2]\n \n    digsums = [1, 4]\n \n    for i in xrange(2, N+1):\n        a, b, d = [], [], []\n        p = 10**(i-1)\n        for j in xrange(len(nums)):\n            for k in xrange(3):\n                n, rn, ds = 10*nums[j] + k, revnums[j] + k*p, digsums[j] + k*k\n                if ds < 5:\n                    a.append(n)\n                    b.append(rn)\n                    d.append(ds)\n                    msq.append(10*p*n + rn) # even length\n                    if i == N:\n                        continue\n                    for l in xrange(3): # odd length\n                        if 2*ds + l*l < 10:\n                            msq.append(100*p*n + 10*p*l + rn)\n        nums, revnums, digsums = a, b, d\n \n    msq.sort()\n    return msq\n \ndef getNum(A, B):\n    return bisect_right(tab2, B) - bisect_right(tab2, A-1)\n \nN = 10\ntab = generateTable(N)\ntab2 = map(lambda n: n**2, tab)\n \nT = int(raw_input())\nfor z in xrange(T):\n    A, B = map(int, raw_input().split())\n    print(\"Case #%d: %d\" % (z+1, getNum(A, B)))\n"}
{"author": "lookingfor", "index": 47, "filename": "2014_2974486_5756407898963968.py", "code": "T = int(raw_input())\n \ndef readSq(n):\n    res = []\n    for i in xrange(n):\n        res.append(set(map(int, raw_input().split())))\n    return res\n \ndef solve():\n    a1 = int(raw_input())\n    s1 = readSq(4)\n    a2 = int(raw_input())\n    s2 = readSq(4)\n    ans = s1[a1-1] & s2[a2-1]\n    if len(ans) == 0:\n        return \"Volunteer cheated!\"\n    if len(ans) > 1:\n        return \"Bad magician!\"\n    return str(list(ans)[0])\n \nfor z in xrange(T):\n    print(\"Case #%d: %s\" % (z+1, solve()))\n"}
{"author": "jakab922", "index": 48, "filename": "2014_2974486_5709773144064000.py", "code": "T = int(raw_input().strip())\n \nfor i in xrange(T):\n\tC, F, X = map(float, raw_input().strip().split(' '))\n\tbest = X / 2.0\n\tc_sum = 0\n\tfactories = 1\n\tn_sum = c_sum + C / (2.0 + (factories - 1) * F)\n\twhile n_sum + X / (2.0 + factories * F) < best:\n\t\tbest = n_sum + X / (2.0 + factories * F)\n\t\tc_sum = n_sum\n\t\tfactories += 1\n\t\tn_sum = c_sum + C / (2.0 + (factories - 1) * F)\n \n\tprint(\"Case #%s: %s\" % (i + 1, best))\n"}
{"author": "jakab922", "index": 48, "filename": "2014_2974486_5690574640250880.py", "code": "T = int(raw_input().strip())\nmisses = set()\n \nfor i in xrange(T):\n\tR, C, M = map(int, raw_input().strip().split(' '))\n\tF = R * C - M\n\t# print(\"F: %s, R: %s, C: %s, M: %s\" % (F, R, C, M))\n\timpossible = False\n\tif F == 1:\n\t\tmatrix = [\"c\" + \"*\" * (C - 1)]\n\t\tfor _ in xrange(R - 1):\n\t\t\tmatrix.append(\"*\" * C)\n\telif R == 1:\n\t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\n\telif C == 1:\n\t\tmatrix = [\"c\"]\n\t\tfor _ in xrange(F - 1):\n\t\t\tmatrix.append(\".\")\n\t\tfor _ in xrange(R - F):\n\t\t\tmatrix.append(\"*\")\n\telif R == 2:\n\t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\n\t\t\tmatrix = [\n\t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\n\t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\n\t\t\t]\n\t\telse:\n\t\t\tmatrix = []\n\t\t\timpossible = True\n\telse:\n\t\tstack = []\n\t\tmatrix = []\n\t\tfor j in xrange(C, 1, -1):\n\t\t\tif F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\n\t\t\t\tstack.append([j, j])\n \n\t\twhile stack:\n\t\t\t# print(\"stack: %s\" % stack)\n\t\t\telems = stack.pop()\n\t\t\tse = sum(elems)\n\t\t\tif se == F:\n\t\t\t\tfor count in elems:\n\t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\n\t\t\t\tfor _ in xrange(R - len(elems)):\n\t\t\t\t\tmatrix.append(\"*\" * C)\n\t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\n\t\t\t\tbreak\n\t\t\telif len(elems) < R:\n\t\t\t\tfor j in xrange(elems[-1], 1, -1):\n\t\t\t\t\tif F - se - j >= 0 and (R - len(elems)) * j >= F - se:\n\t\t\t\t\t\tstack.append(elems[::] + [j])\n \n\t\tif matrix == []:\n\t\t\timpossible =True\n \n\tprint(\"Case #%s:\" % (i + 1))\n\tif impossible:\n\t\tprint(\"Impossible\")\n\telse:\n\t\tfor row in matrix:\n\t\t\tprint(row)\n"}
{"author": "jakab922", "index": 48, "filename": "2012_1460488_1595491.py", "code": "from sys import argv\n \nsurprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]\nregular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]\n \nf = open(argv[1], 'r')\nT = int(f.readline().strip('\\n'))\nfor i in range(T):\n\tboth = 0\n\tsurp_only = 0\n\tline = f.readline().strip('\\n').split(' ')\n\tN = int(line[0]) # What for?\n\tS = int(line[1])\n\tp = int(line[2])\n\tts = map(int, line[3:])\n\tfor t in ts:\n\t\tif reduce(max, map(max, regular[t])) >= p:\n\t\t\tboth += 1\n\t\telif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:\n\t\t\tsurp_only += 1\n \n\tprint(\"Case #%s: %s\" % (i + 1, both + min(surp_only, S)))"}
{"author": "jakab922", "index": 48, "filename": "2013_2270488_2453486.py", "code": "X_WON = 0\nO_WON = 1\nDRAW = 2\nNEITHER = 3\n \nmessages = [\n    \"X won\",\n    \"O won\",\n    \"Draw\",\n    \"Game has not completed\"\n]\n \n \ndef check_win(state):\n    if state['X'] == 4 or state['X'] == 3 and state['T'] == 1:\n        return X_WON\n    elif state['O'] == 4 or state['O'] == 3 and state['T'] == 1:\n        return O_WON\n    else:\n        return -1\n \ndef check_state(table):\n \n    # Check rows\n    for i in xrange(4):\n        state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n        for j in xrange(4):\n            state[table[i][j]] += 1\n        res = check_win(state)\n        if res != -1:\n            return res\n \n    # Check cols\n    for i in xrange(4):\n        state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n        for j in xrange(4):\n            state[table[j][i]] += 1\n        res = check_win(state)\n        if res != -1:\n            return res\n \n    # Check diags\n    # Normal\n    state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n    for i in xrange(4):\n        state[table[i][i]] +=  1\n    res = check_win(state)\n    if res != -1:\n        return res\n \n    # Cross\n    state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n    for i in xrange(4):\n        state[table[i][3 - i]] +=  1\n    res = check_win(state)\n    if res != -1:\n        return res\n \n    # Check not full\n    for i in xrange(4):\n        for j in xrange(4):\n            if table[i][j] == '.':\n                return NEITHER\n \n    # It's a draw\n    return DRAW\n \nT = int(raw_input().strip())\nfor i in xrange(T):\n    table = [[] for _ in xrange(4)]\n    for j in xrange(4):\n        table[j] = list(raw_input().strip())\n    # print(\"table: %s\" % table)\n    if i != T - 1:\n        raw_input()\n    print(\"Case #%s: %s\" % (i + 1, messages[check_state(table)]))"}
{"author": "jakab922", "index": 48, "filename": "2013_2270488_2449486.py", "code": "YES = 0\nNO = 1\n \nmessages = [\n    \"YES\",\n    \"NO\"\n]\n \n# def check_height(lawn, N, M, height, was, levels):\n#     for x, y in levels[height]:\n#         if x not in was['row'] and y not in was['col']:\n#             # Try the row\n#             good_row = True\n#             for i in xrange(M):\n#                 if lawn[x][i] > height:\n#                     good_row = False\n#                     break\n#             if good_row:\n#                 was['row'].add(x)\n#                 continue\n#             good_col = True\n#             for i in xrange(N):\n#                 if lawn[i][y] > height:\n#                     good_col = False\n#                     break\n#             if good_col:\n#                 was['col'].add(y)\n#                 continue\n#             # There is no good cut for this field\n#             return False\n#     return True\n \n# def check_lawn(lawn, N, M):\n#     heights_dict = {i: False for i in xrange(1,101)}\n#     for i in xrange(N):\n#         for j in xrange(M):\n#             heights_dict[lawn[i][j]] = True\n \n#     heights = [key for key in sorted(heights_dict.keys()) if heights_dict[key]]\n#     if len(heights) == 1:\n#         return YES\n#     levels = {height: [] for height in heights}\n \n#     for i in xrange(N):\n#         for j in xrange(M):\n#             levels[lawn[i][j]].append((i, j))\n \n#     was = {\n#         \"row\": set()\n#         \"col\": set()\n#     }\n \n#     for i, height in enumerate(heights[:-1]):\n#         if not check_height(lawn, N, M, height, was, levels):\n#             return NO\n \n#     return YES\n \ndef check_lawn(lawn, N, M):\n    row_maxs = [0 for _ in xrange(N)]\n    col_maxs = [0 for _ in xrange(M)]\n \n    for i in xrange(N):\n        cmax = -1\n        for j in xrange(M):\n            if lawn[i][j] > cmax:\n                cmax = lawn[i][j]\n        row_maxs[i] = cmax\n \n    for j in xrange(M):\n        cmax = -1\n        for i in xrange(N):\n            if lawn[i][j] > cmax:\n                cmax = lawn[i][j]\n        col_maxs[j] = cmax\n \n    for i in xrange(N):\n        for j in xrange(M):\n            if row_maxs[i] > lawn[i][j] and col_maxs[j] > lawn[i][j]:\n                return NO\n \n    return YES\n \n \nT = int(raw_input().strip())\nfor i in xrange(T):\n    N, M = map(int, raw_input().strip().split(' '))\n    lawn = [[] for j in xrange(N)]\n    for j in xrange(N):\n        lawn[j] = map(int, raw_input().strip().split(' '))\n    print(\"Case #%s: %s\" % (i + 1, messages[check_lawn(lawn, N, M)]))\n"}
{"author": "jakab922", "index": 48, "filename": "2012_1460488_1483485.py", "code": "from sys import argv\n \nmapping = { \"a\": \"y\", \"c\": \"e\", \"b\": \"h\", \"e\": \"o\", \"d\": \"s\", \"g\": \"v\", \"f\": \"c\", \"i\": \"d\", \"h\": \"x\", \"k\": \"i\", \"j\": \"u\", \"m\": \"l\", \"l\": \"g\", \"o\": \"k\", \"n\": \"b\", \"p\": \"r\", \"s\": \"n\", \"r\": \"t\", \"u\": \"j\", \"t\": \"w\", \"w\": \"f\", \"v\": \"p\", \"y\": \"a\", \"x\": \"m\", \"q\": \"z\", \"z\": \"q\"}\n \ndef translator(s):\n\tret = []\n\tfor c in s:\n\t\tif ord(c) > 96 and ord(c) < 123:\n\t\t\tret.append(mapping[c])\n\t\telse:\n\t\t\tret.append(c)\n \n\treturn ''.join(ret)\n \nf = open(argv[1], 'r')\nT = int(f.readline().strip('\\n'))\nfor i in range(T):\n\tline = f.readline().strip('\\n')\n\tprint(\"Case #%s: %s\" % (i + 1, translator(line)))"}
{"author": "jakab922", "index": 48, "filename": "2013_2270488_2463486.py", "code": "# In general 1[10]*1 square is always a palindrome and some subset of [12][012]*[12] is also good but it's just\n# too much hassle to figure that out. Also needs a more complex generator for ranges. 55p is hard...\n \n \nLIMIT = 10\n \ndef check_palindrome(number):\n    rev = 0\n    runner = number\n    while runner > 0:\n        rev = rev * 10 + (runner % 10)\n        runner /= 10\n    if rev == number:\n        return True\n    else:\n        return False\n \ndef list_to_number(number_list):\n    l = len(number_list)\n    res = 0; rres = 0\n    multi = 1\n    for i in xrange(1, l + 1):\n        res += number_list[l - i] * multi\n        rres += number_list[i - 1] * multi\n        multi *= 10\n    return (res, rres)\n \ndef gen_one_side(side_length):\n    state = [0 for _ in xrange(side_length)]\n    done = False\n \n    while not done:\n        if state[-1] != 0:\n            yield state\n        state[-1] += 1\n        curr = side_length - 1\n        while state[curr] == LIMIT:\n            if curr == 0:\n                done = True\n                break\n            state[curr] = 0\n            curr -= 1\n            state[curr] += 1\n \ndef gen_odd_palindrome(side_length):\n    if side_length == 0:\n        for i in xrange(1, 10):\n            yield i\n    else:\n        multi = 10**side_length\n        for one_side in gen_one_side(side_length):\n            number, rnumber = list_to_number(one_side)\n            for i in xrange(LIMIT):\n                yield number + i * multi + rnumber * multi * 10\n \ndef gen_even_palindrome(side_length):\n    multi = 10**side_length\n    for one_side in gen_one_side(side_length):\n        number, rnumber = list_to_number(one_side)\n        yield number + rnumber * multi\n \n \ndef gen_palindrome():\n    l = 1\n \n    while True:\n        if l % 2 == 1:\n            for odd_pal in gen_odd_palindrome((l - 1) / 2):\n                yield odd_pal\n        else:\n            for even_pal in gen_even_palindrome(l / 2):\n                yield even_pal\n        l += 1\n \n \ncache = []\nupper = 10**14\nfor pal in gen_palindrome():\n    pal2 = pal**2\n    if pal2 > upper:\n        break\n    if check_palindrome(pal2):\n        cache.append(pal2)\n \ncl = len(cache)\nT = int(raw_input().strip())\nfor i in xrange(T):\n    low_ind = 0\n    high_ind = cl - 1\n    A, B = map(int, raw_input().strip().split(' '))\n \n    # The cache is small for 10**14\n    while cache[low_ind] < A:\n        low_ind += 1\n    while cache[high_ind] > B:\n        high_ind -= 1\n \n \n    if low_ind <= high_ind:\n        print(\"Case #%s: %s\" % (i + 1, high_ind - low_ind + 1))\n    else:\n        print(\"Case #%s: 0\" % (i + 1))\n"}
{"author": "jakab922", "index": 48, "filename": "2014_2974486_5756407898963968.py", "code": "T = int(raw_input().strip())\n \nfor j in xrange(T):\n\trow_num1 = int(raw_input().strip())\n\tfor i in xrange(4):\n\t\tif i + 1 == row_num1:\n\t\t\trow1 = set(map(int, raw_input().strip().split(' ')))\n\t\telse:\n\t\t\traw_input()\n\trow_num2 = int(raw_input().strip())\n\tfor i in xrange(4):\n\t\tif i + 1 == row_num2:\n\t\t\trow2 = set(map(int, raw_input().strip().split(' ')))\n\t\telse:\n\t\t\traw_input()\n\tcommon = row1 & row2\n\tlc = len(common)\n\tif lc == 1:\n\t\tstuff = list(common)[0]\n\telif lc > 1:\n\t\tstuff = \"Bad magician!\"\n\telse:\n\t\tstuff = \"Volunteer cheated!\"\n \n\tprint(\"Case #%s: %s\" % (j + 1, stuff))\n"}
{"author": "gizzywump", "index": 49, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/env python\n \nimport collections\n \nimport math\nimport re\nimport sys\n \nsys.setrecursionlimit(5000)\n \nINPUT = \"tiny\"\nINPUT = \"B-large.in\"\nINPUT = \"B-small-attempt0.in\"\n \ndef debug(*args):\n    return\n    sys.stderr.write(str(args) + \"\\n\")\n \nclass Memoize:\n    def __init__(self,function):\n        self._cache = {}\n        self._callable = function\n             \n    def __call__(self, *args, **kwds):\n        cache = self._cache\n        key = self._getKey(*args,**kwds)\n        try: return cache[key]\n        except KeyError:\n            cachedValue = cache[key] = self._callable(*args,**kwds)\n            return cachedValue\n     \n    def _getKey(self,*args,**kwds):\n        return kwds and (args, ImmutableDict(kwds)) or args    \n \ndef do_trial(C, F, X, rate=2.0):\n    #import pdb; pdb.set_trace()\n    win_time_wait = X / rate\n    buy_time = C / rate\n    win_time_buy_1 = buy_time + X / (rate+F)\n    if win_time_wait < win_time_buy_1:\n        return win_time_wait\n    return buy_time + do_trial(C, F, X, rate+F)\n \nf = file(INPUT)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    C, F, X = [float(x) for x in f.readline().split()]\n    v = do_trial(C, F, X)\n    print(\"Case #%d: %s\" % (i+1, v))\n"}
{"author": "gizzywump", "index": 49, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\n \nimport collections\n \nimport math\nimport re\nimport sys\n \n#sys.setrecursionlimit(50)\n \nINPUT = \"tiny\"\n#INPUT = \"C-large.in\"\nINPUT = \"C-small-attempt1.in\"\n \ndef debug(*args):\n    #return\n    sys.stderr.write(str(args) + \"\\n\")\n \nclass Memoize:\n    def __init__(self,function):\n        self._cache = {}\n        self._callable = function\n             \n    def __call__(self, *args, **kwds):\n        cache = self._cache\n        key = self._getKey(*args,**kwds)\n        try: return cache[key]\n        except KeyError:\n            cachedValue = cache[key] = self._callable(*args,**kwds)\n            return cachedValue\n     \n    def _getKey(self,*args,**kwds):\n        return kwds and (args, ImmutableDict(kwds)) or args    \n \nIMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])\n \nfor i in range(2,51):\n    IMPOSSIBLE.add((2,i,1))\n    IMPOSSIBLE.add((i,2,1))\n \nSOLN = {\n    (1,2,1) : [\"c*\"],\n    (2,1,1) : [\"c\", \"*\"],\n    (2,2,3) : [\"c*\", \"**\"],\n}\n \ndef solve(R, C, M):\n    if M == 0:\n        s = [\"c%s\" % ('.' * (C-1))]\n        for i in range(R-1):\n            s.append('.' * C)\n        return s\n    t = (R, C, M)\n    if t in IMPOSSIBLE:\n        debug(\"** %s %s %s\" % t)\n        raise ValueError\n    if t in SOLN:\n        return SOLN[t]\n \n    # last row?\n    if C < M and R > 2:\n        try:\n            return solve(R-1, C, M-C) + [\"*\" * C]\n        except ValueError:\n            pass\n \n    if C <= R:\n        if M >= C and R > 2:\n            return solve(R-1, C, M-C) + [\"*\" * C]\n    else:\n        if M >= R and C > 2:\n            return [\"%s*\" % s for s in solve(R, C-1, M-R)]\n    if R > 2:\n        # fill in last row\n        mines = min(C, M)\n        if mines == C - 1:\n            mines -= 1\n        try:\n            return solve(R-1, C, M-mines) + [(\".\" * (C - mines)) + (\"*\" * mines)]\n        except ValueError:\n            if C > 2:\n                mines = min(R, M)\n            if mines == R - 1:\n                mines -= 1\n            s = [\"%s%s\" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]\n            return s\n    debug(R, C, M)\n    return []\n \ndef do_trial(R, C, M):\n    try:\n        r = solve(R,C,M)\n        s = \"\\n\" + '\\n'.join(r)\n        assert len(r) == R\n        for r1 in r:\n            assert len(r1) == C\n        assert len(''.join(k for k in s if k == '*')) == M\n        return s\n    except ValueError:\n        return \"\\nImpossible\"\n \n \ndef all():\n    for R in range(1,50):\n        for C in range(1,50):\n            for M in range(R*C):\n                print(R, C, M)\n                print(do_trial(R, C, M))\n    sys.exit(0)\n \n#all()\n \nf = file(INPUT)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    R, C, M = [int(x) for x in f.readline().split()]\n    #import pdb; pdb.set_trace()\n    v = do_trial(R, C, M)\n    print(\"Case #%d: %s\" % (i+1, v))\n"}
{"author": "gizzywump", "index": 49, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/env python\n \nimport pdb\nimport re\nimport sys\n \nINPUT = \"tiny\"\n \nINPUT = \"B-small-attempt0.in.txt\"\n \ndef debug(*args):\n    pass #print(str(args))\n \ndef zdebug(*args):\n    print(''.join(str(s) for s in args))\n \ndef can_score_p(N, p):\n    low_p = max(p-1, 0)\n    if low_p + low_p + p <= N:\n        return \"Y\"\n    low_p = max(p-2, 0)\n    if low_p + low_p + p <= N:\n        return \"S\"\n    return \"N\"\n \ndef do_trial(N, S, p, *scores):\n    d = { \"Y\" : 0, \"N\" : 0, \"S\" : 0 }\n    for s in scores:\n        v = can_score_p(s, p)\n        debug(\"score %s p=%s : %s\" % (s, p, v))\n        d[v] = d[v] + 1\n    return d[\"Y\"] + min(d[\"S\"], S)\n \nf = file(INPUT)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    l = [int(x) for x in f.readline()[:-1].split()]\n    v = do_trial(*l)\n    print(\"Case #%d: %s\" % (i+1, v))\n"}
{"author": "gizzywump", "index": 49, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\n \nimport collections\n \nimport re\nimport sys\n \nINPUT = \"tiny\"\nif 1:\n    INPUT = \"A-small-attempt0.in\"\n \ndef debug(*args):\n    pass #print(str(args))\n \nclass Memoize:\n    def __init__(self,function):\n        self._cache = {}\n        self._callable = function\n             \n    def __call__(self, *args, **kwds):\n        cache = self._cache\n        key = self._getKey(*args,**kwds)\n        try: return cache[key]\n        except KeyError:\n            cachedValue = cache[key] = self._callable(*args,**kwds)\n            return cachedValue\n     \n    def _getKey(self,*args,**kwds):\n        return kwds and (args, ImmutableDict(kwds)) or args    \n \ndef check(board, x, y, dx, dy):\n    #import pdb; pdb.set_trace()\n    c = collections.Counter((board[x+dx*i][y+dy*i] for i in range(4)))\n    if c.get(\"X\", 0) + c.get(\"T\", 0) == 4: return \"X won\"\n    if c.get(\"O\", 0) + c.get(\"T\", 0) == 4: return \"O won\"\n \ndef do_trial(board):\n    #return \"X won\" #(the game is over, and X won)\n    #\"O won\" (the game is over, and O won)\n    #\"Draw\" (the game is over, and it ended in a draw)\n    #\"Game has not completed\" (the game is not over yet)\n    for x in range(4):\n        v = check(board, x, 0, 0, 1)\n        if v: return v\n        v = check(board, 0, x, 1, 0)\n        if v: return v\n    v = check(board, 0, 0, 1, 1)\n    if v: return v\n    v = check(board, 3, 0, -1, 1)\n    if v: return v\n    if '.' in ''.join(board):\n        return \"Game has not completed\"\n    return \"Draw\"\n \nf = file(INPUT)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    lines = [f.readline()[:-1] for j in range(4)]\n    f.readline()\n    v = do_trial(lines)\n    print(\"Case #%d: %s\" % (i+1, v))\n"}
{"author": "gizzywump", "index": 49, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/env python\n \nimport collections\n \nimport re\nimport sys\n \nINPUT = \"tiny\"\nif 1:\n    INPUT = \"B-small-attempt0.in\"\n \ndef debug(*args):\n    pass #print(str(args))\n \nclass Memoize:\n    def __init__(self,function):\n        self._cache = {}\n        self._callable = function\n             \n    def __call__(self, *args, **kwds):\n        cache = self._cache\n        key = self._getKey(*args,**kwds)\n        try: return cache[key]\n        except KeyError:\n            cachedValue = cache[key] = self._callable(*args,**kwds)\n            return cachedValue\n     \n    def _getKey(self,*args,**kwds):\n        return kwds and (args, ImmutableDict(kwds)) or args\n \ndef do_trial(lawn):\n    w = len(lawn[0])\n    h = len(lawn)\n    x_maxes = [max(lawn_row) for lawn_row in lawn]\n    y_maxes = [max(lawn[y][x] for y in range(h)) for x in range(w)]\n    def lawn_row(y):\n        x_max = x_maxes[y]\n        return tuple([min(y_maxes[x], x_max) for x in range(w)])\n    new_lawn = tuple([lawn_row(y) for y in range(h)])\n    #import pdb; pdb.set_trace()\n    if new_lawn == lawn:\n        return \"YES\"\n    return \"NO\"\n \nf = file(INPUT)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    w, h = [int(x) for x in f.readline().split()]\n    lawn = []\n    for k in range(w):\n        lawn.append(tuple([int(x) for x in f.readline().split()]))\n    lawn = tuple(lawn)\n    #if i==2:\n    #    import pdb; pdb.set_trace()\n    v = do_trial(lawn)\n    print(\"Case #%d: %s\" % (i+1, v))\n"}
{"author": "gizzywump", "index": 49, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/env python\n \nimport pdb\nimport re\nimport sys\n \nINPUT = \"tiny\"\nif 1:\n    INPUT = \"A-small-attempt2.in.txt\"\n \nI=re.sub(\" \", \"\", \"ejp mysljylc kd kxveddknmc re jsicpdrysirbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jv\")\nO=re.sub(\" \", \"\", \"our language is impossible to understandthere are twenty six factorial possibilitiesso it is okay if you want to just give up\")\n \n#print(I, O)\n \nMAP={ 'z' : 'q', 'q' : 'z' }\nfor i,o in zip(I,O):\n    MAP[i] = o\n \ndef debug(*args):\n    pass #print(str(args))\n \ndef debug(*args):\n    print(str(args))\n \ndef do_trial(l):\n    t = list(l)\n    t1 = [MAP.get(x, x) for x in t]\n    return ''.join(t1)\n \nf = file(INPUT)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    l = f.readline()[:-1]\n    v = do_trial(l)\n    print(\"Case #%d: %s\" % (i+1, v))\n"}
{"author": "gizzywump", "index": 49, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/env python\n \nimport collections\n \nimport pickle\nimport re\nimport sys\n \nINPUT = \"tiny\"\nif 1:\n    INPUT = \"C-small-attempt0.in\"\n \ndef debug(*args):\n    pass #print(str(args))\n \nclass Memoize:\n    def __init__(self,function):\n        self._cache = {}\n        self._callable = function\n             \n    def __call__(self, *args, **kwds):\n        cache = self._cache\n        key = self._getKey(*args,**kwds)\n        try: return cache[key]\n        except KeyError:\n            cachedValue = cache[key] = self._callable(*args,**kwds)\n            return cachedValue\n     \n    def _getKey(self,*args,**kwds):\n        return kwds and (args, ImmutableDict(kwds)) or args\n \ndef is_palindrome(N):\n    s = str(N)\n    return s == ''.join(reversed(s))\n \ndef fair_and_square_set(max_N):\n    p = \"squareset_%d\" % max_N\n    try:\n        s = pickle.load(file(p))\n        return s\n    except:\n        pass\n    s = set()\n    for i in range(1,max_N+1):\n        if is_palindrome(i) and is_palindrome(i*i):\n            s.add(i*i)\n    pickle.dump(s, file(p, \"wb\"))\n    return s\n \nMAX_N = int(1e7)\nSQUARE_SET = fair_and_square_set(MAX_N)\n#print(SQUARE_SET)\n \ndef do_trial(A, B):\n    count = 0\n    for ss in SQUARE_SET:\n        if A <= ss <= B:\n            count += 1\n    return count\n \nf = file(INPUT)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    A, B = [int(x) for x in f.readline().split()]\n    v = do_trial(A, B)\n    print(\"Case #%d: %s\" % (i+1, v))\n"}
{"author": "gizzywump", "index": 49, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\n \nimport collections\n \nimport math\nimport re\nimport sys\n \nINPUT = \"tiny\"\nif 1:\n    INPUT = \"A-large.in\"\n    INPUT = \"A-small-attempt0.in\"\n \ndef debug(*args):\n    return\n    sys.stderr.write(str(args) + \"\\n\")\n \nclass Memoize:\n    def __init__(self,function):\n        self._cache = {}\n        self._callable = function\n             \n    def __call__(self, *args, **kwds):\n        cache = self._cache\n        key = self._getKey(*args,**kwds)\n        try: return cache[key]\n        except KeyError:\n            cachedValue = cache[key] = self._callable(*args,**kwds)\n            return cachedValue\n     \n    def _getKey(self,*args,**kwds):\n        return kwds and (args, ImmutableDict(kwds)) or args    \n \ndef do_trial(a1, r1, a2, r2):\n    p1 = set(r1[a1-1])\n    p2 = set(r2[a2-1])\n    u = p1.intersection(p2)\n    if len(u) < 1:\n        return \"Volunteer cheated!\"\n    if len(u) > 1:\n        return \"Bad magician!\"\n    return list(u)[0]\n \nf = file(INPUT)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    rows1 = []\n    a1 = int(f.readline()[:-1])\n    for r in range(4):\n        rows1.append([int(x) for x in f.readline().split()])\n    a2 = int(f.readline()[:-1])\n    rows2 = []\n    for r in range(4):\n        rows2.append([int(x) for x in f.readline().split()])\n    v = do_trial(a1, rows1, a2, rows2)\n    print(\"Case #%d: %s\" % (i+1, v))\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2014_2974486_5709773144064000.py", "code": "inputFile = open('B-small-attempt0.in', 'r')\nlines = inputFile.readlines()\ninputFile.close()\n \noutputFile = open('B-small-attempt0.out', 'w')\n \nnumTests = int(lines[0])\n \n \ndef solveCookies(c, f, x):\n    accumTime = 0\n    farmRate = 0\n    while True:\n        # two options: Buy, or don't buy\n        timeToWait = x/(2.0+farmRate)\n        timeIfBuyFarm = (c/(2.0+farmRate) +   # Time to get a farm\n                        x/(2.0+farmRate+f))\n        if timeToWait <= timeIfBuyFarm:\n            return accumTime+timeToWait\n        else:\n            accumTime += c/(2.0+farmRate)\n            farmRate += f\n \nfor i in range(1, numTests+1):\n    [c, f, x] = map(lambda x: float(x), lines[i].split())\n \n    outputFile.write('Case #'+str(i)+': ' + str(solveCookies(c, f, x))+'\\n')\noutputFile.close()\n     \n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2014_2974486_5690574640250880.py", "code": "inputFile = open('C-small-attempt8.in', 'r')\nlines = inputFile.readlines()\ninputFile.close()\n \noutputFile = open('C-small-attempt8.out', 'w')\n \nnumTests = int(lines[0])\n \nfor i in range(1, numTests+1):\n    [r, c, m] = map(lambda x: int(x), lines[i].split())\n \n    openCells = r*c - m\n \n    works = False\n    matrix = [['*']*c for j in range(r)]\n    # Try case analysis first, see if my knowledge of minesweeper can cover everything\n    # This is getting painful :(\n    if r >= 3 and c >= 3:\n        order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\n                (2,0), (2,1)]\n        if openCells == 1 or openCells == 4 or openCells == 6:\n            works = True\n            for (x,y) in order[:openCells]:\n                matrix[x][y] = '.'\n            matrix[0][0] = 'c'\n             \n        elif openCells >= 8:\n            works = True\n            filledRows = openCells / c\n            if filledRows >= 2:\n                if filledRows == r:\n                    matrix = [['.']*c for j in range(r)]\n                    matrix[0][0] = 'c'\n                else:\n                    remainder = openCells%c\n                    if not remainder == 1:\n                        for j in range(filledRows):\n                            matrix[j] = ['.']*c\n                        matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\n                    elif filledRows > 2:\n                        for j in range(filledRows-1):\n                            matrix[j] = ['.']*c\n                        matrix[filledRows-1] = ['.']*(c-1) + ['*']\n                        matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\n                    else:\n                        matrix[0] = ['.']*(c-1) + ['*']                        \n                        matrix[1] = ['.']*(c-1) + ['*']\n                        matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\n                    matrix[0][0] = 'c'\n                 \n            else:\n                for (x,y) in order:\n                    matrix[x][y] = '.'\n                remainingOpen = openCells - 8\n                if remainingOpen % 2 == 0:\n                    for j in range(remainingOpen/2):\n                        matrix[0][j+3] = '.'\n                        matrix[1][j+3] = '.'\n                else:\n                    matrix[2][2] = '.'\n                    remainingOpen -= 1\n                    for j in range(remainingOpen/2):\n                        matrix[0][j+3] = '.'\n                        matrix[1][j+3] = '.'\n                matrix[0][0] = 'c'\n \n    elif r == 1:\n        works = True\n        matrix[0] = ['.']*(c-m) + ['*']*m\n        matrix[0][0] = 'c'\n    elif c == 1:\n        works = True\n        for j in range(r-m):\n            matrix[j][0] = '.'\n        matrix[0][0] = 'c'\n \n    #Only cases left are one or both dimensions being two\n    elif r == 2 and c == 2:\n        if m == 3:\n            works = True\n            matrix[0][0] = 'c'\n        elif m == 0:\n            works = True\n            matrix = [['c', '.'], ['.', '.']]\n    elif r == 2:\n        if m % 2 == 0 and r*c-m > 2:\n            works = True\n            matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\n            matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\n            matrix[0][0] = 'c'\n        elif r*c-m == 1:\n            works = True\n            matrix[0][0] = 'c'\n    elif c == 2:\n        if m % 2 == 0 and r*c-m > 2:\n            works = True\n            for j in range((r*c-m)/2):\n                matrix[j] = ['.', '.']\n            matrix[0][0] = 'c'\n        elif r*c-m == 1:\n            works = True\n            matrix[0][0] = 'c'\n     \n \n    outputFile.write('Case #'+str(i)+':\\n')\n    '''if len(matrix) != r:\n        print i, matrix\n    count = 0\n    for j in range(len(matrix)):\n        for k in range(len(matrix[j])):\n            if matrix[j][k] == '*':\n                count += 1\n    if count != m:\n        print i, matrix'''\n    if not works:\n        outputFile.write('Impossible\\n')\n    else:\n        for x in range(len(matrix)):\n            for y in range(len(matrix[0])):\n                outputFile.write(matrix[x][y])\n            outputFile.write('\\n')\noutputFile.close()\n             \n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2012_1460488_1595491.py", "code": "inputFile = open(\"B-small-attempt0 (3).in\", 'r')\noutputFile = open(\"dancingOutSmall.txt\", 'w')\nnumTests = int(inputFile.readline())\n \ndef countDancers(n,s,p,totals):\n    guaranteed = 0\n    needSurprise = 0\n    if p == 1:\n        for total in totals:\n            if total != 0:\n                guaranteed += 1\n        return guaranteed\n    for total in totals:\n        if total >= p*3 - 2:\n            guaranteed += 1\n        elif total >= p*3 - 4:\n            needSurprise += 1\n    if needSurprise > s:\n        return guaranteed + s\n    else:\n        return guaranteed + needSurprise\n \nfor i in range(numTests):\n    line = inputFile.readline().split()\n    n = int(line[0])\n    s = int(line[1])\n    p = int(line[2])\n    totals = []\n    for j in range(n):\n        totals += [int(line[3+j])]\n    outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\\n')\n \noutputFile.close()\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2013_2270488_2453486.py", "code": "filename = \"A-small-attempt0 (3).in\"\noutputname = filename + \"out.txt\"\n \ninFile = open(filename, 'r')\noutFile = open(outputname, 'w')\n \n \n \n \n \ndef evalGame(lines):\n    board = []\n    gameOver = True\n     \n    for line in lines:\n        bline = []\n        for i in range(len(line)):\n            if line[i] == 'X':\n                bline += [1]\n            elif line[i] == 'O':\n                bline += [2]\n            elif line[i] == 'T':\n                bline += [3]\n            elif line[i] == '.':\n                gameOver = False\n                bline += [0]\n        board += [bline]\n \n    # Check down\n    for i in range(1):\n        for j in range(4):\n            startTile = board[i][j]\n            if startTile == 3 or startTile == 0:\n                continue\n            winner = True\n            for k in range(1,4):\n                if board[i+k][j] not in [startTile, 3]:\n                    winner = False\n                    break\n            if winner:\n                return startTile\n \n    # Check right\n    for i in range(4):\n        for j in range(1):\n            startTile = board[i][j]\n            if startTile == 3 or startTile == 0:\n                continue\n            winner = True\n            for k in range(1,4):\n                if board[i][j+k] not in [startTile, 3]:\n                    winner = False\n                    break\n            if winner:\n                return startTile\n \n    # Check up\n    for i in range(3,4):\n        for j in range(4):\n            startTile = board[i][j]\n            if startTile == 3 or startTile == 0:\n                continue\n            winner = True\n            for k in range(1,4):\n                if board[i-k][j] not in [startTile, 3]:\n                    winner = False\n                    break\n            if winner:\n                return startTile\n \n    # Check left\n    for i in range(4):\n        for j in range(3,4):\n            startTile = board[i][j]\n            if startTile == 3 or startTile == 0:\n                continue\n            winner = True\n            for k in range(1,4):\n                if board[i][j-k] not in [startTile, 3]:\n                    winner = False\n                    break\n            if winner:\n                return startTile\n     \n    # Check down right\n    startTile = board[0][0]\n    if startTile != 3 and startTile != 0:\n        winner = True\n        for k in range(1,4):\n            if board[k][k] not in [startTile, 3]:\n                winner = False\n                break\n        if winner:\n            return startTile\n \n    # Check up right\n    startTile = board[3][0]\n    if startTile != 3 and startTile != 0:\n        winner = True\n        for k in range(1,4):\n            if board[3-k][k] not in [startTile, 3]:\n                winner = False\n                break\n        if winner:\n            return startTile\n \n    # Check up left\n    startTile = board[3][3]\n    if startTile != 3 and startTile != 0:\n        winner = True\n        for k in range(1,4):\n            if board[3-k][3-k] not in [startTile, 3]:\n                winner = False\n                break\n        if winner:\n            return startTile\n \n    # Check down left\n    startTile = board[0][3]\n    if startTile != 3 and startTile != 0:\n        winner = True\n        for k in range(1,4):\n            if board[k][3-k] not in [startTile, 3]:\n                winner = False\n                break\n        if winner:\n            return startTile\n \n \n    if gameOver:\n        return 0\n \n    else:\n        return -1\n     \n                       \n \n \n \n \n \ndef resultToString(result):\n    if result == 0:\n        return \"Draw\"\n    elif result == 1:\n        return \"X won\"\n    elif result == 2:\n        return \"O won\"\n    else:\n        return \"Game has not completed\"\n \n \nnumCases = int(inFile.readline())\n \nfor i in range(numCases):\n    lines = []\n    for j in range(4):\n        lines += [inFile.readline().strip()]\n \n    result = evalGame(lines)\n \n    print(\"Case #\" + str(i+1) + \": \" + resultToString(result))\n    outFile.write(\"Case #\" + str(i+1) + \": \" + resultToString(result) + '\\n')\n     \n    if i < numCases -1:\n        inFile.readline()\n \ninFile.close()\noutFile.close()\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2013_2270488_2449486.py", "code": "def isMowable(lawn):\n    for i in range(len(lawn)):\n        for j in range(len(lawn[i])):\n            cellHeight = lawn[i][j]\n            vertPossible = True\n            horizPossible = True\n            for k in range(len(lawn)):\n                if lawn[k][j] > cellHeight:\n                    vertPossible = False\n                    break\n            for k in range(len(lawn[i])):\n                if lawn[i][k] > cellHeight:\n                    horizPossible = False\n                    break\n            if not vertPossible and not horizPossible:\n                return \"NO\"\n    return \"YES\"\n \n \nfilename = \"B-small-attempt0.in\"\noutputname = filename + \"out.txt\"\n \ninFile = open(filename, 'r')\noutFile = open(outputname, 'w')\n \n \nnumTests = int(inFile.readline())\n \n     \n \nfor i in range(numTests):\n    dimensions = inFile.readline().split()\n    n = int(dimensions[0])\n    m = int(dimensions[1])\n    lawn = []\n    for j in range(n):\n        line = inFile.readline().split()\n        for k in range(m):\n            line[k] = int(line[k])\n        lawn += [line]\n \n    answer = isMowable(lawn)\n     \n     \n    outFile.write(\"Case #\" + str(i+1) + \": \" + answer + '\\n')\n    print(\"Case #\" + str(i+1) + \": \" + answer)\n \ninFile.close()\noutFile.close()\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2012_1460488_1483485.py", "code": "translator = {}\ntranslator['a'] = 'y'\ntranslator['b'] = 'h'\ntranslator['c'] = 'e'\ntranslator['d'] = 's'\ntranslator['e'] = 'o'\ntranslator['f'] = 'c'\ntranslator['g'] = 'v'\ntranslator['h'] = 'x'\ntranslator['i'] = 'd'\ntranslator['j'] = 'u'\ntranslator['k'] = 'i'\ntranslator['l'] = 'g'\ntranslator['m'] = 'l'\ntranslator['n'] = 'b'\ntranslator['o'] = 'k'\ntranslator['p'] = 'r'\ntranslator['q'] = 'z'\ntranslator['r'] = 't'\ntranslator['s'] = 'n'\ntranslator['t'] = 'w'\ntranslator['u'] = 'j'\ntranslator['v'] = 'p'\ntranslator['w'] = 'f'\ntranslator['x'] = 'm'\ntranslator['y'] = 'a'\ntranslator['z'] = 'q'\n \ndef translate(string, translator):\n    accum = \"\"\n    for i in range(len(string)):\n        if string[i] == ' ':\n            accum += ' '\n        elif string[i] == '\\n':\n            break\n        else:\n            accum += translator[string[i]]\n    return accum\n \ninputFile = open(\"A-small-attempt0.in\", 'r')\noutputFile = open(\"tonguesOut.txt\", 'w')\nnumTests = int(inputFile.readline())\n \nfor i in range(numTests):\n    outputFile.write('Case #' + str(i+1) + ': ' + translate(inputFile.readline(), translator) + '\\n')\n \ninputFile.close()\noutputFile.close()\n \n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2013_2270488_2463486.py", "code": "def isPalindrome(number):\n    strNum = str(number)\n    for i in range(len(strNum)/2 + 1):\n        if strNum[i] != strNum[-1*(i+1)]:\n            return False\n    return True\n \n'''for i in range(40):\n    if isPalindrome(i) and isPalindrome(i*i):\n        print(i*i)\n'''\n \n \nfilename = \"C-small-attempt0.in\"\noutputname = filename + \"out.txt\"\n \ninFile = open(filename, 'r')\noutFile = open(outputname, 'w')\n \n \nfairAndSquareNums = [1,4,9,121,484]\n \nnumTests = int(inFile.readline())\n \nfor i in range(numTests):\n    line = inFile.readline().split()\n    count = 0\n    for j in range(int(line[0]), int(line[1])+1):\n        if j in fairAndSquareNums:\n            count += 1\n    outFile.write(\"Case #\" + str(i+1) + \": \" + str(count) + '\\n')\n    print(\"Case #\" + str(i+1) + \": \" + str(count))\n \ninFile.close()\noutFile.close()\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2014_2974486_5756407898963968.py", "code": "inputFile = open('A-small-attempt0.in', 'r')\nlines = inputFile.readlines()\ninputFile.close()\n \noutputFile = open('A-small-attempt0.out', 'w')\n \nnumTests = int(lines[0])\n \n \ncurrLine = 1\nfor i in range(1, numTests+1):\n    firstRow = lines[int(lines[currLine])+currLine]\n    currLine += 5\n    secondRow = lines[int(lines[currLine])+currLine]\n    currLine += 5\n \n    firstNums = map(lambda x: int(x), firstRow.split())\n    secondNums = map(lambda x: int(x), secondRow.split())\n     \n    intersect = [v for v in firstNums if v in secondNums]\n \n    outputFile.write('Case #'+str(i)+': ')\\n    if len(intersect) == 1:\\n        outputFile.write(str(intersect[0])+'\\n')\n    elif len(intersect) == 0:\n        outputFile.write('Volunteer cheated!\\n')\n    else:\n        outputFile.write('Bad magician!\\n')\n \noutputFile.close()\n     \n"}
{"author": "amv", "index": 51, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/env python\nimport sys,os\nimport numpy as np\n \nBIG_NUM=100000\ndef Solve(C,F,X):\n    best_time=float('inf')\n    for n in xrange(0,BIG_NUM):\n        if n==0:\n            farm_time=0\n        else:\n            farm_time += C/(2+(n-1)*F)\n        if best_time<=farm_time: break\n        cookie_time=X/(2+n*F)\n \n        if farm_time+cookie_time<best_time:\n            best_time=farm_time+cookie_time\n \n    return '%.9f'%best_time\n \n \n \ndef parse(infile):\n    C,F,X=map(float, infile.readline().split() )\n    return C,F,X\n \n \n \nclass GCJ_Parser( object ):\n    def __init__(self,fname):\n        self.infile=open(fname,'r')\n        self.NumCases=int(self.infile.readline().strip() )\n        self.caseNum=0\n \n    def __iter__(self): return self\n \n    def next(self):\n        if self.caseNum==self.NumCases: raise StopIteration\n        self.caseNum += 1\n        args=parse(self.infile)\n        return self.caseNum , args\n \n \ndef runmain():\n    myCases=GCJ_Parser(sys.argv[1])\n \n    #Open output file, but don't overwrite old ones (for comparison)\n    outname=sys.argv[1].rstrip('.in')+'.out'\n    if os.path.isfile(outname):\n        oldout=outname+'.old'\n        ii=0\n        while os.path.isfile(oldout):\n            ii+=1\n            oldout=outname+'.old'+str(ii)\n        os.rename(outname,oldout)\n        print ('Rename: %s -> %s'%(outname,oldout))\n  \n    outfile=open(outname,'w')\n \n    for iCase, args in myCases:\n        answer=Solve(*args)\n \n        print ('Case #'+str(iCase)+':',answer)\n        print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \nif __name__=='__main__':\n    runmain()\n"}
{"author": "amv", "index": 51, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\nimport sys,os\nimport numpy as np\nimport Queue\n \n#guaranteed that R,C>=3, and F is not 1,2,3,5,7\ndef Fill(outmat,R,C,F):\n    nF=F\n    #first square\n    outmat[:2,:2]='.'\n    nF-=4\n    if nF==0: return\n \n    #next two\n    outmat[2,:2]='.'\n    nF-=2\n    if nF==0: return    \n \n    #nearly there...\n    outmat[:2,2]='.'\n    nF-=2\n    if nF==0: return\n \n    #Fill by 2 across columns\n    for iC in xrange(3,C):\n        if nF==1:\n            outmat[2,2]='.'\n            return\n        outmat[:2,iC]='.'\n        nF-=2\n        if nF==0: return\n         \n    #Fill by 2 across rows\n    for iR in xrange(3,R):\n        if nF==1:\n            outmat[2,2]='.'\n            return\n        outmat[iR,:2]='.'\n        nF-=2\n        if nF==0: return\n \n    #Now fill singly 3rd row/column\n    for iR,iC in ( (iR,iC) for iR in xrange(2,R)\n                    for iC in xrange(2,C)):\n        outmat[iR,iC]='.'\n        nF-=1\n        if nF==0: return\n     \n \n \n \ndef Solve(R,C,M):\n    F=R*C-M\n    if F==0: return '\\nImpossible'\n    if (R>1 and C>1 and F in (2,3)):\n        return '\\nImpossible'\n \n    outmat=np.zeros( (R,C), dtype='S1')\n    outmat[:,:]='*'\n \n    if R==1:\n        for i in xrange(F):\n            outmat[0][i]='.'\n     \n    elif C==1:\n        for i in xrange(F):\n            outmat[i][0]='.'\n \n    elif F>1:\n        if F in (2,3,5,7): return \"\\nImpossible\"\n        elif (R==2 or C==2) and F%2 != 0:\n            return \"\\nImpossible\"\n        elif R==2:\n            outmat[:,:F/2]='.'\n        elif C==2:\n            outmat[:F/2,:]='.'\n        else: Fill(outmat,R,C,F)\n         \n    outmat[0,0]='c'\n    outmatlines=[ ''.join(x) for x in outmat ]\n    #print outmatlines\n    answer='\\n'+'\\n'.join(outmatlines)\n \n    Verify(answer,F)\n \n    return answer\n \ndisp=[ (dx,dy) for dx in (-1,0,1)\n    for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\n \ndef Verify(answer,F):\n    lines=[list(x) for x in answer.split('\\n')]\n    if len(lines[0])==0: lines.pop(0)\n    R,C=len(lines),len(lines[0])\n    assert lines[0][0]=='c'\n    assert answer.count('.')+1==F\n    q=Queue.Queue()\n    q.put( (0,0) )\n \n    def adjToMine(x,y):\n        for dx,dy in disp:\n            if 0<=x+dx<R and 0<=y+dy<C:\n                if lines[x+dx][y+dy]=='*': return True\n        return False\n                 \n \n    while not q.empty():\n        x,y=q.get()\n        for dx,dy in disp:\n            if 0<=x+dx<R and 0<=y+dy<C:\n                if lines[x+dx][y+dy]=='c': continue\n                lines[x+dx][y+dy]='c'\n                if not adjToMine(x+dx,y+dy):\n                    q.put( (x+dx,y+dy) )\n \n    clicked='\\n'.join([ ''.join(x) for x in lines])\n    if clicked.find('.')>=0:\n        print ('\\n','*'*20,\"\\nERROR, input:\")\n        print (answer)\n        print ('OUTPUT:')\n        print (clicked)\n     \n \n \n \ndef parse(infile):\n    R,C,M=map(int, infile.readline().split() )\n    return R,C,M\n \n \n \nclass GCJ_Parser( object ):\n    def __init__(self,fname):\n        self.infile=open(fname,'r')\n        self.NumCases=int(self.infile.readline().strip() )\n        self.caseNum=0\n \n    def __iter__(self): return self\n \n    def next(self):\n        if self.caseNum==self.NumCases: raise StopIteration\n        self.caseNum += 1\n        args=parse(self.infile)\n        return self.caseNum , args\n \n \ndef runmain():\n    myCases=GCJ_Parser(sys.argv[1])\n \n    #Open output file, but don't overwrite old ones (for comparison)\n    outname=sys.argv[1].rstrip('.in')+'.out'\n    if os.path.isfile(outname):\n        oldout=outname+'.old'\n        ii=0\n        while os.path.isfile(oldout):\n            ii+=1\n            oldout=outname+'.old'+str(ii)\n        os.rename(outname,oldout)\n        print ('Rename: %s -> %s'%(outname,oldout))\n  \n    outfile=open(outname,'w')\n \n    for iCase, args in myCases:\n        answer=Solve(*args)\n \n        print ('Case #'+str(iCase)+':',answer)\n        print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \nif __name__=='__main__':\n    runmain()\n"}
{"author": "amv", "index": 51, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/env python\nimport sys\nimport numpy as np\n \ninfile=open(sys.argv[1],'r')\n \nNumCases=int(infile.readline())\n \nfor iCase in xrange(NumCases):\n    line=[ int(i) for i in infile.readline().split() ]\n \n    n=line.pop(0)\n    s=line.pop(0)\n    p=line.pop(0)\n \n    scores=line\n    assert(len(scores))==n\n \n    imax=0\n    isurprise=0\n \n    for score in scores:\n        if score<p: continue\n        if score<3*p-4:\n            pass\n        elif 3*p-2>score>=3*p-4:\n            isurprise+=1\n        else:\n            imax+=1\n \n    print('Case #'+str(iCase+1)+':',imax+min(isurprise,s))\n \n"}
{"author": "amv", "index": 51, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\nimport sys\nimport numpy as np\n \n \ndef Solve(lines):\n    hasEmpty=False\n \n    rows=[ lines[0][i]+lines[1][i]+lines[2][i]+lines[3][i] \n            for i in xrange(4) ]\n \n    diags=[ lines[0][0]+lines[1][1]+lines[2][2]+lines[3][3] ,\n            lines[0][3]+lines[1][2]+lines[2][1]+lines[3][0] ]\n \n \n    for il in lines + rows + diags:\n        if il.replace('T','X')=='XXXX': return \"X won\"\n        elif il.replace('T','O')=='OOOO': return \"O won\"\n        elif il.find('.')>=0: hasEmpty=True\n \n     \n    if hasEmpty: return \"Game has not completed\"\n    else: return \"Draw\"\n \n \n \ndef parse(infile):\n    lines=[]\n    for i in xrange(4):\n        lines.append(infile.readline().strip())\n    infile.readline()\n    return (lines,)\n \n \n \nclass GCJ_Parser( object ):\n    def __init__(self,fname):\n        self.infile=open(fname,'r')\n        self.NumCases=int(self.infile.readline().strip() )\n        self.caseNum=0\n \n    def __iter__(self): return self\n \n    def next(self):\n        if self.caseNum==self.NumCases: raise StopIteration\n        self.caseNum += 1\n        args=parse(self.infile)\n        return self.caseNum , args\n \n \ndef runmain():\n    myCases=GCJ_Parser(sys.argv[1])\n    outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n    for iCase, args in myCases:\n        answer=Solve(*args)\n \n        print ('Case #'+str(iCase)+':',answer)\n        print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n########library functions\nclass Categorizer(dict):\n    def __init__(self,thelist,transform,trunc=2):\n        dict.__init__(self)\n        self.transform=transform\n        self.AddList(thelist)\n        self.trunc=trunc\n    def AddList(self,thelist):\n        for item in thelist: self.Add( item )\n    def Add(self,object):\n        cat=self.transform( object )\n        if type(cat) is float:\n            cat=round(cat,trunc)\n        if self.has_key(cat):\n            self[cat].append( object )\n        else:\n            self[cat]=[object]\n    def PrintRanking(self,n=None):\n        if n is None: n=len(self)\n        items=self.items()\n        items.sort(key=lambda x:-len(x[1]))\n        total=0\n        for i in items: total+=len(i[1])\n        maxkey=max( len(str(key)) for key in self.iterkeys() )\n        maxval=max( len(str(len(val))) for val in self.itervalues() )\n        formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n        for key,count in items[0:n]:\n            print (formatter.format(key,len(count),\n                                    (\"%.2f\"%(len(count)*100.0/total))+'%'))\n    def Combine(self,newdict):\n        newkeys=newdict.keys()\n        for key in newkeys:\n            if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n        for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n    def Avg(self):\n        avg=0.0\n        ntot=0\n        for key in self.keys():\n            ntot+=len(self[key])\n            avg+=len(self[key])*key\n        return avg/(1.0*ntot)\n    def StdDev(self):\n        avg=self.Avg()\n        ntot=0\n        stddev=0.0\n        for key in self.iterkeys():\n            ntot+=len(self[key])\n            stddev += len(self[key]) * ( (key-avg)**2)\n        return stddev/(1.0*ntot)\n    def Median(self):\n        tot=0\n        for value in self.itervalues(): tot+=len(value)\n        keys=self.keys()\n        keys.sort()\n        nCount=0\n        for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n    def Mode(self):\n        return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \nclass Counter(dict):\n    def __init__(self,thelist,transform=None,trunc=2):\n        dict.__init__(self)\n        self.transform=transform\n        self.trunc=trunc\n        self.AddList(thelist)\n    def AddList(self,thelist):\n        if self.transform is not None:\n            for item in thelist: self.Add( self.transform(item) )\n        else:\n            for item in thelist: self.Add( item )            \n    def Add(self,object):\n        if type(object) is float:\n            object=round(object,self.trunc)\n        if self.has_key(object):\n            self[object]+=1\n        else:\n            self[object]=1\n    def PrintRanking(self,n=None):\n        if n is None: n=len(self)\n        items=self.items()\n        items.sort(key=lambda x:-x[1])\n        total=0\n        for i in items: total+=i[1]\n        maxkey=max( len(str(key)) for key in self.iterkeys() )\n        maxval=max( len(str(val)) for val in self.itervalues() )\n        formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n        for key,count in items[0:n]:\n            print (formatter.format(key,count, (\"%.2f\"%(count*100.0/total))+'%'))\n    def Combine(self,newdict):\n        newkeys=newdict.keys()\n        for key in newkeys:\n            if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n        for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n    def Avg(self):\n        avg=0.0\n        ntot=0\n        for key in self.keys():\n            ntot+=self[key]\n            avg+=self[key]*key\n        return avg/(1.0*ntot)\n    def StdDev(self):\n        avg=self.Avg()\n        ntot=0\n        stddev=0.0\n        for key in self.iterkeys():\n            ntot+=self[key]\n            stddev += self[key] * ( (key-avg)**2)\n        return stddev/(1.0*ntot)\n    def Median(self):\n        total=sum(self.values())\n        keys=self.keys()\n        keys.sort()\n        nCount=0\n        for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n    def Mode(self):\n        return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \ndef gen_primes():\n    \"\"\" Generate an infinite sequence of prime numbers.\n    from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n    \"\"\"\n    D = {}  \n    q = 2  \n \n    while True:\n        if q not in D:\n            yield q        \n            D[q * q] = [q]\n        else:\n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n \n        q += 1\n \n \n \nif __name__=='__main__':\n    runmain()\n"}
{"author": "amv", "index": 51, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/env python\nimport sys\nimport numpy as np\n \n \ndef Solve(n,m,heights):\n    #print heights\n    for i,j in ( (i,j) for i in xrange(n) for j in xrange(m) ):\n        if (heights[i,:]<= heights[i,j]).all(): continue\n \n        if (heights[:,j]>heights[i,j]).any(): return \"NO\"\n \n \n    return 'YES'\n \n \n \ndef parse(infile):\n    n,m=map(int, infile.readline().split() )\n    heights=np.zeros( (n,m) )\n    for i in xrange(n):\n        heights[i,:]=np.array( map(int, infile.readline().split() ) )\n    return n,m,heights\n \n \n \nclass GCJ_Parser( object ):\n    def __init__(self,fname):\n        self.infile=open(fname,'r')\n        self.NumCases=int(self.infile.readline().strip() )\n        self.caseNum=0\n \n    def __iter__(self): return self\n \n    def next(self):\n        if self.caseNum==self.NumCases: raise StopIteration\n        self.caseNum += 1\n        args=parse(self.infile)\n        return self.caseNum , args\n \n \ndef runmain():\n    myCases=GCJ_Parser(sys.argv[1])\n    outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n    for iCase, args in myCases:\n        answer=Solve(*args)\n \n        print ('Case #'+str(iCase)+':',answer)\n        print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n########library functions\nclass Categorizer(dict):\n    def __init__(self,thelist,transform,trunc=2):\n        dict.__init__(self)\n        self.transform=transform\n        self.AddList(thelist)\n        self.trunc=trunc\n    def AddList(self,thelist):\n        for item in thelist: self.Add( item )\n    def Add(self,object):\n        cat=self.transform( object )\n        if type(cat) is float:\n            cat=round(cat,trunc)\n        if self.has_key(cat):\n            self[cat].append( object )\n        else:\n            self[cat]=[object]\n    def PrintRanking(self,n=None):\n        if n is None: n=len(self)\n        items=self.items()\n        items.sort(key=lambda x:-len(x[1]))\n        total=0\n        for i in items: total+=len(i[1])\n        maxkey=max( len(str(key)) for key in self.iterkeys() )\n        maxval=max( len(str(len(val))) for val in self.itervalues() )\n        formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n        for key,count in items[0:n]:\n            print (formatter.format(key,len(count),\n                                    (\"%.2f\"%(len(count)*100.0/total))+'%'))\n    def Combine(self,newdict):\n        newkeys=newdict.keys()\n        for key in newkeys:\n            if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n        for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n    def Avg(self):\n        avg=0.0\n        ntot=0\n        for key in self.keys():\n            ntot+=len(self[key])\n            avg+=len(self[key])*key\n        return avg/(1.0*ntot)\n    def StdDev(self):\n        avg=self.Avg()\n        ntot=0\n        stddev=0.0\n        for key in self.iterkeys():\n            ntot+=len(self[key])\n            stddev += len(self[key]) * ( (key-avg)**2)\n        return stddev/(1.0*ntot)\n    def Median(self):\n        tot=0\n        for value in self.itervalues(): tot+=len(value)\n        keys=self.keys()\n        keys.sort()\n        nCount=0\n        for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n    def Mode(self):\n        return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \nclass Counter(dict):\n    def __init__(self,thelist,transform=None,trunc=2):\n        dict.__init__(self)\n        self.transform=transform\n        self.trunc=trunc\n        self.AddList(thelist)\n    def AddList(self,thelist):\n        if self.transform is not None:\n            for item in thelist: self.Add( self.transform(item) )\n        else:\n            for item in thelist: self.Add( item )            \n    def Add(self,object):\n        if type(object) is float:\n            object=round(object,self.trunc)\n        if self.has_key(object):\n            self[object]+=1\n        else:\n            self[object]=1\n    def PrintRanking(self,n=None):\n        if n is None: n=len(self)\n        items=self.items()\n        items.sort(key=lambda x:-x[1])\n        total=0\n        for i in items: total+=i[1]\n        maxkey=max( len(str(key)) for key in self.iterkeys() )\n        maxval=max( len(str(val)) for val in self.itervalues() )\n        formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n        for key,count in items[0:n]:\n            print (ormatter.format(key,count, (\"%.2f\"%(count*100.0/total))+'%'))\n    def Combine(self,newdict):\n        newkeys=newdict.keys()\n        for key in newkeys:\n            if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n        for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n    def Avg(self):\n        avg=0.0\n        ntot=0\n        for key in self.keys():\n            ntot+=self[key]\n            avg+=self[key]*key\n        return avg/(1.0*ntot)\n    def StdDev(self):\n        avg=self.Avg()\n        ntot=0\n        stddev=0.0\n        for key in self.iterkeys():\n            ntot+=self[key]\n            stddev += self[key] * ( (key-avg)**2)\n        return stddev/(1.0*ntot)\n    def Median(self):\n        total=sum(self.values())\n        keys=self.keys()\n        keys.sort()\n        nCount=0\n        for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n    def Mode(self):\n        return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \ndef gen_primes():\n    \"\"\" Generate an infinite sequence of prime numbers.\n    from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n    \"\"\"\n    D = {}  \n    q = 2  \n \n    while True:\n        if q not in D:\n            yield q        \n            D[q * q] = [q]\n        else:\n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n \n        q += 1\n \n \n \nif __name__=='__main__':\n    runmain()\n"}
{"author": "amv", "index": 51, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/env python\nimport sys\nimport numpy as np\n \ninfile=open(sys.argv[1],'r')\n \nNumCases=int(infile.readline())\n \nmyinput=\"\"\"ejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv\"\"\"\n \nmyoutput=\\\n\"\"\"our language is impossible to understand\nthere are twenty six factorial possibilities\nso it is okay if you want to just give up\"\"\"\n \nmapping={}\nmapping['q']='z'\nmapping['z']='q'\n \n \nfor char,mapto in zip(myinput,myoutput):\n    if mapping.has_key(char):\n        assert mapping[char]==mapto\n    else:\n        mapping[char]=mapto\n \n#allchar=set('abcdefghijklmnopqrstuvwxyz')\n#print(allchar-set( mapping.keys() ))\n#print(allchar-set(mapping.values() ))\n \n \n \nfor iCase in xrange(NumCases):\n    thestring=infile.readline().strip()\n \n    newstring=''\n    for char in thestring: newstring+=mapping[char]\n \n \n    print('Case #'+str(iCase+1)+': '+newstring)\\n \\n"}
{"author": "amv", "index": 51, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/env python\nimport sys\nimport numpy as np\n \ndef isPalindrome(n):\n    cn=str(n)\n    return (cn==cn[::-1])\n \n#Precomputed\npalinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]\n \n \n#  def genPalindromes(nPlaces):\n#     assert nPlaces>0\n \n#     if nPlaces==1:\n#         for i in (1,2,3): yield i\n#     elif nPlaces%2==0:\n#         for i in xrange(nPlaces/2):\n \n             \n         \n         \n \n \n \ndef Solve(a,b):\n    num=0\n    for p in palinSqrt:\n        if a<= p**2 <=b: num+=1\n    return num\n \n \n \ndef parse(infile):\n    a,b=map(int, infile.readline().split() )\n    return a,b\n \n \n \nclass GCJ_Parser( object ):\n    def __init__(self,fname):\n        self.infile=open(fname,'r')\n        self.NumCases=int(self.infile.readline().strip() )\n        self.caseNum=0\n \n    def __iter__(self): return self\n \n    def next(self):\n        if self.caseNum==self.NumCases: raise StopIteration\n        self.caseNum += 1\n        args=parse(self.infile)\n        return self.caseNum , args\n \n \ndef runmain():\n    myCases=GCJ_Parser(sys.argv[1])\n    outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n    for iCase, args in myCases:\n        answer=Solve(*args)\n \n        print ('Case #'+str(iCase)+':',answer)\n        print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n########library functions\nclass Categorizer(dict):\n    def __init__(self,thelist,transform,trunc=2):\n        dict.__init__(self)\n        self.transform=transform\n        self.AddList(thelist)\n        self.trunc=trunc\n    def AddList(self,thelist):\n        for item in thelist: self.Add( item )\n    def Add(self,object):\n        cat=self.transform( object )\n        if type(cat) is float:\n            cat=round(cat,trunc)\n        if self.has_key(cat):\n            self[cat].append( object )\n        else:\n            self[cat]=[object]\n    def PrintRanking(self,n=None):\n        if n is None: n=len(self)\n        items=self.items()\n        items.sort(key=lambda x:-len(x[1]))\n        total=0\n        for i in items: total+=len(i[1])\n        maxkey=max( len(str(key)) for key in self.iterkeys() )\n        maxval=max( len(str(len(val))) for val in self.itervalues() )\n        formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n        for key,count in items[0:n]:\n            print (formatter.format(key,len(count),\n                                    (\"%.2f\"%(len(count)*100.0/total))+'%'))\n    def Combine(self,newdict):\n        newkeys=newdict.keys()\n        for key in newkeys:\n            if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n        for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n    def Avg(self):\n        avg=0.0\n        ntot=0\n        for key in self.keys():\n            ntot+=len(self[key])\n            avg+=len(self[key])*key\n        return avg/(1.0*ntot)\n    def StdDev(self):\n        avg=self.Avg()\n        ntot=0\n        stddev=0.0\n        for key in self.iterkeys():\n            ntot+=len(self[key])\n            stddev += len(self[key]) * ( (key-avg)**2)\n        return stddev/(1.0*ntot)\n    def Median(self):\n        tot=0\n        for value in self.itervalues(): tot+=len(value)\n        keys=self.keys()\n        keys.sort()\n        nCount=0\n        for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n    def Mode(self):\n        return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \nclass Counter(dict):\n    def __init__(self,thelist,transform=None,trunc=2):\n        dict.__init__(self)\n        self.transform=transform\n        self.trunc=trunc\n        self.AddList(thelist)\n    def AddList(self,thelist):\n        if self.transform is not None:\n            for item in thelist: self.Add( self.transform(item) )\n        else:\n            for item in thelist: self.Add( item )            \n    def Add(self,object):\n        if type(object) is float:\n            object=round(object,self.trunc)\n        if self.has_key(object):\n            self[object]+=1\n        else:\n            self[object]=1\n    def PrintRanking(self,n=None):\n        if n is None: n=len(self)\n        items=self.items()\n        items.sort(key=lambda x:-x[1])\n        total=0\n        for i in items: total+=i[1]\n        maxkey=max( len(str(key)) for key in self.iterkeys() )\n        maxval=max( len(str(val)) for val in self.itervalues() )\n        formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n        for key,count in items[0:n]:\n            print (formatter.format(key,count, (\"%.2f\"%(count*100.0/total))+'%'))\n    def Combine(self,newdict):\n        newkeys=newdict.keys()\n        for key in newkeys:\n            if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n        for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n    def Avg(self):\n        avg=0.0\n        ntot=0\n        for key in self.keys():\n            ntot+=self[key]\n            avg+=self[key]*key\n        return avg/(1.0*ntot)\n    def StdDev(self):\n        avg=self.Avg()\n        ntot=0\n        stddev=0.0\n        for key in self.iterkeys():\n            ntot+=self[key]\n            stddev += self[key] * ( (key-avg)**2)\n        return stddev/(1.0*ntot)\n    def Median(self):\n        total=sum(self.values())\n        keys=self.keys()\n        keys.sort()\n        nCount=0\n        for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n    def Mode(self):\n        return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \ndef gen_primes():\n    \"\"\" Generate an infinite sequence of prime numbers.\n    from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n    \"\"\"\n    D = {}  \n    q = 2  \n \n    while True:\n        if q not in D:\n            yield q        \n            D[q * q] = [q]\n        else:\n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n \n        q += 1\n \n \n \nif __name__=='__main__':\n    runmain()\n"}
{"author": "amv", "index": 51, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\nimport sys,os\nimport numpy as np\n \n \ndef Solve(F1,r1,F2,r2):\n    s1=set(F1[r1-1])\n    s2=set(F2[r2-1])\n    sx=s1.intersection(s2)\n    if len(sx)>1:\n        return \"Bad magician!\"\n    elif len(sx)==0:\n        return \"Volunteer cheated!\"\n    else:\n        return sx.__iter__().next()\n \n \n \ndef parse(infile):\n    r1=int(infile.readline().strip())\n    F1=[]\n    for i in xrange(4):\n        F1.append( map(int, infile.readline().split() ))\n    r2=int(infile.readline().strip())\n    F2=[]\n    for i in xrange(4):\n        F2.append( map(int, infile.readline().split() ))\n    return F1,r1,F2,r2\n \n \n \nclass GCJ_Parser( object ):\n    def __init__(self,fname):\n        self.infile=open(fname,'r')\n        self.NumCases=int(self.infile.readline().strip() )\n        self.caseNum=0\n \n    def __iter__(self): return self\n \n    def next(self):\n        if self.caseNum==self.NumCases: raise StopIteration\n        self.caseNum += 1\n        args=parse(self.infile)\n        return self.caseNum , args\n \n \ndef runmain():\n    myCases=GCJ_Parser(sys.argv[1])\n \n    #Open output file, but don't overwrite old ones (for comparison)\n    outname=sys.argv[1].rstrip('.in')+'.out'\n    if os.path.isfile(outname):\n        oldout=outname+'.old'\n        ii=0\n        while os.path.isfile(oldout):\n            ii+=1\n            oldout=outname+'.old'+str(ii)\n        os.rename(outname,oldout)\n        print ('Rename: %s -> %s'%(outname,oldout))\n  \n    outfile=open(outname,'w')\n \n    for iCase, args in myCases:\n        answer=Solve(*args)\n \n        print ('Case #'+str(iCase)+':',answer)\n        print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \nif __name__=='__main__':\n    runmain()\n"}
{"author": "yordan", "index": 52, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\n \n \ndef read_case(f):\n\treturn map(float, f.readline().split())\n \n \ndef solve(C, F, X, rate=2.0):\n\taccum = 0\n\twhile 1:\n\t\tgoal1 = X / rate\n \t\n\t\tfarm = C / rate\n\t\tgoal2 = farm + (X / (rate + F))\n \n\t\tif goal1 <= goal2:\n\t\t\treturn accum + goal1\n\t\telse:\n\t\t\taccum += farm\n\t\t\trate += F\n \n \t\t\t\ndef trunc(x, p=7):\n\tm = 10 ** p\n\treturn round(x * m) / m\n \n \ndef main():\n\tfn = sys.argv[1]\n\twith open(fn, encoding='utf-8') as f:\n\t\tncases = int(f.readline())\n\t\tfor case in range(1, ncases + 1):\n\t\t\tC, F, X = read_case(f)\n\t\t\tsolution = solve(C, F, X)\n\t\t\tprint('Case #{}: {}'.format(case, trunc(solution)))\n \n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "yordan", "index": 52, "filename": "2014_2974486_5690574640250880.py", "code": "import copy\nimport sys\n \n \nFREE = '.'\nBOMB = '*'\nCLICK = 'c'\n \n \nclass Board:\n \n\tdef __init__(self, R, C, M):\n\t\tself.initial_M = M\n\t\tself.R = R\n\t\tself.C = C\n\t\tself.M = M\n\t\tself.matrix = [[FREE for c in range(C)] for r in range(R)]\n\t\t# A rectangle that says what's the current subarea we work on\n\t\tself.endx = len(self.matrix[0])\n\t\tself.endy = len(self.matrix)  # 0 < R * C\n\t\tself.startx = 0\n\t\tself.starty = 0\n \n\tdef fill_row(self, row):\n\t\tfor c in self.range_active_cols:\n\t\t\tself.matrix[row][c] = BOMB\n\t\tself.starty += 1\n\t\tself.M -= self.active_cols\n \n\tdef fill_col(self, col):\n\t\tfor r in self.range_active_rows:\n\t\t\tself.matrix[r][col] = BOMB\n\t\tself.startx += 1\n\t\tself.M -= self.active_rows\n \n\tdef pprint(self):\n\t\t# print('startx={}, endx={}, starty={}, endy={}, M={}'\n\t\t# \t\t.format(self.startx, self.endx, self.starty, self.endy, self.M))\n\t\tfor row in self.matrix:\n\t\t\tfor cell in row:\n\t\t\t\tprint(cell, end='')\n\t\t\tprint()\n \n\t@property\n\tdef active_rows(self):\n\t\treturn self.endy - self.starty\n \n\t@property\n\tdef active_cols(self):\n\t\treturn self.endx - self.startx\n \n\tdef optimize(self):\n\t\twhile 1:\n\t\t\tif (self.active_cols <= self.active_rows\n\t\t\t\t\tand self.active_cols <= self.M):\n\t\t\t\tself.fill_row(self.starty)\n\t\t\telif (self.active_rows < self.active_cols\n\t\t\t\t\tand self.active_rows <= self.M):\n\t\t\t\tself.fill_col(self.startx)\n\t\t\telse:\n\t\t\t\tbreak\n \n\t@property\n\tdef range_active_cols(self):\n\t\treturn range(self.startx, self.endx)\n \n\t@property\n\tdef range_active_rows(self):\n\t\treturn range(self.starty, self.endy)\n \n\tdef is_free(self, row, col):\n\t\treturn self.matrix[row][col] == FREE\n \n\tdef place_bomb(self):\n\t\tfor row in self.range_active_rows:\n\t\t\tfor col in self.range_active_cols:\n\t\t\t\tif (self.is_free(row, col) \n\t\t\t\t\t\tand row + 2 < self.R\n\t\t\t\t\t\tand col + 2 < self.C):\n\t\t\t\t\tself.matrix[row][col] = BOMB\n\t\t\t\t\tself.M -= 1 \n\t\t\t\t\treturn True\n\t\tfor col in self.range_active_cols:\n\t\t\tfor row in self.range_active_rows:\n\t\t\t\tif (self.is_free(row, col)\n\t\t\t\t\t\tand row + 2 < self.R\n\t\t\t\t\t\tand col + 2 < self.C):\n\t\t\t\t\tself.matrix[row][col] = BOMB\n\t\t\t\t\tself.M -= 1\n\t\t\t\t\treturn True\n\t\treturn False\n \n\tdef mark_click(self):\n\t\tself.matrix[-1][-1] = 'c'\n \n\tdef win_condition(self):\n\t\tclick_row = len(self.matrix) - 1\n\t\tclick_col = len(self.matrix[0]) - 1\n\t\t# Check the cell left of the click\n\t\tif (click_col - 1 >= 0\n\t\t\t\tand not self.is_free(click_row, click_col - 1)):\n\t\t\treturn False\n \n\t\tif (click_row - 1 >= 0\n\t\t\t\tand not self.is_free(click_row - 1, click_col)):\n\t\t\treturn False\n \n\t\tif (click_row -1 >= 0\n\t\t\t\tand click_col -1 >= 0\n\t\t\t\tand not self.is_free(click_row - 1, click_col - 1)):\n\t\t\treturn False\n \t\t\n\t\treturn True\n \n\tdef win_cond2(self):\n\t\tif self.initial_M + 1 == self.C * self.R:\n\t\t\treturn True\n\t\treturn False\n \n\tdef solve(self):\n\t\tself.optimize()\n\t\twhile self.M > 0 and self.place_bomb():\n\t\t\tpass\n\t\tif self.M == 0 and (self.win_condition() or self.win_cond2()):\n\t\t\tself.mark_click()\n\t\t\tself.pprint()\n\t\telse:\n\t\t\tprint('Impossible')\n \n \ndef read_case(f):\n\treturn map(int, f.readline().split())\n \n \ndef main():\n\tfn = sys.argv[1]\n\twith open(fn, encoding='utf-8') as f:\n\t\tncases = int(f.readline())\n\t\tfor case in range(1, ncases + 1):\n\t\t\tR, C, M = read_case(f)\n\t\t\tprint('Case #{}:'.format(case))\n\t\t\tb = Board(R, C, M)\n\t\t\tb.solve()\n \n \ndef main1():\n\tb = Board(2, 1, 1)\n\timport pdb; pdb.set_trace()\n\tb.solve()\n \n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "yordan", "index": 52, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/env python\n \n \ndef best(total):\n    \"\"\"Return the best possible score for the given `total`.  Assume\n    the total is computed by summing exactly three scores (each in the\n    interval of 0 to 10 inclusive) and no score can be 2 points apart\n    from another.\n     \n    Arguments:\n    - `total`:\n    \"\"\"\n    m = total % 3\n    if m == 2:\n        b = total // 3 + 2\n    else:\n        b = total // 3 + 1\n    if b > 10:\n        b = 10\n    return b\n \ndef best_non_surprising(total):\n    \"\"\"Return the best possible score for the given `total`, but\n    assume that there should be no more than 1 point difference\n    between the scores.\n \n    Arguments:\n    - `total`:\n    \"\"\"\n    if total % 3 == 0:\n        return total // 3\n    else:\n        return total // 3 + 1\n \ndef max_num_gte_p(totals, S, p):\n    \"\"\"Return the maximum number of Googlers that could have had a\n    best result of at least p.\n     \n    Arguments:\n    - `totals`:\n    - `S`: number of surprising triplets of scores\n    - `p`:\n    \"\"\"\n    res = 0\n    for total in totals:\n        if total == 0:\n            if p == 0:\n                res += 1\n            continue\n \n        if best_non_surprising(total) >= p:\n            # print(total, 'non_surp --> ', best_non_surprising(total))\n            res += 1\n        elif S > 0 and best(total) >= p:\n            # print(total, 'surp --> ', best(total))\n            res += 1\n            S -= 1\n \n    return res\n \ndef main():\n    import sys\n    with open(sys.argv[1], 'r') as f:\n        f.readline()            # skip T\n \n        n = 0\n        for line in f:\n            n += 1\n \n            line = [int(s) for s in line.split()]\n            N = line[0]\n            S = line[1]\n            p = line[2]\n            totals = line[3:]\n \n            # print('S=%d, p=%d, Totals: ' % (S, p), totals)\n            print('Case #%d: %d' % (n, max_num_gte_p(totals, S, p)))\n            # print(if __name__ == '__main__':)\n    main()\n"}
{"author": "yordan", "index": 52, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\n \nimport itertools\nimport sys\n \n \ndef next_board(stream=None):\n    \"\"\"\"\"\"\n    if stream is None:\n        stream = sys.stdin\n    board = []\n    for line in filter(lambda line: len(line) and line[0] in '.OTX', stream):\n        board.append([c for c in line.rstrip()])\n        if len(board) == 4:\n            break\n    return board if len(board) else None\n \n \ndef scan_not_completed(board):\n    if any(board[i][j] == '.'\n            for j in range(len(board))\n            for i in range(len(board))):\n        return '.'\n \n \ndef check_set(s):\n    s.discard('T')\n    return s.pop() if len(s) == 1 and '.' not in s else None\n \n \nscan_diagonal1 = lambda board: check_set({board[i][i]\n        for i in range(len(board))})\n \nscan_diagonal2 = lambda board: check_set({board[i][len(board)-1-i]\n        for i in range(len(board))})\n \nscan_col = lambda board, col: check_set({board[i][col]\n    for i in range(len(board))})\n \nscan_row = lambda board, row: check_set(set(board[row]))\n \n \ndef determine_state(board):\n    \"\"\"\"\"\"\n    for i in range(4):\n        for s in (scan_col, scan_row):\n            ret = s(board, i)\n            if ret:\n                return ret\n    for s in (scan_diagonal1, scan_diagonal2, scan_not_completed):\n        ret = s(board)\n        if ret:\n            return ret\n    return 'draw'\n \n \ndef main():\n    \"\"\"\"\"\"\n    with open('A-small-attempt0.in', encoding='utf-8') as f:\n        for i in itertools.count(1):\n            board = next_board(f)\n            if board is None:\n                break\n            state = determine_state(board)\n            if state == 'X':\n                line = 'X won'\n            elif state == 'O':\n                line = 'O won'\n            elif state == 'draw':\n                line = 'Draw'\n            elif state == '.':\n                line = 'Game has not completed'\n            print('Case #{}: {}'.format(i, line))\n \n \nmain()\n"}
{"author": "yordan", "index": 52, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/env python\n \nfrom itertools import count\nimport sys\n \n \ndef next_lawn(stream):\n    init = stream.readline()\n    if not init:\n        return None\n \n    N, _ = map(int, init.split())\n    lawn = []\n    for i in range(N):\n        line = stream.readline()\n        lawn.append([int(x) for x in line.split()])\n    return lawn\n \n \ndef test_hor(lawn, i, j):\n    me = lawn[i][j]\n    return all(lawn[i][col] <= me for col in range(len(lawn[i])))\n \n \ndef test_ver(lawn, i, j):\n    me = lawn[i][j]\n    return all(lawn[row][j] <= me for row in range(len(lawn)))\n \n \ndef test_square(lawn, i, j):\n    return test_hor(lawn, i, j) or test_ver(lawn, i, j)\n \n \ndef is_possible(lawn):\n    return all(test_square(lawn, i, j) for i in range(len(lawn))\n                for j in range(len(lawn[i])))\n \n \ndef main():\n    with open('B-small-attempt0.in', encoding='utf-8') as f:\n        f.readline()            # Skip the first line\n \n        for i in count(1):\n            lawn = next_lawn(f)\n            if lawn is None:\n                break\n            ans = is_possible(lawn)\n            print('Case #{}: {}'.format(i, 'YES' if ans else 'NO'))\n         \n \nmain()\n"}
{"author": "yordan", "index": 52, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/env python\n \n \n_inp = (\n    'ejp mysljylc kd kxveddknmc re jsicpdrysi',\n    'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',\n    'de kr kd eoya kw aej tysr re ujdr lkgc jv',\n)\n \n_out = (\n    'our language is impossible to understand',\n    'there are twenty six factorial possibilities',\n    'so it is okay if you want to just give up',\n)\n \ndef compute_lang_map(inp, out):\n    lang_map = {}\n    for gs, ss in zip(inp, out):\n        for gl, sl in zip(gs, ss):\n            lang_map[gl] = sl\n    lang_map['q'] = 'z'\n    lang_map['z'] = 'q'\n    return lang_map\n \n_lang_map = compute_lang_map(_inp, _out)\ndef conv(s):\n    out = ''\n    for l in s:\n        out += _lang_map[l]\n    return out\n \ndef main():\n    with open('input-file', 'r') as f:\n        f.readline()            # skip T\n        n = 0\n        for line in f:\n            n += 1\n            print('Case #%d: %s' % (n, conv(line.strip())))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "yordan", "index": 52, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/env python3\n \nfrom itertools import count\nfrom math import sqrt\n \n \ndef next_range(stream):\n    line = stream.readline()\n    if not line:\n        return None\n    return [int(x) for x in line.split()]\n \n \ndef is_palindrome(n):\n    n = str(n)\n    return all(n[i] == n[len(n)-1-i] for i in range(len(n) // 2))\n \ndef mysqrt(n):\n    \"\"\"Return -1 if not an integer\"\"\"\n    rt = int(sqrt(n))\n    return rt if rt * rt == n else -1\n \n \ndef is_fas(n):\n    rt = mysqrt(n)\n    return rt != -1 and is_palindrome(n) and is_palindrome(rt)\n \n \ndef main():\n    with open('C-small-attempt0.in', encoding='utf-8') as f:\n        f.readline()\n \n        for case in count(1):\n            r = next_range(f)\n            if r is None:\n                break\n \n            cnt = 0\n            for n in range(r[0], r[1] + 1):\n                if is_fas(n):\n                    cnt += 1\n \n            print('Case #{}: {}'.format(case, cnt))\n \n \nmain()\n"}
{"author": "yordan", "index": 52, "filename": "2014_2974486_5756407898963968.py", "code": "# -*- coding: utf-8 -*-\n \nimport sys\n \n \ndef read_grid(f):\n\treturn [\n\t\t[int(x) for x in line.split()]\n\t\tfor line in [f.readline() for _ in range(4)]\n\t]\n \ndef read_case(f):\n\tanswer1 = int(f.readline())\n\tgrid1 = read_grid(f)\n\tanswer2 = int(f.readline())\n\tgrid2 = read_grid(f)\n\treturn (grid1[answer1 - 1], grid2[answer2 - 1])\n \n \ndef solve(r1, r2):\n\tres = set(r1) & set(r2)\n\tif len(res) == 0:\n\t\treturn 'Volunteer cheated!'\n\tif len(res) == 1:\n\t\treturn list(res)[0]\n\treturn 'Bad magician!'\n \n \n \ndef main():\n\tfn = sys.argv[1]\n\twith open(fn, encoding='utf-8') as f:\n\t\tncases = int(f.readline())\n\t\tfor case in range(1, ncases + 1):\n\t\t\trow1, row2 = read_case(f)\n\t\t\tsolution = solve(row1, row2)\n\t\t\tprint('Case #{}: {}'.format(case, solution))\n \n \nif __name__ == '__main__':\n\tmain()"}
{"author": "rmmh", "index": 53, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\nif len(sys.argv) == 1:\n    sys.stdin = open(\"B.in\")\nelse:\n    sys.stdin = open(sys.argv[1])\n \ndef to_floats(s):\n    return map(float, s.split())\n \ndef get_floats():\n    return to_floats(raw_input())\n \nn_cases = input()\n \nfor case in xrange(1, n_cases + 1):\n    farm_cost, farm_increase, goal = get_floats()\n \n    best_time = float('inf')\n    time = 0.0\n    rate = 2.0\n    while time < best_time:\n        best_time = min(best_time, time + goal / rate)\n        time += farm_cost / rate\n        rate += farm_increase\n \n    print(\"Case #%d: %.7f\" % (case, best_time))\n"}
{"author": "rmmh", "index": 53, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\nif len(sys.argv) == 1:\n    sys.stdin = open(\"C.in\")\nelse:\n    sys.stdin = open(sys.argv[1])\n \ndef to_ints(s):\n    return map(int, s.split())\n \ndef get_ints():\n    return to_ints(raw_input())\n \nsys.setrecursionlimit(4000)\n \ndef fill(rows, cols, mines):\n    seen = set()\n    visited = set()\n \n    # we are trying to carve through a mountain \n    # and leave 'mine' squares unseen\n    def search(numbered, zeros, min_numbered):\n        left = (rows * cols - mines) - len(numbered)\n        #print left, numbered,  min_numbered, zeros\n        if left == 0:\n            raise StopIteration((numbered, zeros))\n        if left < 0:\n            return\n        for n in xrange(min_numbered, len(numbered)):\n            number = numbered[n]\n            if number in zeros:\n                continue\n            row, col = number\n            neigh = []\n            if row > 0:\n                if col > 0: neigh.append((row - 1, col - 1))\n                neigh.append((row - 1, col))\n                if col < cols - 1: neigh.append((row - 1, col + 1))\n            if col > 0: neigh.append((row, col - 1))\n            if col < cols - 1: neigh.append((row, col + 1))\n            if row < rows - 1:\n                if col > 0: neigh.append((row + 1, col - 1))\n                neigh.append((row + 1, col))\n                if col < cols - 1: neigh.append((row + 1, col + 1))\n            # BUG: we might try to walk to a diagonal, oh well\n            neigh = list(set(neigh) - set(numbered))\n            zeros.add(number)\n            search(numbered + neigh, zeros, n + 1)\n            zeros.remove(number)\n \n    try:\n        for row in xrange(rows):\n            for col in xrange(cols):\n                search([(row, col)], set(), 0)\n    except (StopIteration, e):\n        numbered, zeros = e.message\n        board = {}\n        for row, col in numbered + list(zeros):\n            board[row, col] = '.'\n        if zeros:\n            board[zeros.pop()] = 'c'\n        else: # case where first click is on a number\n            board[0, 0] = 'c'\n        out = ''\n        for row in xrange(rows):\n            for col in xrange(cols):\n                out += board.get((row, col), '*')\n            out += '\\n'\n        return out.strip()\n    return 'Impossible'\n \nn_cases = input()\nfor case in xrange(1, n_cases + 1):\n    rows, cols, mines = get_ints()\n \n    result = fill(rows, cols, mines)\n \n    print (\"Case #%d:\" % case)\n    print (result)\n"}
{"author": "rmmh", "index": 53, "filename": "2012_1460488_1595491.py", "code": "n_cases = input()\n \nfor case in xrange(1, n_cases + 1):\n    ins = map(int, raw_input().strip().split())\n    n = ins[0]\n    s = ins[1]\n    p = ins[2]\n    t = ins[3:]\n \n    out = 0\n    for x in t:\n        if (x + 2) / 3 >= p:\n            out += 1\n        elif s and x > p and p - ((x - p) / 2) <= 2:\n            out += 1\n            s -= 1\n             \n    print(\"Case #%d: %s\" % (case, out))\n"}
{"author": "rmmh", "index": 53, "filename": "2013_2270488_2453486.py", "code": "import sys\n#sys.stdin = open(\"a_example.in\")\n \nn_cases = input()\n \ndef xwin(s):\n    return all(c in 'XT' for c in s)\n \ndef owin(s):\n    return all(c in 'OT' for c in s)\n \nfor case in xrange(1, n_cases + 1):\n    board = [raw_input().strip() for _ in xrange(4)]\n    raw_input()\n \n    board_t = zip(*board)\n \n    #print(board, board_t)\n \n    x_win = False\n    o_win = False\n    full = not any('.' in line for line in board)\n \n    diag_nw = [board[x][x] for x in range(4)]\n    diag_ne = [board[x][3-x] for x in range(4)]\n \n    #print(diag_nw, diag_ne)\n \n    if xwin(diag_nw) or xwin(diag_ne):\n        x_win = True\n    if owin(diag_nw) or owin(diag_ne):\n        o_win = True\n \n    for line, line_t in zip(board, board_t):\n        if xwin(line) or xwin(line_t):\n            x_win = True\n        if owin(line) or owin(line_t):\n            o_win = True\n \n    out = 'Game has not completed'\n    if x_win:\n        out = 'X won'\n    elif o_win:\n        out = 'O won'\n    elif full:\n        out = 'Draw'\n \n    print(\"Case #%d: %s\" % (case, out))\n"}
{"author": "rmmh", "index": 53, "filename": "2013_2270488_2449486.py", "code": "import sys\n#sys.stdin = open(\"b_example.in\")\n \nn_cases = input()\n \ndef to_ints(s):\n    return map(int, s.split())\n \nfor case in xrange(1, n_cases + 1):\n    ydim, xdim = to_ints(raw_input())\n    heights = [to_ints(raw_input()) for _ in xrange(ydim)]\n \n    ymaxes = [max(row) for row in heights]\n    xmaxes = [max(col) for col in zip(*heights)]\n \n    #print(ymaxes, xmaxes)\n \n    poss = True\n \n    for y in range(ydim):\n        for x in range(xdim):\n            height = heights[y][x]\n            if not (height == xmaxes[x] or height == ymaxes[y]):\n                poss = False\n \n \n    print(\"Case #%d: %s\" % (case, 'YES' if poss else 'NO'))\n"}
{"author": "rmmh", "index": 53, "filename": "2012_1460488_1483485.py", "code": "mapping = {'y':'a', 'e':'o', 'q':'z', 'z':'q'}\n \nfor src, dst in [(\"ejp mysljylc kd kxveddknmc re jsicpdrysi\", \"our language is impossible to understand\"),\n    (\"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\",\"there are twenty six factorial possibilities\"),\n    (\"de kr kd eoya kw aej tysr re ujdr lkgc jv\",\"so it is okay if you want to just give up\")]:\n    for a, b in zip(src,dst):\n        mapping[a] = b\n \nn_cases = input()\n \n \nfor case in xrange(1, n_cases + 1):\n    string = raw_input()\n \n    out = ''.join(mapping.get(c, c) for c in string)\n             \n    print(\"Case #%d: %s\" % (case, out))\n"}
{"author": "rmmh", "index": 53, "filename": "2013_2270488_2463486.py", "code": "import sys\n#sys.stdin = open(\"c_example.in\")\n \nn_cases = input()\n \ndef to_ints(s):\n    return map(int, s.split())\n \ndef is_palindrome(n):\n    s = str(n)\n    return s == s[::-1]\n \nfor case in xrange(1, n_cases + 1):\n    a, b = to_ints(raw_input())\n \n    nums = range(int(b ** .5) + 2)\n    palins = filter(is_palindrome, nums)\n    squares = [x**2 for x in palins]\n    palin_squares = filter(is_palindrome, squares)\n    range_squares = [x for x in palin_squares if a <= x <= b]\n \n    print(\"Case #%d: %s\" % (case, len(range_squares)))\n"}
{"author": "rmmh", "index": 53, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\nif len(sys.argv) == 1:\n    sys.stdin = open(\"A.in\")\nelse:\n    sys.stdin = open(sys.argv[1])\n \ndef to_ints(s):\n    return map(int, s.split())\n \ndef get_ints():\n    return to_ints(raw_input())\n \nn_cases = input()\n \nfor case in xrange(1, n_cases + 1):\n    a_row, = get_ints()\n    a_layout = [get_ints() for _ in range(4)]\n    b_row, = get_ints()\n    b_layout = [get_ints() for _ in range(4)]\n \n    poss = set(a_layout[a_row - 1])\n    poss.intersection_update(b_layout[b_row - 1])\n \n    result = 'Bad magician!'\n \n    if len(poss) == 0:\n        result = 'Volunteer cheated!'\n    elif len(poss) == 1:\n        result = poss.pop()\n \n    print(\"Case #%d: %s\" % (case, result))\n"}
{"author": "rajabaz", "index": 54, "filename": "2014_2974486_5709773144064000.py", "code": "def time_to_get(target, num_factories, factory_cost, factory_increase):\n    rate = 2.0\n    t = 0\n    for i in range(num_factories):\n        t += factory_cost/rate\n        rate += factory_increase\n    return t + target/rate\n     \ndef solve(C,F,X):\n    min_sol = None\n    num_fact = 0\n    while True:\n        t = time_to_get(X, num_fact, C, F)\n        if min_sol is None or t < min_sol:\n            min_sol = t\n            num_fact += 1\n        else:\n            return min_sol\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1, T+1):\n        C,F,X = map(float, raw_input().split())\n        print(\"Case #%d: %.07f\" % (i, solve(C,F,X)))\n"}
{"author": "rajabaz", "index": 54, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\n \ndef all_grids(R,C,M, lp=0,placed=0):\n    rem = R*C-lp\n    if M-placed >= rem:\n        if M-placed > rem:\n            return None\n         \n        res = set()\n        for i in range(lp, R*C):\n            res.add(i)\n        return [res]\n         \n    if placed == M:\n        return [set()]\n \n    res = []\n    for i in range(lp, R*C):\n        sub_sol = all_grids(R,C,M,i+1, placed+1)\n        if sub_sol is None:\n            continue\n             \n        for s in sub_sol:\n            s.add(i)\n            res.append(s)\n    return res\n \ndef adj(R,C,i):\n     \n    res = []\n    left_edge = i % C == 0\n    top_edge = i // C == 0\n    right_edge = (i+1) % C == 0\n    bottom_edge = i // C == R-1\n     \n    if not left_edge:\n        res.append(i-1)\n        if not top_edge:\n            res.append(i-1-C)\n        if not bottom_edge:\n            res.append(i+C-1)\n             \n    if not right_edge:\n        res.append(i+1)\n        if not top_edge:\n            res.append(i+1-C)\n        if not bottom_edge:\n            res.append(i+1+C)\n             \n    if not bottom_edge:\n        res.append(i+C)\n    if not top_edge:\n        res.append(i-C)\n    return res\n         \n     \n     \n     \ndef solution(R,C,g):\n    M = R*C\n    res = []\n    num_zeroes = 0\n    for i in range(M):\n        if i in g:\n            res.append('x')\n            continue\n        x = 0\n        for a in adj(R,C,i):\n            if a in g:\n                x += 1\n        if x == 0:\n            num_zeroes += 1\n        res.append(x)\n         \n    for i in range(M):\n        if i in g:\n            continue\n        r = res[i]\n        if r == 0 and num_zeroes == 1:\n            continue\n        connected = False\n        for a in adj(R,C,i):\n            if res[a] == 0:\n                connected = True\n                break\n        if not connected:\n            return None\n     \n    return res.index(0)\n \ndef transcribe(R,C, g, sol):\n    res = []\n    for i in range(R):\n        r = []\n        for j in range(C):\n            x = i*C+j\n            if x in g:\n                r.append('*')\n            elif x == sol:\n                r.append('c')\n            else:\n                r.append('.')\n        res.append(r)\n    return res\n \ndef printed_sol(transcript):\n    if transcript is None:\n        return \"Impossible\"\n    else:\n        return \"\\n\".join(\"\".join(row) for row in transcript)\n \ndef solve(R,C,M):\n    if M == R*C-1:\n        g = []\n        for i in range(R*C-1):\n            g.append(i)\n        return transcribe(R,C, g, R*C-1)\n     \n    for g in all_grids(R,C,M):\n        sol = solution(R,C,g)\n        if sol is None:\n            continue\n        return transcribe(R,C, g, sol)\n    return None\n             \n     \ndef output_grid(R,C,g):\n    for i in range(R):\n        for j in range(C):\n            if i*C+j not in g:\n                sys.stdout.write(\".\")\n            else:\n                sys.stdout.write(\"*\")\n        sys.stdout.write(\"\\n\")\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1,T+1):\n        R,C,M = map(int, raw_input().split())\n        print(\"Case #%d:\" % i)\n        print(printed_sol(solve(R,C,M)))\n"}
{"author": "rajabaz", "index": 54, "filename": "2012_1460488_1595491.py", "code": "def max_of_triplets(n):\n    a = n//3\n    if (n % 3) == 0:\n        if a == 0 : return (0,0)\n        return (a, a+1)\n    if (n % 3) == 1:\n        return (a+1, a+1)\n    if a == 9: return (10, 10)\n    return (a+1, a+2)\n \ndef solve(scores, S, p):\n    t = 0\n    for s in scores:\n        a,b = max_of_triplets(s)\n        if a >= p:\n            t += 1\n        elif b >= p and S > 0:\n            t += 1\n            S -= 1\n    return t\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1, T+1):\n        nums = map(int, raw_input().strip().split())\n        N = nums[0]\n        S = nums[1]\n        p = nums[2]\n        scores = nums[3:]\n        if len(scores) != N:\n            #sanity check\n            print(\"WTF\", i)\n        print(\"Case #%d: %d\" % (i, solve(scores, S, p)))\n     \n"}
{"author": "rajabaz", "index": 54, "filename": "2013_2270488_2453486.py", "code": "def line_status(line):\n    s = set(line)\n    if '.' in s:\n        return 'I'\n    if len(s) == 1 or (len(s) == 2 and 'T' in s):\n        player = s.pop()\n        while player == \"T\":\n            player = s.pop()\n        return player\n    return 'D'\n \ndef grid_status(grid):\n    lines = grid\n    columns = []\n    for i in range(4):\n        columns.append([])\n        for j in range(4):\n            columns[-1].append(grid[j][i])\n    lines.extend(columns)\n    lines.append([grid[i][i] for i in range(4)])\n    lines.append([grid[i][3-i] for i in range(4)])\n    incomplete = False\n    for l in lines:\n        s = line_status(l)\n        if s == 'I':\n            incomplete = True\n        elif s in ('X', 'O'):\n            return s + \" won\"\n    if incomplete:\n        return \"Game has not completed\"\n    return \"Draw\"\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1, T+1):\n        grid = [raw_input() for j in range(4)]\n        if i < T:\n            raw_input()\n        print(\"Case #%d: %s\" % (i, grid_status(grid)))\n     \n"}
{"author": "rajabaz", "index": 54, "filename": "2013_2270488_2449486.py", "code": "def solve(grid, M, N):\n    row_max = {}\n    column_max = {}\n    for i in range(M):\n        row_max[i] = max(grid[i])\n    for i in range(N):\n        column_max[i] = max([grid[j][i] for j in range(M)])\n    for i in range(M):\n        for j in range(N):\n            v = grid[i][j]\n            if v < row_max[i] and v < column_max[j]:\n                return \"NO\"\n    return \"YES\"\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1,T+1):\n        M,N = [int(x) for x in raw_input().split()]\n        grid = [[int(x) for x in raw_input().split()] for j in range(M)]\n        print(\"Case #%d: %s\" % (i, solve(grid, M,N)))\n"}
{"author": "rajabaz", "index": 54, "filename": "2012_1460488_1483485.py", "code": "mapping = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's',\n            'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u',\n            'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n',\n            'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a',\n            'x': 'm', 'z': 'q', 'q': 'z'}\n \ndef translate(s):\n    return \"\".join(map(lambda a: mapping[a], s))\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1, T+1):\n        s = translate(raw_input().strip())\n        print(\"Case #%d: %s\" %(i, s))\n \n         \n"}
{"author": "rajabaz", "index": 54, "filename": "2013_2270488_2463486.py", "code": "from math import sqrt\n \ndef isqrt(num):\n    return int(sqrt(num))\n \ndef is_square(num):\n    return isqrt(num)**2 == num\n \ndef is_palindrome(num):\n    return str(num) == \"\".join(reversed(str(num)))\n \ndef is_fair_and_square(num):\n    return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))\n \ndef solve(A,B):\n    count = 0\n    for i in range(A,B+1):\n        if is_fair_and_square(i):\n            count += 1\n    return count\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1, T+1):\n        A,B = [int(x) for x in raw_input().split()]\n        print(\"Case #%d: %d\" % (i, solve(A,B)))\n         \n"}
{"author": "rajabaz", "index": 54, "filename": "2014_2974486_5756407898963968.py", "code": "def solve(c1, g1, c2, g2):\n    row_1 = g1[c1-1]\n    row_2 = g2[c2-1]\n    inter = set(row_1) & set(row_2)\n    if len(inter) == 0:\n        return \"Volunteer cheated!\"\n    if len(inter) > 1:\n        return \"Bad magician!\"\n    return str(inter.pop())\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1,T+1):\n        c1 = int(raw_input())\n        g1 = []\n        for j in range(4):\n            g1.append(map(int, raw_input().split()))\n        c2 = int(raw_input())\n        g2 = []\n        for j in range(4):\n            g2.append(map(int, raw_input().split()))\n        print(\"Case #%d: %s\" % (i, solve(c1,g1,c2,g2)) )\n         \n     \n"}
{"author": "royf", "index": 55, "filename": "2014_2974486_5709773144064000.py", "code": "\nimport math\nimport itertools\nimport numpy as NP\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_letters(f):\n    return list(read_word(f))\n \ndef read_digits(f, b=10):\n    return [int(x, b) for x in read_letters(f)]\n \ndef read_words(f, d=' '):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' '):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_floats(f, d=' '):\\n    return [float(x) for x in read_words(f, d)]\\n \\ndef read_arr(f, R, reader=read_ints, *args, **kwargs):\\n    return [reader(f, *args, **kwargs) for i in range(R)]\\n \\ndef solve(solver, fn, out_fn=None):\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'w') as fo:\n            T = read_int(fi)\n            for i in range(T):\n                case = read_case(fi)\n                res = solver(case)\n                write_case(fo, i, res)\n \n################################################################################\n \ndef read_case(f):\n    return read_floats(f)\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%i)\n    f.write('%s'%res)\n    f.write('\\n')\n \n################################################################################\n \ndef solve_small(case):\n    (C, F, X) = case\n    res = 0\n    i = 0\n    while X/(2 + i*F) > C/(2 + i*F) + X/(2 + (i+1)*F):\n        res += C/(2 + i*F)\n        i += 1\n    return res + X/(2 + i*F)\n \ndef solve_large(case):\n    return solve_small(case)\n \nDEBUG = 'i'\n \nfrom run import *\n"}
{"author": "royf", "index": 55, "filename": "2014_2974486_5690574640250880.py", "code": "\nimport math\nimport itertools\nimport numpy as NP\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_letters(f):\n    return list(read_word(f))\n \ndef read_digits(f, b=10):\n    return [int(x, b) for x in read_letters(f)]\n \ndef read_words(f, d=' '):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' '):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_floats(f, d=' '):\\n    return [float(x) for x in read_words(f, d)]\\n \\ndef read_arr(f, R, reader=read_ints, *args, **kwargs):\\n    return [reader(f, *args, **kwargs) for i in range(R)]\\n \\ndef solve(solver, fn, out_fn=None):\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'w') as fo:\n            T = read_int(fi)\n            for i in range(T):\n                case = read_case(fi)\n                res = solver(case)\n                write_case(fo, i, res)\n \n################################################################################\n \ndef read_case(f):\n    return read_ints(f)\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%i)\n    if isinstance(res, list):\n        res[0][0] = 'c'\n        res = '\\n'.join(''.join(c for c in r) for r in res)\n    f.write('\\n%s'%res)\n    f.write('\\n')\n \n################################################################################\n \ndef solve_small(case):\n    (R, C, M) = case\n    if R == 1:\n        return 'c' + '.'*(C-M-1) + '*'*M\n    if C == 1:\n        return '\\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\n    m = R*C - M\n    res = [['*']*C for r in range(R)]\n    if m == 1:\n        return res\n    for r in range(2, R+1):\n        c = m // r\n        z = m % r\n        if c < 2 or c + (z>0) > C:\n            continue\n        if z == 1 and (r < 3 or c < 3):\n            continue\n        for x in range(r):\n            for y in range(c):\n                res[x][y] = '.'\n        for y in range(z):\n            res[y][c] = '.'\n        if z == 1:\n            res[z][c] = '.'\n            res[r-1][c-1] = '*'\n        return res\n    return 'Impossible'\n \ndef solve_large(case):\n    return solve_small(case)\n \nDEBUG = 'f'\n \nfrom run import *\n"}
{"author": "royf", "index": 55, "filename": "2012_1460488_1595491.py", "code": "\nimport sys\nimport os\nimport itertools\nimport math\nimport numpy\n \n__file__ = sys.argv[0]\n__path__ = os.path.dirname(__file__)\n__prob__ = os.path.basename(__path__)\n \ndef pout(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'depth' in f.f_locals:\n        d = f.f_locals['depth']\n    print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n \ndef perr(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'depth' in f.f_locals:\n        d = f.f_locals['depth']\n    ERR_FILE.write(' '*d + '%s = %s\\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n \ndef argmin(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best > y:\n            best = y\n            res = x\n    return res\n \ndef argmax(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best < y:\n            best = y\n            res = x\n    return res\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_words(f, d=' '):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' '):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_word_arr(f, R):\\n    res = []\\n    for i in range(R):\\n        res.append(read_word(f))\\n    return res\\n \\ndef read_ints_arr(f, R, dtype=int, *args, **kwargs):\\n    res = []\\n    for i in range(R):\\n        res.append(read_ints(f, *args, **kwargs))\\n    return numpy.array(res, dtype)\\n \\ndef solve(solver, fn, start_case=0, end_case=None, out_fn=None):\\n    global ERR_FILE\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    err_fn = fn + '.err'\n    if start_case == 0:\n        append = True\n        if os.path.exists(out_fn):\n            with open(out_fn, 'r') as f:\n                for l in f:\n                    if l[:6] == 'Case #':\n                        start_case = int(l[6:l.index(':')])+1\n    else:\n        append = False\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'a' if append else 'w') as fo:\n            with open(err_fn, 'w') as ERR_FILE:\n                T = read_int(fi)\n                for i in range(T):\n                    case = read_case(fi)\n                    if i+1 < start_case:\n                        continue\n                    print('Case #%d of %d'%(i+1, T))\n                    ERR_FILE.write('Case #%d of %d\\n'%(i+1, T))\n                    perr('case')\n                    res = solver(case)\n                    perr('res')\n                    write_case(fo, i, res)\n                    fo.flush()\n                    if end_case is not None and i+1 == end_case:\n                        break\n \ndef test(start_case=1, end_case=None):\n    fn = os.path.join(__path__, 'test')\n    solve(solve_small, fn, start_case, end_case)\n \ndef small(start_case=1, end_case=None):\n    fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n    solve(solve_small, fn, start_case, end_case)\n \ndef small2(start_case=1, end_case=None):\n    fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n    solve(solve_large, fn, start_case, end_case, fn + '2.out')\n \ndef large(start_case=0, end_case=None):\n    fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)\n    solve(solve_large, fn, start_case, end_case)\n \n################################################################################\n \ndef read_case(f):\n    Z = read_ints(f)\n    (N, S, p) = Z[:3]\n    t = Z[3:]\n    return (N, S, p, t)\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%(i+1))\n    f.write('%s'%res)\n    f.write('\\n')\n \nFAIL = 'NO SOLUTION'\n \ndef solve_small(case):\n    (N, S, p, t) = case\n    res = 0\n    for i in range(N):\n        if p >= 2:\n            if t[i] >= 3*p-2:\n                res += 1\n            elif S > 0 and t[i] >= 3*p-4:\n                res += 1\n                S -= 1\n        elif p == 1:\n            if t[i] >= 3*p-2:\n                res += 1\n        elif p == 0:\n            res += 1\n    return res\n \nsolve_large = solve_small\n \n##perr = pout\n##pout = lambda s: None\npout = perr\n"}
{"author": "royf", "index": 55, "filename": "2013_2270488_2453486.py", "code": "\nimport math\nimport itertools\nimport numpy\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_letters(f):\n    return list(read_word(f))\n \ndef read_digits(f, b=10):\n    return [int(x, b) for x in read_letters(f)]\n \ndef read_words(f, d=' '):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' '):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_floats(f, d=' '):\\n    return [float(x) for x in read_words(f, d)]\\n \\ndef read_arr(f, R, reader=read_ints, *args, **kwargs):\\n    res = []\\n    for i in range(R):\\n        res.append(reader(f, *args, **kwargs))\\n    return res\\n \\ndef solve(solver, fn, out_fn=None):\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'w') as fo:\n            T = read_int(fi)\n            for i in range(T):\n                case = read_case(fi)\n                res = solver(case)\n                write_case(fo, i, res)\n \n################################################################################\n \ndef read_case(f):\n    B = read_arr(f, 4, read_letters)\n    read_word(f)\n    return B\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%i)\n    f.write('%s'%res)\n    f.write('\\n')\n \n################################################################################\n \ndef test(a):\n    if '.' not in a and 'O' not in a:\n        return 'X won'\n    if '.' not in a and 'X' not in a:\n        return 'O won'\n \ndef solve_small(case):\n    draw = True\n    for row in case:\n        if '.' in row:\n            draw = False\n        res = test(row)\n        if res:\n            return res\n    for i in range(len(case[0])):\n        col = [row[i] for row in case]\n        res = test(col)\n        if res:\n            return res\n    diag = [case[i][i] for i in range(len(case))]\n    res = test(diag)\n    if res:\n        return res\n    diag = [case[i][-i-1] for i in range(len(case))]\n    res = test(diag)\n    if res:\n        return res\n    if draw:\n        return 'Draw'\n    return 'Game has not completed'\n \ndef solve_large(case):\n    return solve_small(case)\n \nDEBUG = 'i'\n \nfrom run import *\n"}
{"author": "royf", "index": 55, "filename": "2013_2270488_2449486.py", "code": "\nimport math\nimport itertools\nimport numpy\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_letters(f):\n    return list(read_word(f))\n \ndef read_digits(f, b=10):\n    return [int(x, b) for x in read_letters(f)]\n \ndef read_words(f, d=' '):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' '):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_floats(f, d=' '):\\n    return [float(x) for x in read_words(f, d)]\\n \\ndef read_arr(f, R, reader=read_ints, *args, **kwargs):\\n    res = []\\n    for i in range(R):\\n        res.append(reader(f, *args, **kwargs))\\n    return res\\n \\ndef solve(solver, fn, out_fn=None):\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'w') as fo:\n            T = read_int(fi)\n            for i in range(T):\n                case = read_case(fi)\n                res = solver(case)\n                write_case(fo, i, res)\n \n################################################################################\n \ndef read_case(f):\n    [N, M] = read_ints(f)\n    A = read_arr(f, N)\n    return (N, M, A)\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%i)\n    f.write('%s'%res)\n    f.write('\\n')\n \n################################################################################\n \ndef solve_small(case):\n    (N, M, A) = case\n    rows = [max(row) for row in A]\n    cols = [max(row[j] for row in A) for j in range(M)]\n    for i in range(N):\n        for j in range(M):\n            if A[i][j] < min(rows[i], cols[j]):\n                return 'NO'\n    return 'YES'\n \ndef solve_large(case):\n    return solve_small(case)\n \nDEBUG = 'i'\n \nfrom run import *\n"}
{"author": "royf", "index": 55, "filename": "2012_1460488_1483485.py", "code": "\nimport sys\nimport os\nimport itertools\nimport math\nimport numpy\n \n__file__ = sys.argv[0]\n__path__ = os.path.dirname(__file__)\n__prob__ = os.path.basename(__path__)\n \ndef pout(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'depth' in f.f_locals:\n        d = f.f_locals['depth']\n    print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n \ndef perr(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'depth' in f.f_locals:\n        d = f.f_locals['depth']\n    ERR_FILE.write(' '*d + '%s = %s\\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n \ndef argmin(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best > y:\n            best = y\n            res = x\n    return res\n \ndef argmax(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best < y:\n            best = y\n            res = x\n    return res\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_words(f, d=' '):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' '):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_word_arr(f, R):\\n    res = []\\n    for i in range(R):\\n        res.append(read_word(f))\\n    return res\\n \\ndef read_ints_arr(f, R, dtype=int, *args, **kwargs):\\n    res = []\\n    for i in range(R):\\n        res.append(read_ints(f, *args, **kwargs))\\n    return numpy.array(res, dtype)\\n \\ndef solve(solver, fn, start_case=0, end_case=None, out_fn=None):\\n    global ERR_FILE\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    err_fn = fn + '.err'\n    if start_case == 0:\n        append = True\n        if os.path.exists(out_fn):\n            with open(out_fn, 'r') as f:\n                for l in f:\n                    if l[:6] == 'Case #':\n                        start_case = int(l[6:l.index(':')])+1\n    else:\n        append = False\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'a' if append else 'w') as fo:\n            with open(err_fn, 'w') as ERR_FILE:\n                T = read_int(fi)\n                for i in range(T):\n                    case = read_case(fi)\n                    if i+1 < start_case:\n                        continue\n                    print('Case #%d of %d'%(i+1, T))\n                    ERR_FILE.write('Case #%d of %d\\n'%(i+1, T))\n                    perr('case')\n                    res = solver(case)\n                    perr('res')\n                    write_case(fo, i, res)\n                    fo.flush()\n                    if end_case is not None and i+1 == end_case:\n                        break\n \ndef test(start_case=1, end_case=None):\n    fn = os.path.join(__path__, 'test')\n    solve(solve_small, fn, start_case, end_case)\n \ndef small(start_case=1, end_case=None):\n    fn = os.path.join(__path__, '%s-small-practice'%__prob__)\n    solve(solve_small, fn, start_case, end_case)\n \ndef small2(start_case=1, end_case=None):\n    fn = os.path.join(__path__, '%s-small-practice'%__prob__)\n    solve(solve_large, fn, start_case, end_case, fn + '2.out')\n \ndef large(start_case=0, end_case=None):\n    fn = os.path.join(__path__, '%s-large-practice'%__prob__)\n    solve(solve_large, fn, start_case, end_case)\n \n################################################################################\n \ndef read_case(f):\n    G = read_word(f)\n    return G\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%(i+1))\n    f.write('%s'%res)\n    f.write('\\n')\n \nFAIL = 'NO SOLUTION'\n \nTRANS = {'z': 'q', 'q': 'z', '\\n': '\\n', ' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm'}\n \ndef solve_small(case):\n    G = case\n    return ''.join(TRANS[x] for x in G)\n \nsolve_large = solve_small\n \n##perr = pout\n##pout = lambda s: None\npout = perr\n"}
{"author": "royf", "index": 55, "filename": "2013_2270488_2463486.py", "code": "\nimport math\nimport itertools\nimport numpy\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_letters(f):\n    return list(read_word(f))\n \ndef read_digits(f, b=10):\n    return [int(x, b) for x in read_letters(f)]\n \ndef read_words(f, d=' '):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' '):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_floats(f, d=' '):\\n    return [float(x) for x in read_words(f, d)]\\n \\ndef read_arr(f, R, reader=read_ints, *args, **kwargs):\\n    res = []\\n    for i in range(R):\\n        res.append(reader(f, *args, **kwargs))\\n    return res\\n \\ndef solve(solver, fn, out_fn=None):\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'w') as fo:\n            T = read_int(fi)\n            for i in range(T):\n                case = read_case(fi)\n                res = solver(case)\n                write_case(fo, i, res)\n \n################################################################################\n \ndef read_case(f):\n    return read_ints(f)\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%i)\n    f.write('%d'%res)\n    f.write('\\n')\n \n################################################################################\n \ndef aux(A, B, x, s):\n    res = 0\n    n = int(''.join(x[::-1]+x))\n    nn = n*n\n    if nn > B:\n        return res\n    if nn >= A:\n        res += 1\n    for c in [0, 1, 2]:\n        if s + c*c < 10:\n            n = int(''.join(x[::-1]+[str(c)]+x))\n            nn = n*n\n            if nn >= A and nn <= B:\n                res += 1\n        if s + 2*c*c < 10:\n            res += aux(A, B, [str(c)]+x, s + 2*c*c)\n    return res\n \ndef solve_small(case):\n    [A, B] = case\n    res = 0\n    for n in [1, 4, 9]:\n        if n >= A and n <= B:\n            res += 1\n    for c in [1, 2]:\n        res += aux(A, B, [str(c)], 2*c*c)\n    return res\n \ndef solve_large(case):\n    return solve_small(case)\n \nDEBUG = 'i'\n \nfrom run import *\n"}
{"author": "royf", "index": 55, "filename": "2014_2974486_5756407898963968.py", "code": "\nimport math\nimport itertools\nimport numpy as NP\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_letters(f):\n    return list(read_word(f))\n \ndef read_digits(f, b=10):\n    return [int(x, b) for x in read_letters(f)]\n \ndef read_words(f, d=' '):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' '):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_floats(f, d=' '):\\n    return [float(x) for x in read_words(f, d)]\\n \\ndef read_arr(f, R, reader=read_ints, *args, **kwargs):\\n    return [reader(f, *args, **kwargs) for i in range(R)]\\n \\ndef solve(solver, fn, out_fn=None):\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'w') as fo:\n            T = read_int(fi)\n            for i in range(T):\n                case = read_case(fi)\n                res = solver(case)\n                write_case(fo, i, res)\n \n################################################################################\n \ndef read_case(f):\n    R1 = read_int(f)\n    Q1 = read_arr(f, 4)\n    R2 = read_int(f)\n    Q2 = read_arr(f, 4)\n    return (R1, Q1, R2, Q2)\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%i)\n    f.write('%s'%res)\n    f.write('\\n')\n \n################################################################################\n \ndef solve_small(case):\n    (R1, Q1, R2, Q2) = case\n    s = set(Q1[R1-1]) & set(Q2[R2-1])\n    if len(s) == 0:\n        return 'Volunteer cheated!'\n    if len(s) == 1:\n        return s.pop()\n    return 'Bad magician!'\n \ndef solve_large(case):\n    return solve_small(case)\n \nDEBUG = 'i'\n \nfrom run import *\n"}
{"author": "cheilman", "index": 56, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/python\n \nimport sys\n \nimport puzutils\n \nclass Cookie_2014_QB(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n        puzutils.CodeJamProblem.__init__(self, inputFilename)\n    \n        self.T = None\n    \n    def load(self):\n        \"\"\"\n        input:\n    \n        T (number of test cases)\n    \n        C F X (real numbers)\n    \n        \"\"\"\n    \n        self.tests = []\n    \n        with open(self.inputFilename, \"rt\") as file:\n            self.T = int(file.readline().strip())\n    \n        for i in xrange(self.T):\n            (C,F,X) = [float(x) for x in file.readline().split(' ')]\n    \n            self.tests.append([C,F,X])\n    \n        return True\n    \n    def timeToNextFarm(self, C, rate):\n        \"\"\"\n        How long in seconds until we get the next farm.\n        \"\"\"\n    \n        return (C * 1.0) / rate\n    \n    def timeToTarget(self, C, X, rate):\n        \"\"\"\n        How long in seconds until we hit the target.\n        \"\"\"\n    \n        return ( X * 1.0) / rate\n    \n    def isFarmWorthIt(self, C, X, F, rate):\n        #print \"C = %.2f, F = %.2f, X = %.2f, rate = %.2f\" % (C, F, X, rate)\n    \n        withoutFarm = self.timeToTarget(C, X, rate)\n        withFarm = self.timeToNextFarm(C, rate) + self.timeToTarget(C, X, rate + F)\n    \n        #print \"With farm = %.2f\" % (withFarm,)\n        #print \"Without farm = %.2f\" % (withoutFarm,)\n    \n        if (withFarm < withoutFarm):\n            return True\n        else:\n            return False\n    \n    def executeTest(self, test):\n        \"\"\"\n        Run a test and return output.\n        \"\"\"\n    \n        (C,F,X) = test\n        rate = 2\n        elapsed = 0.0\n    \n        #print \"C = %.2f, F = %.2f, X = %.2f, rate = %.2f\" % (C, F, X, rate)\n    \n        while True:\n            if self.isFarmWorthIt(C, X, F, rate):\n                #print \"%.2f: Bought farm, rate = %d\" % (elapsed, rate)\n                elapsed = elapsed + self.timeToNextFarm(C, rate)\n                rate = rate + F\n            else:\n                #print \"%.2f: Giving up and finishing it out, rate = %d\" % (elapsed, rate)\n                elapsed = elapsed + self.timeToTarget(C, X, rate)\n                return \"%0.7f\" % (elapsed, )\n \nwith Cookie_2014_QB(sys.argv[1]) as problem:\n    problem.load()\n \nproblem.run()\n"}
{"author": "cheilman", "index": 56, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/python\n \nimport sys\n \nimport puzutils\n \nclass Minesweeper_2014_QC(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n        puzutils.CodeJamProblem.__init__(self, inputFilename)\n    \n        self.T = None\n    \n    def load(self):\n        \"\"\"\n        input:\n    \n        T (number of test cases)\n    \n        R C M (integers)\n    \n        \"\"\"\n    \n        self.tests = []\n    \n        with open(self.inputFilename, \"rt\") as file:\n            self.T = int(file.readline().strip())\n    \n        for i in xrange(self.T):\n            (R,C,M) = [int(x) for x in file.readline().split(' ')]\n    \n            self.tests.append([R,C,M])\n    \n        return True\n    \n    def boardToString(self, board):\n        retval = \"\"\n    \n        for row in board:\n            retval = retval + \"\\n\" + \"\".join(row)\n    \n        return retval\n    \n    def executeTest(self, test):\n        \"\"\"\n        Run a test and return output.\n        \"\"\"\n    \n        (R,C,M) = test\n        #print \"R: %d, C: %d, M: %d\" % (R,C,M)\n    \n        spaces = R * C\n        blanks = spaces - M\n    \n        if (blanks <= 0):\n            #print \"R: %d, C: %d, M: %d, spaces: %d, blanks: %d\" % (R,C,M,spaces,blanks)\n            return \"Impossible\"\n        \n        board = [['.' for x in range(C)] for y in range(R)]\n    \n        board[R-1][C-1] = \"c\"\n    \n        badpositions=[]\n        positions=[]\n    \n        for x in xrange(C):\n            for y in xrange(R):\n                if (x == (C-1)) and (y == (R-1)):\n                    continue\n                if (x == (C-1)) and (y == (R-2)):\n                    badpositions.append((x,y))\n                    continue\n                if (x == (C-2)) and (y == (R-1)):\n                    badpositions.append((x,y))\n                    continue\n                if (x == (C-2)) and (y == (R-2)):\n                    badpositions.append((x,y))\n                    continue\n        \n                positions.append((x,y))\n    \n        positions.reverse()\n    \n        for x in badpositions:\n            positions.insert(0, x)\n    \n        m = M\n    \n        while (m > 0):\n            if len(positions) <= 0:\n                #return self.boardToString(board)\n                return \"Impossible\"\n        \n            pos = positions.pop()\n            (x,y) = pos\n        \n            if (board[y][x] != \".\"):\n                #return self.boardToString(board)\n                return \"Impossible\"\n    \n        board[y][x] = '*'\n        m = m - 1\n    \n        mines = sum([x.count('*') for x in board])\n    \n        if (mines != M):\n            #return self.boardToString(board)\n            return \"Impossible\"\n    \n        if (blanks > 1):\n            if (R > 1):\n                if board[R - 2][C - 1] == \"*\":\n                    #return self.boardToString(board)\n                    return \"Impossible\"\n        \n        if (C > 1):\n            if board[R - 1][C - 2] == \"*\":\n                #return self.boardToString(board)\n                return \"Impossible\"\n    \n        if (R > 1) and (C > 1):\n            if board[R - 2][C - 2] == \"*\":\n                #return self.boardToString(board)\n                return \"Impossible\"\n    \n        #return \"Possible\"\n        return self.boardToString(board)\n \nwith Minesweeper_2014_QC(sys.argv[1]) as problem:\n    problem.load()\n \nproblem.run()\n"}
{"author": "cheilman", "index": 56, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/python\n \ndef readfile(filename):\n\t\"\"\"\n\t\tThe first line of the input gives the number of test\n\t\tcases, T. T test cases follow. Each test case consists of\n\t\ta single line containing integers separated by single\n\t\tspaces. The first integer will be N, the number of\n\t\tGooglers, and the second integer will be S, the number\n\t\tof surprising triplets of scores. The third integer will\n\t\tbe p, as described above. Next will be N integers ti:\n\t\tthe total points of the Googlers.\n\t\"\"\"\n \n\tfile = open(filename, \"rt\")\n \n\tretval = {}\n \n\tT = int(file.readline().strip())\n\tretval['T'] = T\n \n\ttests = []\n \n\tfor i in xrange(T):\n\t\tline = file.readline().strip()\n \n\t\tparts = line.split(\" \")\n \n\t\tN = int(parts[0])\n\t\tS = int(parts[1])\n\t\tp = int(parts[2])\n\t\tt = []\n \n\t\tfor j in xrange(N):\n\t\t\tt = t + [int(parts[3 + j]), ]\n \n\t\ttest = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n\t\ttests = tests + [test, ]\n \n\tretval['tests'] = tests\n\treturn retval\n \ndef spread(triplet):\n\treturn max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))\n \ndef bestresult(triplet):\n\tif triplet:\n\t\treturn max(triplet)\n\treturn 0\n \ndef getcombos(points):\n\t\"\"\"\n\t\tReturns ([unsurprising possibilities, ], [surprising possibilities])\n\t\"\"\"\n \n\tunsurps = []\n\tsurps = []\n \n\tavg = points / 3.0\n \n\t# Go from (avg-2) to (avg+3) to account for rounding\n\tavg = int(avg)\n \n\ttested = []\n \n\tfor i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n\t\tfor j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n\t\t\tfor k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n\t\t\t\tif (i + j + k) != points:\n\t\t\t\t\tcontinue\n \n\t\t\t\tscores = (i,j,k)\n\t\t\t\tscores = sorted(scores)\n \n\t\t\t\tif scores in tested:\n\t\t\t\t\tcontinue\n\t\t\t\ttested.append(scores)\n \n\t\t\t\ts = spread((i,j,k))\n \n\t\t\t\tif (s < 2):\n\t\t\t\t\tunsurps.append(scores)\n\t\t\t\telif (s == 2):\n\t\t\t\t\tsurps.append(scores)\n\t\t\t\telse:\n\t\t\t\t\tcontinue\n \n\treturn (unsurps, surps)\n \ndef getbesttriplet(triplets):\n\tbest = None\n \n\tfor i in triplets:\n\t\tif best:\n\t\t\tif (bestresult(i) > bestresult(best)):\n\t\t\t\tbest = i\n\t\telse:\n\t\t\tbest = i\n \n\treturn best\n \t\n \ndef getmulticombos(peeps):\n\t\"\"\"\n\t\tReturn the best surprising and non-surprising possibility for\n\t\teach person.\n\t\"\"\"\n \n\tret = []\n \n\tfor p in peeps:\n\t\tu,s = getcombos(p)\n \n\t\tbestu = getbesttriplet(u)\n\t\tbests = getbesttriplet(s)\n \n\t\tret.append((bestu, bests))\n \n\treturn ret\n \ndef getbestresults(scores, best, numsur):\n\t\"\"\"\n\t\tFigure out the maximum number of people that could have gotten\n\t\ta single score >= best.  Limited to choosing only numsur surprising\n\t\ttriplets.\n\t\"\"\"\n \n\tpeeps = getmulticombos(scores)\n \n\tcount = 0\n\tsurcount = 0\n \n\tfor p in peeps:\n\t\tif (bestresult(p[0]) >= best):\n\t\t\t# unsurprising is good\n\t\t\tcount = count + 1\n\t\telif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n\t\t\tcount = count + 1\n\t\t\tsurcount = surcount + 1\n \n\treturn count\n \ndef process(test):\n\tN = test['N']\n\tS = test['S']\n\tp = test['p']\n\tt = test['t']\n \n\treturn getbestresults(t, p, S)\n \ndata = readfile(\"B-small-attempt0.in\")\n \nfor i in xrange(data['T']):\n\ttest = data['tests'][i]\n \n\tresult = process(test)\n \n\tprint(\"Case #%d: %d\" % (i+1, result))\n"}
{"author": "cheilman", "index": 56, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/python\n \nimport sys\n \ndef readfile(file):\n\t\"\"\"\n\t\tinput:\n\t\n\t\t\tT (number of test cases)\n\t\n\t\t\txxxx\n\t\t\txxxx\n\t\t\txxxx\n\t\t\txxxx\t(T boards, where x in [X,O,T,.]\n\t\n\t\"\"\"\n\t\n\ttests = []\n\t\n\tT = int(file.readline().strip())\n\t\n\tfor i in xrange(T):\n\t\t\tboard = \"\"\n\t\t\n\t\t\tfor j in xrange(4):\n\t\t\t\tline = file.readline().strip()\n\t\n\t\t\t\tboard = board + line\n\t\n\t\t\tfile.readline()\n\t\n\t\t\ttests.append(board)\n\t\n\treturn tests\n \ndef fourInARow(who, test):\n\t\"\"\"\n\t\tFind four of 'who' in a row (T wild).\n\t\"\"\"\n \n\ttarget = (who, 'T')\n \n\t# Horizontal/Vertical\n\tfor i in range(4):\n\t\thorzWin = True\n\t\tvertWin = True\n \n\t\tfor j in range(4):\n\t\t\thorzIndex = i * 4 + j\n\t\t\tvertIndex = j * 4 + i\n \n\t\t\tif not (test[horzIndex] in target):\n\t\t\t\thorzWin = False\n \n\t\t\tif not (test[vertIndex] in target):\n\t\t\t\tvertWin = False\n \n\t\tif horzWin or vertWin:\n\t\t\treturn True\n \n\t# Diagonal\n\tslashWin = True\n\tbslashWin = True\n \n\tfor i in range(4):\n\t\tx = y = i\n \n\t\tslashIndex = y * 4 + x\n\t\tbslashIndex = y * 4 + (3 - x)\n \n\t\t#print \"Checking (%d,%d) = %s and (%d,%d) = %s\" % (x, y, test[slashIndex], 3-x, y, test[bslashIndex])\n \n\t\tif not (test[slashIndex] in target):\n\t\t\tslashWin = False\n \n\t\tif not (test[bslashIndex] in target):\n\t\t\tbslashWin = False\n \n\tif slashWin or bslashWin:\n\t\treturn True\n \n\treturn False\n \ndef run(test):\n\t\"\"\"\n\t\tRun a test and return output.\n\t\"\"\"\n \n\tif fourInARow('X', test):\n\t\treturn \"X won\"\n\telif fourInARow('O', test):\n\t\treturn \"O won\"\n\telif '.' in test:\n\t\treturn \"Game has not completed\"\n\telse:\n\t\treturn \"Draw\"\n \nfile = open(sys.argv[1], \"rt\")\n \ntests = readfile(file)\n \nfile.close()\n \ncase = 1\n \nfor test in tests:\n\t#if True:\n\t#test = tests[0]\n\tresult = run(test)\n\tprint (\"Case #%d: %s\" % (case, result))\n\tcase = case + 1\n"}
{"author": "cheilman", "index": 56, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/python\n \nimport sys\n \ndef readfile(file):\n\t\"\"\"\n\t\tinput:\n\t\n\t\t\tT (number of test cases)\n\t\n\t\t\tN M\n\t\t\tN lines of M numbers (desired height of grass)\n\t\n\t\"\"\"\n\t\n\ttests = []\n\t\n\tT = int(file.readline().strip())\n\t\n\tfor i in xrange(T):\n\t\t\ttest = {}\n\t\n\t\t\tline = file.readline().strip()\n\t\t\tparts = line.split(' ')\n\t\n\t\t\tif len(parts) != 2:\n\t\t\t\tprint (\"HORRIBLE ERROR in TEST %d!\" % (i+1, ))\n\t\t\t\treturn None\n\t\n\t\t\tN = int(parts[0])\n\t\t\tM = int(parts[1])\n\t\n\t\t\ttest['N'] = N\n\t\t\ttest['M'] = M\n\t\t\ttest['desired'] = []\n\t\t\n\t\t\tfor j in xrange(N):\n\t\t\t\tline = file.readline().strip()\n\t\t\t\tparts = line.split(' ')\n\t\n\t\t\t\tif len(parts) != M:\n\t\t\t\t\tprint (\"TERRIBLE ERROR in TEST %d!\" % (i+1, ))\n\t\t\t\t\treturn None\n\t\n\t\t\t\tfor p in parts:\n\t\t\t\t\tk = int(p)\n\t\t\t\t\ttest['desired'].append(k)\n\t\n\t\t\ttests.append(test)\n\t\n\treturn tests\n \ndef run(test):\n\t\"\"\"\n\t\tRun a test and return output.\n\t\"\"\"\n \n\t# Figure out row/col min and max\n\ttest['row'] = []\n\ttest['col'] = []\n \n\tfor row in xrange(test['N']):\n\t\tr = []\n \n\t\tfor col in xrange(test['M']):\n\t\t\ti = row * test['M'] + col\n \n\t\t\tr.append(test['desired'][i])\n \n\t\ttest['row'].append({'min' : min(r), 'max' : max(r)})\n \n\tfor col in xrange(test['M']):\n\t\tc = []\n \n\t\tfor row in xrange(test['N']):\n\t\t\ti = row * test['M'] + col\n \n\t\t\tc.append(test['desired'][i])\n \n\t\ttest['col'].append({'min' : min(c), 'max' : max(c)})\n \n\tfor x in xrange(test['M']):\n\t\tfor y in xrange(test['N']):\n\t\t\ti = y * test['M'] + x\n\t\t\tv = test['desired'][i]\n \n\t\t\t# If you are smaller than someone in both directions, it's impossible\n\t\t\trowmax = test['row'][y]['max']\n\t\t\tcolmax = test['col'][x]['max']\n\t\t\tif (v < rowmax) and (v < colmax):\n\t\t\t\t#print \"(%d,%d) = %d, row = %d, col = %d\" % (x, y, v, rowmax, colmax)\n\t\t\t\treturn \"NO\"\n \n\treturn \"YES\"\n \nfile = open(sys.argv[1], \"rt\")\n \ntests = readfile(file)\n \nfile.close()\n \ncase = 1\n \nfor test in tests:\n\t#if True:\n\t#test = tests[0]\n\tresult = run(test)\n\tprint (\"Case #%d: %s\" % (case, result))\n\tcase = case + 1\n"}
{"author": "cheilman", "index": 56, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/python\n \nfrom string import maketrans\n \ninput = \"aoz\"\noutpt = \"yeq\"\n \ninput = input + \"our language is impossible to understand\"\noutpt = outpt + \"ejp mysljylc kd kxveddknmc re jsicpdrysi\"\n \ninput = input + \"there are twenty six factorial possibilities\"\noutpt = outpt + \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\"\n \ninput = input + \"so it is okay if you want to just give up\"\noutpt = outpt + \"de kr kd eoya kw aej tysr re ujdr lkgc jv\"\n \ninput = input + \"q\"\noutpt = outpt + \"z\"\n \ntogoog = maketrans(input, outpt)\nungoog = maketrans(outpt, input)\n \nfilename = \"A-small-attempt1.in\"\n \nfile = open(filename, \"rt\")\n \nT = int(file.readline().strip())\n \nfor i in xrange(T):\n\tline = file.readline().strip()\n \n\tprint(\"Case #%d: %s\" % (i + 1, line.translate(ungoog)))\n"}
{"author": "cheilman", "index": 56, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/python\n \nimport sys\nimport math\n \ndef readfile(file):\n\t\"\"\"\n\t\tinput:\n\t\n\t\t\tT (number of test cases)\n\t\n\t\t\tA B\n\t\n\t\"\"\"\n\t\n\ttests = []\n\t\n\tT = int(file.readline().strip())\n\t\n\tfor i in xrange(T):\n\t\t\ttest = {}\n\t\n\t\t\tline = file.readline().strip()\n\t\t\tparts = line.split(\" \")\n\t\n\t\t\tif len(parts) != 2:\n\t\t\t\tprint (\"HORRIBLE ERROR IN TEST CASE %d\" % (i+1,))\n\t\t\t\treturn None\n\t\n\t\t\ttest['A'] = int(parts[0])\n\t\t\ttest['B'] = int(parts[1])\n\t\t\n\t\t\ttests.append(test)\n\t\n\treturn tests\n \ndef isPalindrome(s):\n\t\"\"\"\n\t\tIs s a palindrome.\n \n\t\tS must be a string.\n\t\"\"\"\n \n\tl = len(s)\n \n\tif (l % 2) == 0:\n\t\t# even\n\t\tfrontHalf = s[0:l/2]\n\t\tbackHalf = s[l/2:]\n\telse:\n\t\t# odd\n\t\tfrontHalf = s[0:(l-1)/2]\n\t\tbackHalf = s[(l+1)/2:]\n \n\tbackHalf = backHalf[::-1]\n \n\tif frontHalf == backHalf:\n\t\treturn True\n\telse:\n\t\treturn False\n \ndef isFairAndSquare(n):\n \n\tsqrtN = int(math.sqrt(n))\n \n\tif (sqrtN * sqrtN) != n:\n\t\t#print \"%d is not square\" % (n, )\n\t\treturn False\n \n\tif not isPalindrome(str(n)):\n\t\t#print \"%d is not palindrome\" % (n, )\n\t\treturn False\n \n\tif not isPalindrome(str(sqrtN)):\n\t\t#print \"sqrt(%d) = %d is not palindrome\" % (n, sqrtN)\n\t\treturn False\n \n\treturn True\n \ndef run(test):\n\t\"\"\"\n\t\tRun a test and return output.\n\t\"\"\"\n \n\tcount = 0\n \n\tfor i in xrange(test['A'], test['B'] + 1):\n\t\tif isFairAndSquare(i):\n\t\t\tcount = count + 1\n \n\treturn count\n \n\ti = int(math.sqrt(test['A']))\n \n\tif (i * i) < test['A']:\n\t\ti = i + 1\n \n\t# Generate squares from palindromes\n\twhile i < test['B']:\n\t\t#print \"Checking %d\" % (i, )\n\t\tif not isPalindrome(str(i)):\n\t\t\ti = i + 1\n\t\t\tcontinue\n \n\t\t# square it\n\t\ts = i * i\n \n\t\tif s <= test['B']:\n\t\t\tif isPalindrome(str(s)):\n\t\t\t\t#print \"Counting %d\" % (i * i, )\n\t\t\t\tcount = count + 1\n\t\telse:\n\t\t\t# all done\n\t\t\tbreak\n \n\t\ti = i + 1\n \n\treturn \"%s\" % (count, )\n \nfile = open(sys.argv[1], \"rt\")\n \ntests = readfile(file)\n \nfile.close()\n \ncase = 1\n \nfor test in tests:\n\t#if True:\n\t#test = tests[0]\n\tresult = run(test)\n\tprint (\"Case #%d: %s\" % (case, result))\n\tcase = case + 1\n"}
{"author": "cheilman", "index": 56, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python\n \nimport sys\n \nimport puzutils\n \nclass Magic_2014_QA(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n        puzutils.CodeJamProblem.__init__(self, inputFilename)\n    \n        self.T = None\n    \n    def load(self):\n        \"\"\"\n        input:\n    \n        T (number of test cases)\n    \n        A (answer to first question)\n        x x x x\n        x x x x\n        x x x x\n        x x x x\n        B (answer to second question)\n        x x x x\n        x x x x\n        x x x x\n        x x x x\n    \n        \"\"\"\n    \n        self.tests = []\n    \n        with open(self.inputFilename, \"rt\") as file:\n            self.T = int(file.readline().strip())\n    \n        for i in xrange(self.T):\n            a = int(file.readline().strip())\n            test = {'a': a}\n            board = []\n            \n            for j in xrange(4):\n                line = file.readline().strip()\n                row = set([int(x) for x in line.split(' ')])\n                board.append(row)\n    \n            test['aboard'] = board\n    \n            b = int(file.readline().strip())\n            test['b'] = b\n            board = []\n            \n            for j in xrange(4):\n                line = file.readline().strip()\n                row = set([int(x) for x in line.split(' ')])\n                board.append(row)\n    \n            test['bboard'] = board\n    \n            self.tests.append(test)\n    \n        return True\n    \n    def executeTest(self, test):\n        \"\"\"\n        Run a test and return output.\n        \"\"\"\n    \n        #print \"Test: %s\\n\" % (test, )\n    \n        rowA = test['aboard'][test['a'] - 1]\n        rowB = test['bboard'][test['b'] - 1]\n    \n        #print \"rowA: %s\\nrowB: %s\\n\" % (rowA, rowB)\n    \n        intersect = rowA.intersection(rowB)\n    \n        #print \"intersect: %s\\n\" % (intersect, )\n    \n        if (len(intersect) == 1):\n            (element,) = intersect\n            return element\n        elif (len(intersect) == 0):\n            return \"Volunteer cheated!\"\n        else:\n            return \"Bad magician!\"\n    \nwith Magic_2014_QA(sys.argv[1]) as problem:\n    problem.load()\n \nproblem.run()\n"}
{"author": "elmoatasem", "index": 57, "filename": "2014_2974486_5709773144064000.py", "code": "'''\nCreated on Apr 11, 2014\n \n@author: mostasem\n'''\n \n \ndef getSeconds(C,F,X):\n    seconds = 0.0\n    cookie_rate = 2\n    solved =False\n    while (not solved):\n        choice1 = X/cookie_rate\n        choice2 = C/cookie_rate + X/(cookie_rate + F)\n        if(choice1 < choice2):\n            seconds += choice1\n            solved = True\n        else :\n            seconds += C/cookie_rate\n            cookie_rate += F\n     \n    return seconds\n \nf_r = open('B.in',\"r\")\nn_test=int(f_r.readline().strip()) \nf_w = open(\"B.out\", \"w\")\nresult = \"\"\nfor i in range(n_test):\n    C,F,X = map(float,f_r.readline().split())\n    seconds = getSeconds(C,F,X)\n    result = str(seconds)\n    output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n    f_w.write(output_str+'\\n')\n     \nf_r.close()\nf_w.close()\n \n"}
{"author": "elmoatasem", "index": 57, "filename": "2014_2974486_5690574640250880.py", "code": "'''\nCreated on Apr 12, 2014\n \n@author: mostasem\n'''\n \nimport math\ndef getFloorRoots(m):\n    r1 = -1 + math.sqrt(1 + (8 * m))/2\n    r2 = -1 - math.sqrt(1 + (8 * m))/2\n    return int(math.floor(r1))\n     \ndef boardHasZero(R,C,M):\n    if(R > 1 and C > 1):\n        S = M/C\n        Sr = M % C\n        print(S,Sr)\n        return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\n    else :\n        return M <= ((R*C) - 2)\n \n \ndef generateMineSweeperCase(R,C,M):\n \n    board = \"\"\n \n    if( R > 1 and C > 1 ): # generate special\n        S = M/C\n        Sr = M % C\n        print(S,Sr)\n        if(S): # all rows of *\n            board +=\"\\n\"\n            if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\n                board += (S - 1) * ((C*\"*\") + \"\\n\")\n            else:\n                board += (S - 2) * ((C*\"*\") + \"\\n\")\n            board +=  ((C*\"*\"))\n             \n        if(R >= S+3):\n            if(Sr):\n                board +=\"\\n\"\n                board += ((Sr *\"*\") + ((C - Sr) *\".\"))\n            Rm = R - (S + 1)\n            if(Rm):\n                board +=\"\\n\"\n                board += (Rm - 1) * ((C*\".\") + \"\\n\")\n                board +=  ((C*\".\"))\n                 \n        elif(R == S + 2):\n            Sm = 0\n            if(Sr % 2 == 0):\n                board +=\"\\n\"\n                board += (((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\") +\"\\n\")\n                board += ((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\")\n            else:\n                board +=\"\\n\"\n                board += (((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\") +\"\\n\")\n                board += ((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\")\n        else :\n            Sm = Sr + C\n            board +=\"\\n\"\n            board += (((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\") +\"\\n\")\n            board += ((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\")\n                 \n        list_board = list(board)\n        list_board[len(list_board) - 1] = 'c'\n        board = \"\".join(list_board)\n    else:\n        board +=\"\\n\"\n        if(C == 1):\n            board += M * \"*\\n\"\n            board += (R-M-1) * \".\\n\"\n            board +=  \"c\"\n        else:\n            board += M * \"*\"\n            board += (C-M-1) * \".\"\n            board += \"c\"\n             \n    return board\n        \n        \n        \n \nf_r = open('C.in',\"r\")\nn_test=int(f_r.readline().strip()) \nf_w = open(\"C.out\", \"w\")\nresult = \"\"\nfor i in range(n_test):\n    R,C,M = map(int,f_r.readline().split())\n    print(R,C,M)\n    if(boardHasZero(R,C,M)):\n        result = generateMineSweeperCase(R,C,M)\n    else :\n        result =\"\\nImpossible\"\n    print(result)\n    output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\n    f_w.write(output_str+'\\n')\n     \nf_r.close()"}
{"author": "elmoatasem", "index": 57, "filename": "2012_1460488_1595491.py", "code": "'''\nCreated on Apr 14, 2012\n \n@author: moatasem\n'''\n \n \ndef isSurprising(t):\n    if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):\n        return True\n    else:\n        return False\n \n \ndef getAllTriplets(n):\n    h=[]\n    for i in xrange(11):\n        for j in xrange(i,11):\n            for  k in xrange(j,11):\n                if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):\n                    h.append((i,j,k))\n             \n    return  h\n \ndef getInfo(p,total,S):\n    g= getAllTriplets(total)\n    #print total\n    #print g\n    if(S):\n        s_=len(g)\n        indcies=[]\n        for i in xrange (s_):\n            if(isSurprising(g[i])):\n                indcies.append(i)\n        for i in xrange (len(indcies)):  \n            g.remove(g[indcies[i]])\n    #print g\n    equ=False\n    sur=False\n    sur_equ=False\n    for i in xrange(len(g)):\n        if(max(g[i])>=p):\n            if(isSurprising(g[i])):\n                #print g[i]\n                sur_equ=True\n            else:\n                equ=True\n        elif(isSurprising(g[i])):\n                sur=True\n    return sur_equ,equ,sur\n            \nf = open(\"b_.in\", \"r\")\nn=int(f.readline().strip())\nfor k  in xrange(n):\n    d=f.readline().strip()\n    googlers=[]\n    g=[int(i) for i in d.split(\" \")]\n    N=g[0]\n    S=g[1]\n    noSu=False\n    if(S==0):\n        noSu=True\n    p=g[2]\n    count=0\n    equ_count=0;\n    both_count=0;\n    sur_count=0;\n    first_count=0;\n    googlers=g[3:len(g)]\n    for o in xrange(N):\n        info=getInfo(p,googlers[o],noSu)\n        #print info\n        if(info[0]==True and info[1]==False and S!=0): #101 /100\n            count+=1\n            S-=1\n        elif(info[0]==True and info[1]==True):#110 / 111\n            first_count+=1\n        elif(info[1]==True and info[2]==True):#011\n            both_count+=1\n        elif(info[1]==True):#010\n            count+=1\n        elif(info[2]==True):#001\n            sur_count+=1\n    count+=first_count\n    if(S>0):\n        if(first_count>S):\n            S=0\n        elif(first_count <=S) :\n            S-=first_count\n            if(S>0):\n                if(both_count>S):\n                    both_count-=S\n                    S=0\n                else:\n                    both_count=0\n    count+=both_count\n     \n    print ('Case #'+str((k+1))+\": \"+str(count))\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n     \\n \\n#f=getAllTriplets(18)\\n#print f\\n#for i in xrange(len(f)):\\n#    print isSurprising(f[i])"}
{"author": "elmoatasem", "index": 57, "filename": "2013_2270488_2453486.py", "code": "'''\nCreated on Apr 12, 2013\n \n@author: Moatasem\n'''\n \ndef getStatus(board):\n    status=\"\" \n    solved=False\n    n_dotted=0\n    #checking for columns and rows\n    for i in range(4):\n        result= checkBoard(board[i])\n        if(result!=\"None\"):\n            status=result\n            solved=True\n        else:\n            columnlist=[]\n            for j in range(4):\n                if(board[i][j]=='.'):\n                    n_dotted+=1\n                columnlist.append(board[j][i])\n            result= checkBoard(columnlist)\n            if(result!=\"None\"): \n                solved=True\n                status=result\n                break\n        if(solved):\n            break\n         \n    #checking for diagonals\n    result_l=checkBoard([board[x][x] for x in range(4)]) #leftDiagonal\n    result_r=checkBoard([board[0][3],board[1][2],board[2][1],board[3][0]]) #rightDiagonal\n    if(result_l!=\"None\"): \n            solved=True\n            status=result_l\n    if(result_r!=\"None\"): \n            solved=True\n            status=result_r\n                 \n    if(solved==False):\n        if(n_dotted==0):\n            status=\"Draw\"\n        else: \n            status=\"Game has not completed\"   \n \n    return status\n \n \ndef checkBoard(board):\n        status=\"None\"\n        x_count=board.count('X')\n        o_count=board.count('O')\n        t_count=board.count('T')\n        if(x_count==4 or (x_count==3 and t_count==1)):\n            status=\"X won\"\n        elif(o_count==4 or (o_count==3 and t_count==1)):\n            status=\"O won\"\n        return status\n \n \nf_r = open('A.in',\"r\")\nn_test=int(f_r.readline().strip()) \n \nf_w = open(\"A.out\", \"w\")\nfor i in range(n_test):\n    board=[]\n    for j in range(4):\n        board.append(f_r.readline().strip())\n    result= getStatus(board)\n    output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n    f_w.write(output_str+'\\n')\n    f_r.readline()\nf_r.close()\nf_w.close()\n"}
{"author": "elmoatasem", "index": 57, "filename": "2013_2270488_2449486.py", "code": "'''\nCreated on Apr 12, 2013\n \n@author: Moatasem\n'''\n \nimport math\n \n \n \n \ndef markMax(max_,start,end,marked,isRow,lawn):\n    for i in range(end):\n            if(isRow):\n                if( lawn[start][i]==max_):\n                    marked[start][i]=-1\n            else: \n                if( lawn[i][start]==max_):\n                    marked[i][start]=-1\n                     \n                 \n     \n     \ndef mowerLawn(lawn,m,n,marked):\n    #marked= [[0] *n]*m\n    for i in range(m):\n        max_=max(lawn[i])\n        markMax(max_,i,n,marked,True,lawn) \n     \n    for i in range(n):\n        colList=[]\n        for j in range(m):\n            colList.append(lawn[j][i])\n        max_=max(colList)\n        markMax(max_,i,m,marked,False,lawn) \n            \n    done=True\n    for i in range(m):\n        for j in range(n):\n            if(marked[i][j]!=-1):\n                done=False\n                break\n        if(not done):\n            break\n    if(done):\n        return 'YES'\n    else:\n        return 'NO'\n     \n         \n     \n \nf_r = open('B.in',\"r\")\nn_test=int(f_r.readline().strip()) \nf_w = open(\"B.out\", \"w\")\nfor i in range(n_test):\n    lawn=[]\n     \n    range_ =map(int,f_r.readline().split())\n    #marked= [[0] *range_[1]]*range_[0]\n    marked=[[0]*range_[1] for x in xrange(range_[0])]\n    for j in range(range_[0]):\n        temp=[map(int,f_r.readline().split())]\n        lawn.extend(temp)\n    result=mowerLawn(lawn,range_[0],range_[1],marked)\n    output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n    f_w.write(output_str+'\\n')\nf_r.close()\nf_w.close()"}
{"author": "elmoatasem", "index": 57, "filename": "2012_1460488_1483485.py", "code": "'''\nCreated on Apr 14, 2012\n \n@author: moatasem\n'''\nlan={'z':'q','q':'z',' ':' '}\\n \\ns1=list(\"ejp mysljylc kd kxveddknmc re jsicpdrysi\")\ne1=list (\"our language is impossible to understand\")\ns2=list(\"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\")\ne2=list (\"there are twenty six factorial possibilities\")\ns3=list(\"de kr kd eoya kw aej tysr re ujdr lkgc jv\")\ne3=list (\"so it is okay if you want to just give up\")\nfor i in xrange(len(s1)):\n    if(lan.get(s1[i])==None and s1[i]!=\" \"):\\n        lan[s1[i]]=e1[i]\\n    if(lan.get(s2[i])==None and s2[i]!=\" \"):\\n        lan[s2[i]]=e2[i]\\n    if(lan.get(s3[i])==None and s3[i]!=\" \"):\\n        lan[s3[i]]=e3[i]\\n         \\nf = open(\"A-small-attempt0.in\", \"r\")\nn=int(f.readline().strip())\nfor i  in xrange(n):\n    line=f.readline().strip()\n    res='Case #'+str((i+1))+\": \"\\n    for j in xrange(len(line)):\\n        res+=str(lan.get(line[j]))\\n    print(res)\\n         \\n     \\n \\n"}
{"author": "elmoatasem", "index": 57, "filename": "2013_2270488_2463486.py", "code": "'''\nCreated on Apr 12, 2013\n \n@author: Moatasem\n'''\n \nimport math\n \n \ndef isPalindrome(word):\n    isPalin=False\n    if(len(word)%2==0):\n        f_half=word[0:len(word)/2];\n        s_half=word[len(word)/2:len(word)][::-1]\n        if( f_half==s_half):\n            isPalin= True\n    else:\n        f_half=word[0:len(word)/2]\n        s_half=word[(len(word)/2)+1:len(word)][::-1]\n        if( f_half==s_half):\n            isPalin= True\n    return isPalin\n     \ndef getNumberOfFairAndSquare(range_):\n    start=range_[0]\n    end=range_[1]\n    count_=0\n    for i in range(start,end+1):\n        root=math.sqrt(i);\n        if(root.is_integer() and isPalindrome(str(int(root))) and isPalindrome(str(i))):\n            count_+=1\n    return count_\n         \n         \n     \n \nf_r = open('C.in',\"r\")\nn_test=int(f_r.readline().strip()) \nf_w = open(\"C.out\", \"w\")\nfor i in range(n_test):\n    range_ =map(int,f_r.readline().split())\n    result=getNumberOfFairAndSquare(range_)\n    output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n    f_w.write(output_str+'\\n')\nf_r.close()\nf_w.close()"}
{"author": "elmoatasem", "index": 57, "filename": "2014_2974486_5756407898963968.py", "code": "'''\nCreated on Apr 11, 2014\n \n@author: mostasem\n'''\n \n \n \ndef getIntersection(A,B):\n    intersect_list = []\n    dict = {};\n    for i in range(4):\n        if(dict.get(A[i]) != None):\n            dict[A[i]] += 1\n            if(intersect_list.count(A[i]) == 0):\n                intersect_list.append(A[i])\n        else:\n            dict[A[i]] = 1\n        if(dict.get(B[i]) != None):\n            dict[B[i]] += 1\n            if(intersect_list.count(B[i]) == 0):\n                intersect_list.append(B[i])\n        else:\n            dict[B[i]] = 1\n \n    return intersect_list\n \nf_r = open('A.in',\"r\")\nn_test=int(f_r.readline().strip()) \nf_w = open(\"A.out\", \"w\")\nresult = \"\"\nfor i in range(n_test):\n    cards1 = []\n    row_index_1 = int(f_r.readline()) - 1\n    for j in range(4):\n        cards1.append(map(int,f_r.readline().split()))\n    cards2 = []\n    row_index_2 = int(f_r.readline()) - 1\n    for j in range(4):\n        cards2.append(map(int,f_r.readline().split())) \n#     print cards1 \n#     print cards2\n#     print cards1[row_index_1] ,cards2[row_index_2]\n    int_list =  getIntersection(cards1[row_index_1], cards2[row_index_2])\n#     print int_list\n    result = \"\"\n    if(len(int_list) == 0):\n        result = \"Volunteer cheated!\"\n    elif(len(int_list)  == 1):\n        result = str(int_list[0])\n    else:\n        result = \"Bad magician!\"\n    output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n    print (output_str)\n    f_w.write(output_str+'\\n')\nf_r.close()\nf_w.close()"}
{"author": "entropy", "index": 58, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/python\n \n#!/usr/bin/python\n \nfilename = \"B-small-attempt0.in\"\n# filename = \"sample.in\"\n \ninp = open(filename, \"rU\")\n \nn = int(inp.readline().strip())\n \nfor case in range(1, n + 1):\n    cost, freq, goal = map(float, inp.readline().strip().split(\" \"))\n    fac = 0.0\n    time = 0.0\n    test = lambda x: (goal/(2+(freq * (x + 1)))) + (cost /(2+(freq * x)))\n    test2 = lambda x: (goal/(2+(freq * x)))\n    while(test2(fac) > test(fac)):\n        # print(time)\n        time += cost/(2 + (freq *  fac))\n        fac += 1\n    time += goal/(2+(freq*fac))\n    print(\"Case #{}: {}\".format(case, time))\n"}
{"author": "entropy", "index": 58, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/python\nfrom copy import copy, deepcopy\n \ndef check_bounds(state, coord):\n    if coord[0] < 0 or coord[1] < 0:\n        return False\n    elif coord[0] > (len(state) - 1):\n        return False\n    elif coord[1] > (len(state[coord[0]]) - 1):\n        return False\n    else:\n        return True\n \ndef clear(state, coord):\n    for r in range(-1,2):\n        for c in range(-1,2):\n            row = coord[0] + r\n            col = coord[1] + c\n            if check_bounds(state, (row, col)):\n                state[row][col] = 0\n \ndef count(state):\n    return sum([sum(x) for x in state])\n \ndef state_print(state):\n    print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in state[0][1:]]))\n    for line in state[1:]:\n        print(\"\".join([\"*\"  if x else \".\" for x in line]))\n \ndef solve(state, mines):\n    prev_state = deepcopy(state)\n    for row in range(len(state)):\n        for col in range(len(state[row])):\n            new_state = deepcopy(state)\n            clear(new_state, (row, col))\n            c = count(new_state)\n            # print(c)\n            # state_print(state)\n            if(c < mines):\n                state = prev_state\n            elif( c == mines):\n                state_print(new_state)\n                return True\n            else:\n                if col == len(state[row]) -2:\n                    prev_state = deepcopy(state)\n                state = new_state\n    print(\"Impossible\")\n    return False\n \n \n \n \ndef main():\n    filename = \"C-small-attempt0.in\"\n    # filename = \"C-large.in\"\n    # filename = \"sample.in\"\n \n \n    inp = open(filename, \"rU\")\n \n    n = int(inp.readline().strip())\n \n    for case in range(1, n + 1):\n        R, C, M = map(int, inp.readline().strip().split(\" \"))\n        state = [[1 for x in range(C)] for y in range(R)]\n        print(\"Case #{}:\".format(case))\n        solve(state, M)\n    # state = [[1 for x in range(7)] for y in range(4)]\n    # solve(state, 13)\n \nmain()"}
{"author": "entropy", "index": 58, "filename": "2012_1460488_1595491.py", "code": "#data = [ [int(a) for a in i.split(\" \")] for i in open(\"small.data\",\"rU\").read().split(\"\\n\")]\ndata = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]\ncount = 0\nfor line in data[1:]:\n\tcount += 1\n\tsupps = line[1]\n\tscore = line[2]\n\tmaxes = 0\n\tnonsuptot = (score*3)-2\n\tsuptot = (score*3)-4\n\tif suptot < 0:\n\t\tsuptot = 1\n\tfor i in range(3,(len(line))):\n\t\tif line[i] >= nonsuptot:\n\t\t\tmaxes += 1\n\t\t\tcontinue\n\t\tif (line[i] >= suptot) and (supps > 0):\n\t\t\tmaxes += 1\n\t\t\tsupps -= 1\n\tif score == 0:\n\t\tmaxes = line[0]\n\tprint((\"Case #\"+str(count)+\":\", maxes))\n \t\t\n \t\t\t\n \n \n \n \n"}
{"author": "entropy", "index": 58, "filename": "2013_2270488_2453486.py", "code": "\n \ninfile = open('A-small-attempt0.in', 'Ur').read()[1:].split('\\n\\n')\n \ncase = 1\nfor test in infile:\n    test = test.replace('\\n','')\n    sets = []\n    if not test:\n        break\n \n    r = 0\n    for i in range(4):\n        sets.append(test[i::4])\n        sets.append(test[r:r+4])\n        r = r+4\n    sets.append(test[0] + test[5] + test[10] + test[15])\n    sets.append(test[3] + test[6] + test[9] + test[12])\n \n    sets = [set(x) for x in sets]\n    winner = ''\n    for i in sets:\n        if i.issubset({'X', 'T'}):\n            winner = 'X'\n            break\n        if i.issubset({'O', 'T'}):\n            winner = 'O'\n            break\n \n    if winner:\n        print(\"Case #{0}: {1} won\".format(case, winner))\n    else:\n        if '.' in test:\n            print(\"Case #{0}: Game has not completed\".format(case))\n        else:\n            print(\"Case #{0}: Draw\".format(case))\n    case += 1\n \n"}
{"author": "entropy", "index": 58, "filename": "2013_2270488_2449486.py", "code": "\ndef check(grid):\n    if len(grid) <= 1 or len(grid[0]) <= 1:\n        return True\n    for r in range(len(grid)-1):\n        for c in range(len(grid[r])-1):\n            e1 = grid[r][c]\n            e2 = grid[r][c+1]\n            e3 = grid[r+1][c]\n            e4 = grid[r+1][c+1]\n            if (e1 > e2 and e4 > e2) or (e1 > e3 and e4 > e3):\n                return False\n            if (e2 > e1 and e3 > e1) or (e2 > e4 and e3 > e4):\n                return False\n    return True\n \ndef removeG(grid):\n    for i in range(len(grid)):\n        if len(set(grid[i])) == 1 and grid[i][0] == 1 :\n            del grid[i]\n            return True\n    return False\n \ninfile = open('B-small-attempt5.in', 'Ur')\n#infile = open('test3.in', 'Ur')\n \ntests = int(infile.readline().strip())\n \nfor t in range(tests):\n    grid = []\n    h, w = [int(x) for x in infile.readline().strip().split()]\n    for i in range(h):\n        row =[int(x) for x in infile.readline().strip().split()]\n        grid.append(row)\n \n    pass1 = check(grid)\n    print(\"------\")\n    for r in grid:\n        print(\" \".join([str(x) for x in r]))\n    while len(grid) >= 3:\n        if not removeG(grid):\n            break\n \n    pass2 = check(grid)\n    grid = [x for x in zip(*grid[::-1])]\n    while len(grid) >= 3:\n        if not removeG(grid):\n            break\n    print(\"------\")\n    for r in grid:\n        print(\" \".join([str(x) for x in r]))\n    pass3 = check(grid)\n \n \n#   if len(grid) >= 3:\n#       grid = [row for row in grid if len(set(row)) != 1]\n#   print(\"------\")\n#   for r in grid:\n#       print(\" \".join([str(x) for x in r]))\n \n    if pass1 and pass2 and pass3:\n        res = 'YES'\n    else:\n        res = 'NO'\n \n    print(\"Case #{0}: {1}\".format(t+1,res))\n \n \n"}
{"author": "entropy", "index": 58, "filename": "2012_1460488_1483485.py", "code": "mapp = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm','q':'z','z':'q'}\ninput = open(\"A-small-attempt0.in\", \"rU\").readlines()\ncounter = 0\nfor a in input[1:]:\n\tcounter += 1\n\toutline = a.replace(\"\\n\",'')\n\toutline2 = []\n\tfor i in outline:\n\t\toutline2.append(mapp[i])\n\tprint((\"Case #\"+str(counter)+\":\",''.join(outline2)))\n \n"}
{"author": "entropy", "index": 58, "filename": "2013_2270488_2463486.py", "code": "\ndef ispal(num):\n    num = str(num)\n    if num == num[::-1]:\n        return True\n    else:\n        return False\n \ndef test(bot, top):\n    count = []\n    for i in range(bot,top+1):\n        if not ((int(i**0.5)**2) == i):\n            continue\n        if ispal(i) and ispal(int(i**0.5)):\n            count.append(i)\n    return len(count)\n \ncase = 1\nfor line in open('C-small-attempt2.in', 'Ur'):\n    if ' ' in line:\n        a,b = line.split()\n        res = test(int(a),int(b))\n        print(\"Case #{0}: {1}\".format(case, res))\n        case += 1\n \n \n"}
{"author": "entropy", "index": 58, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python\n \nfilename = \"A-small-attempt0.in\"\n \ninp = open(filename, \"rU\")\n \nn = int(inp.readline().strip())\n \nfor case in range(1, n+1):\n    gr = lambda x: [list(map(int, inp.readline().strip().split(\" \"))) for p in range(4)][x-1]\n    ans1 = int(inp.readline().strip())\n    row1 = set(gr(ans1))\n    ans2 = int(inp.readline().strip())\n    row2 = set(gr(ans2))\n    sect = row1 & row2\n    if len(sect) <= 0:\n        print(\"Case #{}: Volunteer cheated!\".format(case))\n    elif len(sect) == 1:\n        print(\"Case #{}: {}\".format(case, sect.pop()))\n    elif len(sect) > 1:\n        print(\"Case #{}: Bad magician!\".format(case))\n    else:\n        print(\"ERROR\")\n"}
{"author": "nlse", "index": 59, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\nimport string\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \nfor i in range(num):\n    c, e, x = [float(x) for x in f.readline().split()]\n    n = int((x*e-2*c)/(c*e))\n    if n < 0:\n        n = 0\n    t = 0\n    for j in range(n):\n        t += c/(2+j*e)\n    t += x/(2+n*e)\n    print('Case #{}: {}'.format(i+1, t))\n"}
{"author": "nlse", "index": 59, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\nimport string\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \ndef count(z, r, c):\n    return len(z_and_nei(z,r,c))\n \ndef nei(z, r, c):\n    s = z_and_nei(z, r, c)\n    s -= set(z)\n    return s\n \ndef z_and_nei(z, r, c):\n    s = set()\n    for x in z:\n        s.add(x)\n        s.add((x[0]-1,x[1]-1))\n        s.add((x[0]-1,x[1]))\n        s.add((x[0]-1,x[1]+1))\n        s.add((x[0],x[1]-1))\n        s.add((x[0],x[1]+1))\n        s.add((x[0]+1,x[1]-1))\n        s.add((x[0]+1,x[1]))\n        s.add((x[0]+1,x[1]+1))\n    o = set()\n    for x in s:\n        if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\n            o.add(x)\n    s-=o\n    return s\n \ndef find_config(z, r, c, t):\n    if count(z,r,c) == t:\n        return z\n    if count(z,r,c) > t:\n        return []\n    n = nei(z,r,c)\n    for x in n:\n        z.append(x)\n        if find_config(z,r,c,t) != []:\n            return z\n        z.pop()\n    return []\n \nfor i in range(num):\n    print('Case #{}:'.format(i+1))\n    r, c, m = [int(x) for x in f.readline().split()]\n    if r*c-m == 1:\n        print('c' + '*'*(c-1))\n        for i in range(r-1):\n            print('*'*c)\n    else:\n        z = find_config([(0,0)], c, r, c*r-m)\n        if z == []:\n            print(\"Impossible\")\n        else:\n            s = z_and_nei(z, c, r)\n            for j in range(r):\n                for k in range(c):\n                    if j == 0 and k == 0:\n                        print('c',)\n                    elif (k,j) in s:\n                        print('.',)\n                    else:\n                        print('*',)\n                print( )\n"}
{"author": "nlse", "index": 59, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \nfor i in range(num):\n    res = [int(x) for x in f.readline().split()]\n    nrg, nrsup, score = res[0:3]\n    del res[0:3]\n    #print(nrg, nrsup, score, res)\n    nrpass = 0\n    nrsuppass = 0\n    for x in res:\n        if score > 1:\n            if x >= 3*score-2:\n                nrpass += 1\n            elif x >= 3*score-4:\n                nrsuppass += 1\n        elif score == 1:\n            if x > 0:\n                nrpass += 1\n        else:\n            nrpass +=1\n    print('Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass))\n"}
{"author": "nlse", "index": 59, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\nimport string\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \ndef check(x, mat):\n    for i in range(4):\n        row = True\n        col = True\n        for j in range(4):\n            if not (mat[i][j] == x or mat[i][j] == 'T'):\n                row = False\n            if not (mat[j][i] == x or mat[j][i] == 'T'):\n                col = False\n        if row or col:\n            return True\n    diag1 = True\n    diag2 = True\n    for i in range(4):\n        if not (mat[i][i] == x or mat[i][i] == 'T'):\n            diag1 = False\n        if not (mat[3-i][i] == x or mat[3-i][i] == 'T'):\n            diag2 = False\n    if diag1 or diag2:\n        return True\n    return False\n \ndef fin(mat):\n    for i in range(4):\n        for j in range(4):\n            if mat[i][j] == '.':\n                return False\n    return True\n \nfor i in range(num):\n    mat = []\n    for j in range(4):\n        mat.append(list(f.readline().strip()))\n    f.readline()\n    #print(mat)\n    #print(check('X', mat), check('O', mat))\n    if check('X', mat):\n        print('Case #{}: X won'.format(i+1))\n    elif check('O', mat):\n        print('Case #{}: O won'.format(i+1))\n    elif fin(mat):\n        print('Case #{}: Draw'.format(i+1))\n    else:\n        print('Case #{}: Game has not completed'.format(i+1))\n"}
{"author": "nlse", "index": 59, "filename": "2013_2270488_2449486.py", "code": "#!/usr/bin/python\n \nimport sys\nimport math\nimport copy\nimport operator\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \nfor i in range(num):\n    l = f.readline()\n    n,m = l.split()\n    n = int(n)\n    m = int(m)\n    lawn = []\n    seen = []\n    for j in range(n):\n        l = f.readline()\n        lawn.append([int(x) for x in l.split()])\n        seen.append([False]*m)\n    #print(lawn)\n    l = []\n    for j in range(n):\n        for k in range(m):\n            l.append((lawn[j][k], (j,k)))\n    l.sort(key=operator.itemgetter(0))\n    #print(l)\n    ok = True\n    for x in l:\n        if seen[x[1][0]][x[1][1]]:\n            continue\n        row = True\n        for j in range(n):\n            if not (seen[j][x[1][1]] or lawn[j][x[1][1]] <= lawn[x[1][0]][x[1][1]]):\n                row = False\n                break\n        if(row):\n            for j in range(n):\n                seen[j][x[1][1]] = True\n            continue\n        col = True\n        for j in range(m):\n            if not (seen[x[1][0]][j] or lawn[x[1][0]][j] <= lawn[x[1][0]][x[1][1]]):\n                col = False\n                break\n        if(col):\n            for j in range(m):\n                seen[x[1][0]][j] = True\n            continue\n        ok = False\n        break\n    if ok:\n        print('Case #{}: YES'.format(i+1))\n    else:\n        print('Case #{}: NO'.format(i+1))\n"}
{"author": "nlse", "index": 59, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\nimport string\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \nfor i in range(num):\n    s = f.readline().strip()\n    t = s.translate(string.maketrans(\"yeqjpmslckdxvnribtahwfougz\",\n        \"aozurlngeismpbtdhwyxfckjvq\"))\n    #print('Case #{}:'.format(i+1), s)\n    print('Case #{}:'.format(i+1), t)\n"}
{"author": "nlse", "index": 59, "filename": "2013_2270488_2463486.py", "code": "#!/usr/bin/python\n \nimport sys\nimport math\nimport copy\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \ndef pal(x):\n    l = list(str(x))\n    l2 = copy.copy(l)\n    l2.reverse()\n    return l == l2\n \nfor i in range(num):\n    count = 0\n    line = f.readline()\n    a,b = line.split()\n    a = int(a)\n    b = int(b)\n    ma = int(math.sqrt(a))\n    mb = int(math.sqrt(b))+1\n    #print(a,b)\n    for j in range(ma,mb+1):\n        q = j*j\n        if q < a or q > b:\n            continue\n        #print(i*i)\n        if pal(j) and pal(q):\n            #print(i,q)\n            count += 1\n    print('Case #{}:'.format(i+1), count)\n"}
{"author": "nlse", "index": 59, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\nimport string\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \nfor i in range(num):\n    q1 = int(f.readline())\n    for j in range(4):\n        if j+1 == q1:\n            line1 = f.readline()\n        else:\n            f.readline()\n    q2 = int(f.readline())\n    for j in range(4):\n        if j+1 == q2:\n            line2 = f.readline()\n        else:\n            f.readline()\n    line1 = [int(x) for x in line1.split()]\n    line2 = [int(x) for x in line2.split()]\n    count = 0\n    for x in line1:\n        if x in line2:\n            count += 1\n            y = x\n    if count == 0:\n        print('Case #{}: Volunteer cheated!'.format(i+1))\n    elif count == 1:\n        print('Case #{}: {}'.format(i+1, y))\n    else:\n        print('Case #{}: Bad magician!'.format(i+1))\n"}
{"author": "hannanaha", "index": 60, "filename": "2014_2974486_5709773144064000.py", "code": "import os\nimport time\nimport decimal\nimport functools\n \n#===============================================================================\n# Generic helpers\n#===============================================================================\n# TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict\n \n#EOL = os.linesep - using this causes weird \\r\\r\\n problems\nEOL = \"\\n\"\n \n# ------------------------------------------------------------------------------\n \ndef is_equal_approx(x, y, epsilon=1e-6):\n    \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n     \n    By default, 'epsilon' is 1e-6.\n    \"\"\"\n    # Check absolute precision.\n    if -epsilon <= x - y <= epsilon:\n        return True\n \n    # Is x or y too close to zero?\n    if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n        return False\n \n    # Check relative precision.\n    return (-epsilon <= (x - y) / x <= epsilon\n        or -epsilon <= (x - y) / y <= epsilon)\n   \ndef read_syms(fd):\n    \"\"\"Read a line of whitespace separated symbols.\"\"\"\n    return fd.readline().strip().split()\n \ndef read_ints(fd):\n    \"\"\"Read a line of whitespace separated integers.\"\"\"\n    return [int(p) for p in read_syms(fd)]\n \ndef read_floats(fd):\n    \"\"\"Read a line of whitespace separated floats.\"\"\"\n    return [float(p) for p in read_syms(fd)]\n \n# ------------------------------------------------------------------------------\n \nclass Mtrx(object):\n    \"\"\"A matrix object.\"\"\"\n     \n    def __init__(self, rows, cols, data):\n        assert len(data) == rows * cols\n        self.rows = rows\n        self.cols = cols\n        self.data = data\n         \n    def cell(self, r, c):\n        return self.data[r * self.cols + c]\n     \n    def getrow(self, i):\n        return [self.cell(i, c) for c in xrange(self.cols)]\n \n    def getcol(self, i):\n        return [self.cell(c, i) for c in xrange(self.rows)]\n     \n    @classmethod\n    def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n        \"\"\"Read matrix from file, assuming first line at location is `R C`.\n         \n        Return a new Mtrx object. Reading values is performed by the `readfunc`.\n        Pre-determined size can be passed using `rows` and `cols`.\n        \"\"\"\n        data = []\n        if rows is None:\n            assert cols is None\n            rows, cols = read_ints(fd)\n        else:\n            assert cols is not None\n        for _ in range(rows):\n            line = readfunc(fd)\n            assert len(line) == cols\n            data.extend(line)\n        return Mtrx(rows, cols, data)\n             \n    @classmethod\n    def read_int_matrix(cls, fd, rows=None, cols=None):\n        return cls.readfromfile(fd, read_ints, rows, cols)\n             \n    @classmethod\n    def read_sym_matrix(cls, fd, rows=None, cols=None):\n        return cls.readfromfile(fd, read_syms, rows, cols)\n             \n    def __str__(self):\n        res = \"\"\n        for i in xrange(self.rows):\n            res += str(self.getrow(i)) + EOL\n        return res\n     \n    def __repr__(self):\n        return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                        self.cols, self.data)\n \n# ------------------------------------------------------------------------------\n \ncachetotals = 0\ncachemisses = 0\n \ndef statreset():\n    global cachemisses, cachetotals\n    cachemisses = 0\n    cachetotals = 0\n \nclass memoizeit(object):\n    \"\"\"Decorator. Caches a function's return value each time it is called.\n     \n    If called later with the same arguments, the cached value is returned \n    (not reevaluated).\n    \"\"\"\n     \n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n         \n    def __call__(self, *args):\n         \n        # update stats\n        global cachetotals, cachemisses\n        cachetotals += 1\n         \n        try:\n            return self.cache[args]\n        except KeyError:\n             \n            # update stats\n            cachemisses += 1\n             \n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n \n            # update stats\n            cachemisses += 1\n \n            # uncachable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n     \n    @property\n    def __name__(self):\n        return self.func.__name__\n     \n    def __get__(self, obj, objtype):\n        \"\"\"Support instance methods.\"\"\"\n        return functools.partial(self.__call__, obj)\n \n# ------------------------------------------------------------------------------\n \nclass timeit(object):\n    \"\"\"Decorator that times a function.\n     \n    When function ends, print name, runtime, return value and cache stats.\n    \"\"\"\n     \n    def __init__(self, func):\n        self.func = func\n         \n    def __call__(self, *args):\n        start = time.time()\n        value = self.func(*args)\n        delta = time.time() - start\n        cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n            cachetotals else 0\n        print (self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n            delta, value, cachedata))\n        return value\n     \n    def __get__(self, obj, objtype):\n        return functools.partial(self.__call__, obj)\n \n#===============================================================================\n# Input/output\n#===============================================================================\n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r\") as f:\n        cases = read_ints(f)[0]\n        # =============================================\n        for _ in xrange(cases):\n            case = {}\n            case[\"C\"], case[\"F\"], case[\"X\"] = read_floats(f)\n            data.append(case)\n        # =============================================\n    return data\n \ndef make_output(fname, output):\n    CASE_PRFX = \"Case #%s: \"\n    fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n    with open(fname, \"w\") as f:\n        restext = []\n        print (\"Output content ===============\")\n        # =============================================\n        for i, outdata in enumerate(output):\n            line = CASE_PRFX % (i + 1,) + str(outdata) + EOL\n            print (line),\n            restext.append(line)\n        # =============================================\n        print (\"=\" * 30)\n        f.writelines(restext)\n \n#===============================================================================\n# Actual solution\n#===============================================================================\n \n@memoizeit\ndef will_a_farm_help(target, current_rate, farm_cost, farm_rate):\n    no_farm = target / current_rate\n    with_farm = farm_cost / current_rate + target / (farm_rate + current_rate)\n    if no_farm > with_farm:\n        return True, farm_cost / current_rate\n    else:\n        return False, no_farm\n \n@timeit\ndef solveit(case):\n    C = case[\"C\"]\n    F = case[\"F\"]\n    X = case[\"X\"]\n     \n    t = 0\n    current_rate = 2.0 # default rate of 2 cookies per seconds\n     \n    while True:\n        new_farm, add_time = will_a_farm_help(X, current_rate, C, F)\n        if new_farm:\n            t += add_time\n            current_rate += F\n        else:\n            t += add_time\n            return t\n \n#===============================================================================\n# Main\n#===============================================================================\n \n@timeit\ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for case in data:\n        statreset() # reset cache stats\n        # =============================================\n        res = solveit(case)\n        output.append(res)\n        # =============================================\n    make_output(fname, output)\n \n \nif __name__ == '__main__':\n#    main(\"sample.in\")\n    main(\"B-small-attempt0.in\")\n#    main(\"B-large.in\")\n#    main(\"B-small-attempt0.in\")\n#    main(\"A-large.in\")"}
{"author": "hannanaha", "index": 60, "filename": "2014_2974486_5690574640250880.py", "code": "import os\nimport time\nimport decimal\nimport functools\n \n#===============================================================================\n# Generic helpers\n#===============================================================================\n# TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict\n \n#EOL = os.linesep - using this causes weird \\r\\r\\n problems\nEOL = \"\\n\"\n \n# ------------------------------------------------------------------------------\n \ndef is_equal_approx(x, y, epsilon=1e-6):\n    \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n     \n    By default, 'epsilon' is 1e-6.\n    \"\"\"\n    # Check absolute precision.\n    if -epsilon <= x - y <= epsilon:\n        return True\n \n    # Is x or y too close to zero?\n    if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n        return False\n \n    # Check relative precision.\n    return (-epsilon <= (x - y) / x <= epsilon\n        or -epsilon <= (x - y) / y <= epsilon)\n   \ndef read_syms(fd):\n    \"\"\"Read a line of whitespace separated symbols.\"\"\"\n    return fd.readline().strip().split()\n \ndef read_ints(fd):\n    \"\"\"Read a line of whitespace separated integers.\"\"\"\n    return [int(p) for p in read_syms(fd)]\n \ndef read_floats(fd):\n    \"\"\"Read a line of whitespace separated floats.\"\"\"\n    return [float(p) for p in read_syms(fd)]\n \n# ------------------------------------------------------------------------------\n \nclass Mtrx(object):\n    \"\"\"A matrix object.\"\"\"\n     \n    def __init__(self, rows, cols, data):\n        assert len(data) == rows * cols\n        self.rows = rows\n        self.cols = cols\n        self.data = data\n         \n    def cell(self, r, c):\n        return self.data[r * self.cols + c]\n     \n    def getrow(self, i):\n        return [self.cell(i, c) for c in xrange(self.cols)]\n \n    def getcol(self, i):\n        return [self.cell(c, i) for c in xrange(self.rows)]\n     \n    @classmethod\n    def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n        \"\"\"Read matrix from file, assuming first line at location is `R C`.\n         \n        Return a new Mtrx object. Reading values is performed by the `readfunc`.\n        Pre-determined size can be passed using `rows` and `cols`.\n        \"\"\"\n        data = []\n        if rows is None:\n            assert cols is None\n            rows, cols = read_ints(fd)\n        else:\n            assert cols is not None\n        for _ in range(rows):\n            line = readfunc(fd)\n            assert len(line) == cols\n            data.extend(line)\n        return Mtrx(rows, cols, data)\n             \n    @classmethod\n    def read_int_matrix(cls, fd, rows=None, cols=None):\n        return cls.readfromfile(fd, read_ints, rows, cols)\n             \n    @classmethod\n    def read_sym_matrix(cls, fd, rows=None, cols=None):\n        return cls.readfromfile(fd, read_syms, rows, cols)\n             \n    def __str__(self):\n        res = \"\"\n        for i in xrange(self.rows):\n            res += str(self.getrow(i)) + EOL\n        return res\n     \n    def __repr__(self):\n        return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                        self.cols, self.data)\n \n# ------------------------------------------------------------------------------\n \ncachetotals = 0\ncachemisses = 0\n \ndef statreset():\n    global cachemisses, cachetotals\n    cachemisses = 0\n    cachetotals = 0\n \nclass memoizeit(object):\n    \"\"\"Decorator. Caches a function's return value each time it is called.\n     \n    If called later with the same arguments, the cached value is returned \n    (not reevaluated).\n    \"\"\"\n     \n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n         \n    def __call__(self, *args):\n         \n        # update stats\n        global cachetotals, cachemisses\n        cachetotals += 1\n         \n        try:\n            return self.cache[args]\n        except KeyError:\n             \n            # update stats\n            cachemisses += 1\n             \n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n \n            # update stats\n            cachemisses += 1\n \n            # uncachable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n     \n    @property\n    def __name__(self):\n        return self.func.__name__\n     \n    def __get__(self, obj, objtype):\n        \"\"\"Support instance methods.\"\"\"\n        return functools.partial(self.__call__, obj)\n \n# ------------------------------------------------------------------------------\n \nclass timeit(object):\n    \"\"\"Decorator that times a function.\n     \n    When function ends, print name, runtime, return value and cache stats.\n    \"\"\"\n     \n    def __init__(self, func):\n        self.func = func\n         \n    def __call__(self, *args):\n        start = time.time()\n        value = self.func(*args)\n        delta = time.time() - start\n        cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n            cachetotals else 0\n        print (self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n            delta, value, cachedata))\n        return value\n     \n    def __get__(self, obj, objtype):\n        return functools.partial(self.__call__, obj)\n \n#===============================================================================\n# Input/output\n#===============================================================================\n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r\") as f:\n        cases = read_ints(f)[0]\n        # =============================================\n        for _ in xrange(cases):\n            case = {}\n            case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\n            data.append(case)\n        # =============================================\n    return data\n \ndef make_output(fname, output):\n    CASE_PRFX = \"Case #%s: \"\n    fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n    with open(fname, \"w\") as f:\n        restext = []\n        print (\"Output content ===============\")\n        # =============================================\n        for i, outdata in enumerate(output):\n            line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\n            print (line),\n            restext.append(line)\n        # =============================================\n        print (\"=\" * 30)\n        f.writelines(restext)\n \n#===============================================================================\n# Actual solution\n#===============================================================================\n \nMINE = \"*\"\nCLICK = \"c\"\nUNK = \".\"\n \nclass Board(object):\n     \n    def __init__(self, r, c):\n        self.rows = r\n        self.cols = c\n        self.edge_row_idx = self.rows - 1\n        self.edge_col_idx = self.cols - 1\n        self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\n        self.board[0][0] = CLICK\n \n    def fill_edge_row(self, m):\n        i = self.edge_col_idx\n        while m > 0 and i >= 0:\n            self.board[self.edge_row_idx][i] = MINE\n            i -= 1\n            m -= 1\n        self.edge_row_idx -= 1\n \n    def fill_edge_col(self, m):\n        i = self.edge_row_idx\n        while m > 0 and i >= 0:\n            self.board[i][self.edge_col_idx] = MINE\n            i -= 1\n            m -= 1\n        self.edge_col_idx -= 1\n \n    def __str__(self):\n        return EOL.join([\"\".join(r) for r in self.board])\n \n@memoizeit\ndef is_stage_solvable(rows, cols, mines):\n    \"\"\"Return True iff stage is solvable. \n    Also return fill instruction:\n    0 if impossible/dontcare, 1 to fill row, 2 to fill column, \n    3 for row special (most in the row), 4 for col special (most in the col)\n    \"\"\"\n    rc = rows * cols\n     \n    # all full\n    if mines == rc:\n        return False, 0\n \n    if rows == 1:\n        return mines <= rc - 1, 2\n    if cols == 1:\n        return mines <= rc - 1, 1\n     \n    # rows and cols > 1\n    # single cell in corner   \n    if mines == rc - 1:\n        return True, 1  # doesn't matter what to fill\n     \n    # won't find 4 cells for the corner\n    if mines > rc - 4:\n        return False, 0\n     \n    if rows == 2:\n        return (False, 0) if mines == 1 else (True, 2)\n    if cols == 2:\n        return (False, 0) if mines == 1 else (True, 1)\n         \n    # rows and cols > 2\n    if rows <= cols:\n        # try to fill columns\n        if mines >= rows:\n            return True, 2\n        if mines == rows - 1:\n            if mines == cols - 1:\n                if rows == 3:\n                    return False, 0\n                return True, 4 # L shape fill, most in the column\n            else:\n                return True, 1 # fill row\n        return True, 2 \n    else:\n        # try to fill rows\n        if mines >= cols:\n            return True, 1\n        if mines == cols - 1:\n            if mines == rows - 1:\n                if cols == 3:\n                    return False, 0\n                return True, 3 # L shape fill, most in the row\n            else:\n                return True, 2 # fill column\n        return True, 1 \n \n@timeit\ndef solveit(case):\n    rows = case[\"R\"]\n    cols = case[\"C\"]\n    mines = case[\"M\"]\n     \n    b = Board(rows, cols)\n    r, c, m = rows, cols, mines\n     \n    while m >= 0:\n        okgo, howtofill = is_stage_solvable(r, c, m)\n        if not okgo:\n            return \"Impossible\"\n        if howtofill == 1: # fill row\n            b.fill_edge_row(m)\n            if m <= c:\n                break # fill and done\n            m -= c\n            r -= 1\n        elif howtofill == 2: # fill column\n            b.fill_edge_col(m)\n            if m <= r:\n                break # fill and done\n            m -= r\n            c -= 1\n        elif howtofill == 3: # L shape fill, most in the row\n            b.fill_edge_row(m - 1)\n            b.fill_edge_col(1)\n            break # fill and done\n        elif howtofill == 4: # L shape fill, most in the column\n            b.fill_edge_col(m - 1)\n            b.fill_edge_row(1)\n            break # fill and done\n        else:\n            assert False\n \n    return str(b) \n \n \n#===============================================================================\n# Main\n#===============================================================================\n \n@timeit\ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for case in data:\n        statreset() # reset cache stats\n        # =============================================\n        res = solveit(case)\n        output.append(res)\n        # =============================================\n    make_output(fname, output)\n \n \nif __name__ == '__main__':\n#    main(\"sample.in\")\n    main(\"C-small-attempt0.in\")\n#    main(\"B-large.in\")\n#    main(\"B-small-attempt0.in\")\n#    main(\"A-large.in\")"}
{"author": "hannanaha", "index": 60, "filename": "2012_1460488_1595491.py", "code": "import math\n \nOEXT = \".out\"\nIN_S = \"small.in\"\nIN_L = \"large.in\"\nCASE_PRFX = \"Case #%s: \"\n \n \ndef avg(L):\n    return 1.0*sum(L)/len(L)\n \ntriplets = [[0,0,0], [0,0,1], [0,1,1], \n            [0,0,2], [0,2,2], [0,1,2],\n            [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],\n            ]\n \ndef analyze_sum(sm, tgt):\n    av = 1.0 * sm / 3\n    av_cls = av % 1\n \n    #assume non surprising\n    if av_cls > 0.1:\n        ns_max_val = math.ceil(av)\n    else:\n        ns_max_val = av \n     \n    #assume surprising\n    s_max_val = 0 \n    if sm >= 2 and sm <= 28:\n        if av_cls > 0.5:\n            s_max_val = math.ceil(av) + 1\n        elif av_cls > 0.1:\n            s_max_val = math.ceil(av) \n        else:\n            s_max_val = av + 1\n     \n    if ns_max_val >= tgt:\n        res = [ns_max_val, None]\n        kind = 1\n    elif s_max_val < tgt:\n        res = [None, None]\n        kind = 0\n    else:\n        res = [None, s_max_val]\n        kind = 2\n         \n    print(sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind)\n    return res, kind\n \ndef analyze_triplet(trip, tgt):\n    sm = sum(trip)\n    analyze_triplet(sm, tgt)\n     \n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r\") as f:\n        cases = int(f.readline())\n        for _ in xrange(cases):\n            case = f.readline().strip().split()\n            case = [int(c) for c in case]\n            data.append({\"ngoog\": case[0], \"ssurp\": case[1], \"ptgt\": case[2],\n                        \"trips\": case[3:]})\n    return data\n \ndef make_output(fname, output):\n    fname = fname + OEXT\n    with open(fname, \"w\") as f:\n        restext = []\n        for i, v in enumerate(output):\n            restext.append(CASE_PRFX % (i+1,) + str(v) + \"\\n\")\n        f.writelines(restext)\n     \ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for case in data:\n        ansys = [analyze_sum(c, case[\"ptgt\"]) for c in case[\"trips\"]]\n        non_surp_is_enough = len([k for _, k in ansys if k == 1])\n        surp_needed = len([k for _, k in ansys if k == 2])\n        if surp_needed >= case[\"ssurp\"]:\n            res = non_surp_is_enough + case[\"ssurp\"]\n        else:\n            res = non_surp_is_enough + surp_needed\n        output.append(res)\n    print(\"output:\", output)\n    make_output(fname, output)\n      \n \nmain(\"examples.in\")\nmain(\"small.in\")"}
{"author": "hannanaha", "index": 60, "filename": "2013_2270488_2453486.py", "code": "from gcjbase import *\n \nXWON = \"X won\"\nOWON = \"O won\"\nDRAW = \"Draw\" \nNOTOVER = \"Game has not completed\"\n \n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r\") as f:\n        cases = read_ints(f)[0]\n        # =============================================\n        for _ in xrange(cases):\n            board = []\n            for _ in xrange(4):\n                board.extend(read_syms(f))\n            read_syms(f)\n            data.append(board)\n        # =============================================\n    return data\n \ndef make_output(fname, output):\n    CASE_PRFX = \"Case #%s: \"\n    fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n    with open(fname, \"w\") as f:\n        # =============================================\n        restext = []\n        for i, v in enumerate(output):\n            line = CASE_PRFX % (i+1,) + str(v) + \"\\n\"\n            print(line)\n            restext.append(line)\n        f.writelines(restext)\n        # =============================================\n \n# ----------------------------------------------------------------------\n \ndef getrow(board, i):\n    return board[i*4:4*i+4]\n \ndef getcol(board, i):\n    return [c for j, c in enumerate(board) if j % 4 == i ]\n \ndef getdiag(board, i):\n    if i == 0:\n        return board[0], board[5], board[10], board[15]\n    return board[3], board[6], board[9], board[12]\n \n@timeit\ndef solveit(case):\n    print(case)\n    xcase = [(c if c != 'T' else 'X') for c in case]\n    ocase = [(c if c != 'T' else 'O') for c in case]\n     \n    # rows\n    for i in range(4):\n        if all([x == 'X' for x in getrow(xcase, i)]):\n            return XWON\n        if all([x == 'O' for x in getrow(ocase, i)]):\n            return OWON\n         \n    # cols\n    for i in range(4):\n        if all([x == 'X' for x in getcol(xcase, i)]):\n            return XWON\n        if all([x == 'O' for x in getcol(ocase, i)]):\n            return OWON\n         \n    # diag\n    for i in range(2):\n        if all([x == 'X' for x in getdiag(xcase, i)]):\n            return XWON\n        if all([x == 'O' for x in getdiag(ocase, i)]):\n            return OWON\n         \n    if any([x == '.' for x in case]):\n        return NOTOVER\n    return DRAW\n         \n@timeit\ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for i, case in enumerate(data):\n        # =============================================\n        res = solveit(case)\n        output.append(res)\n        # =============================================\n    make_output(fname, output)\n \n \nif __name__ == '__main__':\n    #main(\"sample.in\")\n    main(\"small.in\")\n    #main(\"sample.in\")"}
{"author": "hannanaha", "index": 60, "filename": "2013_2270488_2449486.py", "code": "from gcjbase import *\n \nNO = \"NO\"\nYES = \"YES\"\n \n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r\") as f:\n        cases = read_ints(f)[0]\n        # =============================================\n        for _ in xrange(cases):\n            field = IntMatrix()\n            field.readfromfile(f)\n            data.append(field)\n        # =============================================\n    return data\n \ndef make_output(fname, output):\n    CASE_PRFX = \"Case #%s: \"\n    fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n    with open(fname, \"w\") as f:\n        # =============================================\n        restext = []\n        print(\"Output content ===============\")\n        for i, v in enumerate(output):\n            line = CASE_PRFX % (i+1,) + str(v) + \"\\n\"\n            print(line[:-1])\n            restext.append(line)\n        print(\"=\" * 30)\n        f.writelines(restext)\n        # =============================================\n \n# ----------------------------------------------------------------------\n \n@timeit\ndef solveit(case):\n    print(case)\n    for row in range(case.rows):\n        for col in range(case.cols):\n            cell = case.cell(row, col)\n            if (any([c > cell for c in case.getrow(row)]) and\n                any([c > cell for c in case.getcol(col)])):\n                return NO\n    return YES\n         \n@timeit\ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for i, case in enumerate(data):\n        # =============================================\n        res = solveit(case)\n        output.append(res)\n        # =============================================\n    make_output(fname, output)\n \n \nif __name__ == '__main__':\n#    main(\"sample.in\")\n    main(\"small.in\")\n    #main(\"large.in\")"}
{"author": "hannanaha", "index": 60, "filename": "2012_1460488_1483485.py", "code": "import string \n \nOEXT = \".out\"\nIN_S = \"small.in\"\nIN_L = \"large.in\"\nCASE_PRFX = \"Case #%s: \"\n \nddd = {}\n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r\") as f:\n        cases = int(f.readline())\n        for _ in xrange(cases):\n            code = f.readline()\n            data.append(code)\n    return data\n \ndef make_output(fname, output):\n    fname = fname + OEXT\n    with open(fname, \"w\") as f:\n        restext = []\n        for i, v in enumerate(output):\n            restext.append(CASE_PRFX % (i+1,) + v)\n        f.writelines(restext)\n     \ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for code in data:\n        output.append(\"\".join([ddd[k] for k in code]))\n    print(output)\n    make_output(fname, output)\n     \ndef mainex(fname):\n    with open(fname, \"r\") as f:\n        cases = int(f.readline())\n        for _ in xrange(cases):\n            code = f.readline()\n            trans = f.readline()\n            for i, c in enumerate(code):\n                ddd.setdefault(c, trans[i])\n     \n    abc = string.ascii_lowercase + \" \\n\"\n    for c in abc:\n        if c not in ddd.values():\n            print(\"not in trans:\", c)\n            missingt = c\n        if c not in ddd.keys():\n            print(\"not in code:\", c)\n            missingc = c\n    ddd.setdefault(missingc, missingt)\n    print(ddd)\n    print(len(ddd))\n    return ddd\n     \n     \n     \nmainex(\"examples.in\")\nmain(\"examples_raw.in\")\nmain(\"small.in\")"}
{"author": "hannanaha", "index": 60, "filename": "2013_2270488_2463486.py", "code": "import time\nimport os\nimport sys\nimport itertools\nimport functools\nimport math\n \n# ----------------------------------------------------------------------\n \ndef is_equal_approx(x, y, epsilon=1e-6):\n    \"\"\" Returns True iff y is within relative or absolute 'epsilon' of x.\n        By default, 'epsilon' is 1e-6.\n    \"\"\"\n    # Check absolute precision.\n    if -epsilon <= x - y <= epsilon:\n        return True\n \n    # Is x or y too close to zero?\n    if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n        return False\n \n    # Check relative precision.\n    return (-epsilon <= (x - y) / x <= epsilon\n        or -epsilon <= (x - y) / y <= epsilon)\n   \ndef read_syms(fd):\n    return [c for c in fd.readline().strip()]\n \ndef read_ints(fd):\n    return [int(p) for p in fd.readline().strip().split()]\n \ndef read_floats(fd):\n    return [float(p) for p in fd.readline().strip().split()]\n \nclass Mtrx(object):\n     \n    def __init__(self, readfunc):\n        self.readfunc = readfunc\n         \n    def cell(self, r, c):\n        return self.data[r * self.cols + c]\n     \n    def getrow(self, i):\n        return [self.cell(i, c) for c in range(self.cols)]\n \n    def getcol(self, i):\n        return [self.cell(c, i) for c in range(self.rows)]\n     \n    def readfromfile(self, fd):\n        self.data = []\n        self.rows, self.cols = read_ints(fd)\n        for _ in range(self.rows):\n            line = self.readfunc(fd)\n            assert len(line) == self.cols\n            self.data.extend(line)\n             \n    def __str__(self):\n        res = \"\"\n        for i in xrange(self.rows):\n            res += str(self.getrow(i)) + \"\\n\"\n        return res\n              \nclass IntMatrix(Mtrx):\n    def __init__(self):\n        super(IntMatrix, self).__init__(read_ints)\n \nclass SymMatrix(Mtrx):\n    def __init__(self):\n        super(IntMatrix, self).__init__(read_syms)\n \nclass memoizeit(object):\n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n         \n    def __call__(self, *args):\n        try:\n            return self.cache[args]\n        except KeyError:\n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n            return self.func(*args)\n     \n    @property\n    def __name__(self):\n        return self.func.__name__\n     \n    def __get__(self, obj, objtype):\n        return functools.partial(self.__call__, obj)\n \nclass timeit(object):\n    def __init__(self, func):\n        self.func = func\n    def __call__(self, *args):\n        start = time.time()\n        value = self.func(*args)\n        delta = time.time() - start\n        print(self.func.__name__, \"{:7.3f}s, (res: {})\".format(delta, value))\n        return value\n    def __get__(self, obj, objtype):\n        return functools.partial(self.__call__, obj)\n \n# ----------------------------------------------------------------------\n"}
{"author": "hannanaha", "index": 60, "filename": "2014_2974486_5756407898963968.py", "code": "# TODO FOR 14 : rounding functions, graph manipulation, desert lion\n \nimport time\nimport os\nimport functools\n \n#EOL = os.linesep - using this causes weird \\r\\r\\n problems\nEOL = \"\\n\"\n \n# ----------------------------------------------------------------------\n \ndef is_equal_approx(x, y, epsilon=1e-6):\n    \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n     \n    By default, 'epsilon' is 1e-6.\n    \"\"\"\n    # Check absolute precision.\n    if -epsilon <= x - y <= epsilon:\n        return True\n \n    # Is x or y too close to zero?\n    if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n        return False\n \n    # Check relative precision.\n    return (-epsilon <= (x - y) / x <= epsilon\n        or -epsilon <= (x - y) / y <= epsilon)\n   \ndef read_syms(fd):\n    \"\"\"Read a line of whitespace separated symbols.\"\"\"\n    return fd.readline().strip().split()\n \ndef read_ints(fd):\n    \"\"\"Read a line of whitespace separated integers.\"\"\"\n    return [int(p) for p in read_syms(fd)]\n \ndef read_floats(fd):\n    \"\"\"Read a line of whitespace separated floats.\"\"\"\n    return [float(p) for p in read_syms(fd)]\n \nclass Mtrx(object):\n    \"\"\"A matrix object.\"\"\"\n     \n    def __init__(self, rows, cols, data):\n        assert len(data) == rows * cols\n        self.rows = rows\n        self.cols = cols\n        self.data = data\n         \n    def cell(self, r, c):\n        return self.data[r * self.cols + c]\n     \n    def getrow(self, i):\n        return [self.cell(i, c) for c in xrange(self.cols)]\n \n    def getcol(self, i):\n        return [self.cell(c, i) for c in xrange(self.rows)]\n     \n    @classmethod\n    def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n        \"\"\"Read matrix from file, assuming first line at location is `R C`.\n         \n        Return a new Mtrx object. Reading values is performed by the `readfunc`.\n        Pre-determined size can be passed using `rows` and `cols`.\n        \"\"\"\n        data = []\n        if rows is None:\n            assert cols is None\n            rows, cols = read_ints(fd)\n        else:\n            assert cols is not None\n        for _ in range(rows):\n            line = readfunc(fd)\n            assert len(line) == cols\n            data.extend(line)\n        return Mtrx(rows, cols, data)\n             \n    @classmethod\n    def read_int_matrix(cls, fd, rows=None, cols=None):\n        return cls.readfromfile(fd, read_ints, rows, cols)\n             \n    @classmethod\n    def read_sym_matrix(cls, fd, rows=None, cols=None):\n        return cls.readfromfile(fd, read_syms, rows, cols)\n             \n    def __str__(self):\n        res = \"\"\n        for i in xrange(self.rows):\n            res += str(self.getrow(i)) + EOL\n        return res\n     \n    def __repr__(self):\n        return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                        self.cols, self.data)\n \n#===============================================================================\n# Class decorators \n#===============================================================================\n              \ncachetotals = 0\ncachemisses = 0\n \ndef statreset():\n    global cachemisses, cachetotals\n    cachemisses = 0\n    cachetotals = 0\n \nclass memoizeit(object):\n    \"\"\"Decorator. Caches a function's return value each time it is called.\n     \n    If called later with the same arguments, the cached value is returned \n    (not reevaluated).\n    \"\"\"\n     \n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n         \n    def __call__(self, *args):\n         \n        # update stats\n        global cachetotals, cachemisses\n        cachetotals += 1\n         \n        try:\n            return self.cache[args]\n        except KeyError:\n             \n            # update stats\n            cachemisses += 1\n             \n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n \n            # update stats\n            cachemisses += 1\n \n            # uncachable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n     \n    @property\n    def __name__(self):\n        return self.func.__name__\n     \n    def __get__(self, obj, objtype):\n        \"\"\"Support instance methods.\"\"\"\n        return functools.partial(self.__call__, obj)\n \nclass timeit(object):\n    \"\"\"Decorator that times a function.\n     \n    When function ends, print name, runtime, return value and cache stats.\n    \"\"\"\n     \n    def __init__(self, func):\n        self.func = func\n         \n    def __call__(self, *args):\n        start = time.time()\n        value = self.func(*args)\n        delta = time.time() - start\n        cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n            cachetotals else 0\n        print (self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n            delta, value, cachedata))\n        return value\n     \n    def __get__(self, obj, objtype):\n        return functools.partial(self.__call__, obj)\n \n# ----------------------------------------------------------------------\n"}
{"author": "pek", "index": 61, "filename": "2014_2974486_5709773144064000.py", "code": "import sys\n \nlines = [line.strip() for line in open(sys.argv[1])]\ncount = int(lines[0])\n \nfor i in xrange(count):\n    farm_cost,farm_production,target = map(float, lines[i+1].split())\n    seconds = 0\n    production = 2\n    best = float(\"inf\")\n    while True:\n        best = min(best, seconds + target / production)\n        seconds += farm_cost / production\n        if seconds >= best: break\n        production += farm_production\n \n    print(\"Case #%s: %.7f\" % (i+1, best))\n"}
{"author": "pek", "index": 61, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\n \nlines = [line.strip() for line in open(sys.argv[1])]\ncount = int(lines[0])\n \nfor i in xrange(count):\n    R,C,M = map(int, lines[i+1].split())\n    print(\"Case #%s:\" % (i+1))\n \n    w = max(R,C)\n    h = min(R,C)\n    X = R*C - M\n    assert X > 0\n \n    if X == 1:\n        rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\n    elif h == 1:\n        rows = ['c' + '.' * (X-1) + '*' * M]\n    elif X == 4:\n            rows = [\n                'c.' + '*' * (w-2),\n                '..' + '*' * (w-2),\n            ] + ['*' * w] * (h-2)\n    elif h == 2:\n        if X%2 == 1 or X == 2:\n            rows = None\n        else:\n            rows = [\n                'c' + '.' * (X/2-1) + '*' * (M/2),\n                '.' + '.' * (X/2-1) + '*' * (M/2)\n            ]\n    elif X <= 5 or X == 7:\n        rows = None\n \n    elif X%2 == 0 and X <= w*2:\n        r = X/2\n        rows = [\n            'c' + '.' * (r - 1) + '*' * (w-r),\n                '.' * r       + '*' * (w-r),\n        ] + ['*' * w] * (h-2)\n \n    elif X <= w*3 and (X % 3) != 1:\n        n = (X+1) / 3\n        t = X - 2*n\n        rows = [\n            'c' + '.' * (n-1) + '*' * (w-n),\n                '.' * n     + '*' * (w-n),\n                '.' * t     + '*' * (w-t)\n        ] + ['*' * w] * (h-3)\n    else:\n        n = X / w\n        t = X % w\n        if t == 1:\n            rows = (\n                    ['c' + (w-1) * '.']\n                +   ['.' * w] * (n-2)\n                +   ['.' * (w-1) + '*']\n                +   ['..' + '*' * (w-2)]\n                +   ['*' * w] * (h - n - 1)\n            )\n        else:\n            k = 1 if t == 0 else 0\n            rows = (\n                    ['c' + (w-1) * '.']\n                +   ['.' * w] * (n-1)\n                +   ['.' * t + '*' * (w-t)] * (1 - k)\n                +   ['*' * w] * (h - n - 1 + k)\n            )\n \n    if rows:\n        if R > C:\n            rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\n \n        for row in rows:\n            print(row)\n \n        assert len(rows) == R\n        assert len(rows[0]) == C\n        assert sum(1 for row in rows for col in row if col == '*') == M\n \n    else:\n        print(\"Impossible\")\n \n"}
{"author": "pek", "index": 61, "filename": "2012_1460488_1595491.py", "code": "from sys import stdin\n \nT = int(stdin.readline())\nfor i in xrange(1,T+1):\n\tns = map(int, stdin.readline().split())\n\tN,S,p = ns[0:3]\n \t\n\th = 0\n\tz = 0\n \n\tfor n in ns[3:]:\n\t\tif n <= 1:\n\t\t\tif n >= p: h += 1\t\n\t\telif (n+2) // 3 >= p:\n\t\t\th += 1\n\t\telif (n+4) // 3 >= p:\n\t\t\tz += 1\n \n\tprint(\"Case #%d: %d\" % (i, h + min(S,z)))\n \n \n"}
{"author": "pek", "index": 61, "filename": "2013_2270488_2453486.py", "code": "import sys\n \nstdin = sys.stdin\nixs = range(4)\nfor i in xrange(int(stdin.readline())):\n    print(\"Case #%i: \" % (i+1),)\n    rows = [stdin.readline()[:4] for i in ixs]\n \n    cols = [[row[i] for row in rows] for i in ixs]\n    diags = [\n        [rows[i][i] for i in ixs],\n        [rows[i][3-i] for i in ixs]\n    ]\n    notdone = False\n    for row in rows + cols + diags:\n        x = None\n        for t in row:\n            if t == '.':\n                notdone = True\n                break\n            elif t == 'T':\n                continue\n            elif x is not None and x != t:\n                break\n            else:\n                x = t\n        else:\n            print(x, \"won\")\n            break\n    else:\n        if notdone: print(\"Game has not completed\")\n        else:       print(\"Draw\")\n \n    stdin.readline()\n"}
{"author": "pek", "index": 61, "filename": "2013_2270488_2449486.py", "code": "import sys\n \nstdin = sys.stdin\nfor c in xrange(int(stdin.readline())):\n    n,m = map(int, stdin.readline().split())\n    rows = [map(int, stdin.readline().split()) for i in xrange(n)]\n    cols = [[row[i] for row in rows] for i in xrange(m)]\n \n    rowmaxs = [max(x) for x in rows]\n    colmaxs = [max(x) for x in cols]\n \n    verdict = \"YES\"\n    for i in xrange(n):\n        for k in xrange(m):\n            if min(rowmaxs[i], colmaxs[k]) > rows[i][k]:\n                verdict = \"NO\"\n                break\n \n        if verdict == \"NO\": break\n \n    print(\"Case #%i: %s\" % (c+1, verdict))\n"}
{"author": "pek", "index": 61, "filename": "2012_1460488_1483485.py", "code": "import sys\n \ngooglerese = \"\"\"\ny qee\nejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv\nz\n\"\"\"\n \nplain = \"\"\"\na zoo\nour language is impossible to understand\nthere are twenty six factorial possibilities\nso it is okay if you want to just give up\nq\n\"\"\"\n \ngtos = {}\nstog = {}\n \nfor s,g in zip(plain, googlerese):\n\tgtos[g] = s\n\tstog[s] = g\n \n#for c in \"abcdefghijklmnopqrstuvwxyz\":\n#\tprint(c, stog.get(c, None), gtos.get(c,None))\n \nf = sys.stdin\n \nt = int(f.readline())\n \nfor i in xrange(0,t):\n\tline = f.readline().strip()\n\tprint(\"Case #%d: %s\" % (i+1, \"\".join([gtos.get(c,c) for c in line])))\n \n"}
{"author": "pek", "index": 61, "filename": "2013_2270488_2463486.py", "code": "import sys\nimport bisect\n \ndef is_palindrome(n):\n    s = str(n)\n    return s == s[::-1] \n \npalindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]\nall_palindromes = palindromes[1] + palindromes[2]\nlimit = [100]\n \npalindromic_squares = []\npsqtop = 0\npsqix = 0\n \nstdin = sys.stdin\nfor c in xrange(int(stdin.readline())):\n    a,b = map(int, stdin.readline().split())\n \n    while psqtop < b:\n        while psqix >= len(all_palindromes):\n            ps = []\n            pp = 10 ** (len(palindromes)-1) + 1\n            for i in range(1,10):\n                for p in palindromes[-2]:\n                    ps.append(i * pp + 10 * p) \n            palindromes.append(ps)\n            all_palindromes.extend(ps)\n \n        sq = all_palindromes[psqix] * all_palindromes[psqix]\n        if is_palindrome(sq):\n            palindromic_squares.append(sq)\n        psqix  += 1\n        psqtop = sq\n \n    aix = bisect.bisect_left(palindromic_squares, a)\n    bix = bisect.bisect_right(palindromic_squares, b)\n \n    print(\"Case #%i: %i\" % (c+1, bix-aix) )\n"}
{"author": "pek", "index": 61, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \n \nlines = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\n[count] = lines[0]\nassert count * 10 + 1 == len(lines)\n \nfor i in xrange(count):\n    base = i*10\n    [n1] = lines[base+1]\n    [n2] = lines[base+6]\n    row1 = set(lines[base+1+n1])\n    row2 = set(lines[base+6+n2])\n    common = row1.intersection(row2)\n    print(\"Case #%s:\" % (i+1),)\n    if len(common) == 1:\n        print(list(common)[0])\n    elif not common:\n        print(\"Volunteer cheated!\")\n    else:\n        print(\"Bad magician!\")\n"}
{"author": "radkokotev", "index": 62, "filename": "2014_2974486_5709773144064000.py", "code": "filename = raw_input(\"Name of file: \")\ninfile = open(filename, \"r\")\noutfile = open(filename + \".out\", \"w\")\n \n \nT = int(infile.readline()[:-1])\n## Code starts here\n \n \ndef getMinTime(c, f, x):\n    p0 = 2.0\n    s_prev = x / p0\n    s_curr = c / p0\n    prev_item = 0\n    next_item = x / (p0 + f)\n    n = 1\n    while s_prev + prev_item > s_curr + next_item:\n        s_prev = s_curr\n        prev_item = next_item\n        s_curr += c / (p0 + (n * f))\n        next_item = x / (p0 + ((n + 1) * f))\n        n += 1\n    return s_prev + prev_item\n \nfor t in range(1, T + 1):\n    items = infile.readline()[:-1].split(\" \")\n    c = float(items[0])\n    f = float(items[1])\n    x = float(items[2])\n    time = getMinTime(c, f, x)\n    outfile.write(\"Case #%d: %.7f\\n\" %(t, time))\n     \n         \n     \n## code ends here\n \noutfile.close()\ninfile.close()\n"}
{"author": "radkokotev", "index": 62, "filename": "2014_2974486_5690574640250880.py", "code": "filename = raw_input(\"Name of file: \")\ninfile = open(filename, \"r\")\noutfile = open(filename + \".out\", \"w\")\n \n \nT = int(infile.readline()[:-1])\n## Code starts here\n \ndef addMinesDiagonally(r, c, m):\n    field = []\n    for i in range (r):\n        row = []\n        for j in range(c):\n            row += [\".\"]\n        field += [row]\n         \n    for i in range (r + c):\n        ver = min (i, r - 1)\n        hor = max (0, 1 + i - r)\n        while ver >= 0 and hor <= c - 1 and m > 0:\n            if m == 1 and hor == c - 2 and ver == r - 2:\n                ver -= 1\n                hor += 1\n            field[ver][hor] = \"*\"\n            ver -= 1\n            hor += 1\n            m -= 1\n         \n    return field\n \ndef isPossible(field):\n    if field[-1][-1] != \".\":\n        return False\n    up = True\n    left = True\n    diag = True\n    if len(field) > 1 and field[-2][-1] != \".\":\n            up = len(field[-1]) <= 1\n    if len(field[-1]) > 1 and field[-1][-2] != \".\":\n            left = len(field) <= 1\n    if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\n        diag = False\n    return (up and left and diag) or \\\n            ((not up) and (not left) and (not diag))\n     \n \nfor t in range(1, T + 1):\n    items = infile.readline()[:-1].split(\" \")\n    r = int(items[0])\n    c = int(items[1])\n    m = int(items[2])\n    field = addMinesDiagonally(r, c, m)\n    if isPossible(field):\n        field[-1][-1] = \"c\"\n        s = \"\"\n        for line in field:\n            for cell in line:\n                s += cell\n            s += \"\\n\"\n        outfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\n    else:\n        s = \"IMPOSSIBLE!!!!\\n\"\n        for line in field:\n            for cell in line:\n                s += cell\n            s += \"\\n\"\n        outfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\n        #outfile.write(\"Case #%d:\\n%s\\n\" %(t, \"Impossible\"))\n     \n         \n     \n## code ends here\n \noutfile.close()\ninfile.close()\n"}
{"author": "radkokotev", "index": 62, "filename": "2012_1460488_1595491.py", "code": "fileName = raw_input(\"File name: \")\n \nf = open(fileName,\"r\")\n \nt = int(f.readline()[:-1])\n \ntests = []\n \nfor i in range (t):\n    tests += [f.readline()[:-1]]\n \nf.close()\n \n \ndef compute(raw):\n    dataN = [] # keeps the max mark for not surprising\n    dataS = [] # keeps the max marks for surprisings\n     \n    items = raw.split() \n     \n    for i in range (int(items[0])):\n        ti = int(items[3+i])\n        if ti < 1:\n            dataS += [0]\n            dataN += [0]\n        elif ti > 28:\n            dataS += [10]\n            dataN += [10]\n        else:\n            dataN += [int((ti+2)/3)] # put the values for all participants\n            dataS += [int((ti+4)/3)]\n         \n         \n \n     \n    p = int(items[2])\n    s = int(items[1])\n     \n    n_vals = dataN\n    n_vals.sort()\n     \n \n    i=0\n    minimum = 0 # how many numbers greater than p are there in \"not surprising\"\n    if n_vals[0] < p:\n        while n_vals[-1-i] >= p:\n            minimum += 1\n            i += 1\n    else:\n        minimum = len(n_vals)\n         \n \n    s_vals = dataS\n    s_vals.sort()\n    i=0\n    maximum = 0 # how many numbers greater than p are there in \"surprising\"\n    if s_vals[0] < p:\n        while s_vals[-1-i] >= p:\n            maximum += 1\n            i += 1\n    else:\n        maximum = len(n_vals)\n     \n            # we can make at most (max) but can take only (min + s)\n    return min(maximum, minimum+s) \n     \n \nfor i in range (t):\n    print(\"Case #%d: %d\" %(i+1,compute(tests[i])))\n \n \n     \n"}
{"author": "radkokotev", "index": 62, "filename": "2013_2270488_2453486.py", "code": "fileName = raw_input(\"File name: \")\nf = open(fileName,\"r\")\n \n \nn = int(f.readline()[:-1])\nboards = []\n \ndef check_tuple(row):\n    has_o = False\n    has_x = False\n    for char in row:\n        if(char == \".\"):\n            return (False, \"Game has not completed\")\n        if(char == \"x\" or char == \"X\"):\n            has_x = True\n        if(char == \"o\" or char == \"O\"):\n            has_o = True\n         \n    if has_o and has_x:\n        return (False, \"Draw\")\n    if has_o:\n        return (True, \"O won\")\n    return (True, \"X won\")\n \ndef check_rows(board):\n    for row in board:\n        result = check_tuple(row)\n        if result[0]:\n            return result\n    return (False, \"Unknown result\")\n \ndef check_columns(board):\n    for i in range(len(board)):\n        col = \"\"\n        col += board[0][i]\n        col += board[1][i]\n        col += board[2][i]\n        col += board[3][i]\n        result = check_tuple(col)\n        if result[0]:\n            return result\n    return (False, \"Unknown result\")\n \ndef check_diagonals(board):\n    main_diag = \"\"\n    main_diag += board[0][0]\n    main_diag += board[1][1]\n    main_diag += board[2][2]\n    main_diag += board[3][3]\n    result = check_tuple(main_diag)\n    if result[0]:\n        return result\n     \n    sec_diag = \"\"\n    sec_diag += board[0][3]\n    sec_diag += board[1][2]\n    sec_diag += board[2][1]\n    sec_diag += board[3][0]\n \n    result = check_tuple(sec_diag)\n    if result[0]:\n        return result\n \n    return (False,\"Unknown reason\")\n \n     \n             \n     \n \ndef check_board(board,might_have_finished):\n    result = check_rows(board)\n    if result[0]:\n        return result[1]\n     \n    result = check_columns(board)\n    if result[0]:\n        return result[1]\n     \n    result = check_diagonals(board)\n    if result[0]:\n        return result[1]\n \n    if(might_have_finished):\n        return \"Game has not completed\"\n    return \"Draw\"\n     \n     \n     \n     \n     \n \n \nfor i in range(n):\n    board = []\n    might_have_finished = False\n    for j in range(4): \n        row = f.readline()[:-1]\n        #print(row)\n        #row_lst = [[row[0]],[row[1]],[row[2]],[row[3]]]\n        if \".\" in row:\n            might_have_finished = True\n        board += [row]\n    print(\"Case #%d: %s\" %(i+1, check_board(board,might_have_finished)))\n    f.readline()\n \nf.close()\n#print(might_have_finished, boards)\n \n##for i in range(n): # print(out)\n##    print(\"Case #%d: %s\" %(i+1, translate(cases[i])))\n     \n     \n \n \n     \n"}
{"author": "radkokotev", "index": 62, "filename": "2013_2270488_2449486.py", "code": "fileName = raw_input(\"File name: \")\nf = open(fileName,\"r\")\n \n \nn = int(f.readline()[:-1])\n \ndef check_row(board, index):\n    row = board[index]\n    M = row[0]\n    index = 0\n    for i in range(len(row)):\n        num = row[i]\n        if(num > M):\n            M = num\n            index = i\n    for i in range(len(row)):\n        num = row[i]\n        if(num < M):\n            if not check_col(board,i,num):\n                return False\n    return True\n \n \ndef check_col(board,index,number):\n    for i in range(len(board)):\n        if board[i][index] > number:\n            return False\n    return True\n \ndef check_all(board):\n    for i in range(len(board)):\n        if not check_row(board, i):\n            return False\n    return True    \n  \noutputFileName = raw_input(\"output file name: \")\nof = open(outputFileName,\"w\")\n \nfor i in range(n):\n    board = []\n    mn = f.readline()[:-1].split()\n    m = int(mn[0])\n    n = int(mn[1])\n    for j in range(m): \n        row = f.readline()[:-1].split()\n        #print(row)\n        row_lst = []\n        for s in row:\n            row_lst += [int(s)]\n        board += [row]\n    if check_all(board):\n        of.write( \"Case #%d: %s\\n\" %(i+1, \"YES\"))\n    else:\n        of.write( \"Case #%d: %s\\n\" %(i+1, \"NO\"))\n \nof.close()\nf.close()\n \n#print(might_have_finished, boards)\n \n##for i in range(n): # print(out)\n##    print(\"Case #%d: %s\" %(i+1, translate(cases[i])))\n     \n     \n \n \n     \n"}
{"author": "radkokotev", "index": 62, "filename": "2012_1460488_1483485.py", "code": "from string import *\ndictionary = {\n    \"a\":\"y\",\n    \"b\":\"h\",\n    \"c\":\"e\",\n    \"d\":\"s\",\n    \"e\":\"o\",\n    \"f\":\"c\",\n    \"g\":\"v\",\n    \"h\":\"x\",\n    \"i\":\"d\",\n    \"j\":\"u\",\n    \"k\":\"i\",\n    \"l\":\"g\",\n    \"m\":\"l\",\n    \"n\":\"b\",\n    \"o\":\"k\",\n    \"p\":\"r\",\n    \"q\":\"z\",\n    \"r\":\"t\",\n    \"s\":\"n\",\n    \"t\":\"w\",\n    \"u\":\"j\",\n    \"v\":\"p\",\n    \"w\":\"f\",\n    \"x\":\"m\",\n    \"y\":\"a\",\n    \"z\":\"q\",\n    \" \":\" \"    \\n    }\\n \\ndef translate(sen):\\n     \\n    new_sen = \"\"\n \n    for char in sen: #translate each charecter\n        new_sen += dictionary[char]\n         \n    return new_sen\n \nfileName = raw_input(\"File name: \")\nf = open(fileName,\"r\")\n \nn = int(f.readline()[:-1])\ncases = [] #keeps the input msgs\n \nfor i in range(n):\n    cases += [f.readline()[:-1]]\n \nf.close()\n \n \nfor i in range(n): # print(out)\n    print(\"Case #%d: %s\" %(i+1, translate(cases[i])))\n     \n     \n \n \n     \n"}
{"author": "radkokotev", "index": 62, "filename": "2013_2270488_2463486.py", "code": "lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,\n    100020001,102030201,104060401,121242121,123454321,125686521,400080004,\n    404090404,10000200001,10221412201,12102420121,12345654321,40000800004,\n    1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,\n    1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,\n    1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,\n    102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,\n    123456787654321,400000080000004]\n \n \ndef solve(lo,hi):\n    global lst\n    count = 0\n    for i in range(len(lst)):\n        if (lst[i] >= lo and lst[i] <= hi ):\n            count += 1\n    return count\n \nfname = raw_input(\"name of file: \")\noname = raw_input(\"output file name:\")\nf = open(fname,\"r\")\nout = open(oname,\"w\")\nn = int(f.readline()[:-1])\ncase_num = 1\nfor line in f:\n    args = line[:-1].split()\n    lo = int(args[0])\n    hi = int(args[1])\n    out.write(\"Case #%d: %d\\n\" %(case_num,solve(lo,hi)))\n    case_num += 1\n     \nout.close()\nf.close()\n     \n"}
{"author": "radkokotev", "index": 62, "filename": "2014_2974486_5756407898963968.py", "code": "filename = raw_input(\"Name of file: \")\nf = open(filename, \"r\")\no = open(filename + \".out\", \"w\")\n \n \nT = int(f.readline()[:-1])\n## Code starts here\n \nmany_possible = \"Bad magician!\"\nzero_possible = \"Volunteer cheated!\"\n \nfor t in range(1, T + 1):\n    first = int(f.readline()[:-1]) - 1\n    grid1 = []\n    for i in range(4):\n        grid1 += [f.readline()[:-1].split(\" \")]\n         \n    second = int(f.readline()[:-1]) - 1\n    grid2 = []\n    for i in range(4):\n        grid2 += [f.readline()[:-1].split(\" \")]\n \n    possible = []\n    for num in grid1[first]:\n        if num in grid2[second]:\n            possible += [num]\n \n    if len(possible) == 1:\n        o.write(\"Case #%d: %s\\n\" %(t, possible[0]))\n    elif len(possible) == 0:\n        o.write(\"Case #%d: %s\\n\" %(t, zero_possible))\n    else:\n        o.write(\"Case #%d: %s\\n\" %(t, many_possible))\n         \n     \n## code ends here\n \no.close()\nf.close()\n"}
{"author": "intn", "index": 63, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/env python\nimport sys\n \n \ndef process(C, F, X):\n\tspeed = 2.0\n\ttime = 0.0\n\twhile True:\n\t\tif C / speed + X / (speed + F) > X / speed:\n\t\t\ttime += X / speed\n\t\t\tbreak\n\t\ttime += C / speed\n\t\tspeed += F\n\treturn round(time, 7)\n \ninput_file = open(sys.argv[1], 'r')\nT = int(input_file.readline())\nfor i in range(T):\n\t(C, F, X) = map(float, input_file.readline().split())\n\tprint('Case #%d:' % (i + 1), process(C, F, X))\n"}
{"author": "intn", "index": 63, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\nimport sys\n \ndef put_mines_last_step(R, C, M, grid):\n\tif M == 0:\n\t\treturn\n\tR -= 1\n\tC -= 1\n\tgrid[R][C] = '*'\n\tM -= 1\n\tr = R - 1\n\tc = C - 1\n\twhile M > 0:\n\t\tif r > c:\n\t\t\tgrid[r][C] = '*'\n\t\t\tr -= 1\n\t\telse:\n\t\t\tgrid[R][c] = '*'\n\t\t\tc -= 1\n\t\tM -= 1\n \ndef put_mines(R, C, M, grid):\n\tif R > C:\n\t\tif M < C:\n\t\t\tput_mines_last_step(R, C, M, grid)\n\t\t\treturn\n\t\tfor i in range(C):\n\t\t\tgrid[R - 1][i] = '*'\n\t\tput_mines(R - 1, C, M - C, grid)\n\t\treturn\n\tif M < R:\n\t\tput_mines_last_step(R, C, M, grid)\n\t\treturn\n\tfor i in range(R):\n\t\tgrid[i][C - 1] = '*'\n\tput_mines(R, C - 1, M - R, grid)\n\treturn\n \ndef process(R, C, M):\n\trlt = ''\n\tgrid = []\n\tfor i in range(R):\n\t\tgrid.append(['.'] * C)\n\tput_mines(R, C, M, grid)\n\tif not C == 1:\n\t\tfor i in range(R):\n\t\t\tif not grid[i][0] == '.':\n\t\t\t\tbreak\n\t\t\tif not grid[i][1] == '.':\n\t\t\t\treturn '\\nImpossible'\n\tif not R == 1:\n\t\tfor i in range(C):\n\t\t\tif not grid[0][i] == '.':\n\t\t\t\tbreak\n\t\t\tif not grid[1][i] == '.':\n\t\t\t\treturn '\\nImpossible'\n\tgrid[0][0] = 'c'\n\tfor i in grid:\n\t\trlt += '\\n' + ''.join(i)\n\treturn rlt\n \ninput_file = open(sys.argv[1], 'r')\nT = int(input_file.readline())\nfor i in range(T):\n\t(R, C, M) = map(int, input_file.readline().split())\n\tprint('Case #%d:' % (i + 1), process(R, C, M))\n"}
{"author": "intn", "index": 63, "filename": "2012_1460488_1595491.py", "code": "'''\nCreated on 2012-4-14\n \n@author: hemnd\n'''\ndef cal(args):\n    rslt = 0\n    N = int(args[0])\n    S = int(args[1])\n    p = int(args[2])\n    for i in range(N):\n        s = int(args[i + 3])\n        e = s / 3\n        r = s % 3\n        if e >= p:\n            rslt += 1\n        elif r == 1:\n            if e + 1 >= p:\n                rslt += 1\n        elif r == 0:\n            if e == 0:\n                continue\n            if S > 0 and e + 1 >= p:\n                rslt += 1\n                S -= 1\n        elif r == 2:\n            if e + 1 >= p:\n                rslt += 1\n            elif S > 0 and e + 2 >= p:\n                rslt += 1\n                S -= 1\n    return rslt\n \ninputFile = open('B-small-attempt0.in', 'r')\n#inputFile = open('test.txt', 'r')\ninputLines = inputFile.readlines()\ninputFile.close()\n \nT = int(inputLines[0])\noutputLines = []\n \nfor i in range(1, T + 1):\n    args = inputLines[i].strip().split(' ')\n    outputLines.append('Case #%d: %d\\n' % (i, cal(args)))\n    print(outputLines[i - 1],)\n \noutputFile = open('B-small.out', 'w')\noutputFile.writelines(outputLines)\noutputFile.close()\n"}
{"author": "intn", "index": 63, "filename": "2013_2270488_2453486.py", "code": "'''\nCreated on 13 Apr 2013\n \n@author: mengda\n'''\nboard = []\n \ndef whoIsWinner(num):\n    if num == 4000 or num == 3010:\n        return 'X'\n    if num == 400 or num == 310:\n        return 'O'\n    return False\n \ndef process(board):\n    full = True\n    newboard = []\n    for i in range(4):\n        line = []\n        for j in range(4):\n            c = board[i][j]\n            if   c == 'X':\n                line.append(1000)\n            elif c == 'O':\n                line.append(100)\n            elif c == 'T':\n                line.append(10)\n            elif c == '.':\n                line.append(1)\n                full = False\n        newboard.append(line)\n    board = newboard\n    for i in range(4):\n        sumH = 0\n        sumV = 0\n        for j in range(4):\n            sumH += board[i][j]\n            sumV += board[j][i]\n        winner = whoIsWinner(sumH)\n        if winner:\n            return winner + ' won'\n        winner = whoIsWinner(sumV)\n        if winner:\n            return winner + ' won'\n    sumD0 = board[0][0] + board[1][1] + board[2][2] + board[3][3]\n    winner = whoIsWinner(sumD0)\n    if winner:\n        return winner + ' won'\n    sumD1 = board[3][0] + board[2][1] + board[1][2] + board[0][3]\n    winner = whoIsWinner(sumD1)\n    if winner:\n        return winner + ' won'\n    if full:\n        return 'Draw'\n    return 'Game has not completed'\n \nf = open('A-small-attempt0.in', 'r')\nN = int(f.readline())\noutLine = []\n \nfor i in range(1, N + 1):\n    board = []\n    for j in range(4):\n        board.append(f.readline())\n    outLine.append('Case #%d: %s\\n' % (i, process(board)))\n    f.readline()\n    print(outLine[-1],)\n \nf.close()\noutFile = open('1.out', 'w')\noutFile.writelines(outLine)\noutFile.close()\n"}
{"author": "intn", "index": 63, "filename": "2013_2270488_2449486.py", "code": "'''\nCreated on 13 Apr 2013\n \n@author: mengda\n'''\nexpected = []\n \ndef process(N, M):\n    lawn = []\n    for n in range(N):\n        lawn.append([100] * M)\n    for n in range(N):\n        highest = 0\n        for m in range(M):\n            if expected[n][m] > highest:\n                highest = expected[n][m]\n        for m in range(M):\n            if lawn[n][m] > highest:\n                lawn[n][m] = highest\n    for m in range(M):\n        highest = 0\n        for n in range(N):\n            if expected[n][m] > highest:\n                highest = expected[n][m]\n        for n in range(N):\n            if lawn[n][m] > highest:\n                lawn[n][m] = highest\n    for n in range(N):\n        for m in range(M):\n            if lawn[n][m] != expected[n][m]:\n                return 'NO'\n    return 'YES'\n \nf = open('B-small-attempt0.in', 'r')\nT = int(f.readline())\noutLine = []\n \nfor i in range(1, T + 1):\n    expected = []\n    (N, M) = map(int, f.readline().split())\n    for _ in range(N):\n        expected.append(map(int, f.readline().split()))\n    outLine.append('Case #%d: %s\\n' % (i, process(N, M)))\n    print (outLine[-1],)\n \nf.close()\noutFile = open('b.s.out', 'w')\noutFile.writelines(outLine)\noutFile.close()\n"}
{"author": "intn", "index": 63, "filename": "2012_1460488_1483485.py", "code": "'''\nCreated on 2012-4-14\n \n@author: hemnd\n'''\ndict = {}\nstrs1 = ['our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up']\nstrs0 = ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv']\n \nfor i in range(3):\n    for j in range(len(strs1[i])):\n        c = strs0[i][j]\n        if c == ' ':\n            continue\n        e = strs1[i][j]\n        try:\n            dict[c]\n            print(c, '=', dict[c], e)\n        except:\n            dict[c] = e\n            print(c, '=', e)\n \nfor k in dict.keys():\n    print(k, dict[k])\n     \ndict['q'] = 'z'\ndict['z'] = 'q'\ndict[' '] = ' '\\n \\ndef trans(s):\\n    rslt = ''\n    for i in range(len(s) - 1):\n        rslt += dict[s[i]]\n    return rslt\n \n#inputFile = open('A-small-practice.in', 'r')\ninputFile = open('A-small-attempt0.in', 'r')\ninputLines = inputFile.readlines()\ninputFile.close()\n \nN = int(inputLines[0])\noutputLines = []\n \nfor i in range(1, N + 1):\n    outputLines.append('Case #%d: %s\\n' % (i, trans(inputLines[i])))\n    print(outputLines[i - 1],)\n \noutputFile = open('A-small-practice.out', 'w')\noutputFile.writelines(outputLines)\noutputFile.close()\n"}
{"author": "intn", "index": 63, "filename": "2013_2270488_2463486.py", "code": "'''\nCreated on 13 Apr 2013\n \n@author: mengda\n'''\nimport math\n \nls = []\n \ndef isP(num):\n    num = str(int(num))\n    for i in range(len(num) / 2):\n        if num[i] != num[-1 - i]:\n            return False\n    return True\n \ndef createP(root, half_digits):\n    root = str(root)\n    for i in range(half_digits):\n        ls[i] = root[i]\n        ls[-1 - i] = root[i]\n    return int(''.join(ls))\n \ndef process(A, B):\n    rlt = 0\n    a = int(math.ceil(math.sqrt(A)))\n    b = int(math.floor(math.sqrt(B)))\n    str_a = str(a)\n    half_digits = int(math.ceil(len(str_a) / 2.0))\n    root = int(str_a[:half_digits])\n    next_root = 10 ** half_digits\n    digits = len(str_a)\n    for _ in range(digits - len(ls)):\n        ls.append('')\n    while True:\n        if root == next_root:\n            if digits % 2 == 0:\n                next_root *= 10\n                half_digits += 1\n            else:\n                root /= 10\n            digits += 1\n            ls.append('')\n        p = createP(root, half_digits)\n        print (p),\n        if p > b:\n            print ('too large')\n            break\n        if isP(math.pow(p, 2)):\n            print ('right one!')\n            rlt += 1\n        else:\n            print \n        root += 1\n    return rlt\n \ndef process1(A, B):\n    rlt = 0\n    a = int(math.ceil(math.sqrt(A)))\n    b = int(math.floor(math.sqrt(B)))\n    for i in range(a, b + 1):\n        if not isP(i):\n            continue\n        power = math.pow(i, 2)\n        if isP(power):\n            rlt += 1\n    return rlt\n \nf = open('C-small-attempt1.in', 'r')\nT = int(f.readline())\noutLine = []\n \nfor i in range(1, T + 1):\n    (A, B) = map(int, f.readline().split())\n    outLine.append('Case #%d: %s\\n' % (i, process1(A, B)))\n    print (outLine[-1],)\n \nf.close()\noutFile = open('C-S.out', 'w')\noutFile.writelines(outLine)\noutFile.close()\n"}
{"author": "intn", "index": 63, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\nimport sys\n \n \ndef process(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\n\trlt = 'Volunteer cheated!'\n\tfound = False\n\tfor i in arrange_1[chosen_row_1]:\n\t\tif i in arrange_2[chosen_row_2]:\n\t\t\tif not found:\n\t\t\t\trlt = i\n\t\t\t\tfound = True\n\t\t\telse:\n\t\t\t\trlt = 'Bad magician!'\n\t\t\t\tbreak\n\treturn rlt\n \ninput_file = open(sys.argv[1], 'r')\nT = int(input_file.readline())\nfor i in range(T):\n\tchosen_row_1 = int(input_file.readline()) - 1\n\tarrange_1 = []\n\tarrange_1.append(map(int, input_file.readline().split()))\n\tarrange_1.append(map(int, input_file.readline().split()))\n\tarrange_1.append(map(int, input_file.readline().split()))\n\tarrange_1.append(map(int, input_file.readline().split()))\n\tchosen_row_2 = int(input_file.readline()) - 1\n\tarrange_2 = []\n\tarrange_2.append(map(int, input_file.readline().split()))\n\tarrange_2.append(map(int, input_file.readline().split()))\n\tarrange_2.append(map(int, input_file.readline().split()))\n\tarrange_2.append(map(int, input_file.readline().split()))\n\tprint('Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2))\n"}
{"author": "addie9000", "index": 64, "filename": "2014_2974486_5709773144064000.py", "code": "#!/usr/bin/python\nimport sys, string\n \n#solve case function\ndef solve_case(c, f, x, case_number):\n    rate = 2.0\n    time = 0.0\n    rest = x\n    while True:\n        time_to_c = c / rate\n        time_to_x = rest / rate\n        if time_to_c < time_to_x:\n            time_to_x_with_boost = time_to_c + (rest / (rate + f))\n            if time_to_x_with_boost < time_to_x:\n                rate += f\n                time += time_to_c\n            else:\n                break\n        else:\n            break\n    time += rest / rate\n    print(\"Case #%d: %.7f\" % (case_number, time))\n \n#main\nr = sys.stdin\n \nif len(sys.argv) > 1:\n    r = open(sys.argv[1], 'r')\n \ntotal_cases = r.readline()\nfor case_number in range(1, int(total_cases) + 1):\n    values = map(float, r.readline().split(' '))\n    solve_case(values[0], values[1], values[2], case_number)\n"}
{"author": "addie9000", "index": 64, "filename": "2014_2974486_5690574640250880.py", "code": "# !/usr/bin/python\nimport sys\nimport math\n \n \ndef print_basic_board(no_mine, r, c):\n    printed_c = False\n    for row in range(0, r):\n        line = []\n        for column in range(0, c):\n            if printed_c:\n                if no_mine > 0:\n                    line.append(\".\")\n                    no_mine -= 1\n                else:\n                    line.append(\"*\")\n            else:\n                line.append(\"c\")\n                no_mine -= 1\n                printed_c = True\n        print(\"\".join(line))\n \n \ndef print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c):\n    printed_c = False\n    for row in range(0, r):\n        line = []\n        for column in range(0, c):\n            if printed_c:\n                if row < no_mine_row and column < no_mine_column:\n                    line.append(\".\")\n                elif rest_no_mine_for_column > 0 and column == no_mine_column:\n                    line.append(\".\")\n                    rest_no_mine_for_column -= 1\n                elif rest_no_mine_for_row > 0 and row == no_mine_row:\n                    line.append(\".\")\n                    rest_no_mine_for_row -= 1\n                else:\n                    line.append(\"*\")\n            else:\n                line.append(\"c\")\n                printed_c = True\n        print(\"\".join(line))\n \n \n#solve case function\ndef solve_case(r, c, m, case_number):\n    print(\"Case #%d:\" % case_number)\n    no_mine = r * c - m\n    if r < 2 or c < 2 or no_mine == 1:\n        print_basic_board(no_mine, r, c)\n    else:\n        no_mine_row_max = int(math.ceil(float(no_mine) / 2))\n        if no_mine_row_max > r:\n            no_mine_row_max = r\n        for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):\n            if no_mine_column > c:\n                break\n            for no_mine_row in range(2, no_mine_row_max + 1):\n                rest_no_mine = no_mine - (no_mine_column * no_mine_row)\n                if rest_no_mine < 0:\n                    continue\n                if rest_no_mine == 1:\n                    continue\n \n                if rest_no_mine == 0:\n                    print_board(no_mine_row, no_mine_column, 0, 0, r, c)\n                    return\n                if rest_no_mine <= no_mine_row and no_mine_column < c:\n                    print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)\n                    return\n                if rest_no_mine <= no_mine_column and no_mine_row < r:\n                    print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)\n                    return\n \n                if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:\n                    for rest_no_mine_for_row in range(2, no_mine_column):\n                        rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row\n                        if rest_no_mine_for_column < no_mine_row:\n                            print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c)\n                            return\n \n        print(\"Impossible\")\n \n#main\nr_file = sys.stdin\n \nif len(sys.argv) > 1:\n    r_file = open(sys.argv[1], 'r')\n \ntotal_cases = r_file.readline()\nfor case_number in range(1, int(total_cases) + 1):\n    values = map(int, r_file.readline().split(' '))\n    solve_case(values[0], values[1], values[2], case_number)\n \n"}
{"author": "addie9000", "index": 64, "filename": "2012_1460488_1595491.py", "code": "#!/usr/bin/python\nimport sys, string\n \nmod_plus_conv_with_s = {0:1, 1:1, 2:2}\nmod_plus_conv_without_s = {0:0, 1:1, 2:1}\n \n#solve case function\ndef solve_case(s, p, scores,case_number):\n\tans = 0\n\tfor score in scores:\n\t\tif p <= (score / 3) + mod_plus_conv_without_s[score % 3]:\n\t\t\tans = ans + 1\n\t\telif s > 0 and (score / 3) > 0: \n\t\t\tif p <= (score / 3) + mod_plus_conv_with_s[score % 3]:\n\t\t\t\tans = ans + 1\n\t\t\t\ts = s - 1\n\tprint(\"Case #%d: %d\" % (case_number, ans))\n \n#main\nr = sys.stdin\n \nif len(sys.argv) > 1:\n\tr = open(sys.argv[1], 'r')\n \ntotal_cases = r.readline()\nfor case_number in range(1, int(total_cases) + 1):\n\tcase_line = map(int, r.readline().rstrip().split(' '))\n\tsolve_case(case_line[1], case_line[2], case_line[3:], case_number)\n \n"}
{"author": "addie9000", "index": 64, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/python\nimport sys, string\n \n#output result\ndef output(case_number, status):\n    print(\"Case #%d: %s\" % (case_number, status))\n \n#solve case function\ndef solve_case(board, case_number):\n    has_game_completed = True\n \n    # check row\n    for column in range(0, 4):\n        x = 0\n        o = 0\n        for row in range(0, 4):\n            if board[column][row] == 'X':\n                x += 1\n            elif board[column][row] == 'O':\n                o += 1\n            elif board[column][row] == 'T':\n                x += 1\n                o += 1\n            else:\n                has_game_completed = False\n \n        # check if X or O won already\n        if x > 3:\n            output(case_number, \"X won\")\n            return\n        if o > 3:\n            output(case_number, \"O won\")\n            return\n \n    # check column\n    for row in range(0, 4):\n        x = 0\n        o = 0\n        for column in range(0, 4):\n            if board[column][row] == 'X':\n                x += 1\n            elif board[column][row] == 'O':\n                o += 1\n            elif board[column][row] == 'T':\n                x += 1\n                o += 1\n \n        # check if X or O won already\n        if x > 3:\n            output(case_number, \"X won\")\n            return\n        if o > 3:\n            output(case_number, \"O won\")\n            return\n \n    # check diagonal 1\n    x = 0\n    o = 0\n    for rc in range(0, 4):\n        if board[rc][rc] == 'X':\n            x += 1\n        elif board[rc][rc] == 'O':\n            o += 1\n        elif board[rc][rc] == 'T':\n            x += 1\n            o += 1\n \n    # check if X or O won already\n    if x > 3:\n        output(case_number, \"X won\")\n        return\n    if o > 3:\n        output(case_number, \"O won\")\n        return\n \n    # check diagonal 2\n    x = 0\n    o = 0\n    for rc in range(0, 4):\n        if board[rc][3 - rc] == 'X':\n            x += 1\n        elif board[rc][3 - rc] == 'O':\n            o += 1\n        elif board[rc][3 - rc] == 'T':\n            x += 1\n            o += 1\n \n    # check if X or O won already\n    if x > 3:\n        output(case_number, \"X won\")\n        return\n    if o > 3:\n        output(case_number, \"O won\")\n        return\n \n    if has_game_completed:\n        output(case_number, \"Draw\")\n    else:\n        output(case_number, \"Game has not completed\")\n \n#main\ndef main():\n    r = sys.stdin\n    if len(sys.argv) > 1:\n        r = open(sys.argv[1], 'r')\n \n    total_cases = r.readline()\n    for case_number in range(1, int(total_cases) + 1):\n        board = []\n        for row in range(0, 4):\n            board.append(list(r.readline().strip()))\n \n        #skip the last empty line\n        r.readline()\n        solve_case(board, case_number)\n \n# invoke main\nif __name__ == \"__main__\":\n    main()"}
{"author": "addie9000", "index": 64, "filename": "2013_2270488_2449486.py", "code": "#!/usr/local/bin/python\nimport sys, string\n \n \n#solve case function\ndef solve_case(nm, lawn, case_number):\n    zipped_lawn = zip(*lawn)\n    for n in range(0, nm[0]):\n        max_lawn_n = max(lawn[n])\n        for m in range(0, nm[1]):\n            max_lawn_m = max(zipped_lawn[m])\n            if lawn[n][m] < max_lawn_n and lawn[n][m] < max_lawn_m:\n                print(\"Case #%d: NO\" % case_number)\n                return\n \n    print(\"Case #%d: YES\" % case_number)\n \n \n#main\ndef main():\n    r = sys.stdin\n    if len(sys.argv) > 1:\n        r = open(sys.argv[1], 'r')\n \n    total_cases = r.readline()\n    for case_number in range(1, int(total_cases) + 1):\n        nm = map(int, r.readline().strip().split(' '))\n        lawn = []\n        for n in range(0, nm[0]):\n            lawn.append(map(int, r.readline().strip().split(' ')))\n        solve_case(nm, lawn, case_number)\n \n# invoke main\nif __name__ == \"__main__\":\n    main()"}
{"author": "addie9000", "index": 64, "filename": "2012_1460488_1483485.py", "code": "#!/usr/bin/python\nimport sys, string\n \n# make the googlerese dic\ngdic = {}\nsample_googlerese = \"yqeeejpmysljylckdkxveddknmcrejsicpdrysirbcpcypcrtcsradkhwyfrepkymveddknkmkrkcddekrkdeoyakwaejtysrreujdrlkgcjv\"\nsample_plain_text = \"azooourlanguageisimpossibletounderstandtherearetwentysixfactorialpossibilitiessoitisokayifyouwanttojustgiveup\"\nfor gletter, pletter in zip(sample_googlerese, sample_plain_text):\n\tif gletter in gdic:\n\t\tif not gdic[gletter] == pletter:\n\t\t\tprint(\"ERROR!! Can't analyze the sample text.\")\n\t\t\tsys.exit()\n\telse:\n\t\tgdic[gletter] = pletter\n \nif len(gdic) == 25:\n\tcandidate_gletter = set(string.ascii_lowercase) - set(sample_googlerese)\n\tcandidate_pletter = set(string.ascii_lowercase) - set(sample_plain_text)\n\tif len(candidate_gletter) == 1 and len(candidate_pletter) == 1:\n\t\tgdic[candidate_gletter.pop()] = candidate_pletter.pop()\n \ngdic[' '] = ' '\\n \\n# open the file\\nr = sys.stdin\\n \\nif len(sys.argv) > 1:\\n\tr = open(sys.argv[1], 'r')\n \n# solve the cases \ntotal_cases = r.readline()\nfor case_number in range(1, int(total_cases) + 1):\n\tgooglerese_text = r.readline().rstrip()\n\tplain_text = \"\"\t\n\tfor gletter in googlerese_text:\n\t\tplain_text = plain_text + gdic[gletter]\n \n\tprint(\"Case #%d: %s\" % (case_number, plain_text))\n"}
{"author": "addie9000", "index": 64, "filename": "2013_2270488_2463486.py", "code": "#!/usr/local/bin/python\nimport sys, string, math\n \n \n# check if num x is palindrome\ndef is_palindrome(x):\n    candidate = list(str(x))\n    while len(candidate) > 1:\n        if candidate.pop(0) != candidate.pop():\n            return False\n    return True\n \n \n#square\ndef square(x):\n    return x * x\n \n \n#solve case function\ndef solve_case(ab, case_number):\n    fs = 0\n    root = int(math.sqrt(ab[0]))\n    sq = square(root)\n    if sq < ab[0]:\n        root += 1\n        sq = square(root)\n \n    while sq <= ab[1]:\n        if is_palindrome(root) and is_palindrome(sq):\n            fs += 1\n \n        #prepare for next\n        root += 1\n        sq = square(root)\n \n    print(\"Case #%d: %d\" % (case_number, fs))\n \n \n#main\ndef main():\n    r = sys.stdin\n    if len(sys.argv) > 1:\n        r = open(sys.argv[1], 'r')\n \n    total_cases = r.readline()\n    for case_number in range(1, int(total_cases) + 1):\n        ab = map(int, r.readline().strip().split(' '))\n        solve_case(ab, case_number)\n \n# invoke main\nif __name__ == \"__main__\":\n    main()"}
{"author": "addie9000", "index": 64, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python\nimport sys, string\n \n#solve case function\ndef solve_case(answers, arrangements_of_cards, case_number):\n    first_candidates = arrangements_of_cards[0][answers[0] - 1]\n    second_candidates = arrangements_of_cards[1][answers[1] - 1]\n    answer = set(first_candidates) & set(second_candidates)\n    length_of_answer = len(answer)\n    if length_of_answer > 1:\n        print(\"Case #%d: Bad magician!\" % case_number)\n    elif length_of_answer < 1:\n        print(\"Case #%d: Volunteer cheated!\" % case_number)\n    else:\n        # There is only one element in the set!\n        print(\"Case #%d: %d\" % (case_number, answer.pop()))\n \n#main\nr = sys.stdin\n \nif len(sys.argv) > 1:\n    r = open(sys.argv[1], 'r')\n \ntotal_cases = r.readline()\nfor case_number in range(1, int(total_cases) + 1):\n    answers = []\n    arrangements_of_cards = []\n    answers.append(int(r.readline()))\n    arrangements_of_cards.append([])\n    for row in range(0, 4):\n        arrangements_of_cards[0].append(map(int, r.readline().split(' ')))\n    answers.append(int(r.readline()))\n    arrangements_of_cards.append([])\n    for row in range(0, 4):\n        arrangements_of_cards[1].append(map(int, r.readline().split(' ')))\n    solve_case(answers, arrangements_of_cards, case_number)\n"}
