maxbublis	<>	0	<>	2013_2270488_2463486.py	<>	#!/usr/bin/env python\n import math\n import sys\n \n \n def is_palindrome(a):\n     return str(a) == ''.join(reversed(str(a)))\n \n \n def solve_problem(min_num, max_num):\n     count = 0\n     for i in xrange(min_num, max_num + 1):\n         if is_palindrome(i):\n             sqrt = math.sqrt(i)\n             if int(sqrt) == sqrt and is_palindrome(int(sqrt)):\n                 count += 1\n     return count\n \n \n if __name__ == '__main__':\n     num_of_cases = int(sys.stdin.readline())\n     for i in xrange(1, num_of_cases + 1):\n         min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))\n         print 'Case #{0}: {1}'.format(i, solve_problem(min_num, max_num))\n
maxbublis	<>	0	<>	2013_2270488_2449486.py	<>	#!/usr/bin/env python\n import sys\n \n \n def solve_problem(lawn, size_x, size_y):\n     for i in xrange(size_x):\n         for k in xrange(size_y):\n             elem = lawn[i][k]\n             if max(lawn[i]) > elem and max([lawn[j][k] for j in xrange(size_x)]) > elem:\n                 return 'NO'\n \n     return 'YES'\n \n def read_lawn(stdin, size_x, size_y):\n     lawn = []\n     for i in xrange(size_x):\n         line = map(int, sys.stdin.readline().strip().split(' '))\n         lawn.append(line)\n     return lawn\n \n \n if __name__ == '__main__':\n     num_of_cases = int(sys.stdin.readline())\n     for i in xrange(1, num_of_cases + 1):\n         size_x, size_y = map(int, sys.stdin.readline().strip().split(' '))\n         lawn = read_lawn(sys.stdin, size_x, size_y)\n         print 'Case #{0}: {1}'.format(i, solve_problem(lawn, size_x, size_y))\n
maxbublis	<>	0	<>	2012_1460488_1483488.py	<>	"""\n Google Code Jam 2012 Problem C\n Usage:\n     python problem_c.py < input.txt > output.txt\n """\n import itertools\n import sys\n \n \n def is_recycled(n, m, _cache={}, _cache_sorted={}, _cache_length={}):\n     if not n in _cache:\n         _cache[n] = str(n)\n \n     if not m in _cache:\n         _cache[m] = str(m)\n \n     str_n = _cache[n]\n     str_m = _cache[m]\n \n     if not n in _cache_sorted:\n         _cache_sorted[n] = sorted(str_n)\n \n     if not m in _cache_sorted:\n         _cache_sorted[m] = sorted(str_m)\n \n     if _cache_sorted[n] != _cache_sorted[m]:\n         return False\n \n     if not n in _cache_length:\n         _cache_length[n] = len(str_n)\n \n     for i in xrange(_cache_length[n] + 1):\n         if str_m == str_n[i:] + str_n[:i]:\n             return True\n \n     return False\n \n \n def solve_problem():\n     number_of_cases = int(sys.stdin.readline())\n \n     for i in xrange(1, number_of_cases + 1):\n         case = sys.stdin.readline().strip()\n         A, B = map(int, case.split())\n         result = sum(itertools.imap(lambda (n, m): is_recycled(n, m),\n                                     itertools.combinations(xrange(A, B + 1), 2)))\n \n         sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n \n if __name__ == '__main__':\n     solve_problem()\n
maxbublis	<>	0	<>	2014_2974486_5756407898963968.py	<>	"""\n Google Code Jam 2014 Qualification Problem A\n Usage:\n     python a.py < input.txt > output.txt\n """\n import sys\n \n \n def solve_problem(first, first_rows, second, second_rows):\n     intersection = set(first_rows[first - 1]) & set(second_rows[second - 1])\n \n     if not intersection:\n         return "Volunteer cheated!"\n     elif len(intersection) > 1:\n         return "Bad magician!"\n     else:\n         return intersection.pop()\n \n \n \n if __name__ == "__main__":\n     num_of_cases = int(sys.stdin.readline().strip())\n \n     for i in xrange(1, num_of_cases + 1):\n         first_answer = int(sys.stdin.readline().strip())\n         first_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n \n         second_answer = int(sys.stdin.readline().strip())\n         second_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n \n         print "Case #{0}: {1}".format(i, solve_problem(first_answer, first_arrangement, second_answer, second_arrangement))\n
maxbublis	<>	0	<>	2012_1460488_1483485.py	<>	"""\n Google Code Jam 2012 Problem A\n Usage:\n     python problem_a.py < input.txt > output.txt\n """\n import sys\n \n hints = {\n     'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',\n     'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',\n     'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up',\n }\n \n mapping = {'q': 'z', 'z': 'q'}\n \n for k, v in hints.items():\n     for from_char, to_char in zip(k, v):\n         mapping[from_char] = to_char\n \n def solve_problem():\n     number_of_cases = int(sys.stdin.readline())\n     for i in xrange(1, number_of_cases + 1):\n         case = sys.stdin.readline().strip()\n         translated = ''.join(map(lambda c: mapping.get(c, c), case))\n         sys.stdout.write('Case #{0}: {1}\n'.format(i, translated))\n \n if __name__ == '__main__':\n     solve_problem()\n
maxbublis	<>	0	<>	2014_2974486_5709773144064000.py	<>	"""\n Google Code Jam 2014 Qualification Problem B\n Usage:\n     python b.py < input.txt > output.txt\n """\n import sys\n \n \n def solve_problem(farm_cost, farm_rate, target):\n     rate = 2.0\n     farms = 0.0\n \n     while (farms + target / rate) > (farms + farm_cost / rate + target / (rate + farm_rate)):\n         farms = farms + farm_cost / rate\n         rate = rate + farm_rate\n \n     return farms + target / rate\n \n \n if __name__ == "__main__":\n     num_of_cases = int(sys.stdin.readline().strip())\n     for i in xrange(1, num_of_cases + 1):\n         farm_cost, farm_rate, target = map(float, sys.stdin.readline().strip().split())\n         print "Case #{0}: {1:9.7f}".format(i, solve_problem(farm_cost, farm_rate, target))\n
maxbublis	<>	0	<>	2013_2270488_2453486.py	<>	#!/usr/bin/env python\n import sys\n import itertools\n \n \n WINNING = (\n     set(['X']),\n     set(['O']),\n     set(['X', 'T']),\n     set(['O', 'T']),\n )\n \n \n def solve_problem(matrix):\n     game_completed = True\n \n     lines_combo = (matrix[i] for i in xrange(4))\n     rows_combo = ((matrix[k][i] for k in xrange(4)) for i in xrange(4))\n     diagonals = ((matrix[i][i] for i in xrange(4)),\n                  (matrix[i][3 - i] for i in xrange(4)))\n \n     for combo in itertools.chain(lines_combo, rows_combo, diagonals):\n         combo_set = set(combo)\n         if combo_set in WINNING:\n             if 'X' in combo_set:\n                 return 'X won'\n             if 'O' in combo_set:\n                 return 'O won'\n         if '.' in combo_set:\n             game_completed = False\n \n     # we have no winner, check game status\n \n     if game_completed:\n         return 'Draw'\n     else:\n         return 'Game has not completed'\n \n     return 0\n \n def read_matrix(stdin):\n     matrix = [[], [], [], []]\n     for i in xrange(4):\n         line = stdin.readline().strip()\n         for k in line:\n             matrix[i].append(k)\n     return matrix\n \n \n if __name__ == '__main__':\n     num_of_cases = int(sys.stdin.readline())\n     for i in xrange(1, num_of_cases + 1):\n         matrix = read_matrix(sys.stdin)\n         print 'Case #{0}: {1}'.format(i, solve_problem(matrix))\n         sys.stdin.readline() # separator\n
maxbublis	<>	0	<>	2014_2974486_5690574640250880.py	<>	"""\n Google Code Jam 2014 Qualification Problem C\n Usage:\n     python c.py < input.txt > output.txt\n """\n import copy\n import itertools\n import sys\n \n \n def iter_neighbors(x, y, cells):\n     columns = len(cells[0])\n     rows = len(cells)\n \n     if y > 0:\n         if x > 0:\n             yield x - 1, y - 1\n         yield x, y - 1\n \n         if x + 1 < columns:\n             yield x + 1, y - 1\n \n     if x > 0:\n         yield x - 1, y\n \n     if x + 1 < columns:\n         yield x + 1, y\n \n     if y + 1 < rows:\n         if x > 0:\n             yield x - 1, y + 1\n \n         yield x, y + 1\n \n         if x + 1 < columns:\n             yield x + 1, y + 1\n \n \n def try_to_click(x, y, cells, remaining):\n     if remaining == 0:\n         return cells\n \n     recent = []\n \n     opened = 0\n \n     for n_x, n_y in iter_neighbors(x, y, cells):\n         if cells[n_y][n_x] == "?":\n             cells[n_y][n_x] = "."\n             opened += 1\n             recent.append((n_x, n_y))\n \n     if opened == remaining:\n         return cells\n \n     if opened > remaining:\n         return []\n \n     for n_x, n_y in recent:\n         solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)\n         if solution:\n             return solution\n \n     return []\n \n \n def solve_problem(rows, columns, mines):\n \n     for x in xrange(columns):\n         for y in xrange(rows):\n             cells = [["?" for i in xrange(columns)] for j in xrange(rows)]\n             cells[y][x] = "c"\n             solution = try_to_click(x, y, cells, rows * columns - mines - 1)\n \n             if solution:\n                 return "\n".join(["".join(row) for row in solution]).replace("?", "*")\n \n     return "Impossible"\n \n \n if __name__ == "__main__":\n     num_of_cases = int(sys.stdin.readline().strip())\n     for i in xrange(1, num_of_cases + 1):\n \n         rows, columns, mines = map(int, sys.stdin.readline().strip().split())\n \n         print "Case #{0}:\n{1}".format(i, solve_problem(rows, columns, mines))\n
coconutbig	<>	1	<>	2013_2270488_2463486.py	<>	import math\n \n def get_number_of_test_case():\n     return int(raw_input().strip())\n \n def solve_case(t):\n     A, B = [int(x) for x in raw_input().strip().split()]\n \n     print 'Case #%d: %d' % (t, get_number_of_palindrome(B) - get_number_of_palindrome(A - 1),)\n \n def get_number_of_palindrome(n):\n     ret = 0\n \n     nt = int(math.floor(math.sqrt(n)))\n     total_column = int(math.ceil(math.ceil(math.log10(nt + 1)) / 2.0))\n     upper_limit = 10 ** total_column\n \n     counter = 0\n     while counter < upper_limit:\n         c_str = [c for c in str(counter)]\n         c_str.reverse()\n \n         number = str(counter)\n         for c in c_str:\n             number += c\n         number = int(number)\n         number = number ** 2\n         if number <= n and is_palindrome(number):\n             ret += 1\n \n         number = str(counter)\n         for c in c_str[1:]:\n             number += c\n         number = int(number)\n         number = number ** 2\n         if number <= n and is_palindrome(number):\n             ret += 1\n         \n         counter += 1\n \n     return ret\n \n def is_palindrome(n):\n     if n == 0:\n         return False\n     num = str(n)\n     check_len = len(num) / 2\n     ret = True\n     for i in range(check_len):\n         ret &= num[i] == num[-i - 1]\n     return ret\n \n T = get_number_of_test_case()\n t = 1\n while t <= T:\n     solve_case(t)\n     t += 1\n \n
coconutbig	<>	1	<>	2013_2270488_2449486.py	<>	def get_number_of_test_case():\n     return int(raw_input().strip())\n \n def solve_case(t):\n     N, M = [int(x) for x in raw_input().strip().split()]\n     \n     matrix = [[int(x) for x in raw_input().strip().split()] for y in range(N)]\n \n     s_list = list()\n     for i in range(N):\n         for j in range(M):\n             s_list.append([matrix[i][j], i, j,])\n     s_list.sort(cmp = lambda x, y: x[0] - y[0])\n \n     outcome = 'YES'\n     for s in s_list:\n         if matrix[s[1]][s[2]] == 0:\n             continue\n \n         row, col = s[1], s[2]\n \n         can_do = True\n         for i in range(N):\n             can_do &= matrix[i][col] <= s[0]\n         if can_do:\n             for i in range(N):\n                 matrix[i][col] = 0\n             continue\n \n         can_do = True\n         for j in range(M):\n             can_do &= matrix[row][j] <= s[0]\n         if can_do:\n             for j in range(M):\n                 matrix[row][j] = 0\n         else:\n             outcome = 'NO'\n             break\n     \n     print 'Case #%d: %s' % (t, outcome,)\n \n \n T = get_number_of_test_case()\n t = 1\n while t <= T:\n     solve_case(t)\n     t += 1\n \n
coconutbig	<>	1	<>	2014_2974486_5756407898963968.py	<>	def solve_case(t):\n     interested_row = int(raw_input().strip())\n     i = 1\n     while i <= 4:\n         row = raw_input()\n         if i == interested_row:\n             first_set = set(row.strip().split())\n         i += 1\n     interested_row = int(raw_input().strip())\n     i = 1\n     while i <= 4:\n         row = raw_input()\n         if i == interested_row:\n             second_set = set(row.strip().split())\n         i += 1\n     ans_set = first_set & second_set\n     if len(ans_set) == 1:\n         print 'Case #%d: %s' % (t, ans_set.pop(),)\n     elif len(ans_set) > 1:\n         print 'Case #%d: Bad magician!' % (t,)\n     else:\n         print 'Case #%d: Volunteer cheated!' % (t,)\n \n def main():\n     t = int(raw_input().strip())\n     for i in range(1, t + 1):\n         solve_case(i)\n \n if __name__ == '__main__':\n     main()\n
coconutbig	<>	1	<>	2012_1460488_1483485.py	<>	"""\n num = int(raw_input('num: ').strip())\n \n c_map = [None for x in range(0, 26)]\n \n while num > 0:\n 	googleres = raw_input('googleres: ').strip()\n 	original = raw_input('original: ').strip()\n \n \n 	ord_a = ord('a')\n 	ord_z = ord('z')\n \n 	i = 0\n 	for c in googleres:\n 		ord_c = ord(c)\n 		if ord_a <= ord_c and ord_c <= ord_z:\n 			c_map[ord_c - ord_a] = ord(original[i]) - ord_c\n 		i += 1\n 	\n 	num -= 1\n \n print c_map\n """\n \n """\n c_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]\n i = 0\n original_list = list()\n while i < 25:\n 	original_list.append(c_map[i] + i)\n 	i += 1\n original_list.sort()\n print original_list\n """\n \n c_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]\n \n t = int(raw_input().strip())\n t_count = 1\n while t_count <= t:\n 	ord_a = ord('a')\n 	ord_z = ord('z')\n 	googleres = raw_input().strip()\n 	original = ''\n 	for c in googleres:\n 		ord_c = ord(c)\n 		if ord_a <= ord_c and ord_c <= ord_z:\n 			original += chr(c_map[ord_c - ord_a] + ord_c)\n 		else:\n 			original += c\n 	print 'Case #%d: %s' % (t_count, original,)\n 	t_count += 1\n \n
coconutbig	<>	1	<>	2014_2974486_5709773144064000.py	<>	def solve_case(t):\n     c, f, x = [float(num) for num in raw_input().strip().split()]\n     current_time_usage = x / 2.0\n \n     n = 1\n     build_farm_time = c / (2.0 + float((n - 1) * f))\n     attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time\n \n     while attemp_time_usage < current_time_usage:\n         current_time_usage = attemp_time_usage\n \n         n += 1\n         build_farm_time += c / (2.0 + float((n - 1) * f))\n         attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time\n \n     print 'Case #%d: %.7f' % (t, current_time_usage,)\n \n def main():\n     t = int(raw_input().strip())\n     for i in range(1, t + 1):\n         solve_case(i)\n \n if __name__ == '__main__':\n     main()\n
coconutbig	<>	1	<>	2013_2270488_2453486.py	<>	def get_number_of_test_case():\n     return int(raw_input().strip())\n \n def solve_case(t):\n     lines = [list(raw_input().strip()) for i in range(4)]\n     raw_input()\n \n     i = 0\n     j = 0\n \n     p_list = list()\n     while i < 4:\n         j = 0\n         s = ''\n         while j < 4:\n             s += lines[i][j]\n             j += 1\n         p_list.append(s.replace('T', 'X'))\n         p_list.append(s.replace('T', 'O'))\n         i += 1\n \n     j = 0\n     while j < 4:\n         i = 0\n         s = ''\n         while i < 4:\n             s += lines[i][j]\n             i += 1\n         p_list.append(s.replace('T', 'X'))\n         p_list.append(s.replace('T', 'O'))\n         j += 1\n     \n     s = lines[0][0] + lines[1][1] + lines[2][2] + lines[3][3]\n     p_list.append(s.replace('T', 'X'))\n     p_list.append(s.replace('T', 'O'))\n \n     s = lines[0][3] + lines[1][2] + lines[2][1] + lines[3][0]\n     p_list.append(s.replace('T', 'X'))\n     p_list.append(s.replace('T', 'O'))\n \n     has_empty = False\n     outcome = ''\n     for p in p_list:\n         has_empty |= '.' in p\n         if p == 'XXXX':\n             outcome = 'X won'\n             break\n         elif p == 'OOOO':\n             outcome = 'O won'\n             break\n     if not outcome:\n         if has_empty:\n             outcome = 'Game has not completed'\n         else:\n             outcome = 'Draw'\n     \n     print 'Case #%d: %s' % (t, outcome,)\n \n T = get_number_of_test_case()\n t = 1\n while t <= T:\n     solve_case(t)\n     t += 1\n \n
coconutbig	<>	1	<>	2014_2974486_5690574640250880.py	<>	class Sweeper(object):\n     def __init__(self, r, c, m):\n         self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]\n         self.matrix[0][0] = 'c'\n \n         self.r = r\n         self.c = c\n         self.m = m\n         self.current_r = r\n         self.current_c = c\n         self.current_m = m\n \n     def fill_row(self):\n         if self.current_r >= 3 and self.current_m >= self.current_c:\n             for i in range(0, self.current_c):\n                 self.matrix[self.current_r - 1][i] = '*'\n             self.current_r -= 1\n             self.current_m -= self.current_c\n             return True\n         return False\n \n     def fill_col(self):\n         if self.current_c >= 3 and self.current_m >= self.current_r:\n             for i in range(0, self.current_r):\n                 self.matrix[i][self.current_c - 1] = '*'\n             self.current_c -= 1\n             self.current_m -= self.current_r\n             return True\n         return False\n \n     def fill_partial(self):\n         if self.current_r >= 3:\n             fill_num = min(self.current_m, self.current_c - 2)\n             for i in range(0, fill_num):\n                 self.matrix[self.current_r - 1][self.current_c - 1 - i] = '*'\n             self.current_m -= fill_num\n             if fill_num > 0:\n                 self.current_r -= 1\n         if self.current_c >= 3:\n             fill_num = min(self.current_m, self.current_r - 2)\n             for i in range(0, fill_num):\n                 self.matrix[self.current_r - 1 - i][self.current_c - 1] = '*'\n             self.current_m -= fill_num\n             if fill_num > 0:\n                 self.current_c -= 1\n         if self.current_m > 0:\n             return False\n         else:\n             return True\n \n     def fill_special_one(self):\n         if self.current_r * self.current_c == self.current_m + 1:\n             for i in range(0, self.current_r):\n                 for j in range(0, self.current_c):\n                     self.matrix[i][j] = '*'\n             self.matrix[0][0] = 'c'\n             self.current_r = 0\n             self.current_c = 0\n             self.current_m = 0\n             return True\n         return False\n \n     def fill_special_col(self):\n         if self.current_c == 1 and self.current_r > self.current_m:\n             for i in range(0, self.current_m):\n                 self.matrix[self.current_r - 1 - i][0] = '*'\n             self.matrix[0][0] = 'c'\n             self.current_m = 0\n             self.current_r = 0\n             self.current_c = 0\n             return True\n         return False\n \n     def fill_special_row(self):\n         if self.current_r == 1 and self.current_c > self.current_m:\n             for i in range(0, self.current_m):\n                 self.matrix[0][self.current_c - 1 - i] = '*'\n             self.matrix[0][0] = 'c'\n             self.current_m = 0\n             self.current_r = 0\n             self.current_c = 0\n             return True\n         return False\n \n def print_matrix(matrix):\n     for row in matrix:\n         s = ''\n         for col in row:\n             s += col\n         print s\n \n #def check_matrix(matrix, m):\n #    for row in matrix:\n #        for col in row:\n #            if col == '*':\n #                m -= 1\n #    if m > 0 or matrix[0][0] != 'c':\n #        print '>>>>>>>>>>>> BUG <<<<<<<<<<<'\n     \n def solve_case(t):\n     r, c, m = [int(num) for num in raw_input().strip().split()]\n     sweeper = Sweeper(r, c, m)\n     print 'Case #%d:' % (t,)\n     if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():\n         #check_matrix(sweeper.matrix, m)\n         print_matrix(sweeper.matrix)\n         return\n     f_result = True\n     while sweeper.current_m > 0 and f_result:\n         f_result = False\n         f_result |= sweeper.fill_row()\n         f_result |= sweeper.fill_col()\n     if sweeper.current_m > 0:\n         sweeper.fill_partial()\n     if sweeper.current_m > 0:\n         print 'Impossible'\n     else:\n         #check_matrix(sweeper.matrix, m)\n         print_matrix(sweeper.matrix)\n \n def main():\n     t = int(raw_input().strip())\n     for i in range(1, t + 1):\n         solve_case(i)\n \n if __name__ == '__main__':\n     main()\n
gepa	<>	2	<>	2013_2270488_2449486.py	<>	import sys\n \n \n def compute(N, M, a):\n     rows = [0] * N\n     cols = [0] * M\n     for r in xrange(N):\n         rows[r] = 0\n         for c in xrange(M):\n             if a[r][c] > rows[r]:\n                 rows[r] = a[r][c]\n     for c in xrange(M):\n         cols[c] = 0\n         for r in xrange(N):\n             if a[r][c] > cols[c]:\n                 cols[c] = a[r][c]\n     for r in xrange(N):\n         for c in xrange(M):\n             if a[r][c] < rows[r] and a[r][c] < cols[c]:\n                 return "NO"\n     return "YES"\n \n \n def parse():\n     N, M = map(int, sys.stdin.readline().strip().split())\n     a = []\n     for i in xrange(N):\n         a.append(map(int, sys.stdin.readline().strip().split()))\n     return N, M, a,\n \n \n if __name__ == "__main__":\n     sys.setrecursionlimit(100000)\n     T = int(sys.stdin.readline().strip())\n     count = 1\n     part = 0\n     if len(sys.argv) == 3:\n         part = int(sys.argv[1])\n         count = int(sys.argv[2])\n     for i in xrange(T):\n         data = parse()\n         if i * count >= part * T and i * count < (part + 1) * T:\n             result = compute(*data)\n             print "Case #%d: %s" % (i + 1, result)\n
gepa	<>	2	<>	2012_1460488_1483488.py	<>	import sys\n \n MAX_LIMIT = 2000000\n \n \n def get_min_mapped(n):\n     n_min = n\n     x = str(n)\n     for i in xrange(1, len(x)):\n         x = x[1:] + x[0]\n         if x[0] == '0':\n             continue\n         n_min = min(n_min, int(x))\n     return n_min\n \n \n if __name__ == "__main__":\n     T = int(sys.stdin.readline().strip())\n     min_mapped = [0] * (MAX_LIMIT + 1)\n     for i in xrange(1, MAX_LIMIT + 1):\n         min_mapped[i] = get_min_mapped(i)\n \n     for r in xrange(T):\n         values = map(int, sys.stdin.readline().strip().split(' '))\n         A, B = values\n         cnt_mapped = [0] * (B + 1)\n         for i in xrange(A, B + 1):\n             cnt_mapped[min_mapped[i]] += 1\n         total = 0\n         for i in xrange(B + 1):\n             if cnt_mapped[i] > 1:\n                 total += (cnt_mapped[i] * (cnt_mapped[i] - 1)) / 2\n         print "Case #%d: %s" % (r + 1, total)\n
gepa	<>	2	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n \n def compute(r1, m1, r2, m2):\n     valid1 = set(m1[r1 - 1])\n     valid2 = set(m2[r2 - 1])\n     valid = valid1 & valid2\n     if len(valid) == 0:\n         return 'Volunteer cheated!'\n     if len(valid) > 1:\n         return 'Bad magician!'\n     return valid.pop()\n \n \n def parse_single():\n     r = int(sys.stdin.readline().strip())\n     m = []\n     for i in xrange(4):\n         m.append(map(int, sys.stdin.readline().strip().split()))\n     return r, m\n \n def parse():\n     r1, m1 = parse_single()\n     r2, m2 = parse_single()\n     return r1, m1, r2, m2\n \n \n if __name__ == "__main__":\n     sys.setrecursionlimit(100000)\n     T = int(sys.stdin.readline().strip())\n     for i in xrange(T):\n         data = parse()\n         result = compute(*data)\n         print "Case #%d: %s" % (i + 1, result)\n
gepa	<>	2	<>	2012_1460488_1483485.py	<>	import sys\n \n mapping = {}\n \n def init_mapping():\n     encoded = ["ejp mysljylc kd kxveddknmc re jsicpdrysi",\n             "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n             "de kr kd eoya kw aej tysr re ujdr lkgc jv",\n             "y qee z"\n             ]\n     decoded = ["our language is impossible to understand",\n             "there are twenty six factorial possibilities",\n             "so it is okay if you want to just give up",\n             "a zoo q"\n             ]\n     for i in xrange(len(encoded)):\n         for j in xrange(len(encoded[i])):\n             if encoded[i][j] in mapping and mapping[encoded[i][j]] != decoded[i][j]:\n                 raise Exception("Multiple mapping for %s" % encoded[i][j])\n             mapping[encoded[i][j]] = decoded[i][j]\n \n \n def decode(sentence):\n     return ''.join(map(lambda x : mapping.get(x, x), sentence))\n \n \n if __name__ == "__main__":\n     init_mapping()\n     T = int(sys.stdin.readline().strip())\n     for i in xrange(T):\n         result = decode(sys.stdin.readline().strip())\n         print "Case #%d: %s" % (i + 1, result)\n
gepa	<>	2	<>	2014_2974486_5709773144064000.py	<>	import math\n import sys\n \n \n def compute(C, F, X):\n     k = int(math.floor(X / C - 2.0 / F))\n     if k <= 0:\n         return X / 2\n     total = 0.0\n     for i in xrange(k):\n         total += 1.0 / (2.0 + i * F)\n     return C * total + X / (2.0 + k * F)\n \n \n def parse():\n     C, F, X = map(float, sys.stdin.readline().strip().split())\n     return C, F, X\n \n \n if __name__ == "__main__":\n     sys.setrecursionlimit(100000)\n     T = int(sys.stdin.readline().strip())\n     for i in xrange(T):\n         data = parse()\n         result = compute(*data)\n         print "Case #%d: %0.7f" % (i + 1, result)\n
gepa	<>	2	<>	2013_2270488_2453486.py	<>	import sys\n import string\n \n \n def won(board, mapping):\n     val = int(board.translate(string.maketrans(mapping, "1100")), 2)\n     for v in [0x000f, 0x00f0, 0x0f00, 0xf000,\n               0x1111, 0x2222, 0x4444, 0x8888,\n               0x1248, 0x8421]:\n         if (val & v) == v:\n             return True\n     return False\n \n \n def finished(board):\n     return '.' not in board\n \n \n def compute(board):\n     if won(board, 'XTO.'):\n         return "X won"\n     if won(board, 'OTX.'):\n         return "O won"\n     if finished(board):\n         return "Draw"\n     return "Game has not completed"\n \n \n def parse():\n     board = []\n     for i in xrange(4):\n         board.append(sys.stdin.readline().strip())\n     sys.stdin.readline()\n     return (''.join(board),)\n \n \n if __name__ == "__main__":\n     sys.setrecursionlimit(100000)\n     T = int(sys.stdin.readline().strip())\n     count = 1\n     part = 0\n     if len(sys.argv) == 3:\n         part = int(sys.argv[1])\n         count = int(sys.argv[2])\n     for i in xrange(T):\n         data = parse()\n         if i * count >= part * T and i * count < (part + 1) * T:\n             result = compute(*data)\n             print "Case #%d: %s" % (i + 1, result)\n
gepa	<>	2	<>	2014_2974486_5690574640250880.py	<>	import sys\n \n \n DX = (-1, -1, -1, 0, 1, 1, 1, 0)\n DY = (-1, 0, 1, 1, 1, 0, -1, -1)\n \n \n def compute(R, C, M):\n     if M == 0:\n         return empty(R, C)\n     free = R * C - M\n     if free == 1:\n         return single_free(R, C)\n     if R == 1:\n         return single_row(C, M)\n     if C == 1:\n         return single_column(R, M)\n     if R == 2:\n         return two_rows(C, M)\n     if C == 2:\n         return two_columns(R, M)\n     if free in (2,3,5,7):\n         return "\nImpossible"\n     return at_least_three(R, C, M)\n \n \n def make_board(R, C, default='.'):\n     return [[default for j in xrange(C)] for i in xrange(R)]\n \n \n def to_string(board):\n     s = ""\n     for i in xrange(len(board)):\n         s += '\n' + ''.join(board[i])\n     return s\n \n         \n def empty(R, C):\n     board = make_board(R, C)\n     board[0][0] = 'c'\n     return to_string(board)\n \n \n def single_free(R, C):\n     board = make_board(R, C, default='*')\n     board[0][0] = 'c'\n     return to_string(board)\n \n \n def single_row(C, M):\n     board = make_board(1, C)\n     board[0][0] = 'c'\n     for i in xrange(M):\n         board[0][C - 1 - i] = '*'\n     return to_string(board)\n \n \n def single_column(R, M):\n     board = make_board(R, 1)\n     board[0][0] = 'c'\n     for i in xrange(M):\n         board[R - 1 - i][0] = '*'\n     return to_string(board)\n \n \n def two_rows(C, M):\n     if M % 2 != 0:\n         return "\nImpossible"\n     if 2 * C - M < 4:\n         return "\nImpossible"\n     board = make_board(2, C)\n     for i in xrange(M / 2):\n         board[0][C - 1 - i] = '*'\n         board[1][C - 1 - i] = '*'\n     board[0][0] = 'c'\n     return to_string(board)\n \n \n def two_columns(R, M):\n     if M % 2 != 0:\n         return "\nImpossible"\n     if 2 * R - M < 4:\n         return "\nImpossible"\n     board = make_board(R, 2)\n     for i in xrange(M / 2):\n         board[R - 1 - i][0] = '*'\n         board[R - 1 - i][1] = '*'\n     board[0][0] = 'c'\n     return to_string(board)\n \n \n def finalize(R, C, M, board):\n     mines = 0\n     for i in xrange(R):\n         for j in xrange(C):\n             if board[i][j] == '0':\n                 continue\n             empty = False\n             for d in xrange(8):\n                 if i + DX[d] < 0 or i + DX[d] >= R or j + DY[d] < 0 or j + DY[d] >= C:\n                     continue\n                 if board[i + DX[d]][j + DY[d]] == '0':\n                     empty = True\n                     break\n             if empty:\n                 board[i][j] = '.'\n             else:\n                 board[i][j] = '*'\n                 mines += 1\n     for i in xrange(R):\n         for j in xrange(C):\n             if board[i][j] == '0':\n                 board[i][j] = '.'\n     board[0][0] = 'c'\n     if mines != M:\n         sys.stderr.write("mines:%s expected:%s\n" % (mines, M))\n     return to_string(board)\n \n \n def at_least_three(R, C, M):\n     board = make_board(R, C)\n     board[0][0] = '0'\n     free = R * C - M\n     count = 4\n     if count == free:\n         return finalize(R, C, M, board)\n     board[0][1] = '0'\n     count += 2\n     if count == free:\n         return finalize(R, C, M, board)\n     board[1][0] = '0'\n     count += 2\n     if count == free:\n         return finalize(R, C, M, board)\n     for j in xrange(2, C - 1):\n         if count + 2 > free:\n             break\n         board[0][j] = '0'\n         count += 2\n     for i in xrange(2, R - 1):\n         if count + 2 > free:\n             break\n         board[i][0] = '0'\n         count += 2\n     for i in xrange(1, R - 1):\n         for j in xrange(1, C - 1):\n             if count == free:\n                 return finalize(R, C, M, board)\n             board[i][j] = '0'\n             count += 1\n     sys.stderr.write("empty board?\n")\n     return finalize(board)\n \n \n def parse():\n     R, C, M = map(int, sys.stdin.readline().strip().split())\n     return R, C, M\n \n \n if __name__ == "__main__":\n     sys.setrecursionlimit(100000)\n     T = int(sys.stdin.readline().strip())\n     for i in xrange(T):\n         sys.stderr.write("case:%s\n" % (i + 1))\n         data = parse()\n         result = compute(*data)\n         print "Case #%d: %s" % (i + 1, result)\n
addie9000	<>	3	<>	2013_2270488_2463486.py	<>	#!/usr/local/bin/python\n import sys, string, math\n \n \n # check if num x is palindrome\n def is_palindrome(x):\n     candidate = list(str(x))\n     while len(candidate) > 1:\n         if candidate.pop(0) != candidate.pop():\n             return False\n     return True\n \n \n #square\n def square(x):\n     return x * x\n \n \n #solve case function\n def solve_case(ab, case_number):\n     fs = 0\n     root = int(math.sqrt(ab[0]))\n     sq = square(root)\n     if sq < ab[0]:\n         root += 1\n         sq = square(root)\n \n     while sq <= ab[1]:\n         if is_palindrome(root) and is_palindrome(sq):\n             fs += 1\n \n         #prepare for next\n         root += 1\n         sq = square(root)\n \n     print "Case #%d: %d" % (case_number, fs)\n \n \n #main\n def main():\n     r = sys.stdin\n     if len(sys.argv) > 1:\n         r = open(sys.argv[1], 'r')\n \n     total_cases = r.readline()\n     for case_number in range(1, int(total_cases) + 1):\n         ab = map(int, r.readline().strip().split(' '))\n         solve_case(ab, case_number)\n \n # invoke main\n if __name__ == "__main__":\n     main()
addie9000	<>	3	<>	2013_2270488_2449486.py	<>	#!/usr/local/bin/python\n import sys, string\n \n \n #solve case function\n def solve_case(nm, lawn, case_number):\n     zipped_lawn = zip(*lawn)\n     for n in range(0, nm[0]):\n         max_lawn_n = max(lawn[n])\n         for m in range(0, nm[1]):\n             max_lawn_m = max(zipped_lawn[m])\n             if lawn[n][m] < max_lawn_n and lawn[n][m] < max_lawn_m:\n                 print "Case #%d: NO" % case_number\n                 return\n \n     print "Case #%d: YES" % case_number\n \n \n #main\n def main():\n     r = sys.stdin\n     if len(sys.argv) > 1:\n         r = open(sys.argv[1], 'r')\n \n     total_cases = r.readline()\n     for case_number in range(1, int(total_cases) + 1):\n         nm = map(int, r.readline().strip().split(' '))\n         lawn = []\n         for n in range(0, nm[0]):\n             lawn.append(map(int, r.readline().strip().split(' ')))\n         solve_case(nm, lawn, case_number)\n \n # invoke main\n if __name__ == "__main__":\n     main()
addie9000	<>	3	<>	2012_1460488_1483488.py	<>	#!/usr/bin/python\n import sys, string, math\n \n #solve case function\n def solve_case(min, max, case_number):\n 	ans = 0\n \n 	for candidate in range(min, max + 1):\n 		candidate_str = str(candidate)\n 		ignore = []\n 		for rot in range(1, len(candidate_str)):\n 			rot_candidate = int(candidate_str[rot:] + candidate_str[:rot])\n 			if not rot_candidate in ignore:\n 				if rot_candidate <= max and candidate < rot_candidate:\n 					ans = ans + 1\n 				ignore.append(rot_candidate)\n \n 	print "Case #%d: %d" % (case_number, ans)\n \n #main\n r = sys.stdin\n \n if len(sys.argv) > 1:\n 	r = open(sys.argv[1], 'r')\n \n total_cases = r.readline()\n for case_number in range(1, int(total_cases) + 1):\n 	case = map(int, r.readline().rstrip().split(' '))\n 	solve_case(case[0], case[1], case_number)\n \n
addie9000	<>	3	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/python\n import sys, string\n \n #solve case function\n def solve_case(answers, arrangements_of_cards, case_number):\n     first_candidates = arrangements_of_cards[0][answers[0] - 1]\n     second_candidates = arrangements_of_cards[1][answers[1] - 1]\n     answer = set(first_candidates) & set(second_candidates)\n     length_of_answer = len(answer)\n     if length_of_answer > 1:\n         print "Case #%d: Bad magician!" % case_number\n     elif length_of_answer < 1:\n         print "Case #%d: Volunteer cheated!" % case_number\n     else:\n         # There is only one element in the set!\n         print "Case #%d: %d" % (case_number, answer.pop())\n \n #main\n r = sys.stdin\n \n if len(sys.argv) > 1:\n     r = open(sys.argv[1], 'r')\n \n total_cases = r.readline()\n for case_number in range(1, int(total_cases) + 1):\n     answers = []\n     arrangements_of_cards = []\n     answers.append(int(r.readline()))\n     arrangements_of_cards.append([])\n     for row in range(0, 4):\n         arrangements_of_cards[0].append(map(int, r.readline().split(' ')))\n     answers.append(int(r.readline()))\n     arrangements_of_cards.append([])\n     for row in range(0, 4):\n         arrangements_of_cards[1].append(map(int, r.readline().split(' ')))\n     solve_case(answers, arrangements_of_cards, case_number)\n
addie9000	<>	3	<>	2012_1460488_1483485.py	<>	#!/usr/bin/python\n import sys, string\n \n # make the googlerese dic\n gdic = {}\n sample_googlerese = "yqeeejpmysljylckdkxveddknmcrejsicpdrysirbcpcypcrtcsradkhwyfrepkymveddknkmkrkcddekrkdeoyakwaejtysrreujdrlkgcjv"\n sample_plain_text = "azooourlanguageisimpossibletounderstandtherearetwentysixfactorialpossibilitiessoitisokayifyouwanttojustgiveup"\n for gletter, pletter in zip(sample_googlerese, sample_plain_text):\n 	if gletter in gdic:\n 		if not gdic[gletter] == pletter:\n 			print "ERROR!! Can't analyze the sample text."\n 			sys.exit()\n 	else:\n 		gdic[gletter] = pletter\n \n if len(gdic) == 25:\n 	candidate_gletter = set(string.ascii_lowercase) - set(sample_googlerese)\n 	candidate_pletter = set(string.ascii_lowercase) - set(sample_plain_text)\n 	if len(candidate_gletter) == 1 and len(candidate_pletter) == 1:\n 		gdic[candidate_gletter.pop()] = candidate_pletter.pop()\n \n gdic[' '] = ' '\n \n # open the file\n r = sys.stdin\n \n if len(sys.argv) > 1:\n 	r = open(sys.argv[1], 'r')\n \n # solve the cases \n total_cases = r.readline()\n for case_number in range(1, int(total_cases) + 1):\n 	googlerese_text = r.readline().rstrip()\n 	plain_text = ""	\n 	for gletter in googlerese_text:\n 		plain_text = plain_text + gdic[gletter]\n \n 	print "Case #%d: %s" % (case_number, plain_text)\n
addie9000	<>	3	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/python\n import sys, string\n \n #solve case function\n def solve_case(c, f, x, case_number):\n     rate = 2.0\n     time = 0.0\n     rest = x\n     while True:\n         time_to_c = c / rate\n         time_to_x = rest / rate\n         if time_to_c < time_to_x:\n             time_to_x_with_boost = time_to_c + (rest / (rate + f))\n             if time_to_x_with_boost < time_to_x:\n                 rate += f\n                 time += time_to_c\n             else:\n                 break\n         else:\n             break\n     time += rest / rate\n     print "Case #%d: %.7f" % (case_number, time)\n \n #main\n r = sys.stdin\n \n if len(sys.argv) > 1:\n     r = open(sys.argv[1], 'r')\n \n total_cases = r.readline()\n for case_number in range(1, int(total_cases) + 1):\n     values = map(float, r.readline().split(' '))\n     solve_case(values[0], values[1], values[2], case_number)\n
addie9000	<>	3	<>	2013_2270488_2453486.py	<>	#!/usr/bin/python\n import sys, string\n \n #output result\n def output(case_number, status):\n     print "Case #%d: %s" % (case_number, status)\n \n #solve case function\n def solve_case(board, case_number):\n     has_game_completed = True\n \n     # check row\n     for column in range(0, 4):\n         x = 0\n         o = 0\n         for row in range(0, 4):\n             if board[column][row] == 'X':\n                 x += 1\n             elif board[column][row] == 'O':\n                 o += 1\n             elif board[column][row] == 'T':\n                 x += 1\n                 o += 1\n             else:\n                 has_game_completed = False\n \n         # check if X or O won already\n         if x > 3:\n             output(case_number, "X won")\n             return\n         if o > 3:\n             output(case_number, "O won")\n             return\n \n     # check column\n     for row in range(0, 4):\n         x = 0\n         o = 0\n         for column in range(0, 4):\n             if board[column][row] == 'X':\n                 x += 1\n             elif board[column][row] == 'O':\n                 o += 1\n             elif board[column][row] == 'T':\n                 x += 1\n                 o += 1\n \n         # check if X or O won already\n         if x > 3:\n             output(case_number, "X won")\n             return\n         if o > 3:\n             output(case_number, "O won")\n             return\n \n     # check diagonal 1\n     x = 0\n     o = 0\n     for rc in range(0, 4):\n         if board[rc][rc] == 'X':\n             x += 1\n         elif board[rc][rc] == 'O':\n             o += 1\n         elif board[rc][rc] == 'T':\n             x += 1\n             o += 1\n \n     # check if X or O won already\n     if x > 3:\n         output(case_number, "X won")\n         return\n     if o > 3:\n         output(case_number, "O won")\n         return\n \n     # check diagonal 2\n     x = 0\n     o = 0\n     for rc in range(0, 4):\n         if board[rc][3 - rc] == 'X':\n             x += 1\n         elif board[rc][3 - rc] == 'O':\n             o += 1\n         elif board[rc][3 - rc] == 'T':\n             x += 1\n             o += 1\n \n     # check if X or O won already\n     if x > 3:\n         output(case_number, "X won")\n         return\n     if o > 3:\n         output(case_number, "O won")\n         return\n \n     if has_game_completed:\n         output(case_number, "Draw")\n     else:\n         output(case_number, "Game has not completed")\n \n #main\n def main():\n     r = sys.stdin\n     if len(sys.argv) > 1:\n         r = open(sys.argv[1], 'r')\n \n     total_cases = r.readline()\n     for case_number in range(1, int(total_cases) + 1):\n         board = []\n         for row in range(0, 4):\n             board.append(list(r.readline().strip()))\n \n         #skip the last empty line\n         r.readline()\n         solve_case(board, case_number)\n \n # invoke main\n if __name__ == "__main__":\n     main()
addie9000	<>	3	<>	2014_2974486_5690574640250880.py	<>	# !/usr/bin/python\n import sys\n import math\n \n \n def print_basic_board(no_mine, r, c):\n     printed_c = False\n     for row in range(0, r):\n         line = []\n         for column in range(0, c):\n             if printed_c:\n                 if no_mine > 0:\n                     line.append(".")\n                     no_mine -= 1\n                 else:\n                     line.append("*")\n             else:\n                 line.append("c")\n                 no_mine -= 1\n                 printed_c = True\n         print "".join(line)\n \n \n def print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c):\n     printed_c = False\n     for row in range(0, r):\n         line = []\n         for column in range(0, c):\n             if printed_c:\n                 if row < no_mine_row and column < no_mine_column:\n                     line.append(".")\n                 elif rest_no_mine_for_column > 0 and column == no_mine_column:\n                     line.append(".")\n                     rest_no_mine_for_column -= 1\n                 elif rest_no_mine_for_row > 0 and row == no_mine_row:\n                     line.append(".")\n                     rest_no_mine_for_row -= 1\n                 else:\n                     line.append("*")\n             else:\n                 line.append("c")\n                 printed_c = True\n         print "".join(line)\n \n \n #solve case function\n def solve_case(r, c, m, case_number):\n     print "Case #%d:" % case_number\n     no_mine = r * c - m\n     if r < 2 or c < 2 or no_mine == 1:\n         print_basic_board(no_mine, r, c)\n     else:\n         no_mine_row_max = int(math.ceil(float(no_mine) / 2))\n         if no_mine_row_max > r:\n             no_mine_row_max = r\n         for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):\n             if no_mine_column > c:\n                 break\n             for no_mine_row in range(2, no_mine_row_max + 1):\n                 rest_no_mine = no_mine - (no_mine_column * no_mine_row)\n                 if rest_no_mine < 0:\n                     continue\n                 if rest_no_mine == 1:\n                     continue\n \n                 if rest_no_mine == 0:\n                     print_board(no_mine_row, no_mine_column, 0, 0, r, c)\n                     return\n                 if rest_no_mine <= no_mine_row and no_mine_column < c:\n                     print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)\n                     return\n                 if rest_no_mine <= no_mine_column and no_mine_row < r:\n                     print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)\n                     return\n \n                 if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:\n                     for rest_no_mine_for_row in range(2, no_mine_column):\n                         rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row\n                         if rest_no_mine_for_column < no_mine_row:\n                             print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c)\n                             return\n \n         print "Impossible"\n \n #main\n r_file = sys.stdin\n \n if len(sys.argv) > 1:\n     r_file = open(sys.argv[1], 'r')\n \n total_cases = r_file.readline()\n for case_number in range(1, int(total_cases) + 1):\n     values = map(int, r_file.readline().split(' '))\n     solve_case(values[0], values[1], values[2], case_number)\n \n
serialk	<>	4	<>	2013_2270488_2463486.py	<>	#!/usr/bin/env python3\n # -*- encoding: utf-8 -*-\n \n from math import sqrt\n \n def is_palindromic(i):\n     n = i\n     rev = 0\n     while i > 0:\n         dig = i % 10\n         rev = rev * 10 + dig\n         i = i // 10\n     return n == rev\n \n def is_square(i):\n     if i == 1:\n         return True\n     x = i // 2\n     seen = set([x])\n     while x * x != i:\n         x = (x + (i // x)) // 2\n         if x in seen:\n             return False\n         seen.add(x)\n     return True\n \n def f(a, b):\n     tot = 0\n \n     sra = a\n     while not is_square(sra):\n         sra += 1\n     srb = b\n     while not is_square(srb):\n         srb -= 1\n \n     sra = int(sqrt(sra))\n     srb = int(sqrt(srb))\n \n     for i in range(sra, srb+1):\n         if is_palindromic(i) and is_palindromic(i ** 2):\n             tot += 1\n \n     return tot\n \n if __name__ == '__main__':\n     T = int(input())\n     for i in range(T):\n         a, b = map(int, input().split())\n         r = f(a, b)\n         print('Case #{}: {}'.format(i+1, r))\n
serialk	<>	4	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python2.7\n \n T = int(raw_input())\n for i in xrange(T):\n     values = map(int, raw_input().split())\n     [N,s,p] = values[0:3]\n     t = values[3:]\n     answer = 0\n     for note in t:\n         if note < 2:\n             if note >= p:\n                 answer += 1\n         elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n             answer += 1\n         elif note % 3 == 0:\n             n = note / 3\n             if n >= p:\n                 answer += 1\n             elif s > 0 and n + 1 >= p:\n                 answer += 1\n                 s -= 1\n         elif note % 3 == 2:\n             n = (note - 2) / 3\n             if n + 1 >= p:\n                 answer += 1\n             elif s > 0 and n + 2 >= p:\n                 answer += 1\n                 s -= 1\n     print 'Case #{0}: {1}'.format(i+1, answer)\n
serialk	<>	4	<>	2014_2974486_5756407898963968.py	<>	T = int(input())\n \n for i in range(T):\n     a1 = int(input())\n     mat1 = [list(map(int, input().split())) for k in range(4)]\n     a2 = int(input())\n     mat2 = [list(map(int, input().split())) for k in range(4)]\n     final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])\n     if not len(final_set):\n         s = 'Volunteer cheated!'\n     elif len(final_set) > 1:\n         s = 'Bad magician!'\n     else:\n         s = list(final_set)[0]\n     print('Case #{}: {}'.format(i + 1, s))\n
serialk	<>	4	<>	2012_1460488_1483485.py	<>	#!/usr/bin/env python2.6\n \n translate = {'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'q': 'z', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm', 'z': 'q'}\n \n nb = int(raw_input())\n for i in xrange(nb):\n     s = ''.join([translate[char] if char in translate.keys() else char for char in str(raw_input())])\n     print 'Case #{0}:'.format(i+1), s\n
serialk	<>	4	<>	2014_2974486_5709773144064000.py	<>	import sys\n \n sys.setrecursionlimit(9299999)\n \n def min_time(C, F, X, speed, nb_cookies):\n 	if (X - nb_cookies) / speed < (X - (nb_cookies - C)) / (speed + F):\n 		return (X - nb_cookies) / speed\n 	elif nb_cookies >= C:\n 		return min_time(C, F, X, speed + F, nb_cookies - C)\n 	else:\n 		return (C - nb_cookies) / speed + min_time(C, F, X, speed, C)\n \n T = int(raw_input())\n for i in range(T):\n 	C, F, X = map(float, raw_input().split())\n 	print 'Case #%d: %f' % (i + 1, min_time(C, F, X, 2, 0))\n
serialk	<>	4	<>	2013_2270488_2453486.py	<>	#!/usr/bin/env python3\n # -*- encoding: utf-8 -*-\n \n \n def who_won(l):\n     current = None\n     for i in l:\n         if i == '.':\n             return None\n         if not current and i in 'OX':\n             current = i\n         if current and current != i and i != 'T':\n             return None\n     return current\n \n \n def f(m):\n     still = False\n     for i in m:\n         for j in i:\n             if j == '.':\n                 still = True\n \n     rows = m # [[m[i][j] for i in range(4)] for j in range(4)]\n     cols = [[m[i][j] for i in range(4)] for j in range(4)]\n     diag = [[m[i][i] for i in range(4)], [m[3-i][i] for i in range(4)]]\n \n     winner = None\n \n     for l in rows + cols + diag:\n         c = who_won(l)\n         if c:\n             winner = c + ' won'\n \n     if not winner:\n         if still:\n             winner = 'Game has not completed'\n         else:\n             winner = 'Draw'\n     return winner\n \n if __name__ == '__main__':\n     T = int(input())\n     for i in range(T):\n         m = [list(input()) for k in range(4)]\n         if i != T- 1:\n             input()\n         r = f(m)\n         print('Case #{}: {}'.format(i+1, r))\n
serialk	<>	4	<>	2014_2974486_5690574640250880.py	<>	CACHE = {(1, 1, 0): ['c'],\n  (1, 2, 0): ['c.'],\n  (1, 2, 1): ['*c'],\n  (1, 3, 0): ['c..'],\n  (1, 3, 1): ['*.c'],\n  (1, 3, 2): ['**c'],\n  (1, 4, 0): ['c...'],\n  (1, 4, 1): ['*.c.'],\n  (1, 4, 2): ['**.c'],\n  (1, 4, 3): ['***c'],\n  (1, 5, 0): ['c....'],\n  (1, 5, 1): ['*.c..'],\n  (1, 5, 2): ['**.c.'],\n  (1, 5, 3): ['***.c'],\n  (1, 5, 4): ['****c'],\n  (2, 1, 0): ['c', '.'],\n  (2, 1, 1): ['*', 'c'],\n  (2, 2, 0): ['c.', '..'],\n  (2, 2, 1): None,\n  (2, 2, 2): None,\n  (2, 2, 3): ['**', '*c'],\n  (2, 3, 0): ['c..', '...'],\n  (2, 3, 1): None,\n  (2, 3, 2): ['*.c', '*..'],\n  (2, 3, 3): None,\n  (2, 3, 4): None,\n  (2, 3, 5): ['***', '**c'],\n  (2, 4, 0): ['c...', '....'],\n  (2, 4, 1): None,\n  (2, 4, 2): ['*.c.', '*...'],\n  (2, 4, 3): None,\n  (2, 4, 4): ['**.c', '**..'],\n  (2, 4, 5): None,\n  (2, 4, 6): None,\n  (2, 4, 7): ['****', '***c'],\n  (2, 5, 0): ['c....', '.....'],\n  (2, 5, 1): None,\n  (2, 5, 2): ['*.c..', '*....'],\n  (2, 5, 3): None,\n  (2, 5, 4): ['**.c.', '**...'],\n  (2, 5, 5): None,\n  (2, 5, 6): ['***.c', '***..'],\n  (2, 5, 7): None,\n  (2, 5, 8): None,\n  (2, 5, 9): ['*****', '****c'],\n  (3, 1, 0): ['c', '.', '.'],\n  (3, 1, 1): ['*', '.', 'c'],\n  (3, 1, 2): ['*', '*', 'c'],\n  (3, 2, 0): ['c.', '..', '..'],\n  (3, 2, 1): None,\n  (3, 2, 2): ['**', '..', 'c.'],\n  (3, 2, 3): None,\n  (3, 2, 4): None,\n  (3, 2, 5): ['**', '**', '*c'],\n  (3, 3, 0): ['c..', '...', '...'],\n  (3, 3, 1): ['*.c', '...', '...'],\n  (3, 3, 2): None,\n  (3, 3, 3): ['***', '...', 'c..'],\n  (3, 3, 4): None,\n  (3, 3, 5): ['***', '*..', '*.c'],\n  (3, 3, 6): None,\n  (3, 3, 7): None,\n  (3, 3, 8): ['***', '***', '**c'],\n  (3, 4, 0): ['c...', '....', '....'],\n  (3, 4, 1): ['*.c.', '....', '....'],\n  (3, 4, 2): ['**.c', '....', '....'],\n  (3, 4, 3): ['*.c.', '*...', '*...'],\n  (3, 4, 4): ['****', '....', 'c...'],\n  (3, 4, 5): None,\n  (3, 4, 6): ['****', '*...', '*.c.'],\n  (3, 4, 7): None,\n  (3, 4, 8): ['****', '**..', '**.c'],\n  (3, 4, 9): None,\n  (3, 4, 10): None,\n  (3, 4, 11): ['****', '****', '***c'],\n  (3, 5, 0): ['c....', '.....', '.....'],\n  (3, 5, 1): ['*.c..', '.....', '.....'],\n  (3, 5, 2): ['**.c.', '.....', '.....'],\n  (3, 5, 3): ['***.c', '.....', '.....'],\n  (3, 5, 4): ['**.c.', '*....', '*....'],\n  (3, 5, 5): ['*****', '.....', 'c....'],\n  (3, 5, 6): ['**.c.', '**...', '**...'],\n  (3, 5, 7): ['*****', '*....', '*.c..'],\n  (3, 5, 8): None,\n  (3, 5, 9): ['*****', '**...', '**.c.'],\n  (3, 5, 10): None,\n  (3, 5, 11): ['*****', '***..', '***.c'],\n  (3, 5, 12): None,\n  (3, 5, 13): None,\n  (3, 5, 14): ['*****', '*****', '****c'],\n  (4, 1, 0): ['c', '.', '.', '.'],\n  (4, 1, 1): ['*', '.', 'c', '.'],\n  (4, 1, 2): ['*', '*', '.', 'c'],\n  (4, 1, 3): ['*', '*', '*', 'c'],\n  (4, 2, 0): ['c.', '..', '..', '..'],\n  (4, 2, 1): None,\n  (4, 2, 2): ['**', '..', 'c.', '..'],\n  (4, 2, 3): None,\n  (4, 2, 4): ['**', '**', '..', 'c.'],\n  (4, 2, 5): None,\n  (4, 2, 6): None,\n  (4, 2, 7): ['**', '**', '**', '*c'],\n  (4, 3, 0): ['c..', '...', '...', '...'],\n  (4, 3, 1): ['*.c', '...', '...', '...'],\n  (4, 3, 2): ['*.c', '*..', '...', '...'],\n  (4, 3, 3): ['***', '...', 'c..', '...'],\n  (4, 3, 4): ['***', '*..', '..c', '...'],\n  (4, 3, 5): None,\n  (4, 3, 6): ['***', '***', '...', 'c..'],\n  (4, 3, 7): None,\n  (4, 3, 8): ['***', '***', '*..', '*.c'],\n  (4, 3, 9): None,\n  (4, 3, 10): None,\n  (4, 3, 11): ['***', '***', '***', '**c'],\n  (4, 4, 0): ['c...', '....', '....', '....'],\n  (4, 4, 1): ['*.c.', '....', '....', '....'],\n  (4, 4, 2): ['**.c', '....', '....', '....'],\n  (4, 4, 3): ['**.c', '*...', '....', '....'],\n  (4, 4, 4): ['****', '....', 'c...', '....'],\n  (4, 4, 5): ['****', '*...', '..c.', '....'],\n  (4, 4, 6): ['****', '**..', '...c', '....'],\n  (4, 4, 7): ['****', '*...', '*.c.', '*...'],\n  (4, 4, 8): ['****', '****', '....', 'c...'],\n  (4, 4, 9): None,\n  (4, 4, 10): ['****', '****', '*...', '*.c.'],\n  (4, 4, 11): None,\n  (4, 4, 12): ['****', '****', '**..', '**.c'],\n  (4, 4, 13): None,\n  (4, 4, 14): None,\n  (4, 4, 15): ['****', '****', '****', '***c'],\n  (4, 5, 0): ['c....', '.....', '.....', '.....'],\n  (4, 5, 1): ['*.c..', '.....', '.....', '.....'],\n  (4, 5, 2): ['**.c.', '.....', '.....', '.....'],\n  (4, 5, 3): ['***.c', '.....', '.....', '.....'],\n  (4, 5, 4): ['***.c', '*....', '.....', '.....'],\n  (4, 5, 5): ['*****', '.....', 'c....', '.....'],\n  (4, 5, 6): ['*****', '*....', '..c..', '.....'],\n  (4, 5, 7): ['*****', '**...', '...c.', '.....'],\n  (4, 5, 8): ['*****', '***..', '....c', '.....'],\n  (4, 5, 9): ['*****', '**...', '*..c.', '*....'],\n  (4, 5, 10): ['*****', '*****', '.....', 'c....'],\n  (4, 5, 11): ['*****', '**...', '**.c.', '**...'],\n  (4, 5, 12): ['*****', '*****', '*....', '*.c..'],\n  (4, 5, 13): None,\n  (4, 5, 14): ['*****', '*****', '**...', '**.c.'],\n  (4, 5, 15): None,\n  (4, 5, 16): ['*****', '*****', '***..', '***.c'],\n  (4, 5, 17): None,\n  (4, 5, 18): None,\n  (4, 5, 19): ['*****', '*****', '*****', '****c'],\n  (5, 1, 0): ['c', '.', '.', '.', '.'],\n  (5, 1, 1): ['*', '.', 'c', '.', '.'],\n  (5, 1, 2): ['*', '*', '.', 'c', '.'],\n  (5, 1, 3): ['*', '*', '*', '.', 'c'],\n  (5, 1, 4): ['*', '*', '*', '*', 'c'],\n  (5, 2, 0): ['c.', '..', '..', '..', '..'],\n  (5, 2, 1): None,\n  (5, 2, 2): ['**', '..', 'c.', '..', '..'],\n  (5, 2, 3): None,\n  (5, 2, 4): ['**', '**', '..', 'c.', '..'],\n  (5, 2, 5): None,\n  (5, 2, 6): ['**', '**', '**', '..', 'c.'],\n  (5, 2, 7): None,\n  (5, 2, 8): None,\n  (5, 2, 9): ['**', '**', '**', '**', '*c'],\n  (5, 3, 0): ['c..', '...', '...', '...', '...'],\n  (5, 3, 1): ['*.c', '...', '...', '...', '...'],\n  (5, 3, 2): ['*.c', '*..', '...', '...', '...'],\n  (5, 3, 3): ['***', '...', 'c..', '...', '...'],\n  (5, 3, 4): ['***', '*..', '..c', '...', '...'],\n  (5, 3, 5): ['***', '*..', '*.c', '...', '...'],\n  (5, 3, 6): ['***', '***', '...', 'c..', '...'],\n  (5, 3, 7): ['***', '***', '*..', '..c', '...'],\n  (5, 3, 8): None,\n  (5, 3, 9): ['***', '***', '***', '...', 'c..'],\n  (5, 3, 10): None,\n  (5, 3, 11): ['***', '***', '***', '*..', '*.c'],\n  (5, 3, 12): None,\n  (5, 3, 13): None,\n  (5, 3, 14): ['***', '***', '***', '***', '**c'],\n  (5, 4, 0): ['c...', '....', '....', '....', '....'],\n  (5, 4, 1): ['*.c.', '....', '....', '....', '....'],\n  (5, 4, 2): ['**.c', '....', '....', '....', '....'],\n  (5, 4, 3): ['**.c', '*...', '....', '....', '....'],\n  (5, 4, 4): ['****', '....', 'c...', '....', '....'],\n  (5, 4, 5): ['****', '*...', '..c.', '....', '....'],\n  (5, 4, 6): ['****', '**..', '...c', '....', '....'],\n  (5, 4, 7): ['****', '**..', '*..c', '....', '....'],\n  (5, 4, 8): ['****', '****', '....', 'c...', '....'],\n  (5, 4, 9): ['****', '****', '*...', '..c.', '....'],\n  (5, 4, 10): ['****', '****', '**..', '...c', '....'],\n  (5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],\n  (5, 4, 12): ['****', '****', '****', '....', 'c...'],\n  (5, 4, 13): None,\n  (5, 4, 14): ['****', '****', '****', '*...', '*.c.'],\n  (5, 4, 15): None,\n  (5, 4, 16): ['****', '****', '****', '**..', '**.c'],\n  (5, 4, 17): None,\n  (5, 4, 18): None,\n  (5, 4, 19): ['****', '****', '****', '****', '***c'],\n  (5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],\n  (5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],\n  (5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],\n  (5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],\n  (5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],\n  (5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],\n  (5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],\n  (5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],\n  (5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],\n  (5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],\n  (5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],\n  (5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],\n  (5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],\n  (5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],\n  (5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],\n  (5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],\n  (5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],\n  (5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],\n  (5, 5, 18): None,\n  (5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],\n  (5, 5, 20): None,\n  (5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],\n  (5, 5, 22): None,\n  (5, 5, 23): None,\n  (5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}\n \n \n T = int(input())\n for i in range(T):\n 	R, C, M = map(int, input().split())\n 	print('Case #{}:'.format(i + 1))\n 	try:\n 		print('\n'.join(CACHE[(R, C, M)]))\n 	except:\n 		print('Impossible')\n
ralfkistner	<>	5	<>	2013_2270488_2463486.py	<>	import sys\n import bisect\n \n N = 10**4\n \n # [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]\n # [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001, 100220141022001, 102012040210201, 102234363432201, 121000242000121, 121242363242121, 123212464212321, 123456787654321, 400000080000004, 10000000200000001, 10002000300020001, 10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, 10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, 10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, 12122232623222121, 12124434743442121, 12321024642012321, 12323244744232321, 12343456865434321, 12345678987654321, 40000000800000004, 40004000900040004, 1000000002000000001, 1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, 1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, 1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, 1232344458544432321, 1234323468643234321, 4000000008000000004, 100000000020000000001L, 100002000030000200001L, 100004000060000400001L, 100020201040102020001L, 100022201252102220001L, 100024201484102420001L, 100200120040021002001L, 100202122050221202001L, 100204124080421402001L, 100220341262143022001L, 100222343474343222001L, 102010002040200010201L, 102012022050220210201L, 102014042080240410201L, 102030405060504030201L, 102032425272524230201L, 102212122262221212201L, 102214144272441412201L, 102232545484545232201L, 102234567696765432201L, 121000000242000000121L, 121002200252002200121L, 121004400282004400121L, 121022221262122220121L, 121024421474124420121L, 121220122262221022121L, 121222324272423222121L, 121242363484363242121L, 121244565696565442121L, 123210002464200012321L, 123212222474222212321L, 123232425484524232321L, 123234645696546432321L, 123432124686421234321L, 123434346696643434321L, 400000000080000000004L, 400004000090000400004L, 10000000000200000000001L, 10000220001410002200001L, 10002002100400120020001L, 10002222123632122220001L, 10020010200400201002001L, 10020230421612403202001L, 10022014302620341022001L, 10022234545854543222001L, 10201000020402000010201L, 10201222221612222210201L, 10203022140604122030201L, 10203244363836344230201L, 10221210222622201212201L, 10221432643834623412201L, 10223234344844343232201L, 12100000002420000000121L, 12100242003630024200121L, 12102202302620320220121L, 12102444325852344420121L, 12122010222622201022121L, 12122252443834425222121L, 12124214524842541242121L, 12321000024642000012321L, 12321244225852244212321L, 12323222344844322232321L, 12343210246864201234321L, 40000000000800000000004L]\n def isp(n):\n     s = str(n)\n     return s == s[::-1]\n \n fs = []\n for i in range(N):\n     s = str(i)\n     n1 = int(s + s[::-1])**2\n     n2 = int(s[:-1] + s[::-1])**2\n \n     if isp(n1):\n         fs.append(n1)\n     if isp(n2):\n         fs.append(n2)\n \n fs.sort()\n \n print(fs, file=sys.stderr)\n \n \n fin = sys.stdin\n T = int(fin.readline())\n for case in range(1,T+1):\n     board = []\n     A, B = map(int, fin.readline().split())\n \n     i = bisect.bisect_left(fs, A)\n     j = bisect.bisect_right(fs, B)\n \n     print("Case #%d: %s" % (case, j-i))\n \n \n
ralfkistner	<>	5	<>	2013_2270488_2449486.py	<>	\n import sys\n fin = sys.stdin\n T = int(fin.readline())\n for case in range(1,T+1):\n     board = []\n     N, M = map(int, fin.readline().split())\n     for i in range(N):\n         board.append(list(map(int, fin.readline().split())))\n     \n     row_min = [100]*N\n     row_max = [0]*N\n     col_min = [100]*M\n     col_max = [0]*M\n \n     for i in range(N):\n         for j in range(M):\n             v = board[i][j]\n             row_min[i] = min(v, row_min[i])\n             row_max[i] = max(v, row_max[i])\n             col_min[j] = min(v, col_min[j])\n             col_max[j] = max(v, col_max[j])\n \n \n     possible = True\n     for i in range(N):\n         for j in range(M):\n             v = board[i][j]\n             if v != row_max[i] and v != col_max[j]:\n                 possible = False\n                 break\n \n \n     print("Case #%d: %s" % (case, possible and "YES" or "NO"))\n \n \n \n
ralfkistner	<>	5	<>	2012_1460488_1483488.py	<>	# -*- coding: utf-8 -*-\n import sys\n fin = sys.stdin\n T = int(fin.readline())\n for case in range(1,T+1):\n     A, B = map(int, fin.readline().split())\n \n     total = 0\n \n     for i in range(A, B+1):\n         n = str(i)\n         pairs = set()\n         for shift in range(1, len(n)):\n             m = n[shift:] + n[:shift]\n             j = int(m)\n             if j > i and j <= B:\n                 pairs.add(m)\n         total += len(pairs)\n \n \n     print "Case #%d: %s" % (case, total)\n \n
ralfkistner	<>	5	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/env python3\n # -*- coding: utf-8 -*-\n # Uses https://github.com/rkistner/contest-algorithms\n \n # Recently you went to a magic show. You were very impressed by one of the tricks, so you decided to try to figure out the secret behind it!\n \n # The magician starts by arranging 16 cards in a square grid: 4 rows of cards, with 4 cards in each row. Each card has a different number from 1 to 16 written on the side that is showing. Next, the magician asks a volunteer to choose a card, and to tell him which row that card is in.\n \n # Finally, the magician arranges the 16 cards in a square grid again, possibly in a different order. Once again, he asks the volunteer which row her card is in. With only the answers to these two questions, the magician then correctly determines which card the volunteer chose. Amazing, right?\n \n # You decide to write a program to help you understand the magician's technique. The program will be given the two arrangements of the cards, and the volunteer's answers to the two questions: the row number of the selected card in the first arrangement, and the row number of the selected card in the second arrangement. The rows are numbered 1 to 4 from top to bottom.\n \n # Your program should determine which card the volunteer chose; or if there is more than one card the volunteer might have chosen (the magician did a bad job); or if there's no card consistent with the volunteer's answers (the volunteer cheated).\n \n # Solving this problem\n \n # Usually, Google Code Jam problems have 1 Small input and 1 Large input. This problem has only 1 Small input. Once you have solved the Small input, you have finished solving this problem.\n \n # Input\n \n # The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with a line containing an integer: the answer to the first question. The next 4 lines represent the first arrangement of the cards: each contains 4 integers, separated by a single space. The next line contains the answer to the second question, and the following four lines contain the second arrangement in the same format.\n \n # Output\n \n # For each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1).\n \n # If there is a single card the volunteer could have chosen, y should be the number on the card. If there are multiple cards the volunteer could have chosen, y should be "Bad magician!", without the quotes. If there are no cards consistent with the volunteer's answers, y should be "Volunteer cheated!", without the quotes. The text needs to be exactly right, so consider copying/pasting it from here.\n \n # Limits\n \n # 1  T  100.\n # 1  both answers  4.\n # Each number from 1 to 16 will appear exactly once in each arrangement.\n \n \n import sys\n \n \n def debug(*args):\n     print(*args, file=sys.stderr)\n \n fin = sys.stdin\n T = int(fin.readline())\n for case in range(1, T + 1):\n     answer1 = int(fin.readline())\n     rows1 = []\n     for i in range(4):\n         rows1.append(set(map(int, fin.readline().split())))\n     answer2 = int(fin.readline())\n     rows2 = []\n     for i in range(4):\n         rows2.append(set(map(int, fin.readline().split())))\n \n     possibilities1 = rows1[answer1-1]\n     possibilities2 = rows2[answer2-1]\n \n     numbers = possibilities1.intersection(possibilities2)\n     result = None\n     if len(numbers) == 1:\n         result = list(numbers)[0]\n     elif len(numbers) == 0:\n         result = 'Volunteer cheated!'\n     else:\n         result = 'Bad magician!'\n \n \n     print("Case #%d: %s" % (case, result))\n \n
ralfkistner	<>	5	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/env python3\n # -*- coding: utf-8 -*-\n # Uses https://github.com/rkistner/contest-algorithms\n \n # Cookie Clicker is a Javascript game by Orteil, where players click on a picture of a giant cookie. Clicking on the giant cookie gives them cookies. They can spend those cookies to buy buildings. Those buildings help them get even more cookies. Like this problem, the game is very cookie-focused. This problem has a similar idea, but it does not assume you have played Cookie Clicker. Please don't go play it now: it might be a long time before you come back.\n \n # Problem\n \n # In this problem, you start with 0 cookies. You gain cookies at a rate of 2 cookies per second, by clicking on a giant cookie. Any time you have at least C cookies, you can buy a cookie farm. Every time you buy a cookie farm, it costs you C cookies and gives you an extra F cookies per second.\n \n # Once you have X cookies that you haven't spent on farms, you win! Figure out how long it will take you to win if you use the best possible strategy.\n \n # Example\n \n # Suppose C=500.0, F=4.0 and X=2000.0. Here's how the best possible strategy plays out:\n \n # You start with 0 cookies, but producing 2 cookies per second.\n # After 250 seconds, you will have C=500 cookies and can buy a farm that produces F=4 cookies per second.\n # After buying the farm, you have 0 cookies, and your total cookie production is 6 cookies per second.\n # The next farm will cost 500 cookies, which you can buy after about 83.3333333 seconds.\n # After buying your second farm, you have 0 cookies, and your total cookie production is 10 cookies per second.\n # Another farm will cost 500 cookies, which you can buy after 50 seconds.\n # After buying your third farm, you have 0 cookies, and your total cookie production is 14 cookies per second.\n # Another farm would cost 500 cookies, but it actually makes sense not to buy it: instead you can just wait until you have X=2000 cookies, which takes about 142.8571429 seconds.\n # Total time: 250 + 83.3333333 + 50 + 142.8571429 = 526.1904762 seconds.\n # Notice that you get cookies continuously: so 0.1 seconds after the game starts you'll have 0.2 cookies, and  seconds after the game starts you'll have 2 cookies.\n \n # Input\n \n # The first line of the input gives the number of test cases, T. T lines follow. Each line contains three space-separated real-valued numbers: C, F and X, whose meanings are described earlier in the problem statement.\n \n # C, F and X will each consist of at least 1 digit followed by 1 decimal point followed by from 1 to 5 digits. There will be no leading zeroes.\n \n # Output\n \n # For each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1) and y is the minimum number of seconds it takes before you can have X delicious cookies.\n \n \n # Limits\n \n # 1  T  100.\n \n # Small dataset\n \n # 1  C  500.\n # 1  F  4.\n # 1  X  2000.\n # Large dataset\n \n # 1  C  10000.\n # 1  F  100.\n # 1  X  100000.\n \n import sys\n \n \n def debug(*args):\n     print(*args, file=sys.stderr)\n \n fin = sys.stdin\n T = int(fin.readline())\n for case in range(1, T + 1):\n     C, F, X = map(float, fin.readline().split())\n \n \n     rate = 2\n     time = 0\n \n     best = 10**20\n \n     while time < best:\n         result = X / rate + time\n         if result < best:\n             best = result\n         time += C / rate\n         rate += F\n \n \n \n     print("Case #%d: %.7f" % (case, best))\n \n
ralfkistner	<>	5	<>	2013_2270488_2453486.py	<>	\n import sys\n fin = sys.stdin\n T = int(fin.readline())\n for case in range(1,T+1):\n     board = []\n     for i in range(4):\n         row = list(fin.readline().strip())\n         board.append(row)\n \n     fin.readline()\n \n     rows = [[], [], [], []]\n     cols = [[], [], [], []]\n     diags = [[], []]\n \n     for i in range(4):\n         for j in range(4):\n             v = board[i][j]\n             rows[i].append(v)\n             cols[j].append(v)\n             if i == j:\n                 diags[0].append(v)\n             if i + j == 3:\n                 diags[1].append(v)\n \n     buckets = rows + cols + diags\n     result = 'Draw'\n     filled = True\n     for bucket in buckets:\n         d = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n         for v in bucket:\n             d[v] += 1\n         if d['T'] + d['X'] == 4:\n             result = 'X won'\n             break\n         if d['T'] + d['O'] == 4:\n             result = 'O won'\n             break\n         if d['.'] > 0:\n             result = 'Game has not completed'\n \n     print("Case #%d: %s" % (case, result))\n \n \n \n
ralfkistner	<>	5	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/env python3\n # -*- coding: utf-8 -*-\n # Uses https://github.com/rkistner/contest-algorithms\n \n # Minesweeper is a computer game that became popular in the 1980s, and is still included in some versions of the Microsoft Windows operating system. This problem has a similar idea, but it does not assume you have played Minesweeper.\n \n # In this problem, you are playing a game on a grid of identical cells. The content of each cell is initially hidden. There are M mines hidden in M different cells of the grid. No other cells contain mines. You may click on any cell to reveal it. If the revealed cell contains a mine, then the game is over, and you lose. Otherwise, the revealed cell will contain a digit between 0 and 8, inclusive, which corresponds to the number of neighboring cells that contain mines. Two cells are neighbors if they share a corner or an edge. Additionally, if the revealed cell contains a 0, then all of the neighbors of the revealed cell are automatically revealed as well, recursively. When all the cells that don't contain mines have been revealed, the game ends, and you win.\n \n # For example, an initial configuration of the board may look like this ('*' denotes a mine, and 'c' is the first clicked cell):\n \n # *..*...**.\n # ....*.....\n # ..c..*....\n # ........*.\n # ..........\n # There are no mines adjacent to the clicked cell, so when it is revealed, it becomes a 0, and its 8 adjacent cells are revealed as well. This process continues, resulting in the following board:\n # *..*...**.\n # 1112*.....\n # 00012*....\n # 00001111*.\n # 00000001..\n # At this point, there are still un-revealed cells that do not contain mines (denoted by '.' characters), so the player has to click again in order to continue the game.\n # You want to win the game as quickly as possible. There is nothing quicker than winning in one click. Given the size of the board (R x C) and the number of hidden mines M, is it possible (however unlikely) to win in one click? You may choose where you click. If it is possible, then print any valid mine configuration and the coordinates of your click, following the specifications in the Output section. Otherwise, print "Impossible".\n \n # Input\n \n # The first line of the input gives the number of test cases, T. T lines follow. Each line contains three space-separated integers: R, C, and M.\n \n # Output\n \n # For each test case, output a line containing "Case #x:", where x is the test case number (starting from 1). On the following R lines, output the board configuration with C characters per line, using '.' to represent an empty cell, '*' to represent a cell that contains a mine, and 'c' to represent the clicked cell.\n \n # If there is no possible configuration, then instead of the grid, output a line with "Impossible" instead. If there are multiple possible configurations, output any one of them.\n \n # Limits\n \n # 0  M < R * C.\n # Small dataset\n \n # 1  T  230.\n # 1  R, C  5.\n # Large dataset\n \n # 1  T  140.\n # 1  R, C  50.\n  \n \n \n import sys\n \n \n def debug(*args):\n     print(*args, file=sys.stderr)\n \n fin = sys.stdin\n T = int(fin.readline())\n for case in range(1, T + 1):\n     RR, CC, M = map(int, fin.readline().split())\n     R, C = None, None\n     blocks = RR*CC - M\n     inverse = False\n     if RR > CC:\n         inverse = True\n         R, C = CC, RR\n     else:\n         R, C = RR, CC\n     result = None\n     # Now R <= C\n     if R == 1:\n         # Always possible\n         result = [('.' * blocks) + ('*' * M)]\n     elif R == 2:\n         # Possible if blocks == 1 or blocks % 2 == 0\n         if blocks == 1:\n             result = ['.' + ('*' * (C-1)), '*' * C]\n         elif blocks % 2 == 0 and blocks != 2:\n             cc = blocks // 2\n             result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n         else:\n             result = None\n     else:\n         if blocks == 1:\n             result = ['*' * C] * R\n         elif blocks == 4:\n             result = ['..' + (C-2)*'*']*2\n             result += ['*'*C] * (R-2)\n         elif blocks == 6:\n             result = ['...' + (C-3)*'*']*2\n             result += ['*'*C] * (R-2)\n         for rows in range(3, R+1):\n             for columns in range(rows, C+1):\n                 size = rows * columns\n                 if size - blocks >= 0:\n                     if size - blocks <= columns - 2: \n                         result = []\n                         for r in range(rows):\n                             if r < rows - 1:\n                                 result.append(('.' * columns) + ('*' * (C - columns)))\n                             else:\n                                 cc = columns - (size - blocks)\n                                 result.append(('.' * cc) + ('*' * (C - cc)))\n                         for r in range(R - rows):\n                             result.append('*' * C)\n                     elif size - blocks == columns - 1 and rows >= 4:\n                         result = []\n                         for r in range(rows):\n                             if r < rows - 2:\n                                 result.append(('.' * columns) + ('*' * (C - columns)))\n                             elif r == rows - 2:\n                                 cc = columns - 1\n                                 result.append(('.' * cc) + ('*' * (C - cc)))\n                             else:\n                                 cc = 2\n                                 result.append(('.' * cc) + ('*' * (C - cc)))\n                         for r in range(R - rows):\n                             result.append('*' * C)\n                     \n \n \n \n     print("Case #%d: " % (case))\n     if result is None:\n         debug('impossible', blocks, RR, CC)\n         print("Impossible")\n     else:\n         mines = 0\n         for r in range(RR):\n             row = ''\n             for c in range(CC):\n                 rr, cc = r, c\n                 if inverse:\n                     rr, cc = c, r\n                 if rr == 0 and cc == 0:\n                     row += 'c'\n                 else:\n                     row += result[rr][cc]\n                     if result[rr][cc] == '*':\n                         mines += 1\n             print(row)\n         if mines != M:\n             raise Exception("%d != %d %d x %d" % (mines, M, RR, CC))\n             \n \n \n
idolivneh	<>	6	<>	2013_2270488_2463486.py	<>	import sys\n import time\n import itertools #use combinations!\n import math\n \n def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n 	with file(filepath, 'rb') as f_in:\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			yield line_index, line.strip().split(' ')\n \n def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 1\n 		case = []\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			case.append(line.strip().split(' '))\n 			if not line_index % n:\n 				yield case_counter, case\n 				case_counter += 1\n 				case = []\n \n def iterate_cases_glpc(filepath):		#glpc - given lines per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 0\n 		new_case = True\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			if new_case:\n 				new_case = False\n 				case_counter += 1\n 				case = []\n 				assert len(line.strip().split(' ')) == 1\n 				lines_left = int(line.strip())\n 				if not lines_left:\n 					new_case = True\n 					yield case_counter, case\n 				continue\n 			if lines_left:\n 				lines_left -= 1\n 				case.append(line.strip().split(' '))\n 			if not lines_left:\n 				new_case = True\n 				yield case_counter, case\n 			\n def part_of_list_to_int(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(int(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_int(array):\n 	return part_of_list_to_int(array, [True] * len(array))\n \n def part_of_list_to_float(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(float(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_float(array):\n 	return part_of_list_to_float(array, [True] * len(array))\n \n def get_max_array_on_index(array, index):\n 	elem_len = len(array[0])\n 	assert index < elem_len\n 	for elem in array:\n 		assert elem_len == len(elem)\n 	max_sub = array[0][index]\n 	max_elem = array[0]\n 	for elem in array:\n 		if elem[index] > max_sub:\n 			max_sub = elem[index]\n 			max_elem = elem\n 	return max_elem\n \n def list_index_in_sorted_with_position(a_list, value, pos):\n 	list_len = len(a_list)\n 	if list_len == 1:\n 		if a_list[0] == value:\n 			return pos\n 		return -1\n 	if a_list[list_len/2] > value:\n 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n 	else:\n 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n 	\n def list_index_in_sorted_list(a_list, value):\n 	return list_index_in_sorted_with_position(a_list, value, 0)\n 	\n ############################################################\n #### add solution here 									####\n #### don't forget to change data from str to int/float  ####\n ############################################################\n def check_palindrome(value):\n 	val_str = str(value)\n 	length = len(val_str)\n 	for i in xrange(length):\n 		if val_str[i] != val_str[length - 1 - i]:\n 			return False\n 	return True\n 	#print "\t\t%d: '%s'" % (value, val_str)\n \n def calc_result(case):\n 	A = int(case[0])\n 	B = int(case[1])\n 	\n 	A_sqrt = int(math.ceil(math.sqrt(A)))\n 	B_sqrt = int(math.floor(math.sqrt(B)))\n 	\n 	print "\tinterval: %s" % [A, B]\n 	print "\tsqrt_int: %s" % [A_sqrt, B_sqrt]\n 	\n 	count = 0\n 	for i in xrange(A_sqrt, B_sqrt + 1):\n 		if check_palindrome(i):\n 			if check_palindrome(i * i):\n 				count += 1\n 				print "\tfound: %d, %d" % (i, i * i)\n 	\n 	print "\ttot: %d" % count\n 	print \n 	result = "%s" % count\n 	return result\n \n def main(filepath):\n 	start_time = time.time()\n 	with file('output.txt', 'wb') as f_out:\n 		\n 		######################################\n 		#### select input iteration type: ####\n 		####	- iterate_cases_1lpc	  ####\n 		####	- iterate_cases_nlpc +n	  ####\n 		####	- iterate_cases_glpc	  ####\n 		######################################\n 		for case_index, case in iterate_cases_1lpc(filepath):\n 			\n 			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n 			result = calc_result(case)\n 			\n 			#######################\n 			#### format output ####\n 			#######################\n 			f_out.write("Case #%d: %s\n" % (case_index, result))\n 				\n if __name__ == '__main__':\n 	main(sys.argv[1])\n
idolivneh	<>	6	<>	2013_2270488_2449486.py	<>	import sys\n import time\n import itertools #use combinations!\n \n def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n 	with file(filepath, 'rb') as f_in:\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			yield line_index, line.strip().split(' ')\n \n def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 1\n 		case = []\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			case.append(line.strip().split(' '))\n 			if not line_index % n:\n 				yield case_counter, case\n 				case_counter += 1\n 				case = []\n \n def iterate_cases_glpc(filepath):		#glpc - given lines per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 0\n 		new_case = True\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			if new_case:\n 				new_case = False\n 				case_counter += 1\n 				case = []\n 				assert len(line.strip().split(' ')) == 2\n 				N = int(line.strip().split(' ')[0])\n 				M = int(line.strip().split(' ')[1])\n 				lines_left = N\n 				case.append(N)\n 				case.append(M)\n 				if not lines_left:\n 					new_case = True\n 					yield case_counter, case\n 				continue\n 			if lines_left:\n 				lines_left -= 1\n 				case.append(line.strip().split(' '))\n 			if not lines_left:\n 				new_case = True\n 				yield case_counter, case\n 			\n def part_of_list_to_int(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(int(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_int(array):\n 	return part_of_list_to_int(array, [True] * len(array))\n \n def part_of_list_to_float(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(float(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_float(array):\n 	return part_of_list_to_float(array, [True] * len(array))\n \n def get_max_array_on_index(array, index):\n 	elem_len = len(array[0])\n 	assert index < elem_len\n 	for elem in array:\n 		assert elem_len == len(elem)\n 	max_sub = array[0][index]\n 	max_elem = array[0]\n 	for elem in array:\n 		if elem[index] > max_sub:\n 			max_sub = elem[index]\n 			max_elem = elem\n 	return max_elem\n \n def list_index_in_sorted_with_position(a_list, value, pos):\n 	list_len = len(a_list)\n 	if list_len == 1:\n 		if a_list[0] == value:\n 			return pos\n 		return -1\n 	if a_list[list_len/2] > value:\n 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n 	else:\n 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n 	\n def list_index_in_sorted_list(a_list, value):\n 	return list_index_in_sorted_with_position(a_list, value, 0)\n 	\n ############################################################\n #### add solution here 									####\n #### don't forget to change data from str to int/float  ####\n ############################################################\n def test_row(row, value):\n 	for elem in row:\n 		if elem > value:\n 			return False\n 	return True\n \n def calc_result(case):\n 	#print "\t%s" % case[2:]\n 	N = case[0]\n 	M = case[1]\n 	rows = []\n 	for str_row in case[2:]:\n 		rows.append(list_to_int(str_row))\n 	#print "\trows: %s" % rows\n 	columns = []\n 	for i in xrange(M):\n 		column = []\n 		for j in xrange(N):\n 			column.append(rows[j][i])\n 		columns.append(column)\n 	#print "\tcolumns: %s" % columns\n 	\n 	for i in xrange(N):\n 		for j in xrange(M):\n 			if not (test_row(rows[i], rows[i][j]) or test_row(columns[j], rows[i][j])):\n 				print "i,j: %d,%d" % (i, j)\n 				result = "NO"\n 				print "\t%s" % result\n 				return result\n 	\n 	result = "YES"\n 	print "\t%s" % result\n 	return result\n \n def main(filepath):\n 	start_time = time.time()\n 	with file('output.txt', 'wb') as f_out:\n 		\n 		######################################\n 		#### select input iteration type: ####\n 		####	- iterate_cases_1lpc	  ####\n 		####	- iterate_cases_nlpc +n	  ####\n 		####	- iterate_cases_glpc	  ####\n 		######################################\n 		for case_index, case in iterate_cases_glpc(filepath):\n 			\n 			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n 			result = calc_result(case)\n 			\n 			#######################\n 			#### format output ####\n 			#######################\n 			f_out.write("Case #%d: %s\n" % (case_index, result))\n 				\n if __name__ == '__main__':\n 	main(sys.argv[1])\n
idolivneh	<>	6	<>	2014_2974486_5756407898963968.py	<>	import sys\n import time\n import itertools #use combinations!\n \n def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n 	with file(filepath, 'rb') as f_in:\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			yield line_index, line.strip().split(' ')\n \n def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 1\n 		case = []\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			case.append(line.strip().split(' '))\n 			if not line_index % n:\n 				yield case_counter, case\n 				case_counter += 1\n 				case = []\n \n def iterate_cases_glpc(filepath):		#glpc - given lines per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 0\n 		new_case = True\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			if new_case:\n 				new_case = False\n 				case_counter += 1\n 				case = []\n 				assert len(line.strip().split(' ')) == 1\n 				lines_left = int(line.strip())\n 				if not lines_left:\n 					new_case = True\n 					yield case_counter, case\n 				continue\n 			if lines_left:\n 				lines_left -= 1\n 				case.append(line.strip().split(' '))\n 			if not lines_left:\n 				new_case = True\n 				yield case_counter, case\n 			\n def part_of_list_to_int(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(int(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_int(array):\n 	return part_of_list_to_int(array, [True] * len(array))\n \n def part_of_list_to_float(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(float(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_float(array):\n 	return part_of_list_to_float(array, [True] * len(array))\n \n def get_max_array_on_index(array, index):\n 	elem_len = len(array[0])\n 	assert index < elem_len\n 	for elem in array:\n 		assert elem_len == len(elem)\n 	max_sub = array[0][index]\n 	max_elem = array[0]\n 	for elem in array:\n 		if elem[index] > max_sub:\n 			max_sub = elem[index]\n 			max_elem = elem\n 	return max_elem\n \n def list_index_in_sorted_with_position(a_list, value, pos):\n 	list_len = len(a_list)\n 	if list_len == 1:\n 		if a_list[0] == value:\n 			return pos\n 		return -1\n 	if a_list[list_len/2] > value:\n 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n 	else:\n 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n 	\n def list_index_in_sorted_list(a_list, value):\n 	return list_index_in_sorted_with_position(a_list, value, 0)\n \n def copy_list(list):\n 	res = []\n 	for elem in list:\n 		res.append(elem)\n 	return res	\n \n ############################################################\n #### add solution here 									####\n #### don't forget to change data from str to int/float  ####\n ############################################################\n \n def intersect(arr_A, arr_B):\n 	print '\t\t%s\n\t\t%s' % (arr_A, arr_B)\n 	res = []\n 	for a in arr_A:\n 		if arr_B.count(a):\n 			res.append(a)\n 	print '\t\t%s' % res\n 	return res\n \n def solve(row_A_selected, board_A,\n 		  row_B_selected, board_B):\n 	res = intersect(board_A[row_A_selected - 1], \n 					board_B[row_B_selected - 1])\n 	if len(res) == 0:\n 		return 'Volunteer cheated!'\n 	if len(res) == 1:\n 		return res[0]\n 	return 'Bad magician!'\n 	\n def calc_result(case):\n 	result = None\n 	\n 	row_A_selected = int(case[0][0])\n 	row_B_selected = int(case[5][0])\n 	board_A = case[1:5]\n 	board_B = case[6:10]\n 	\n 	print "row_A_selected: %s" % row_A_selected\n 	print "row_B_selected: %s" % row_B_selected\n 	print \n 	print board_A\n 	print \n 	print board_B\n 	print\n 	\n 	result = solve(row_A_selected, board_A,\n 				   row_B_selected, board_B)\n 	print result\n 	\n 	\n 	return result\n \n def main(filepath):\n 	start_time = time.time()\n 	with file('output.txt', 'wb') as f_out:\n 		\n 		######################################\n 		#### select input iteration type: ####\n 		####	- iterate_cases_1lpc	  ####\n 		####	- iterate_cases_nlpc +n	  ####\n 		####	- iterate_cases_glpc	  ####\n 		######################################\n 		for case_index, case in iterate_cases_nlpc(filepath, 10):\n 			\n 			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n 			result = calc_result(case)\n 			\n 			#######################\n 			#### format output ####\n 			#######################\n 			f_out.write("Case #%d: %s\n" % (case_index, result))\n 				\n if __name__ == '__main__':\n 	main(sys.argv[1])\n
idolivneh	<>	6	<>	2012_1460488_1483485.py	<>	import sys\n \n class Translation(object):\n 	def __init__(self):\n 		self.letters = {}\n 		self.letters['z'] = 'q'	# from text under 'Problem'\n 		self.letters['q'] = 'z'\n 		self.letters[' '] = ' '\n 		self.count = 0\n 	\n 	def update_letter(self, source, image):\n 		if source in self.letters.keys():\n 			if self.letters[source] != image:\n 				raise Exception('old: %s-->%s. new: %s-->%s' % (source, \n 																self.letters[source],\n 																source,\n 																image))\n 		else:\n 			self.letters[source] = image\n 	\n 	def update_word(self, source, image):\n 		for char_index, _ in enumerate(source):\n 			self.update_letter(source[char_index], image[char_index])\n 	\n 	def update_line(self, source, image):\n 		for word_index, _ in enumerate(source.strip().split(' ')):\n 			self.update_word(source.strip().split(' ')[word_index],\n 							 image.strip().split(' ')[word_index])\n 	\n 	def print_dict(self):\n 		for i in xrange(ord('a'), ord('z') + 1):\n 			print "%s-->%s" % (chr(i), self.letters.get(chr(i), 'None'))\n 	\n 	def translate_line(self, line):\n 		out = ""\n 		for char in line:\n 			out += self.letters[char]\n 		return out\n 		\n def main(filepath):\n 	translation = Translation()\n 	before = []\n 	after = []\n 	with file('tounges_before.txt', 'rb') as f_before:\n 		for line in f_before:\n 			before.append(line)\n 		\n 	with file('tounges_after.txt', 'rb') as f_after:\n 		for line in f_after:\n 			after.append(line)\n 	\n 	if len(before) != len(after):\n 		raise Exception('the before and after files are not of the same size')\n 	\n 	for line_index in xrange(len(before)):\n 		translation.update_line(before[line_index], after[line_index])\n 	\n 	translation.print_dict()\n 	\n 	with file('tounges_output.txt', 'wb') as f_out:\n 		with file(filepath, 'rb') as f_in:\n 			for line_index, line in enumerate(f_in):\n 				if line_index == 0: #T\n 					continue\n 				result = translation.translate_line(line.strip())\n 				print\n 				print line.strip()\n 				print result\n 				f_out.write("Case #%d: %s\n" % (line_index, result))\n 			\n if __name__ == '__main__':\n 	main(sys.argv[1])
idolivneh	<>	6	<>	2014_2974486_5709773144064000.py	<>	import sys\n import time\n import itertools #use combinations!\n \n def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n 	with file(filepath, 'rb') as f_in:\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			yield line_index, line.strip().split(' ')\n \n def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 1\n 		case = []\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			case.append(line.strip().split(' '))\n 			if not line_index % n:\n 				yield case_counter, case\n 				case_counter += 1\n 				case = []\n \n def iterate_cases_glpc(filepath):		#glpc - given lines per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 0\n 		new_case = True\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			if new_case:\n 				new_case = False\n 				case_counter += 1\n 				case = []\n 				assert len(line.strip().split(' ')) == 1\n 				lines_left = int(line.strip())\n 				if not lines_left:\n 					new_case = True\n 					yield case_counter, case\n 				continue\n 			if lines_left:\n 				lines_left -= 1\n 				case.append(line.strip().split(' '))\n 			if not lines_left:\n 				new_case = True\n 				yield case_counter, case\n 			\n def part_of_list_to_int(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(int(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_int(array):\n 	return part_of_list_to_int(array, [True] * len(array))\n \n def part_of_list_to_float(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(float(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_float(array):\n 	return part_of_list_to_float(array, [True] * len(array))\n \n def get_max_array_on_index(array, index):\n 	elem_len = len(array[0])\n 	assert index < elem_len\n 	for elem in array:\n 		assert elem_len == len(elem)\n 	max_sub = array[0][index]\n 	max_elem = array[0]\n 	for elem in array:\n 		if elem[index] > max_sub:\n 			max_sub = elem[index]\n 			max_elem = elem\n 	return max_elem\n \n def list_index_in_sorted_with_position(a_list, value, pos):\n 	list_len = len(a_list)\n 	if list_len == 1:\n 		if a_list[0] == value:\n 			return pos\n 		return -1\n 	if a_list[list_len/2] > value:\n 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n 	else:\n 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n 	\n def list_index_in_sorted_list(a_list, value):\n 	return list_index_in_sorted_with_position(a_list, value, 0)\n \n def copy_list(list):\n 	res = []\n 	for elem in list:\n 		res.append(elem)\n 	return res	\n \n ############################################################\n #### add solution here 									####\n #### don't forget to change data from str to int/float  ####\n ############################################################\n \n def solve(C, F, X):\n 	farms_num = 0\n 	waiting_for_farms = 0\n 	production_rate = 2\n 	final_run_time = X / production_rate\n 	result = final_run_time + waiting_for_farms\n 	\n 	print "%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f" % (farms_num,\n 																				production_rate,\n 																				final_run_time,\n 																				waiting_for_farms,\n 																				result)\n 		\n \n 	\n 	while True:\n 		farms_num += 1\n 		waiting_for_farms += C / production_rate\n 		production_rate += F\n 		final_run_time = X / production_rate\n 		new_result = final_run_time + waiting_for_farms\n 		print "%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f" % (farms_num,\n 																					production_rate,\n 																					final_run_time,\n 																					waiting_for_farms,\n 																					new_result)\n 		if new_result > result:\n 			return result\n 		result = new_result\n 	\n def calc_result(case):\n 	result = None\n 	\n 	C = float(case[0])\n 	F = float(case[1])\n 	X = float(case[2])\n 	print C, F, X\n 	\n 	result = solve(C, F, X)\n 	print result\n 	\n 	return result\n \n def main(filepath):\n 	start_time = time.time()\n 	with file('output.txt', 'wb') as f_out:\n 		\n 		######################################\n 		#### select input iteration type: ####\n 		####	- iterate_cases_1lpc	  ####\n 		####	- iterate_cases_nlpc +n	  ####\n 		####	- iterate_cases_glpc	  ####\n 		######################################\n 		for case_index, case in iterate_cases_1lpc(filepath):\n 			\n 			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n 			result = calc_result(case)\n 			\n 			#######################\n 			#### format output ####\n 			#######################\n 			f_out.write("Case #%d: %.07f\n" % (case_index, result))\n 				\n if __name__ == '__main__':\n 	main(sys.argv[1])\n
idolivneh	<>	6	<>	2013_2270488_2453486.py	<>	import sys\n import time\n import itertools #use combinations!\n \n def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n 	with file(filepath, 'rb') as f_in:\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			yield line_index, line.strip().split(' ')\n \n def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 1\n 		case = []\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			case.append(line.strip().split(' '))\n 			if not line_index % n:\n 				yield case_counter, case\n 				case_counter += 1\n 				case = []\n \n def iterate_cases_glpc(filepath):		#glpc - given lines per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 0\n 		new_case = True\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			if new_case:\n 				new_case = False\n 				case_counter += 1\n 				case = []\n 				assert len(line.strip().split(' ')) == 1\n 				lines_left = int(line.strip())\n 				if not lines_left:\n 					new_case = True\n 					yield case_counter, case\n 				continue\n 			if lines_left:\n 				lines_left -= 1\n 				case.append(line.strip().split(' '))\n 			if not lines_left:\n 				new_case = True\n 				yield case_counter, case\n 			\n def part_of_list_to_int(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(int(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_int(array):\n 	return part_of_list_to_int(array, [True] * len(array))\n \n def part_of_list_to_float(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(float(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_float(array):\n 	return part_of_list_to_float(array, [True] * len(array))\n \n def get_max_array_on_index(array, index):\n 	elem_len = len(array[0])\n 	assert index < elem_len\n 	for elem in array:\n 		assert elem_len == len(elem)\n 	max_sub = array[0][index]\n 	max_elem = array[0]\n 	for elem in array:\n 		if elem[index] > max_sub:\n 			max_sub = elem[index]\n 			max_elem = elem\n 	return max_elem\n \n def list_index_in_sorted_with_position(a_list, value, pos):\n 	list_len = len(a_list)\n 	if list_len == 1:\n 		if a_list[0] == value:\n 			return pos\n 		return -1\n 	if a_list[list_len/2] > value:\n 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n 	else:\n 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n 	\n def list_index_in_sorted_list(a_list, value):\n 	return list_index_in_sorted_with_position(a_list, value, 0)\n 	\n ############################################################\n #### add solution here 									####\n #### don't forget to change data from str to int/float  ####\n ############################################################\n \n def check_row(row):\n 	if row.count('X') == 4:\n 		return 'X'\n 	if row.count('O') == 4:\n 		return 'O'\n 	if row.count('X') == 3 and row.count('T') == 1:\n 		return 'X'\n 	if row.count('O') == 3 and row.count('T') == 1:\n 		return 'O'\n 	if row.count('.') > 0:\n 		return '.'\n 	return 'F'\n 		\n \n def calc_result(case):\n 	case = case[:-1]\n 	print "\t%s" % case\n 	\n 	rows = []\n 	for row in case:\n 		#print "\trow: '%s'" % row[0]\n 		rows.append(row[0])\n 	\n 	for i in xrange(4):\n 		column = ""\n 		for j in xrange(4):\n 			column += case[j][0][i]\n 		#print "\trow: '%s'" % column\n 		rows.append(column)\n 	\n 	diag1 = ""\n 	diag2 = ""\n 	for i in xrange(4):\n 		diag1 += case[i][0][i]\n 		diag2 += case[3-i][0][i]\n 	#print "\trow: '%s'" % diag1\n 	#print "\trow: '%s'" % diag2\n 	rows.append(diag1)\n 	rows.append(diag2)\n 	\n 	res = []\n 	for row in rows:\n 		res.append(check_row(row))\n 	\n 	if res.count('X'):\n 		if res.count('O'):\n 			raise IOError('both X and O won')\n 		else:\n 			result = "X won"\n 	else:\n 		if res.count('O'):\n 			result = "O won"\n 		else:\n 			if res.count('.'):\n 				result = "Game has not completed"\n 			else:\n 				result = "Draw"\n 	\n 	print "\t%s" % res\n 	print "\t%s" % result\n 	\n 	return result\n \n def main(filepath):\n 	start_time = time.time()\n 	with file('output.txt', 'wb') as f_out:\n 		\n 		######################################\n 		#### select input iteration type: ####\n 		####	- iterate_cases_1lpc	  ####\n 		####	- iterate_cases_nlpc +n	  ####\n 		####	- iterate_cases_glpc	  ####\n 		######################################\n 		for case_index, case in iterate_cases_nlpc(filepath, 5):\n 			\n 			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n 			result = calc_result(case)\n 			\n 			#######################\n 			#### format output ####\n 			#######################\n 			f_out.write("Case #%d: %s\n" % (case_index, result))\n 				\n if __name__ == '__main__':\n 	main(sys.argv[1])\n
idolivneh	<>	6	<>	2014_2974486_5690574640250880.py	<>	import sys\n import time\n import itertools #use combinations!\n import random\n \n def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n 	with file(filepath, 'rb') as f_in:\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			yield line_index, line.strip().split(' ')\n \n def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 1\n 		case = []\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			case.append(line.strip().split(' '))\n 			if not line_index % n:\n 				yield case_counter, case\n 				case_counter += 1\n 				case = []\n \n def iterate_cases_glpc(filepath):		#glpc - given lines per case\n 	with file(filepath, 'rb') as f_in:\n 		case_counter = 0\n 		new_case = True\n 		for line_index, line in enumerate(f_in):\n 			if line_index == 0: #T\n 				continue\n 			if new_case:\n 				new_case = False\n 				case_counter += 1\n 				case = []\n 				assert len(line.strip().split(' ')) == 1\n 				lines_left = int(line.strip())\n 				if not lines_left:\n 					new_case = True\n 					yield case_counter, case\n 				continue\n 			if lines_left:\n 				lines_left -= 1\n 				case.append(line.strip().split(' '))\n 			if not lines_left:\n 				new_case = True\n 				yield case_counter, case\n 			\n def part_of_list_to_int(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(int(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_int(array):\n 	return part_of_list_to_int(array, [True] * len(array))\n \n def part_of_list_to_float(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(float(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_float(array):\n 	return part_of_list_to_float(array, [True] * len(array))\n \n def get_max_array_on_index(array, index):\n 	elem_len = len(array[0])\n 	assert index < elem_len\n 	for elem in array:\n 		assert elem_len == len(elem)\n 	max_sub = array[0][index]\n 	max_elem = array[0]\n 	for elem in array:\n 		if elem[index] > max_sub:\n 			max_sub = elem[index]\n 			max_elem = elem\n 	return max_elem\n \n def list_index_in_sorted_with_position(a_list, value, pos):\n 	list_len = len(a_list)\n 	if list_len == 1:\n 		if a_list[0] == value:\n 			return pos\n 		return -1\n 	if a_list[list_len/2] > value:\n 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n 	else:\n 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n 	\n def list_index_in_sorted_list(a_list, value):\n 	return list_index_in_sorted_with_position(a_list, value, 0)\n \n def copy_list(list):\n 	res = []\n 	for elem in list:\n 		res.append(elem)\n 	return res	\n \n ############################################################\n #### add solution here 									####\n #### don't forget to change data from str to int/float  ####\n ############################################################\n \n def conj_mat(a):\n 	R = len(a)\n 	C = len(a[0])\n 	res = [['.' for _ in xrange(R)] for __ in xrange(C)]\n 	for i in xrange(R):\n 		for j in xrange(C):\n 			res[j][i] = a[i][j]\n 	return res\n \n def one_line_builder(R, C, M):\n 	res = []\n 	res.extend(['*'] * M)\n 	res.extend(['.'] * (C - M))\n 	res[-1] = 'c'\n 	return [res]\n 	\n def two_line_builder(R, C, M):\n 	line = []\n 	line.extend(['*'] * (M / 2))\n 	line.extend(['.'] * (C - M / 2))\n 	res = [line, copy_list(line)]\n 	res[1][-1] = 'c'\n 	if M%2 == 1:\n 		res[0][-1] = '*'\n 	return res\n 	\n def three_line_builder(R, C, M):\n 	res = [['.' for _ in xrange(C)] for __ in xrange(R)]\n 	res[-1][-1] = 'c'\n 	m = min([M, R * C - 9])\n 	stop_flag = False\n 	for j in xrange(C):\n 		if stop_flag:\n 			break\n 		for i in xrange(R):\n 			if m == 0:\n 				stop_flag = True\n 				break\n 			res[i][j] = '*'\n 			m -= 1\n 	print i,j\n 	if i == 2:\n 		res[1][j-1] = '.'\n 		if j == C - 3:\n 			res[0][j] = '*'\n 		else:\n 			res[0][-1] = '*'\n 	\n 	if M <= R * C - 9:\n 		return res\n 	else:\n 		m = M - (R * C - 9)\n 		assert m not in [2, 4, 6, 7, 9]\n 		assert m > 0\n 		assert m < 10\n 		\n 		res[-3][-3] = '*'\n 		m -= 1\n 		if m == 0: return res\n 		res[-2][-3] = '*'\n 		res[-1][-3] = '*'\n 		m -= 2\n 		if m == 0: return res\n 		res[-3][-2] = '*'\n 		res[-3][-1] = '*'\n 		m -= 2\n 		if m == 0: return res\n 		res[-2][-2] = '*'\n 		res[-2][-1] = '*'\n 		res[-1][-2] = '*'\n 		m -= 3\n 		if m == 0: return res\n 		assert False\n 	\n 	\n 	\n def over_three_line_builder(R, C, M):\n 	if M <= (R - 3) * C:\n 		res = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\n 		flag = False\n 		if (M % C) != (C - 1):\n 			line = ['*' for _ in xrange(M % C)]\n 			line.extend(['.' for _ in xrange(C - (M % C))])\n 		else:\n 			line = ['*' for _ in xrange((M % C) - 1)]\n 			line.extend(['.' for _ in xrange((C - (M % C)) + 1)])\n 			flag = True\n 		res.append(line)\n 		index = len(res)\n 		res.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\n 		if flag:\n 			res[index][0] = '*'\n 		res[-1][-1] = 'c'\n 		assert len(res) == R\n 		assert len(res[0]) == C\n 		return res\n 	else:\n 		res = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\n 		M -= (R - 3) * C\n 		tmp = three_line_builder(3, C, M)\n 		if len(tmp) != 3: # error msg\n 			return tmp\n 		res.extend(tmp)\n 		return res\n 	\n def solve(R, C, M):\n 	res = None\n 	\n 	if M == R * C:\n 		return 'Impossible'\n 	if R >= 3 and C >= 3:\n 		if R*C - M in [7, 5, 3, 2]:\n 			return 'Impossible'\n 		return over_three_line_builder(R, C, M)\n 		\n 	elif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\n 		if (R*C - M) % 2 == 1:\n 			if M < R*C - 1:\n 				return 'Impossible'\n 		if M + 2 == R * C:\n 			return 'Impossible'\n 		else:\n 			if R == 2:\n 				return two_line_builder(R, C, M)\n 			else:\n 				tmp = two_line_builder(C, R, M)\n 				return conj_mat(tmp)\n 	\n 	else:					#which means one of them is 1\n 		if R == 1:\n 			return one_line_builder(R, C, M)\n 		else:\n 			tmp = one_line_builder(C, R, M)\n 			return conj_mat(tmp)\n 		\n 	return res\n \n def mat_to_str(a):\n 	if a in ['Impossible', 'Not Implemented']:\n 		return a\n 	str_out = ''\n 	for row in a:\n 		for elem in row:\n 			str_out += elem\n 		str_out += '\n'\n 	return str_out[:-1]\n 	\n def calc_result(case):\n 	result = None\n 	\n 	R = int(case[0])\n 	C = int(case[1])\n 	M = int(case[2])\n 	print R, C, M\n 	\n 	result = solve(R, C, M)\n 	\n 	str_out = mat_to_str(result)\n 	m = str_out.count('*')\n 	assert (m==0 or m==M)\n 	print str_out\n 	\n 	return '\n%s' % str_out\n \n def main(filepath):\n 	start_time = time.time()\n 	with file('output.txt', 'wb') as f_out:\n 		\n 		######################################\n 		#### select input iteration type: ####\n 		####	- iterate_cases_1lpc	  ####\n 		####	- iterate_cases_nlpc +n	  ####\n 		####	- iterate_cases_glpc	  ####\n 		######################################\n 		for case_index, case in iterate_cases_1lpc(filepath):\n 			\n 			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n 			result = calc_result(case)\n 			\n 			#######################\n 			#### format output ####\n 			#######################\n 			f_out.write("Case #%d: %s\n" % (case_index, result))\n 				\n if __name__ == '__main__':\n 	main(sys.argv[1])\n
nooodles	<>	7	<>	2013_2270488_2463486.py	<>	def IsPal(n):\n     S = str(n);\n     return S == S[::-1];\n \n \n def Gen():\n     LIM = 10**14;\n     N = 10**7;\n     LIST = [];\n     for i in range(1, N):\n         if IsPal(i):\n             if IsPal(i*i):\n                 LIST.append(i);\n     return LIST\n \n PP = Gen();\n #print 'Generated'\n \n T = int(raw_input());\n for q in range(1,T+1):\n     [A,B] = map(int, raw_input().split());    \n     ANS = 0;\n     for i in range(len(PP)):\n         if B >= PP[i]**2 >= A:\n             ANS += 1;\n     \n     print "Case #%d: %d" %(q, ANS);\n
nooodles	<>	7	<>	2013_2270488_2449486.py	<>	T = int(raw_input());\n for q in range(T):\n     [H,W] = map(int, raw_input().split());\n     Lawn = [];\n     MRow = [0]*H;\n     MCol = [0]*W;\n     for i in range(H):\n         Lawn.append( map(int, raw_input().split()) );\n         MRow[i] = max(Lawn[-1]);\n         for j in range(W):\n             MCol[j] = max(MCol[j], Lawn[-1][j]);\n \n     Valid = True;\n     for i in range(H):\n         for j in range(W):\n             if Lawn[i][j] not in [MRow[i], MCol[j]]:\n                 Valid = False;\n                 break;\n     \n \n     if Valid:\n         print "Case #%d: YES" %(q+1);\n     else:\n         print "Case #%d: NO" %(q+1);        \n
nooodles	<>	7	<>	2012_1460488_1483488.py	<>	T = int(raw_input());\n for case in range(T):\n    [A,B] = map(int, raw_input().split());\n \n    Big = 10**(len(str(A))-1);\n    Ans = 0;\n \n    for i in range(A,B+1):\n       j = (i/10)+Big*(i%10);\n       while (j != i):\n          if i < j <= B:\n             Ans += 1;\n          j = (j/10)+Big*(j%10);\n \n    print "Case #%d:" % (case+1),;\n    print Ans;\n    \n \n
nooodles	<>	7	<>	2014_2974486_5756407898963968.py	<>	T = int(raw_input());\n for q in range(T):\n     R1 = int(raw_input());\n     Data1 = [];\n     for i in range(4):\n         Data1.append( map(int, raw_input().split()) );\n         \n     R2 = int(raw_input());\n     Data2 = [];\n     for i in range(4):\n         Data2.append( map(int, raw_input().split()) );\n \n     Ans = [];\n     for entry in Data1[R1-1]:\n         if entry in Data2[R2-1]:\n             Ans.append(entry);\n \n     print "Case #%d:" % (q+1),;\n \n     if len(Ans) == 0:\n         print "Volunteer cheated!";\n     if len(Ans) == 1:\n         print Ans[0];\n     if len(Ans) > 1:\n         print "Bad magician!"\n         \n
nooodles	<>	7	<>	2012_1460488_1483485.py	<>	RAW = ['ejp mysljylc kd kxveddknmc re jsicpdrysi',\n        'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',\n        'de kr kd eoya kw aej tysr re ujdr lkgc jv']\n ENG = ['our language is impossible to understand',\n        'there are twenty six factorial possibilities',\n        'so it is okay if you want to just give up'];\n \n New = [32]*128;\n Left = [];\n for c in range(97, 123):\n    Left += [chr(c)];\n \n for i in range(3):\n    for j in range(len(RAW[i])):\n        x = ord(RAW[i][j]);\n        if (New[x] == 32) and (x != 32):\n           Left.remove(RAW[i][j]);\n        New[x] = ord(ENG[i][j]);\n \n New[ord('q')] = ord('z');\n New[ord('z')] = ord('q');\n \n \n T = int(raw_input());\n for i in range(T):\n    print "Case #%d:" % (i+1),;\n    S_in = raw_input();\n    S_out = '';\n    for c in S_in:\n       S_out += chr(New[ord(c)])\n    print S_out\n    \n \n
nooodles	<>	7	<>	2014_2974486_5709773144064000.py	<>	T = int(raw_input());\n for q in range(T):\n     [C,F,X] = map(float, raw_input().split());\n \n     # Default rate is 2 cookies / s;\n     # Farm costs C\n     #   produces F\n     # Target is X;\n \n     Time = 0.;\n     Rate = 2.;\n     Fin = False;\n     while (not Fin):\n         t0 = X/Rate;\n         t1 = C/Rate + X/(Rate+F);\n \n         if t0 <= t1:\n             Time += t0;\n             Fin = True;\n         else:\n             Time += C/Rate;\n             Rate += F;\n \n     print "Case #%d:" % (q+1),;\n     print "%.7f" % Time;\n     \n         \n
nooodles	<>	7	<>	2013_2270488_2453486.py	<>	def Winner( M ):\n     for i in range(4):          # Check rows\n         nX = 0;     nO = 0;     \n         for j in range(4):\n             if M[i][j] == 'X':\n                 nX += 1;\n             if M[i][j] == 'O':\n                 nO += 1;\n             if M[i][j] == 'T':\n                 nX += 1;\n                 nO += 1;\n         if nX == 4:\n             return 'X';\n         if nO == 4:\n             return 'O';\n         \n     for j in range(4):          # Check columns\n         nX = 0;     nO = 0;     \n         for i in range(4):\n             if M[i][j] == 'X':\n                 nX += 1;\n             if M[i][j] == 'O':\n                 nO += 1;\n             if M[i][j] == 'T':\n                 nX += 1;\n                 nO += 1;\n         if nX == 4:\n             return 'X';\n         if nO == 4:\n             return 'O';\n \n     if (M[0][0] in ['X','T']) and (M[1][1] in ['X','T']) and (M[2][2] in ['X','T']) and (M[3][3] in ['X','T']):\n         return 'X';\n     if (M[0][3] in ['X','T']) and (M[1][2] in ['X','T']) and (M[2][1] in ['X','T']) and (M[3][0] in ['X','T']):\n         return 'X';\n     if (M[0][0] in ['O','T']) and (M[1][1] in ['O','T']) and (M[2][2] in ['O','T']) and (M[3][3] in ['O','T']):\n         return 'O';           \n     if (M[0][3] in ['O','T']) and (M[1][2] in ['O','T']) and (M[2][1] in ['O','T']) and (M[3][0] in ['O','T']):\n         return 'O';\n \n     return 'D';            \n \n \n T = int(raw_input());\n for q in range(T):\n     if q != 0:\n         raw_input();\n     Map = [];\n     Dot = False;\n     for i in range(4):\n         Map.append( raw_input() );\n         if '.' in Map[-1]:\n             Dot = True;\n \n     ANS = Winner(Map);\n #    print ANS\n     if ANS == 'X':\n         print "Case #%d: X won" %(q+1)\n     if ANS == 'O':\n         print "Case #%d: O won" %(q+1)\n     if ANS == 'D':\n         if Dot:\n             print "Case #%d: Game has not completed" %(q+1)\n         else:\n             print "Case #%d: Draw " % (q+1)\n \n
nooodles	<>	7	<>	2014_2974486_5690574640250880.py	<>	def Trivial(R,C,char):\n #    print\n     for i in range(R):\n         Ans = '';\n         for j in range(C):\n             if (i==j==0):\n                 Ans += 'c';\n             else:\n                 Ans += char;\n         print Ans;\n \n \n def Draw1(R,C,Blank):\n #    print\n     Ans = "c";\n     for i in range(Blank-1):\n         Ans += '.';\n     for i in range(R*C-Blank):\n         Ans += '*';\n     if (R == 1):\n         print Ans;        \n         return;\n     if (C == 1):\n         for i in range(len(Ans)):\n             print Ans[i];\n \n def Draw2(R,C,Blank):\n     if (Blank%2 != 0) or (Blank == 2):\n         print "Impossible";\n         return;\n     Row1 = '.'*(Blank/2) + '*'*(Mine/2);\n     Row0 = 'c' + Row1[1:];\n     if R==2:\n         print Row0;\n         print Row1;\n     else:\n         for i in range(len(Row0)):\n             print Row0[i]+Row1[i];\n     return;\n \n \n def Generate(R, C, Blank):\n     TODO = Blank;\n     Spaces = [0]*R;\n     if TODO <= 2*C:\n         if TODO%2 == 0:\n             Spaces[0] = TODO/2;\n             Spaces[1] = TODO-Spaces[0];\n         else:\n             if (TODO == 7):\n                 Spaces[0] = 3;\n                 Spaces[1] = 2;\n                 Spaces[2] = 2;\n             else:\n                 Spaces[0] = (TODO-3)/2;\n                 Spaces[1] = (TODO-3)/2;\n                 Spaces[2] = 3;\n     else:\n         row = 0;\n         if (TODO >= 2*C+2):\n             Spaces[0] = C;\n             Spaces[1] = C;\n             TODO -= 2*C;\n             row = 2;\n             \n         while TODO > C+1:\n             if (TODO == 2*C+1) and (C != 3):\n                 Spaces[row] = C-1;\n                 Spaces[row+1] = C-1;\n                 Spaces[row+2] = 3;\n                 TODO = 0;\n             else:\n                 Spaces[row] = C;\n                 TODO -= C;\n                 row += 1;\n         if (TODO == C+1):\n             Spaces[row] += C-1;\n             Spaces[row+1] = 2;\n             TODO = 0;\n         Spaces[row] += TODO;\n \n     for r in range(R):\n         Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\n         if r == 0:\n             Ans = 'c'+Ans[1:];\n         print Ans;\n \n \n def Solve(R, C, M):\n     Blank = R*C-M;\n     if Blank == 0:\n         print "Impossible";\n         return;\n \n     if (Blank == 1):\n         Trivial(R,C,'*');\n         return\n     if (Blank == R*C):\n         Trivial(R,C,'.');\n         return\n \n     if (R == 1) or (C == 1):\n           Draw1(R,C,Blank);\n           return\n \n     if (R-2)*(C-2) == 0:\n         Draw2(R,C,Blank);\n         return\n \n     if Blank in [2,3,5,7]:\n         print "Impossible";\n         return;\n     \n     if (R >= 3) and (C >= 3):\n         Generate(R, C, Blank);\n \n     return;\n \n \n T = int(raw_input());\n for q in range(T):\n     [Row,Col,Mine] = map(int, raw_input().split());\n \n     Blanks = Row*Col - Mine;\n     \n     print "Case #%d:" % (q+1)\n #    print str(Row)+'x'+str(Col)+' with '+str(Mine)+' mines ('+str(Blanks)+' gaps)'\n     Solve(Row, Col, Mine);\n     \n         \n
nwin	<>	8	<>	2013_2270488_2463486.py	<>	from bisect import *\n a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]\n A = a[:10]\n def subdfs(pre, mid, d, t, n):\n     if d == t:\n         k = long(''.join([pre, mid, pre[::-1]]))\n         k = k * k\n         if k > n:\n             return [1, 0]\n         sqk = str(k)\n         if sqk == sqk[::-1]:\n             A.append(k)\n             return [0, 1]\n         else:\n             return [0, 0]\n     res = subdfs(pre + '0', mid, d + 1, t, n)\n     if res[0]: return res\n     if not res[1]: return res\n     res2 = subdfs(pre + '1', mid, d + 1, t, n)\n     if res2[0]: return [1, res[1] + res2[1]]\n     return [0, res[1] + res2[1]]\n \n def dfs(d, n):\n     subdfs('1', '', 0, d, n)\n     subdfs('2' + '0' * d, '', d, d, n)\n     subdfs('1', '0', 0, d, n)\n     subdfs('1', '1', 0, d, n)\n     subdfs('1', '2', 0, d, n)\n     subdfs('2' + '0' * d, '0', d, d, n)\n     subdfs('2' + '0' * d, '1', d, d, n)\n \n def solve(pre):\n     read_ints = lambda: map(int, raw_input().split())\n     l, r = read_ints()\n     cl = bisect_left(A, l)\n     cr = bisect_right(A, r)\n     cl_ = cr_ = 0\n     for i in xrange(40):\n         if a[i] < l: cl_ += 1\n     for i in xrange(40):\n         if a[i] <= r: cr_ += 1\n     #print pre, cr_ - cl_\n     print pre, cr - cl\n \n for k in xrange(1, 48):\n     dfs(k, 10 ** 100 + 1)\n A.sort()\n N = int(raw_input())\n for i in xrange(1, N + 1):\n     solve("Case #%d:" % i)\n
nwin	<>	8	<>	2013_2270488_2449486.py	<>	def solve(pre):\n     read_ints = lambda: map(int, raw_input().split())\n     h, w = read_ints()\n     to = [read_ints() for _ in xrange(h)]\n     lawn = [[100] * w for _ in xrange(h)]\n     for i, r in enumerate(to):\n         cut = max(r)\n         for j in xrange(w):\n             lawn[i][j] = min(lawn[i][j], cut)\n     for i, c in enumerate(zip(*to)):\n         cut = max(c)\n         for j in xrange(h):\n             lawn[j][i] = min(lawn[j][i], cut)\n     if lawn == to:\n         print pre, "YES"\n     else:\n         print pre, "NO"\n \n n = int(raw_input())\n for i in xrange(n):\n     solve("Case #%d:" % (i + 1))\n
nwin	<>	8	<>	2012_1460488_1483488.py	<>	def solve(a, b):\n     n = len(str(a))\n     N = 10 ** n\n     cnt = 0\n     for x in xrange(a, b):\n         y = x\n         S = set([y])\n         for j in xrange(n-1):\n             y = y * 10\n             y += y / N\n             y %= N\n             if a <= x < y <= b and y not in S:\n                 cnt += 1\n                 S.add(y)\n     return cnt\n \n T = int(raw_input())\n for t in xrange(T):\n     a, b = map(int, raw_input().split())\n     print "Case #%d: %d" % (t + 1, solve(a, b))\n
nwin	<>	8	<>	2014_2974486_5756407898963968.py	<>	def solve():\n     r1 = int(raw_input())\n     a1 = [map(int, raw_input().split()) for i in xrange(4)]\n     r2 = int(raw_input())\n     a2 = [map(int, raw_input().split()) for i in xrange(4)]\n     ans = -1\n     for i in xrange(1, 17):\n         if i in a1[r1-1] and i in a2[r2-1]:\n             if ans != -1:\n                 return "Bad magician!"\n             ans = i\n     if ans == -1:\n         return "Volunteer cheated!"\n     return ans\n for t in xrange(int(raw_input())):\n     print "Case #%d:" % (t + 1), solve()\n
nwin	<>	8	<>	2012_1460488_1483485.py	<>	import string\n n = int(raw_input())\n S = """\n y qee\n ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv\n z\n """\n T = """\n a zoo\n our language is impossible to understand\n there are twenty six factorial possibilities\n so it is okay if you want to just give up\n q\n """\n trans = {}\n for i in xrange(len(S)):\n     trans[S[i]] = T[i]\n A = ""\n B = ""\n for (c, d) in trans.items():\n     A += c\n     B += d\n for i in xrange(n):\n     print "Case #%d: %s" % (i + 1, raw_input().strip().translate(string.maketrans(A, B)))\n
nwin	<>	8	<>	2014_2974486_5709773144064000.py	<>	def solve():\n     c, f, x = map(float, raw_input().split())\n     ans = 1e40\n     cur = 0.0\n     psp = 2.0\n     while cur < ans + 1e-8:\n         ans = min(ans, cur + x / psp)\n         cur += c / psp\n         psp += f\n     return ans\n for t in xrange(int(raw_input())):\n     print "Case #%d: %.7f" % (t + 1, solve())\n
nwin	<>	8	<>	2013_2270488_2453486.py	<>	def solve(pre):\n     b = [raw_input().strip() for _ in xrange(4)]\n     raw_input()\n     for s in b + zip(*b) + [''.join(b[i][i] for i in xrange(4)), ''.join(b[3-i][i] for i in xrange(4))]:\n         for c in 'XO':\n             if s.count('T') + s.count(c) == 4:\n                 print pre, c, "won"\n                 return\n     if ''.join(b).count('.'):\n         print pre, "Game has not completed"\n     else:\n         print pre, "Draw"\n \n n = int(raw_input())\n for i in xrange(n):\n     solve("Case #%d:" % (i + 1))\n
michael	<>	9	<>	2013_2270488_2463486.py	<>	from math import *\n \n def read_line():\n     return raw_input().strip()\n \n def read_words():\n     return read_line().split()\n \n def read_integer():\n     return int( read_line() )\n \n def read_integers():\n     return [ int( x ) for x in read_words() ]\n \n T = read_integer()\n for t in range( T ):\n     A, B = read_integers()\n     A_root = int( ceil( sqrt( A ) ) )\n     B_root = int( floor( sqrt( B ) ) )\n     count = 0\n     for root in range( A_root, B_root + 1 ):\n         word = str( root )\n         if word == word[ : : -1 ]:\n             word = str( root*root )\n             if word == word[ : : -1 ]:\n                 count += 1\n     print 'Case #%i:' % ( t + 1 ), count\n
michael	<>	9	<>	2013_2270488_2449486.py	<>	from numpy import *\n \n def read_line():\n     return raw_input().strip()\n \n def read_words():\n     return read_line().split()\n \n def read_integer():\n     return int( read_line() )\n \n def read_integers():\n     return [ int( x ) for x in read_words() ]\n \n T = read_integer()\n for t in range( T ):\n     N, M = read_integers()\n     lawn = array( [ read_integers() for n in range( N ) ] )\n     valid = zeros( lawn.shape, bool )\n     for row in range( N ):\n         valid[ row ][ lawn[ row ] == amax( lawn[ row ] ) ] = True\n     for column in range( M ):\n         valid[ :, column ][ lawn[ :, column ] == amax( lawn[ :, column ] ) ] = 1\n     print 'Case #%i:' % ( t + 1 ), 'YES' if all( valid ) else 'NO'\n
michael	<>	9	<>	2012_1460488_1483488.py	<>	def read_line():\n     return raw_input().strip()\n \n def read_words():\n     return read_line().split()\n \n def read_integer():\n     return int( read_line() )\n \n def read_integers():\n     return [ int( x ) for x in read_words() ]\n \n T = read_integer()\n for t in range( T ):\n     print 'Case #%i:' % ( t + 1 ),\n     A, B = read_integers()\n     length = len( str( A ) )\n     pairs = set()\n     for n in range( A, B ):\n         digits = str( n )\n         for start in range( 1, length ):\n             m = int( digits[ start : ] + digits[ : start ] )\n             if n < m <= B:\n                 pairs.add( ( n, m ) )\n     print len( pairs )\n
michael	<>	9	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n def read_line():\n     return sys.stdin.readline().rstrip( '\n' )\n \n def read_integer():\n     return int( read_line() )\n \n def read_integers():\n     return [ int( x ) for x in read_line().split() ]\n \n def read_string():\n     return read_line().strip()\n \n def read_strings():\n     return read_line().split()\n \n def input_string_stack():\n     data = []\n     for line in sys.stdin.readlines():\n         data.extend( line.split() )\n     data.reverse()\n     return data\n \n def input_integer_stack():\n     return [ int( x ) for x in read_string_stack() ]\n \n class memoized( object ):\n    def __init__( self, function ):\n       self.function = function\n       self.cache = {}\n    def __call__( self, *arguments ):\n       try:\n          return self.cache[ arguments ]\n       except KeyError:\n          value = self.function( *arguments )\n          self.cache[ arguments ] = value\n          return value\n \n T = read_integer()\n for t in range( T ):\n     row = read_integer()\n     candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n     row = read_integer()\n     candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n     print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'\n
michael	<>	9	<>	2012_1460488_1483485.py	<>	def read_line():\n     return raw_input().strip()\n \n def read_words():\n     return read_line().split()\n \n def read_integer():\n     return int( read_line() )\n \n def read_integers():\n     return [ int( x ) for x in read_words() ]\n \n \n ciphers = 'y qee', 'ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv'\n plaintexts = 'a zoo', 'our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up'\n \n mapping = {}\n for cipher, plaintext in zip( ciphers, plaintexts ):\n     for key, value in zip( cipher, plaintext ):\n         mapping[ key.lower() ] = value.lower()\n mapping[ 'z' ] = 'q'\n \n T = read_integer()\n for t in range( T ):\n     print 'Case #%i:' % ( t + 1 ), ''.join( mapping[ key.lower() ].upper() if key.isupper() else mapping[ key ] for key in read_line() )\n
michael	<>	9	<>	2014_2974486_5709773144064000.py	<>	import sys\n \n def read_line():\n     return sys.stdin.readline().rstrip( '\n' )\n \n def read_integer():\n     return int( read_line() )\n \n def read_float():\n     return float( read_line() )\n \n def read_floats():\n     return [ float( x ) for x in read_line().split() ]\n \n T = read_integer()\n for t in range( T ):\n     C, F, X = read_floats()\n     rate = 2\n     cookies = 0\n     s = 0\n     while True:\n         t1 = X/rate\n         t2 = C/rate + X/( rate + F )\n         if t1 < t2:\n             s += t1\n             break\n         s += C/rate\n         rate += F\n     print 'Case #%i: %.7f' % ( t + 1, s )\n
michael	<>	9	<>	2013_2270488_2453486.py	<>	def read_line():\n     return raw_input().strip()\n \n def read_integer():\n     return int( read_line() )\n \n T = read_integer()\n for t in range( T ):\n     board = [ read_line() for index in range( 4 ) ]\n     read_line()\n     print 'Case #%i:' % ( t + 1 ),\n     blank_count = 0\n     for row, column, row_increment, column_increment in ( ( 0, 0, 0, 1 ),\n                                                           ( 1, 0, 0, 1 ),\n                                                           ( 2, 0, 0, 1 ),\n                                                           ( 3, 0, 0, 1 ),\n                                                           ( 0, 0, 1, 0 ),\n                                                           ( 0, 1, 1, 0 ),\n                                                           ( 0, 2, 1, 0 ),\n                                                           ( 0, 3, 1, 0 ),\n                                                           ( 0, 0, 1, 1 ),\n                                                           ( 0, 3, 1, -1 ) ):\n         O_count = 0\n         X_count = 0\n         for index in range( 4 ):\n             value = board[ row ][ column ]\n             if value == 'O':\n                 O_count += 1\n             elif value == 'X':\n                 X_count += 1\n             elif value == 'T':\n                 O_count += 1\n                 X_count += 1\n             else:\n                 blank_count += 1\n             row += row_increment\n             column += column_increment\n         result = 'O' if O_count == 4 else 'X' if X_count == 4 else None\n         if result:\n             break\n     else:\n         print 'Game has not completed' if blank_count else 'Draw'\n         continue\n     print result, 'won'\n
michael	<>	9	<>	2014_2974486_5690574640250880.py	<>	import sys\n \n def read_line():\n     return sys.stdin.readline().rstrip( '\n' )\n \n def read_integer():\n     return int( read_line() )\n \n def read_integers():\n     return [ int( x ) for x in read_line().split() ]\n \n def flip( grid ):\n     return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n \n def grow( R, C, M ):\n     grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n     b = R*C - M\n     if C > R:\n         R, C, grid = C, R, flip( grid )\n         flipped = True\n     else:\n         flipped = False\n     if b < 2*C:\n         if b == 1:\n             grid[ 0 ][ 0 ] = 'c'\n         elif b == 3 and C >= 3:\n             grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n         elif b % 2:\n             return\n         else:\n             grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n             grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n             grid[ 0 ][ 0 ] = 'c'\n     else:\n         r = 0\n         while b >= C:\n             grid[ r ] = bytearray( C*[ '.' ] )\n             b -= C\n             r += 1\n         if b:\n             if b >= 2:\n                 grid[ r ][ : b ] = b*'.'\n             elif C > 2 and r > 2:\n                 grid[ r - 1 ][ -1 ] = '*'\n                 grid[ r ][ : 2 ] = '..'\n             else:\n                 return\n         grid[ 0 ][ 0 ] = 'c'\n     return flip( grid ) if flipped else grid\n     \n T = read_integer()\n for t in range( T ):\n     print 'Case #%i:' % ( t + 1 )\n     R, C, M = read_integers()\n     grid = grow( R, C, M )\n     print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\n
taichino	<>	10	<>	2013_2270488_2463486.py	<>	# -*- coding: utf-8 -*-\n \n import sys\n \n def is_palindrome(num):\n     s1 = str(num)\n     s2 = s1[::-1]\n     return s1 == s2\n \n fair_numbers = []\n for i in range(pow(10, 7)+1):\n     if is_palindrome(i):\n         num = i*i\n         if is_palindrome(num):\n             fair_numbers.append(num)\n \n N = int(sys.stdin.readline())\n for T in range(1, N+1):\n     min_val, max_val = map(int, sys.stdin.readline().strip().split())\n \n     ans = 0\n     for num in fair_numbers:\n         if num < min_val:\n             continue\n         if num > max_val:\n             break\n         ans += 1\n     print 'Case #%(T)s: %(ans)s' % locals()\n
taichino	<>	10	<>	2013_2270488_2449486.py	<>	# -*- coding: utf-8 -*-\n \n import sys\n import copy\n \n def next_pos(grass, goal, elems):\n     while elems:\n         val = elems[0]\n         for n in range(len(goal)):\n             for m in range(len(goal[0])):\n                 if goal[n][m] == val and goal[n][m] < grass[n][m]:\n                     return (n, m)\n         elems.remove(val)\n     return None\n \n def check(grass, goal):\n     possible = True\n     completed = True\n     for n in range(len(grass)):\n         for m in range(len(grass[0])):\n             if grass[n][m] > goal[n][m]:\n                 completed = False\n             elif grass[n][m] < goal[n][m]:\n                 possible = False\n \n     return possible, completed\n \n def cut(grass, goal, pos, h, elems):\n     \n     def _cut(grass, goal, pos, h, is_horizontal):\n         if is_horizontal:\n             for m in range(len(grass[0])):\n                 grass[pos[0]][m] = h\n         else:\n             for n in range(len(grass)):\n                 grass[n][pos[1]] = h\n         possible, completed = check(grass, goal)\n         if completed and possible:\n             return 'YES'\n         elif not completed and possible:\n             pos = next_pos(grass, goal, elems)\n             if not pos:\n                 return 'NO'\n             h = goal[pos[0]][pos[1]]\n             return cut(grass, goal, pos, h, elems)\n         elif not possible:\n             return 'NO'\n \n     ans1 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=True)\n     if ans1 == 'YES':\n         return 'YES'\n     ans2 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=False)\n     if ans2 == 'YES':\n         return 'YES'\n     return 'NO'\n \n \n def calc(grass, goal):\n     def _elems(goal):\n         elems = set()\n         for n in range(len(goal)):\n             for m in range(len(goal[0])):\n                 elems.add(goal[n][m])\n         return sorted(list(elems), reverse=True)\n \n     elems = _elems(goal)\n     pos = next_pos(grass, goal, elems)\n     h = goal[pos[0]][pos[1]]\n     return cut(grass, goal, pos, h, elems)\n \n \n N = int(sys.stdin.readline())\n for T in range(1, N+1):\n     N, M = map(int, sys.stdin.readline().strip().split())\n \n     goal = []\n     for i in range(N):\n         goal.append(map(int, sys.stdin.readline().strip().split()))\n \n     grass = []\n     for i in range(N):\n         line = [100] * M\n         grass.append(line)\n \n     ans = calc(grass, goal)\n     print 'Case #%(T)s: %(ans)s' % locals()\n
taichino	<>	10	<>	2012_1460488_1483488.py	<>	#!/usr/bin/python\n # -*- coding: utf-8 -*-\n \n import sys\n \n def recycled_numbers(num):\n     result = []\n     num_text = str(num)\n     for i in range(1, len(num_text)):\n         rotated = int(num_text[i:] + num_text[:i])\n         if num != rotated:\n             result.append(rotated)\n     return result\n \n for T, line in enumerate(sys.stdin):\n     if T == 0:\n         continue\n \n     results = []\n     params = [int(n) for n in line.split(' ')]\n     (A, B) = params\n     for i in range(A, B):\n         candidates = recycled_numbers(i)\n         for c in candidates:\n             pair = (i, c)\n             if pair not in results and A <= c and c <= B and i < c:\n                 results.append(pair)\n     # print results\n     ans = len(results)\n     print 'Case #%(T)s: %(ans)s' % locals()\n
taichino	<>	10	<>	2014_2974486_5756407898963968.py	<>	# -*- coding: utf-8 -*-\n \n import sys\n \n N = int(sys.stdin.readline())\n \n for T in range(1, N+1):\n     first_ans = int(sys.stdin.readline())\n     first_grid = []\n     for i in range(4):\n         row = [int(v) for v in sys.stdin.readline().split(' ')]\n         first_grid.append(row)\n     first_list = set(first_grid[first_ans-1])\n     \n     second_ans = int(sys.stdin.readline())\n     second_grid = []\n     for i in range(4):\n         row = [int(v) for v in sys.stdin.readline().split(' ')]\n         second_grid.append(row)\n     second_list = set(second_grid[second_ans-1])\n \n     intersection = first_list.intersection(second_list)\n \n     if len(intersection) == 1:\n         ans = intersection.pop()\n     elif len(intersection) == 0:\n         ans = 'Volunteer cheated!'\n     else:\n         ans = 'Bad magician!'\n \n     print 'Case #%(T)s: %(ans)s' % locals()\n
taichino	<>	10	<>	2012_1460488_1483485.py	<>	#!/usr/bin/python\n # -*- coding: utf-8 -*-\n \n import sys\n \n alphabet = 'abcdefghijklmnopqrstuvwxyz'\n gog = 'ejp mysljylc kd kxveddknmc re jsicpdrysi' + \\n       'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' + \\n       'de kr kd eoya kw aej tysr re ujdr lkgc jv' + \\n       'y qee'\n \n eng = 'our language is impossible to understand' + \\n       'there are twenty six factorial possibilities' + \\n       'so it is okay if you want to just give up' + \\n       'a zoo'\n \n rule = {}\n for i, c in enumerate(gog):\n    rule[c] = eng[i]\n \n gog_alphabet = rule.keys()\n eng_alphabet = rule.values()\n missing_key = None\n missing_val = None\n for c in alphabet:\n     if not c in gog_alphabet:\n         missing_key = c\n     if not c in eng_alphabet:\n         missing_val = c\n rule[missing_key] = missing_val\n \n for i, line in enumerate(sys.stdin):\n     if i == 0:\n         continue\n \n     orig = line.strip()\n     ans = ''.join([rule[c] for c in orig])\n     print 'Case #%(i)s: %(ans)s' % locals()\n \n
taichino	<>	10	<>	2014_2974486_5709773144064000.py	<>	# -*- coding: utf-8 -*-\n \n import sys\n \n N = int(sys.stdin.readline())\n \n for T in range(1, N+1):\n     C, F, X = map(float, sys.stdin.readline().split(' '))\n \n     # find N\n     N = 0\n     for i in range(int(X)):\n         diff = (2 + F * i) * C - F * X\n         if diff >= 0: break\n         N = i\n \n     # calc seconds\n     total = 0\n     for i in range(N):\n         val = C / (2 + i * F)\n         total += val\n     val = X / (2.0 + N * F)\n     total += val\n         \n     ans = '%s' % (total)\n     print 'Case #%(T)s: %(ans)s' % locals()\n
taichino	<>	10	<>	2013_2270488_2453486.py	<>	# -*- coding: utf-8 -*-\n \n import sys\n \n N = int(sys.stdin.readline())\n \n for T in range(1, N+1):\n     lines = []\n     completed = True\n     for i in range(4):\n         line = sys.stdin.readline().strip()\n         if '.' in line:\n             completed = False\n         lines.append(line)\n     sys.stdin.readline() # empty line\n \n     ans = 'Draw' if completed else 'Game has not completed'\n     # horizontal\n     for row in range(4):\n         X, O = 0, 0\n         for col in range(4):\n             spot = lines[row][col]\n             if spot == 'O':\n                 O += 1\n             elif spot == 'X':\n                 X += 1\n             if spot == 'T':\n                 O += 1\n                 X += 1\n         if X == 4:\n             ans = 'X won'\n         elif O == 4:\n             ans = 'O won'\n \n     # vertical\n     for col in range(4):\n         X, O = 0, 0\n         for row in range(4):\n             spot = lines[row][col]\n             if spot == 'O':\n                 O += 1\n             elif spot == 'X':\n                 X += 1\n             if spot == 'T':\n                 O += 1\n                 X += 1\n         if X == 4:\n             ans = 'X won'\n         elif O == 4:\n             ans = 'O won'\n \n     # diagonal\n     X1, X2, O1, O2 = 0, 0, 0, 0\n     for i in range(4):\n         spot1 = lines[i][i]\n         spot2 = lines[4-i-1][i]\n \n         if spot1 == 'O':\n             O1 += 1\n         elif spot1 == 'X':\n             X1 += 1\n         elif spot1 == 'T':\n             O1 += 1\n             X1 += 1\n \n         if spot2 == 'O':\n             O2 += 1\n         elif spot2 == 'X':\n             X2 += 1\n         elif spot2 == 'T':\n             O2 += 1\n             X2 += 1\n \n     if X1 == 4 or X2 == 4:\n         ans = 'X won'\n     elif O1 == 4 or O2 == 4:\n         ans = 'O won'\n     \n     \n     print 'Case #%(T)s: %(ans)s' % locals()\n
taichino	<>	10	<>	2014_2974486_5690574640250880.py	<>	# -*- coding: utf-8 -*-\n \n import sys\n \n \n def show_board(board):\n     for row in board:\n         print ''.join(row)\n \n \n N = int(sys.stdin.readline())\n \n for T in range(1, N+1):\n     (R, C, M) = map(int, sys.stdin.readline().split(' '))\n     E = R*C-M # empty\n     possible, reverse, need_adjust, column_base = (False, False, False, False)\n     if C > R:\n         (R, C) = (C, R)\n         reverse = True\n \n     #\n     # judgement\n     #\n     W = 0\n     lastRow = 0\n     if E == 0:\n         pass\n     elif E == 1 or M == 0:\n         W = C\n         possible = True\n     elif C == 1:\n         W = 1\n         if E > 0:\n             possible = True\n     elif C == 2:\n         W = 2\n         lastRow = int(E / 2) + 1   # 1 base\n         if E % 2 == 0 and E >= 4:\n             possible = True\n     elif C >= 3:\n         for w in range(2, C+1):\n             lastRow = int(E / w) + 1   # 1 base\n             if lastRow > R: continue\n             lastRowNum = E % w\n             \n             if lastRow == 2 and lastRowNum == 0:\n                 pass\n             elif lastRow == 2:   # lastRow == 1 => impossible\n                 if lastRowNum == 0:\n                     W = w\n                     possible = True\n                     break\n             elif lastRow >= 3:\n                 if lastRowNum >= 2 or lastRowNum == 0:\n                     W = w\n                     possible = True\n                     break\n                 elif C >= 4 and lastRowNum == 1 and R >= 3:\n                     W = w\n                     possible = True\n                     need_adjust = True\n                     break\n         if not possible:\n             for w in range(2, R+1):\n                 lastRow = int(E / w) + 1   # 1 base\n                 if lastRow > R: continue\n                 lastRowNum = E % w\n                 if lastRow == 2 and lastRowNum == 0:\n                     pass\n                 elif lastRow == 2:   # lastRow == 1 => impossible\n                     if lastRowNum == 0:\n                         W = w\n                         possible = True\n                         column_base = True\n                         break\n                 elif lastRow >= 3:\n                     if lastRowNum >= 2 or lastRowNum == 0:\n                         W = w\n                         possible = True\n                         column_base = True\n                         break\n                     elif C >= 4 and lastRowNum == 1 and R >= 3:\n                         W = w\n                         possible = True\n                         need_adjust = True\n                         column_base = True\n                         break\n                                 \n     if not possible:\n         if reverse:\n             R, C = (C, R)        \n         ans = 'Impossible %sx%s M=%s' % (R, C, M)\n         # ans = 'Impossible'\n         print 'Case #%(T)s: %(ans)s' % locals()\n         continue\n \n     #\n     # make board\n     #\n     board = [['*'] * C for i in range(R)]\n     for i in range(E):\n         if not column_base:\n             c = i % W\n             r = i / W\n         else:\n             r = i % W\n             c = i / W            \n         board[r][c] = '.'\n     if need_adjust:\n         board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]\n     if reverse:\n         board = map(list, zip(*board))\n         R, C = (C, R)\n \n     clicked = False\n     for r in range(R):\n         if clicked: break\n         for c in range(C):\n             cell = board[r][c]\n             if cell != '.': continue\n             if E == 1:\n                 board[r][c] = 'c'\n                 clicked = True\n                 break\n             \n             if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\n             if r >= 1              and board[r-1][c]   == '*': continue\n             if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\n             if             c >= 1  and board[r][c-1]   == '*': continue\n             if             c < C-1 and board[r][c+1]   == '*': continue\n             if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\n             if r < R-1             and board[r+1][c]   == '*': continue\n             if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\n             board[r][c] = 'c'\n             clicked = True\n             break\n \n     #\n     # show answer\n     #\n     ans = 'Possible' if possible else 'Impossible'\n     print 'Case #%(T)s:' % locals()\n     show_board(board)\n
elmoatasem	<>	11	<>	2013_2270488_2463486.py	<>	'''\n Created on Apr 12, 2013\n \n @author: Moatasem\n '''\n \n import math\n \n \n def isPalindrome(word):\n     isPalin=False\n     if(len(word)%2==0):\n         f_half=word[0:len(word)/2];\n         s_half=word[len(word)/2:len(word)][::-1]\n         if( f_half==s_half):\n             isPalin= True\n     else:\n         f_half=word[0:len(word)/2]\n         s_half=word[(len(word)/2)+1:len(word)][::-1]\n         if( f_half==s_half):\n             isPalin= True\n     return isPalin\n     \n def getNumberOfFairAndSquare(range_):\n     start=range_[0]\n     end=range_[1]\n     count_=0\n     for i in range(start,end+1):\n         root=math.sqrt(i);\n         if(root.is_integer() and isPalindrome(str(int(root))) and isPalindrome(str(i))):\n             count_+=1\n     return count_\n         \n         \n     \n \n f_r = open('C.in',"r")\n n_test=int(f_r.readline().strip()) \n f_w = open("C.out", "w")\n for i in range(n_test):\n     range_ =map(int,f_r.readline().split())\n     result=getNumberOfFairAndSquare(range_)\n     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n     f_w.write(output_str+'\n')\n f_r.close()\n f_w.close()
elmoatasem	<>	11	<>	2013_2270488_2449486.py	<>	'''\n Created on Apr 12, 2013\n \n @author: Moatasem\n '''\n \n import math\n \n \n \n \n def markMax(max_,start,end,marked,isRow,lawn):\n     for i in range(end):\n             if(isRow):\n                 if( lawn[start][i]==max_):\n                     marked[start][i]=-1\n             else: \n                 if( lawn[i][start]==max_):\n                     marked[i][start]=-1\n                     \n                 \n     \n     \n def mowerLawn(lawn,m,n,marked):\n     #marked= [[0] *n]*m\n     for i in range(m):\n         max_=max(lawn[i])\n         markMax(max_,i,n,marked,True,lawn) \n     \n     for i in range(n):\n         colList=[]\n         for j in range(m):\n             colList.append(lawn[j][i])\n         max_=max(colList)\n         markMax(max_,i,m,marked,False,lawn) \n            \n     done=True\n     for i in range(m):\n         for j in range(n):\n             if(marked[i][j]!=-1):\n                 done=False\n                 break\n         if(not done):\n             break\n     if(done):\n         return 'YES'\n     else:\n         return 'NO'\n     \n         \n     \n \n f_r = open('B.in',"r")\n n_test=int(f_r.readline().strip()) \n f_w = open("B.out", "w")\n for i in range(n_test):\n     lawn=[]\n     \n     range_ =map(int,f_r.readline().split())\n     #marked= [[0] *range_[1]]*range_[0]\n     marked=[[0]*range_[1] for x in xrange(range_[0])]\n     for j in range(range_[0]):\n         temp=[map(int,f_r.readline().split())]\n         lawn.extend(temp)\n     result=mowerLawn(lawn,range_[0],range_[1],marked)\n     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n     f_w.write(output_str+'\n')\n f_r.close()\n f_w.close()
elmoatasem	<>	11	<>	2012_1460488_1483488.py	<>	'''\n Created on Apr 14, 2012\n \n @author: moatasem\n '''\n \n def getNumRecycle(n,A,B,h):\n         c=0\n         x=list(str(n))\n         for i in xrange(1,len(x)):\n             t1="".join(x[0:i])\n             t2="".join(x[i:len(x)])\n             num=int(t2+t1)\n             if((num>=A and num<=B) and num<>n and h.get((num,n))==None and h.get((n,num))==None):\n                 #print "(",str(n),",",str(num),")"\n                 h[(num,n)]=0;\n                 c+=1\n         return c\n     \n     \n f = open("C-small-attempt0.in", "r")\n n=int(f.readline().strip())\n for k  in xrange(n):\n     d=f.readline().strip()\n     A,B=[int(i) for i in d.split(" ")]\n     count=0\n     h={}\n     for j in range(A,B+1):\n         count+= getNumRecycle(j,A,B,h)\n     print 'Case #'+str((k+1))+": "+str(count)
elmoatasem	<>	11	<>	2014_2974486_5756407898963968.py	<>	'''\n Created on Apr 11, 2014\n \n @author: mostasem\n '''\n \n \n \n def getIntersection(A,B):\n     intersect_list = []\n     dict = {};\n     for i in range(4):\n         if(dict.get(A[i]) <> None):\n             dict[A[i]] += 1\n             if(intersect_list.count(A[i]) == 0):\n                 intersect_list.append(A[i])\n         else:\n             dict[A[i]] = 1\n         if(dict.get(B[i]) <> None):\n             dict[B[i]] += 1\n             if(intersect_list.count(B[i]) == 0):\n                 intersect_list.append(B[i])\n         else:\n             dict[B[i]] = 1\n \n     return intersect_list\n \n f_r = open('A.in',"r")\n n_test=int(f_r.readline().strip()) \n f_w = open("A.out", "w")\n result = ""\n for i in range(n_test):\n     cards1 = []\n     row_index_1 = int(f_r.readline()) - 1\n     for j in range(4):\n         cards1.append(map(int,f_r.readline().split()))\n     cards2 = []\n     row_index_2 = int(f_r.readline()) - 1\n     for j in range(4):\n         cards2.append(map(int,f_r.readline().split())) \n #     print cards1 \n #     print cards2\n #     print cards1[row_index_1] ,cards2[row_index_2]\n     int_list =  getIntersection(cards1[row_index_1], cards2[row_index_2])\n #     print int_list\n     result = ""\n     if(len(int_list) == 0):\n         result = "Volunteer cheated!"\n     elif(len(int_list)  == 1):\n         result = str(int_list[0])\n     else:\n         result = "Bad magician!"\n     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n     print output_str\n     f_w.write(output_str+'\n')\n f_r.close()\n f_w.close()
elmoatasem	<>	11	<>	2012_1460488_1483485.py	<>	'''\n Created on Apr 14, 2012\n \n @author: moatasem\n '''\n lan={'z':'q','q':'z',' ':' '}\n \n s1=list("ejp mysljylc kd kxveddknmc re jsicpdrysi")\n e1=list ("our language is impossible to understand")\n s2=list("rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd")\n e2=list ("there are twenty six factorial possibilities")\n s3=list("de kr kd eoya kw aej tysr re ujdr lkgc jv")\n e3=list ("so it is okay if you want to just give up")\n for i in xrange(len(s1)):\n     if(lan.get(s1[i])==None and s1[i]!=" "):\n         lan[s1[i]]=e1[i]\n     if(lan.get(s2[i])==None and s2[i]!=" "):\n         lan[s2[i]]=e2[i]\n     if(lan.get(s3[i])==None and s3[i]!=" "):\n         lan[s3[i]]=e3[i]\n         \n f = open("A-small-attempt0.in", "r")\n n=int(f.readline().strip())\n for i  in xrange(n):\n     line=f.readline().strip()\n     res='Case #'+str((i+1))+": "\n     for j in xrange(len(line)):\n         res+=str(lan.get(line[j]))\n     print res\n         \n     \n \n
elmoatasem	<>	11	<>	2014_2974486_5709773144064000.py	<>	'''\n Created on Apr 11, 2014\n \n @author: mostasem\n '''\n \n \n def getSeconds(C,F,X):\n     seconds = 0.0\n     cookie_rate = 2\n     solved =False\n     while (not solved):\n         choice1 = X/cookie_rate\n         choice2 = C/cookie_rate + X/(cookie_rate + F)\n         if(choice1 < choice2):\n             seconds += choice1\n             solved = True\n         else :\n             seconds += C/cookie_rate\n             cookie_rate += F\n     \n     return seconds\n \n f_r = open('B.in',"r")\n n_test=int(f_r.readline().strip()) \n f_w = open("B.out", "w")\n result = ""\n for i in range(n_test):\n     C,F,X = map(float,f_r.readline().split())\n     seconds = getSeconds(C,F,X)\n     result = str(seconds)\n     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n     f_w.write(output_str+'\n')\n     \n f_r.close()\n f_w.close()\n \n
elmoatasem	<>	11	<>	2013_2270488_2453486.py	<>	'''\n Created on Apr 12, 2013\n \n @author: Moatasem\n '''\n \n def getStatus(board):\n     status="" \n     solved=False\n     n_dotted=0\n     #checking for columns and rows\n     for i in range(4):\n         result= checkBoard(board[i])\n         if(result!="None"):\n             status=result\n             solved=True\n         else:\n             columnlist=[]\n             for j in range(4):\n                 if(board[i][j]=='.'):\n                     n_dotted+=1\n                 columnlist.append(board[j][i])\n             result= checkBoard(columnlist)\n             if(result!="None"): \n                 solved=True\n                 status=result\n                 break\n         if(solved):\n             break\n         \n     #checking for diagonals\n     result_l=checkBoard([board[x][x] for x in range(4)]) #leftDiagonal\n     result_r=checkBoard([board[0][3],board[1][2],board[2][1],board[3][0]]) #rightDiagonal\n     if(result_l!="None"): \n             solved=True\n             status=result_l\n     if(result_r!="None"): \n             solved=True\n             status=result_r\n                 \n     if(solved==False):\n         if(n_dotted==0):\n             status="Draw"\n         else: \n             status="Game has not completed"   \n \n     return status\n \n \n def checkBoard(board):\n         status="None"\n         x_count=board.count('X')\n         o_count=board.count('O')\n         t_count=board.count('T')\n         if(x_count==4 or (x_count==3 and t_count==1)):\n             status="X won"\n         elif(o_count==4 or (o_count==3 and t_count==1)):\n             status="O won"\n         return status\n \n \n f_r = open('A.in',"r")\n n_test=int(f_r.readline().strip()) \n \n f_w = open("A.out", "w")\n for i in range(n_test):\n     board=[]\n     for j in range(4):\n         board.append(f_r.readline().strip())\n     result= getStatus(board)\n     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n     f_w.write(output_str+'\n')\n     f_r.readline()\n f_r.close()\n f_w.close()\n
elmoatasem	<>	11	<>	2014_2974486_5690574640250880.py	<>	'''\n Created on Apr 12, 2014\n \n @author: mostasem\n '''\n \n import math\n def getFloorRoots(m):\n     r1 = -1 + math.sqrt(1 + (8 * m))/2\n     r2 = -1 - math.sqrt(1 + (8 * m))/2\n     return int(math.floor(r1))\n     \n def boardHasZero(R,C,M):\n     if(R > 1 and C > 1):\n         S = M/C\n         Sr = M % C\n         print S,Sr\n         return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\n     else :\n         return M <= ((R*C) - 2)\n \n \n def generateMineSweeperCase(R,C,M):\n \n     board = ""\n \n     if( R > 1 and C > 1 ): # generate special\n         S = M/C\n         Sr = M % C\n         print S,Sr\n         if(S): # all rows of *\n             board +="\n"\n             if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\n                 board += (S - 1) * ((C*"*") + "\n")\n             else:\n                 board += (S - 2) * ((C*"*") + "\n")\n             board +=  ((C*"*"))\n             \n         if(R >= S+3):\n             if(Sr):\n                 board +="\n"\n                 board += ((Sr *"*") + ((C - Sr) *"."))\n             Rm = R - (S + 1)\n             if(Rm):\n                 board +="\n"\n                 board += (Rm - 1) * ((C*".") + "\n")\n                 board +=  ((C*"."))\n                 \n         elif(R == S + 2):\n             Sm = 0\n             if(Sr % 2 == 0):\n                 board +="\n"\n                 board += (((Sr / 2) *"*") + ((C - (Sr / 2)) *".") +"\n")\n                 board += ((Sr / 2) *"*") + ((C - (Sr / 2)) *".")\n             else:\n                 board +="\n"\n                 board += (((Sr / 3) *"*") + ((C - (Sr / 3)) *".") +"\n")\n                 board += ((Sr / 3) *"*") + ((C - (Sr / 3)) *".")\n         else :\n             Sm = Sr + C\n             board +="\n"\n             board += (((Sm / 2) *"*") + ((C - (Sm / 2)) *".") +"\n")\n             board += ((Sm / 2) *"*") + ((C - (Sm / 2)) *".")\n                 \n         list_board = list(board)\n         list_board[len(list_board) - 1] = 'c'\n         board = "".join(list_board)\n     else:\n         board +="\n"\n         if(C == 1):\n             board += M * "*\n"\n             board += (R-M-1) * ".\n"\n             board +=  "c"\n         else:\n             board += M * "*"\n             board += (C-M-1) * "."\n             board += "c"\n             \n     return board\n        \n        \n        \n \n f_r = open('C.in',"r")\n n_test=int(f_r.readline().strip()) \n f_w = open("C.out", "w")\n result = ""\n for i in range(n_test):\n     R,C,M = map(int,f_r.readline().split())\n     print R,C,M\n     if(boardHasZero(R,C,M)):\n         result = generateMineSweeperCase(R,C,M)\n     else :\n         result ="\nImpossible"\n     print result\n     output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\n     f_w.write(output_str+'\n')\n     \n f_r.close()
entropy	<>	12	<>	2013_2270488_2463486.py	<>	\n def ispal(num):\n     num = str(num)\n     if num == num[::-1]:\n         return True\n     else:\n         return False\n \n def test(bot, top):\n     count = []\n     for i in range(bot,top+1):\n         if not ((int(i**0.5)**2) == i):\n             continue\n         if ispal(i) and ispal(int(i**0.5)):\n             count.append(i)\n     return len(count)\n \n case = 1\n for line in open('C-small-attempt2.in', 'Ur'):\n     if ' ' in line:\n         a,b = line.split()\n         res = test(int(a),int(b))\n         print("Case #{0}: {1}".format(case, res))\n         case += 1\n \n \n
entropy	<>	12	<>	2013_2270488_2449486.py	<>	\n def check(grid):\n     if len(grid) <= 1 or len(grid[0]) <= 1:\n         return True\n     for r in range(len(grid)-1):\n         for c in range(len(grid[r])-1):\n             e1 = grid[r][c]\n             e2 = grid[r][c+1]\n             e3 = grid[r+1][c]\n             e4 = grid[r+1][c+1]\n             if (e1 > e2 and e4 > e2) or (e1 > e3 and e4 > e3):\n                 return False\n             if (e2 > e1 and e3 > e1) or (e2 > e4 and e3 > e4):\n                 return False\n     return True\n \n def removeG(grid):\n     for i in range(len(grid)):\n         if len(set(grid[i])) == 1 and grid[i][0] == 1 :\n             del grid[i]\n             return True\n     return False\n \n infile = open('B-small-attempt5.in', 'Ur')\n #infile = open('test3.in', 'Ur')\n \n tests = int(infile.readline().strip())\n \n for t in range(tests):\n     grid = []\n     h, w = [int(x) for x in infile.readline().strip().split()]\n     for i in range(h):\n         row =[int(x) for x in infile.readline().strip().split()]\n         grid.append(row)\n \n     pass1 = check(grid)\n     print("------")\n     for r in grid:\n         print(" ".join([str(x) for x in r]))\n     while len(grid) >= 3:\n         if not removeG(grid):\n             break\n \n     pass2 = check(grid)\n     grid = [x for x in zip(*grid[::-1])]\n     while len(grid) >= 3:\n         if not removeG(grid):\n             break\n     print("------")\n     for r in grid:\n         print(" ".join([str(x) for x in r]))\n     pass3 = check(grid)\n \n \n #   if len(grid) >= 3:\n #       grid = [row for row in grid if len(set(row)) != 1]\n #   print("------")\n #   for r in grid:\n #       print(" ".join([str(x) for x in r]))\n \n     if pass1 and pass2 and pass3:\n         res = 'YES'\n     else:\n         res = 'NO'\n \n     print("Case #{0}: {1}".format(t+1,res))\n \n \n
entropy	<>	12	<>	2012_1460488_1483488.py	<>	data = [ [int(a) for a in i.split(" ")] for i in open("C-small-attempt0.in","rU").read()[:-1].split("\n")]\n \n def recycle(number, mini, maxi):\n 	number2 = str(number)\n 	count = 0\n 	for i in range(len(number2)):\n 		number2 = number2[-1:] + number2[:-1]\n 		numtemp = int(number2)\n 		if (number == numtemp) or (number > numtemp):\n 			continue\n 		if ((numtemp <= maxi) and (numtemp > mini)):\n 			#print (number,numtemp)\n 			numlist.append((number,numtemp))\n 			count += 1\n 	return count\n # total = 0\n # for i in range(1111,2222):\n # 	total += (recycle(i,1111,2222))\n # 	print (len(set(numlist)))\n \n \n \n count = 0\n for line in data[1:]:\n 	count += 1\n 	total = 0\n 	numlist = []\n 	for a in range(line[0],(line[1])):\n 		total += recycle(a,line[0], line[1])\n 	print ("Case #"+str(count)+":", len(set(numlist)))
entropy	<>	12	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/python\n \n filename = "A-small-attempt0.in"\n \n inp = open(filename, "rU")\n \n n = int(inp.readline().strip())\n \n for case in range(1, n+1):\n     gr = lambda x: [list(map(int, inp.readline().strip().split(" "))) for p in range(4)][x-1]\n     ans1 = int(inp.readline().strip())\n     row1 = set(gr(ans1))\n     ans2 = int(inp.readline().strip())\n     row2 = set(gr(ans2))\n     sect = row1 & row2\n     if len(sect) <= 0:\n         print("Case #{}: Volunteer cheated!".format(case))\n     elif len(sect) == 1:\n         print("Case #{}: {}".format(case, sect.pop()))\n     elif len(sect) > 1:\n         print("Case #{}: Bad magician!".format(case))\n     else:\n         print("ERROR")\n
entropy	<>	12	<>	2012_1460488_1483485.py	<>	mapp = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm','q':'z','z':'q'}\n input = open("A-small-attempt0.in", "rU").readlines()\n counter = 0\n for a in input[1:]:\n 	counter += 1\n 	outline = a.replace("\n",'')\n 	outline2 = []\n 	for i in outline:\n 		outline2.append(mapp[i])\n 	print ("Case #"+str(counter)+":",''.join(outline2))\n \n
entropy	<>	12	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/python\n \n #!/usr/bin/python\n \n filename = "B-small-attempt0.in"\n # filename = "sample.in"\n \n inp = open(filename, "rU")\n \n n = int(inp.readline().strip())\n \n for case in range(1, n + 1):\n     cost, freq, goal = map(float, inp.readline().strip().split(" "))\n     fac = 0.0\n     time = 0.0\n     test = lambda x: (goal/(2+(freq * (x + 1)))) + (cost /(2+(freq * x)))\n     test2 = lambda x: (goal/(2+(freq * x)))\n     while(test2(fac) > test(fac)):\n         # print(time)\n         time += cost/(2 + (freq *  fac))\n         fac += 1\n     time += goal/(2+(freq*fac))\n     print("Case #{}: {}".format(case, time))\n
entropy	<>	12	<>	2013_2270488_2453486.py	<>	\n \n infile = open('A-small-attempt0.in', 'Ur').read()[1:].split('\n\n')\n \n case = 1\n for test in infile:\n     test = test.replace('\n','')\n     sets = []\n     if not test:\n         break\n \n     r = 0\n     for i in range(4):\n         sets.append(test[i::4])\n         sets.append(test[r:r+4])\n         r = r+4\n     sets.append(test[0] + test[5] + test[10] + test[15])\n     sets.append(test[3] + test[6] + test[9] + test[12])\n \n     sets = [set(x) for x in sets]\n     winner = ''\n     for i in sets:\n         if i.issubset({'X', 'T'}):\n             winner = 'X'\n             break\n         if i.issubset({'O', 'T'}):\n             winner = 'O'\n             break\n \n     if winner:\n         print("Case #{0}: {1} won".format(case, winner))\n     else:\n         if '.' in test:\n             print("Case #{0}: Game has not completed".format(case))\n         else:\n             print("Case #{0}: Draw".format(case))\n     case += 1\n \n
entropy	<>	12	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/python\n from copy import copy, deepcopy\n \n def check_bounds(state, coord):\n     if coord[0] < 0 or coord[1] < 0:\n         return False\n     elif coord[0] > (len(state) - 1):\n         return False\n     elif coord[1] > (len(state[coord[0]]) - 1):\n         return False\n     else:\n         return True\n \n def clear(state, coord):\n     for r in range(-1,2):\n         for c in range(-1,2):\n             row = coord[0] + r\n             col = coord[1] + c\n             if check_bounds(state, (row, col)):\n                 state[row][col] = 0\n \n def count(state):\n     return sum([sum(x) for x in state])\n \n def state_print(state):\n     print("c" + "".join(["*"  if x else "." for x in state[0][1:]]))\n     for line in state[1:]:\n         print("".join(["*"  if x else "." for x in line]))\n \n def solve(state, mines):\n     prev_state = deepcopy(state)\n     for row in range(len(state)):\n         for col in range(len(state[row])):\n             new_state = deepcopy(state)\n             clear(new_state, (row, col))\n             c = count(new_state)\n             # print(c)\n             # state_print(state)\n             if(c < mines):\n                 state = prev_state\n             elif( c == mines):\n                 state_print(new_state)\n                 return True\n             else:\n                 if col == len(state[row]) -2:\n                     prev_state = deepcopy(state)\n                 state = new_state\n     print("Impossible")\n     return False\n \n \n \n \n def main():\n     filename = "C-small-attempt0.in"\n     # filename = "C-large.in"\n     # filename = "sample.in"\n \n \n     inp = open(filename, "rU")\n \n     n = int(inp.readline().strip())\n \n     for case in range(1, n + 1):\n         R, C, M = map(int, inp.readline().strip().split(" "))\n         state = [[1 for x in range(C)] for y in range(R)]\n         print("Case #{}:".format(case))\n         solve(state, M)\n     # state = [[1 for x in range(7)] for y in range(4)]\n     # solve(state, 13)\n \n main()
gizzywump	<>	13	<>	2013_2270488_2463486.py	<>	#!/usr/bin/env python\n \n import collections\n \n import pickle\n import re\n import sys\n \n INPUT = "tiny"\n if 1:\n     INPUT = "C-small-attempt0.in"\n \n def debug(*args):\n     pass #print str(args)\n \n class Memoize:\n     def __init__(self,function):\n         self._cache = {}\n         self._callable = function\n             \n     def __call__(self, *args, **kwds):\n         cache = self._cache\n         key = self._getKey(*args,**kwds)\n         try: return cache[key]\n         except KeyError:\n             cachedValue = cache[key] = self._callable(*args,**kwds)\n             return cachedValue\n     \n     def _getKey(self,*args,**kwds):\n         return kwds and (args, ImmutableDict(kwds)) or args\n \n def is_palindrome(N):\n     s = str(N)\n     return s == ''.join(reversed(s))\n \n def fair_and_square_set(max_N):\n     p = "squareset_%d" % max_N\n     try:\n         s = pickle.load(file(p))\n         return s\n     except:\n         pass\n     s = set()\n     for i in range(1,max_N+1):\n         if is_palindrome(i) and is_palindrome(i*i):\n             s.add(i*i)\n     pickle.dump(s, file(p, "wb"))\n     return s\n \n MAX_N = int(1e7)\n SQUARE_SET = fair_and_square_set(MAX_N)\n #print(SQUARE_SET)\n \n def do_trial(A, B):\n     count = 0\n     for ss in SQUARE_SET:\n         if A <= ss <= B:\n             count += 1\n     return count\n \n f = file(INPUT)\n T = int(f.readline()[:-1])\n for i in range(T):\n     A, B = [int(x) for x in f.readline().split()]\n     v = do_trial(A, B)\n     print "Case #%d: %s" % (i+1, v)\n
gizzywump	<>	13	<>	2013_2270488_2449486.py	<>	#!/usr/bin/env python\n \n import collections\n \n import re\n import sys\n \n INPUT = "tiny"\n if 1:\n     INPUT = "B-small-attempt0.in"\n \n def debug(*args):\n     pass #print str(args)\n \n class Memoize:\n     def __init__(self,function):\n         self._cache = {}\n         self._callable = function\n             \n     def __call__(self, *args, **kwds):\n         cache = self._cache\n         key = self._getKey(*args,**kwds)\n         try: return cache[key]\n         except KeyError:\n             cachedValue = cache[key] = self._callable(*args,**kwds)\n             return cachedValue\n     \n     def _getKey(self,*args,**kwds):\n         return kwds and (args, ImmutableDict(kwds)) or args\n \n def do_trial(lawn):\n     w = len(lawn[0])\n     h = len(lawn)\n     x_maxes = [max(lawn_row) for lawn_row in lawn]\n     y_maxes = [max(lawn[y][x] for y in range(h)) for x in range(w)]\n     def lawn_row(y):\n         x_max = x_maxes[y]\n         return tuple([min(y_maxes[x], x_max) for x in range(w)])\n     new_lawn = tuple([lawn_row(y) for y in range(h)])\n     #import pdb; pdb.set_trace()\n     if new_lawn == lawn:\n         return "YES"\n     return "NO"\n \n f = file(INPUT)\n T = int(f.readline()[:-1])\n for i in range(T):\n     w, h = [int(x) for x in f.readline().split()]\n     lawn = []\n     for k in range(w):\n         lawn.append(tuple([int(x) for x in f.readline().split()]))\n     lawn = tuple(lawn)\n     #if i==2:\n     #    import pdb; pdb.set_trace()\n     v = do_trial(lawn)\n     print "Case #%d: %s" % (i+1, v)\n
gizzywump	<>	13	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python\n \n import pdb\n import re\n import sys\n \n INPUT = "tiny"\n \n INPUT = "C-small-attempt0.in.txt"\n \n def debug(*args):\n     pass #print str(args)\n \n if 0:\n     def debug(*args):\n         sys.stderr(''.join(str(s) for s in args) + "\n")\n \n def recycleables(N, A, B):\n     t = set()\n     s = str(N)\n     for i in range(len(s)):\n         s1 = int(s[i:] + s[:i])\n         if A <= s1 <= B:\n             t.add(s1)\n     return t\n \n def do_trial(A, B):\n     total = 0\n     seen = set()\n     for i in xrange(A, B+1):\n         if i not in seen:\n             t = recycleables(i, A, B)\n             z = len(t)\n             total += z * (z-1) / 2\n             seen.update(t)\n     return total\n \n f = file(INPUT)\n T = int(f.readline()[:-1])\n for i in range(T):\n     A, B = [int(x) for x in f.readline()[:-1].split()]\n     v = do_trial(A, B)\n     print "Case #%d: %s" % (i+1, v)\n
gizzywump	<>	13	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/env python\n \n import collections\n \n import math\n import re\n import sys\n \n INPUT = "tiny"\n if 1:\n     INPUT = "A-large.in"\n     INPUT = "A-small-attempt0.in"\n \n def debug(*args):\n     return\n     sys.stderr.write(str(args) + "\n")\n \n class Memoize:\n     def __init__(self,function):\n         self._cache = {}\n         self._callable = function\n             \n     def __call__(self, *args, **kwds):\n         cache = self._cache\n         key = self._getKey(*args,**kwds)\n         try: return cache[key]\n         except KeyError:\n             cachedValue = cache[key] = self._callable(*args,**kwds)\n             return cachedValue\n     \n     def _getKey(self,*args,**kwds):\n         return kwds and (args, ImmutableDict(kwds)) or args    \n \n def do_trial(a1, r1, a2, r2):\n     p1 = set(r1[a1-1])\n     p2 = set(r2[a2-1])\n     u = p1.intersection(p2)\n     if len(u) < 1:\n         return "Volunteer cheated!"\n     if len(u) > 1:\n         return "Bad magician!"\n     return list(u)[0]\n \n f = file(INPUT)\n T = int(f.readline()[:-1])\n for i in range(T):\n     rows1 = []\n     a1 = int(f.readline()[:-1])\n     for r in range(4):\n         rows1.append([int(x) for x in f.readline().split()])\n     a2 = int(f.readline()[:-1])\n     rows2 = []\n     for r in range(4):\n         rows2.append([int(x) for x in f.readline().split()])\n     v = do_trial(a1, rows1, a2, rows2)\n     print "Case #%d: %s" % (i+1, v)\n
gizzywump	<>	13	<>	2012_1460488_1483485.py	<>	#!/usr/bin/env python\n \n import pdb\n import re\n import sys\n \n INPUT = "tiny"\n if 1:\n     INPUT = "A-small-attempt2.in.txt"\n \n I=re.sub(" ", "", "ejp mysljylc kd kxveddknmc re jsicpdrysirbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jv")\n O=re.sub(" ", "", "our language is impossible to understandthere are twenty six factorial possibilitiesso it is okay if you want to just give up")\n \n #print I, O\n \n MAP={ 'z' : 'q', 'q' : 'z' }\n for i,o in zip(I,O):\n     MAP[i] = o\n \n def debug(*args):\n     pass #print str(args)\n \n def debug(*args):\n     print str(args)\n \n def do_trial(l):\n     t = list(l)\n     t1 = [MAP.get(x, x) for x in t]\n     return ''.join(t1)\n \n f = file(INPUT)\n T = int(f.readline()[:-1])\n for i in range(T):\n     l = f.readline()[:-1]\n     v = do_trial(l)\n     print "Case #%d: %s" % (i+1, v)\n
gizzywump	<>	13	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/env python\n \n import collections\n \n import math\n import re\n import sys\n \n sys.setrecursionlimit(5000)\n \n INPUT = "tiny"\n INPUT = "B-large.in"\n INPUT = "B-small-attempt0.in"\n \n def debug(*args):\n     return\n     sys.stderr.write(str(args) + "\n")\n \n class Memoize:\n     def __init__(self,function):\n         self._cache = {}\n         self._callable = function\n             \n     def __call__(self, *args, **kwds):\n         cache = self._cache\n         key = self._getKey(*args,**kwds)\n         try: return cache[key]\n         except KeyError:\n             cachedValue = cache[key] = self._callable(*args,**kwds)\n             return cachedValue\n     \n     def _getKey(self,*args,**kwds):\n         return kwds and (args, ImmutableDict(kwds)) or args    \n \n def do_trial(C, F, X, rate=2.0):\n     #import pdb; pdb.set_trace()\n     win_time_wait = X / rate\n     buy_time = C / rate\n     win_time_buy_1 = buy_time + X / (rate+F)\n     if win_time_wait < win_time_buy_1:\n         return win_time_wait\n     return buy_time + do_trial(C, F, X, rate+F)\n \n f = file(INPUT)\n T = int(f.readline()[:-1])\n for i in range(T):\n     C, F, X = [float(x) for x in f.readline().split()]\n     v = do_trial(C, F, X)\n     print "Case #%d: %s" % (i+1, v)\n
gizzywump	<>	13	<>	2013_2270488_2453486.py	<>	#!/usr/bin/env python\n \n import collections\n \n import re\n import sys\n \n INPUT = "tiny"\n if 1:\n     INPUT = "A-small-attempt0.in"\n \n def debug(*args):\n     pass #print str(args)\n \n class Memoize:\n     def __init__(self,function):\n         self._cache = {}\n         self._callable = function\n             \n     def __call__(self, *args, **kwds):\n         cache = self._cache\n         key = self._getKey(*args,**kwds)\n         try: return cache[key]\n         except KeyError:\n             cachedValue = cache[key] = self._callable(*args,**kwds)\n             return cachedValue\n     \n     def _getKey(self,*args,**kwds):\n         return kwds and (args, ImmutableDict(kwds)) or args    \n \n def check(board, x, y, dx, dy):\n     #import pdb; pdb.set_trace()\n     c = collections.Counter((board[x+dx*i][y+dy*i] for i in range(4)))\n     if c.get("X", 0) + c.get("T", 0) == 4: return "X won"\n     if c.get("O", 0) + c.get("T", 0) == 4: return "O won"\n \n def do_trial(board):\n     #return "X won" #(the game is over, and X won)\n     #"O won" (the game is over, and O won)\n     #"Draw" (the game is over, and it ended in a draw)\n     #"Game has not completed" (the game is not over yet)\n     for x in range(4):\n         v = check(board, x, 0, 0, 1)\n         if v: return v\n         v = check(board, 0, x, 1, 0)\n         if v: return v\n     v = check(board, 0, 0, 1, 1)\n     if v: return v\n     v = check(board, 3, 0, -1, 1)\n     if v: return v\n     if '.' in ''.join(board):\n         return "Game has not completed"\n     return "Draw"\n \n f = file(INPUT)\n T = int(f.readline()[:-1])\n for i in range(T):\n     lines = [f.readline()[:-1] for j in range(4)]\n     f.readline()\n     v = do_trial(lines)\n     print "Case #%d: %s" % (i+1, v)\n
gizzywump	<>	13	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/env python\n \n import collections\n \n import math\n import re\n import sys\n \n #sys.setrecursionlimit(50)\n \n INPUT = "tiny"\n #INPUT = "C-large.in"\n INPUT = "C-small-attempt1.in"\n \n def debug(*args):\n     #return\n     sys.stderr.write(str(args) + "\n")\n \n class Memoize:\n     def __init__(self,function):\n         self._cache = {}\n         self._callable = function\n             \n     def __call__(self, *args, **kwds):\n         cache = self._cache\n         key = self._getKey(*args,**kwds)\n         try: return cache[key]\n         except KeyError:\n             cachedValue = cache[key] = self._callable(*args,**kwds)\n             return cachedValue\n     \n     def _getKey(self,*args,**kwds):\n         return kwds and (args, ImmutableDict(kwds)) or args    \n \n IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])\n \n for i in range(2,51):\n     IMPOSSIBLE.add((2,i,1))\n     IMPOSSIBLE.add((i,2,1))\n \n SOLN = {\n     (1,2,1) : ["c*"],\n     (2,1,1) : ["c", "*"],\n     (2,2,3) : ["c*", "**"],\n }\n \n def solve(R, C, M):\n     if M == 0:\n         s = ["c%s" % ('.' * (C-1))]\n         for i in range(R-1):\n             s.append('.' * C)\n         return s\n     t = (R, C, M)\n     if t in IMPOSSIBLE:\n         debug("** %s %s %s" % t)\n         raise ValueError\n     if t in SOLN:\n         return SOLN[t]\n \n     # last row?\n     if C < M and R > 2:\n         try:\n             return solve(R-1, C, M-C) + ["*" * C]\n         except ValueError:\n             pass\n \n     if C <= R:\n         if M >= C and R > 2:\n             return solve(R-1, C, M-C) + ["*" * C]\n     else:\n         if M >= R and C > 2:\n             return ["%s*" % s for s in solve(R, C-1, M-R)]\n     if R > 2:\n         # fill in last row\n         mines = min(C, M)\n         if mines == C - 1:\n             mines -= 1\n         try:\n             return solve(R-1, C, M-mines) + [("." * (C - mines)) + ("*" * mines)]\n         except ValueError:\n             if C > 2:\n                 mines = min(R, M)\n             if mines == R - 1:\n                 mines -= 1\n             s = ["%s%s" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]\n             return s\n     debug(R, C, M)\n     return []\n \n def do_trial(R, C, M):\n     try:\n         r = solve(R,C,M)\n         s = "\n" + '\n'.join(r)\n         assert len(r) == R\n         for r1 in r:\n             assert len(r1) == C\n         assert len(''.join(k for k in s if k == '*')) == M\n         return s\n     except ValueError:\n         return "\nImpossible"\n \n \n def all():\n     for R in range(1,50):\n         for C in range(1,50):\n             for M in range(R*C):\n                 print(R, C, M)\n                 print(do_trial(R, C, M))\n     sys.exit(0)\n \n #all()\n \n f = file(INPUT)\n T = int(f.readline()[:-1])\n for i in range(T):\n     R, C, M = [int(x) for x in f.readline().split()]\n     #import pdb; pdb.set_trace()\n     v = do_trial(R, C, M)\n     print "Case #%d: %s" % (i+1, v)\n
fractal	<>	14	<>	2013_2270488_2463486.py	<>	#! /usr/bin/python\n \n T = input()\n \n for n in range(1, T+1):\n \n     A, B = raw_input().split()\n     A, B = int(A), int(B)\n \n     j = 0\n     for i in range(A, B+1):\n         s = str(i)\n         m = int(i**.5)\n         if s[-1] in ["1", "4", "5", "6", "9"] and \\n                 (s == "".join(reversed(s))) and \\n                 m**2 == i:\n             s = str(m)\n             if s == "".join(reversed(s)):\n                 j += 1\n \n \n     print "Case #%d: %d" % (n, j)\n
fractal	<>	14	<>	2013_2270488_2449486.py	<>	#! /usr/bin/python\n \n T=input()\n \n for i in range(1, T+1):\n     N, M = raw_input().split()\n     N, M = int(N), int(M)\n     matrix = []\n     for j in range(N):\n         row = raw_input().split()\n         assert len(row) == M\n         row = [int(x) for x in row]\n         matrix.append(row)\n     rmax = [max(x) for x in matrix]\n     matrix_t = [list(x) for x in zip(*matrix)]\n     cmax = [max(x) for x in matrix_t]\n     feasible = True\n     for r, k in zip(matrix, range(N)):\n         for c, l in zip(r, range(M)):\n             if c == rmax[k]:\n                 continue\n             elif c == cmax[l]:\n                 continue\n             else:\n                 break\n         else:\n             continue\n         break\n     else:\n         print "Case #%d: %s" % (i, "YES")\n         continue\n     print "Case #%d: %s" % (i, "NO")\n
fractal	<>	14	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python\n \n import fileinput\n \n def checkIndex(index,num,numB):\n 	n=int(str(num)[index:]+str(num)[:index])\n 	if n > num and n <= numB:\n 		#print "pair",num, n\n 		return n\n 	else: return False\n \n \n for line in fileinput.input():\n 	if fileinput.isfirstline():\n 		T=int(line) # no. of test cases\n 		continue\n 	numStrs=line.split()\n 	numSize=len(numStrs[0])\n 	numA=int(numStrs[0])\n 	numB=int(numStrs[1])\n 	count=0\n 	for num in xrange(numA, numB+1):\n 		pairs=set()\n 		for i in range(numSize):\n 			n=checkIndex(i,num, numB)\n 			if n:\n 				pairs.add(n)\n 		count +=len(pairs)\n 				\n 	print "Case #%(k)i: %(count)i" % {"k":fileinput.lineno()-1,"count":count}\n 	
fractal	<>	14	<>	2014_2974486_5756407898963968.py	<>	#! /usr/bin/python3\n ncases = int(input())\n \n for n in range(1, ncases+1):\n     row = int(input())\n     for m in range(1, 5):\n         if m == row:\n             r1list = [int(x) for x in input().split()]\n             assert len(r1list) == 4\n         else:\n             tmp = input()\n     row = int(input())\n     for m in range(1,5):\n         if m == row:\n             r2list = [int(x) for x in input().split()]\n             assert len(r1list) == 4\n         else:\n             tmp = input()\n     nset = set(r1list) & set(r2list)\n     if len(nset) == 1:\n         print("Case #%d:" % n, nset.pop())\n     elif len(nset) > 1:\n         print("Case #%d:" % n, "Bad magician!")\n     else:\n         print("Case #%d:" % n, "Volunteer cheated!")\n
fractal	<>	14	<>	2012_1460488_1483485.py	<>	import fileinput\n \n str1="""ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv"""\n \n strlist=str1.split()\n \n str2="""our language is impossible to understand\n there are twenty six factorial possibilities\n so it is okay if you want to just give up"""\n \n strlist2=str2.split()\n \n mapLang={"y":"a","e":"o","q":"z"}\n for x,y in zip(strlist,strlist2):\n     for xi,yj in zip(x,y):\n         if xi not in mapLang:\n             mapLang[xi]=yj\n             \n alphabet= ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n for letter in  alphabet:\n     if letter not in mapLang.keys():\n         for lv in alphabet:\n             if lv not in mapLang.values():\n                 mapLang[letter]=lv\n                 break\n     \n #print "dict size is:", len(mapLang)\n #print mapLang\n ncases=0\n sp=" "\n for txt in fileinput.input():\n     if fileinput.isfirstline():\n         ncases=int(txt)\n         continue\n     txtList=txt.split()\n     outList=[]\n     for word in txtList:\n         outword=""\n         for letter in word:\n             outword += mapLang[letter]\n         outList.append(outword)\n     outstr=sp.join(outList)\n     print "Case #%(k)i: %(str)s" % {"k":fileinput.lineno()-1,"str":outstr}\n
fractal	<>	14	<>	2014_2974486_5709773144064000.py	<>	#! /usr/bin/python3\n \n T = int(input())\n \n for x in range(1, T+1):\n     (C, F, X) = [float(y) for y in input().split()]\n     totalsecs = 0\n     cur_speed = 2\n     while True:\n         cur_time = X/cur_speed\n         new_speed = cur_speed + F\n         new_time = C/cur_speed + X/new_speed\n         if new_time < cur_time:\n             totalsecs += C/cur_speed\n             cur_speed = new_speed\n         else:\n             totalsecs += cur_time\n             break\n     \n     print("Case #%d: %.7f" % (x, totalsecs))\n
fractal	<>	14	<>	2013_2270488_2453486.py	<>	#! /usr/bin/python\n import re\n \n T=input()\n for i in range(1, T+1):\n     game = []\n     res = ""\n     unfinished = False\n     for j in range(4):\n         game.append(raw_input())\n     diag1=""\n     diag2=""\n     for (j, line) in zip(range(4), game):\n         if re.match("(X|T){4}|(O|T){4}", line):\n             res = line[0] if line[0] != 'T' else line[1]\n             break\n         else:\n             if "." in line:\n                 unfinished = True\n             diag1 += line[j]\n             diag2 += line[3-j]\n     if not res:\n         game = ["".join(x) for x in zip(*game)]\n         game.append(diag1)\n         game.append(diag2)\n         for line in game:\n             grp = re.match("(X|T){4}|(O|T){4}", line)\n             if grp:\n                 res = line[0] if line[0] != 'T' else line[1]\n                 break\n \n     if res:\n         print "Case #%d: %s won" % (i, res)\n     elif unfinished:\n         print "Case #%d: Game has not completed" % i\n     else:\n         print "Case #%d: Draw" % i\n     raw_input() #empty line after each test case\n
fractal	<>	14	<>	2014_2974486_5690574640250880.py	<>	#! /usr/bin/python3\n \n T = int(input())\n \n for n in range(1, T+1):\n     print("Case #%d:" % n)\n     (R, C, M) = (int(x) for x in input().split())\n     dots = R*C - M\n     if M == 0:\n         print("\n".join(["c"+(C-1)*"."] + (R-1)*[C*"."]))\n     elif dots == 0:\n         print("Impossible")\n     elif R == 1:\n         assert C - M > 0\n         print("c"+(C-M-1)*"."+M*"*")\n     elif C == 1:\n         assert R - M > 0\n         print("c\n"+(R-M-1)*".\n"+M*"*\n", end='')\n     elif dots == 1:\n         print("\n".join(["c"+ (C-1)*"*"] + (R-1)*[C*"*"]))\n     elif dots > 3:\n         if (dots == 5) or (dots == 7):\n             print("Impossible")\n             continue\n         if (R == 2) or (C == 2):\n             if dots%2 != 0 :\n                 print("Impossible")\n                 continue\n             elif R == 2:\n                 l = int(dots/2)\n                 print("c"+(l-1)*"."+(C-l)*"*")\n                 print(l*"."+(C-l)*"*")\n                 continue\n             elif C == 2:\n                 l = int(dots/2)\n                 print("c.")\n                 print((l-1)*"..\n", end='')\n                 print(int(M/2)*"**\n", end='')\n                 continue\n         (lines, extra) = divmod(dots, C)\n         temp = []\n         if (lines >= 2) and (extra != 1):\n             temp.append("c"+(C-1)*".")\n             temp.extend((lines-1)*[C*"."])\n             temp.append(extra*"."+(C-extra)*"*")\n             temp.extend((R-lines-1)*[C*"*"])\n             print("\n".join(temp))\n             continue\n         elif (lines > 2) and (extra == 1):\n             temp.append("c"+(C-1)*".")\n             temp.extend((lines-2)*[C*"."])\n             temp.append((C-1)*"."+"*")\n             temp.append(".."+ (C-2)*"*")\n             temp.extend((R-lines-1)*[C*"*"])\n             print("\n".join(temp))\n             continue\n         elif (lines == 2) and (extra == 1):\n             temp.append("c"+(C-2)*"."+"*")\n             temp.append((C-1)*"."+"*")\n             temp.append(3*"."+(C-3)*"*")\n             temp.extend((R-3)*[C*"*"])\n             print("\n".join(temp))\n             continue\n         elif lines < 2:\n             (l, rem) = divmod(dots, 2)\n             if rem == 1:\n                 l -= 1\n                 rem += 2\n             temp.append("c"+(l-1)*"."+(C-l)*"*")\n             temp.append(l*"."+(C-l)*"*")\n             temp.append(rem*"."+(C-rem)*"*")\n             temp.extend( (R-3)*[ C*"*" ])\n             print("\n".join(temp))\n             continue\n     else:\n         print("Impossible")\n \n
sickmath	<>	15	<>	2013_2270488_2463486.py	<>	import math\n \n def isPalindrome(n) :\n     return str(n) == str(n)[::-1]\n \n def findPalindrome(n) :\n     if n % 2 == 0 : return [start*(10**(n/2)) + int(str(start)[::-1]) for start in range(10**(n/2-1),10**(n/2))]\n     if n == 1 : return range(1,10)\n     return [start*(10**(n/2)) + int(str(start)[:-1][::-1]) for start in range(10**(n/2),10**((n+1)/2))]\n \n def findPalindromeInRange(a, b) :\n     num = range(len(str(a)), len(str(b)) + 1)\n     allPalindrome = []\n     for n in num : allPalindrome += findPalindrome(n)\n     return filter(lambda x : a <= x <= b, allPalindrome)\n \n f = open('C-small-attempt0.in', 'r')\n g = open('output', 'w')\n \n T = int(f.readline()[:-1])\n \n for case in range(T) :\n     A, B = map(int, f.readline()[:-1].split())\n     a = int(math.ceil(A**0.5))\n     b = int(B**0.5)\n     res = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(a, b)))\n     outString = 'Case #' + str(case+1) + ': ' + str(res) + '\n'\n     print outString[:-1]\n     g.write(outString)\n \n f.close()\n g.close()\n
sickmath	<>	15	<>	2013_2270488_2449486.py	<>	f = open('B-small-attempt0.in', 'r')\n g = open('output', 'w')\n \n T = int(f.readline()[:-1])\n \n for case in range(T) :\n     A = []\n     N, M = map(int, f.readline()[:-1].split())\n     for i in range(N) : A.append(map(int, f.readline()[:-1].split()))\n     for line in A : print line\n     maxPerRow = map(max, A)\n     maxPerColumn = map(max, zip(*A))\n     res = all(A[i][j] in (maxPerRow[i], maxPerColumn[j]) for i in range(N) for j in range(M))\n     outString = 'Case #' + str(case+1) + ': ' + ('YES' if res else 'NO') + '\n'\n     print outString[:-1]\n     g.write(outString)\n \n f.close()\n g.close()\n
sickmath	<>	15	<>	2012_1460488_1483488.py	<>	fin = open('C-small-attempt0.in', 'r')\n fout = open('C-output.txt', 'w')\n \n cases = int(fin.readline()[:-1])\n \n for case in range(cases) :\n     A, B = map(int, fin.readline()[:-1].split(' '))\n     digits = len(str(A))\n     couples = set()\n     for n in range(A,B+1) :\n         for t in range(1,digits) :\n             m = [str(n)[(i+t)%digits] for i in range(digits)]\n             m = int(''.join(m))\n             if A <= n < m <= B :\n                 couples.add(str([n,m]))\n     res = len(couples)\n     print 'Case #' + str(case+1) + ': ' + str(res)\n     fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n     \n fin.close()\n fout.close()\n
sickmath	<>	15	<>	2014_2974486_5756407898963968.py	<>	f = open('input.in')\n g = open('output', 'w')\n \n T = int(f.readline()[:-1])\n \n for case in xrange(T) :\n     a1 = int(f.readline()[:-1])\n     M1 = [map(int, f.readline()[:-1].split()) for i in range(4)]\n     a2 = int(f.readline()[:-1])\n     M2 = [map(int, f.readline()[:-1].split()) for i in range(4)]\n     r1 = M1[a1-1]\n     r2 = M2[a2-1]\n     res = set(r1).intersection(set(r2))\n     if len(res) == 1 : res = res.pop()\n     elif len(res) == 0 : res = 'Volunteer cheated!'\n     else : res = 'Bad magician!'\n     output = 'Case #' + str(case + 1) + ': ' + str(res)\n     g.write(output + '\n')\n     print output\n \n f.close()\n g.close()\n
sickmath	<>	15	<>	2012_1460488_1483485.py	<>	fin = open('A-small-attempt0.in', 'r')\n fout = open('A-output.txt', 'w')\n \n translation = {'y': 'a', 'e': 'o', 'q': 'z'}\n \n knownresults = {\n     'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',\n     'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',\n     'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up'\n     }\n \n for key in knownresults :\n     for letter in range(len(key)) :\n         translation[key[letter]] = knownresults[key][letter]\n \n missingkey = [i for i in translation.values() if i not in translation.keys()][0]\n missingvalue = [i for i in translation.keys() if i not in translation.values()][0]\n \n translation[missingkey] = missingvalue\n \n cases = int(fin.readline()[:-1])\n \n for case in range(cases) :\n     line = fin.readline()[:-1]\n     res = [translation[line[i]] for i in range(len(line))]\n     res = ''.join(res)\n     fout.write('Case #' + str(case+1) + ': ' + res + '\n')\n     \n fin.close()\n fout.close()\n
sickmath	<>	15	<>	2014_2974486_5709773144064000.py	<>	f = open('input.in')\n g = open('output', 'w')\n \n T = int(f.readline()[:-1])\n \n def tot(n) :\n     if n == 0 : return X / 2\n     else :\n         s = 0\n         for i in range(0, n) : s += C / (2 + i*F)\n         return s + X / (2 + n*F)\n \n for case in xrange(T) :\n     C, F, X = map(float, f.readline()[:-1].split())\n     N =  int(X/C) + 1\n     s, e = 0, N\n     if tot(0) >= tot(1) : \n         while True :\n             m = (s+e)/2\n             if tot(m) <= tot(m-1) and tot(m) <= tot(m+1) : break\n             elif tot(m-1) <= tot(m) <= tot(m+1) : e = m\n             elif tot(m-1) >= tot(m) >= tot(m+1) : s = m\n             else : 1/0\n     else : m = 0\n     output = 'Case #' + str(case + 1) + ': ' + str(tot(m))\n     g.write(output + '\n')\n     print output\n \n f.close()\n g.close()\n
sickmath	<>	15	<>	2013_2270488_2453486.py	<>	def detectResults() :\n     for sym in ('X', 'O') :\n         for line in board :\n             if all(elem in (sym, 'T') for elem in line) :\n                 return sym + ' won'\n         for column in range(4) :\n             if all(board[i][column] in (sym, 'T') for i in range(4)) :\n                 return sym + ' won'\n         if all(board[i][i] in (sym, 'T') for i in range(4)) or all(board[3-i][i] in (sym, 'T') for i in range(4)) :\n             return sym + ' won'\n     for sym in ('X', 'O') :\n         for line in board :\n             if all(elem in (sym, 'T', '.') for elem in line) :\n                 return 'Game has not completed'\n         for column in range(4) :\n             if all(board[i][column] in (sym, 'T', '.') for i in range(4)) :\n                 return 'Game has not completed'\n         if all(board[i][i] in (sym, 'T', '.') for i in range(4)) or all(board[3-i][i] in (sym, 'T', '.') for i in range(4)) :\n             return 'Game has not completed'\n     return 'Draw'\n \n f = open('A-small-attempt0.in', 'r')\n g = open('output', 'w')\n \n T = int(f.readline()[:-1])\n \n for case in range(T) :\n     board = []\n     for i in range(4) : board.append([i for i in f.readline()[:-1]])\n     outString = 'Case #' + str(case+1) + ': ' + detectResults() + '\n'\n     print outString[:-1]\n     g.write(outString)\n     useless = f.readline()[:-1]\n \n f.close()\n g.close()\n
sickmath	<>	15	<>	2014_2974486_5690574640250880.py	<>	f = open('input.in')\n g = open('output', 'w')\n \n T = int(f.readline()[:-1])\n \n for case in xrange(T) :\n     R, C, M = map(int, f.readline()[:-1].split())\n     FREE = R*C - M\n     if FREE == 0 : res = '\nImpossible'\n     elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\nImpossible'\n     elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\nImpossible'\n     else :\n         MAP = [['.' for c in range(C)] for r in range(R)]\n         MAP[0][0] = 'c'\n         if R == 1 :\n             for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\n         elif C == 1 :\n             for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\n         elif R == 2 :\n             for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\n             if FREE == 1 : MAP[1][0] = '*'\n         elif C == 2 :\n             for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\n             if FREE == 1 : MAP[0][1] = '*'\n         else :\n             com = M / C\n             for i in range(R-1, max(R-com-1, 2), -1) :\n                 MAP[i] = ['*' for j in range(C)]\n                 M -= C\n             I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\n             if I == 2 :\n                 com = M / 3\n                 if com == 0 : i = C\n                 for i in range(C-1, C-com-1, -1) :\n                     MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\n                     M -= 3\n                 if M >= 1 : MAP[2][i-1] = '*'\n                 if M >= 2 :\n                     if i != 1 : MAP[2][i-2] = '*'\n                     else : MAP[1][0] = '*'\n             else :\n                 for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\n                 if i == 1 :\n                     MAP[I][i] = '.'\n                     MAP[I-1][C-1] = '*'\n         res = '\n' + '\n'.join([''.join(i) for i in MAP])\n     output = 'Case #' + str(case + 1) + ': ' + str(res)\n     g.write(output + '\n')\n     print output\n \n f.close()\n g.close()\n
yordan	<>	16	<>	2013_2270488_2463486.py	<>	#!/usr/bin/env python3\n \n from itertools import count\n from math import sqrt\n \n \n def next_range(stream):\n     line = stream.readline()\n     if not line:\n         return None\n     return [int(x) for x in line.split()]\n \n \n def is_palindrome(n):\n     n = str(n)\n     return all(n[i] == n[len(n)-1-i] for i in range(len(n) // 2))\n \n def mysqrt(n):\n     """Return -1 if not an integer"""\n     rt = int(sqrt(n))\n     return rt if rt * rt == n else -1\n \n \n def is_fas(n):\n     rt = mysqrt(n)\n     return rt != -1 and is_palindrome(n) and is_palindrome(rt)\n \n \n def main():\n     with open('C-small-attempt0.in', encoding='utf-8') as f:\n         f.readline()\n \n         for case in count(1):\n             r = next_range(f)\n             if r is None:\n                 break\n \n             cnt = 0\n             for n in range(r[0], r[1] + 1):\n                 if is_fas(n):\n                     cnt += 1\n \n             print('Case #{}: {}'.format(case, cnt))\n \n \n main()\n
yordan	<>	16	<>	2013_2270488_2449486.py	<>	#!/usr/bin/env python\n \n from itertools import count\n import sys\n \n \n def next_lawn(stream):\n     init = stream.readline()\n     if not init:\n         return None\n \n     N, _ = map(int, init.split())\n     lawn = []\n     for i in range(N):\n         line = stream.readline()\n         lawn.append([int(x) for x in line.split()])\n     return lawn\n \n \n def test_hor(lawn, i, j):\n     me = lawn[i][j]\n     return all(lawn[i][col] <= me for col in range(len(lawn[i])))\n \n \n def test_ver(lawn, i, j):\n     me = lawn[i][j]\n     return all(lawn[row][j] <= me for row in range(len(lawn)))\n \n \n def test_square(lawn, i, j):\n     return test_hor(lawn, i, j) or test_ver(lawn, i, j)\n \n \n def is_possible(lawn):\n     return all(test_square(lawn, i, j) for i in range(len(lawn))\n                for j in range(len(lawn[i])))\n \n \n def main():\n     with open('B-small-attempt0.in', encoding='utf-8') as f:\n         f.readline()            # Skip the first line\n \n         for i in count(1):\n             lawn = next_lawn(f)\n             if lawn is None:\n                 break\n             ans = is_possible(lawn)\n             print('Case #{}: {}'.format(i, 'YES' if ans else 'NO'))\n         \n \n main()\n
yordan	<>	16	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python\n \n \n def rotate(i, ndigits):\n     s = str(i)\n     s = s[-ndigits:] + s[:-ndigits]\n     return int(s)\n \n def pairs(A, B):\n     for n in range(A, B + 1):\n         for i in range(1, len(str(n))):\n             m = rotate(n, i)\n             if n >= m or m > B: continue\n             yield n, m\n \n def main():\n     import sys\n     with open(sys.argv[1], 'r') as f:\n         f.readline()\n         n = 0\n         for line in f:\n             n += 1\n \n             A, B = [int(x) for x in line.split(' ')]\n             unique = set()\n             for pair in pairs(A, B):\n                 unique.add(pair)\n             print 'Case #%d: %d' % (n, len(unique))\n \n if __name__ == '__main__':\n     main()\n
yordan	<>	16	<>	2014_2974486_5756407898963968.py	<>	# -*- coding: utf-8 -*-\n \n import sys\n \n \n def read_grid(f):\n 	return [\n 		[int(x) for x in line.split()]\n 		for line in [f.readline() for _ in range(4)]\n 	]\n \n def read_case(f):\n 	answer1 = int(f.readline())\n 	grid1 = read_grid(f)\n 	answer2 = int(f.readline())\n 	grid2 = read_grid(f)\n 	return (grid1[answer1 - 1], grid2[answer2 - 1])\n \n \n def solve(r1, r2):\n 	res = set(r1) & set(r2)\n 	if len(res) == 0:\n 		return 'Volunteer cheated!'\n 	if len(res) == 1:\n 		return list(res)[0]\n 	return 'Bad magician!'\n \n \n \n def main():\n 	fn = sys.argv[1]\n 	with open(fn, encoding='utf-8') as f:\n 		ncases = int(f.readline())\n 		for case in range(1, ncases + 1):\n 			row1, row2 = read_case(f)\n 			solution = solve(row1, row2)\n 			print('Case #{}: {}'.format(case, solution))\n \n \n if __name__ == '__main__':\n 	main()
yordan	<>	16	<>	2012_1460488_1483485.py	<>	#!/usr/bin/env python\n \n \n _inp = (\n     'ejp mysljylc kd kxveddknmc re jsicpdrysi',\n     'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',\n     'de kr kd eoya kw aej tysr re ujdr lkgc jv',\n )\n \n _out = (\n     'our language is impossible to understand',\n     'there are twenty six factorial possibilities',\n     'so it is okay if you want to just give up',\n )\n \n def compute_lang_map(inp, out):\n     lang_map = {}\n     for gs, ss in zip(inp, out):\n         for gl, sl in zip(gs, ss):\n             lang_map[gl] = sl\n     lang_map['q'] = 'z'\n     lang_map['z'] = 'q'\n     return lang_map\n \n _lang_map = compute_lang_map(_inp, _out)\n def conv(s):\n     out = ''\n     for l in s:\n         out += _lang_map[l]\n     return out\n \n def main():\n     with open('input-file', 'r') as f:\n         f.readline()            # skip T\n         n = 0\n         for line in f:\n             n += 1\n             print 'Case #%d: %s' % (n, conv(line.strip()))\n \n if __name__ == '__main__':\n     main()\n
yordan	<>	16	<>	2014_2974486_5709773144064000.py	<>	import sys\n \n \n def read_case(f):\n 	return map(float, f.readline().split())\n \n \n def solve(C, F, X, rate=2.0):\n 	accum = 0\n 	while 1:\n 		goal1 = X / rate\n 	\n 		farm = C / rate\n 		goal2 = farm + (X / (rate + F))\n \n 		if goal1 <= goal2:\n 			return accum + goal1\n 		else:\n 			accum += farm\n 			rate += F\n \n 			\n def trunc(x, p=7):\n 	m = 10 ** p\n 	return round(x * m) / m\n \n \n def main():\n 	fn = sys.argv[1]\n 	with open(fn, encoding='utf-8') as f:\n 		ncases = int(f.readline())\n 		for case in range(1, ncases + 1):\n 			C, F, X = read_case(f)\n 			solution = solve(C, F, X)\n 			print('Case #{}: {}'.format(case, trunc(solution)))\n \n \n if __name__ == '__main__':\n 	main()\n
yordan	<>	16	<>	2013_2270488_2453486.py	<>	#!/usr/bin/env python\n \n import itertools\n import sys\n \n \n def next_board(stream=None):\n     """"""\n     if stream is None:\n         stream = sys.stdin\n     board = []\n     for line in filter(lambda line: len(line) and line[0] in '.OTX', stream):\n         board.append([c for c in line.rstrip()])\n         if len(board) == 4:\n             break\n     return board if len(board) else None\n \n \n def scan_not_completed(board):\n     if any(board[i][j] == '.'\n            for j in range(len(board))\n            for i in range(len(board))):\n         return '.'\n \n \n def check_set(s):\n     s.discard('T')\n     return s.pop() if len(s) == 1 and '.' not in s else None\n \n \n scan_diagonal1 = lambda board: check_set({board[i][i]\n         for i in range(len(board))})\n \n scan_diagonal2 = lambda board: check_set({board[i][len(board)-1-i]\n         for i in range(len(board))})\n \n scan_col = lambda board, col: check_set({board[i][col]\n     for i in range(len(board))})\n \n scan_row = lambda board, row: check_set(set(board[row]))\n \n \n def determine_state(board):\n     """"""\n     for i in range(4):\n         for s in (scan_col, scan_row):\n             ret = s(board, i)\n             if ret:\n                 return ret\n     for s in (scan_diagonal1, scan_diagonal2, scan_not_completed):\n         ret = s(board)\n         if ret:\n             return ret\n     return 'draw'\n \n \n def main():\n     """"""\n     with open('A-small-attempt0.in', encoding='utf-8') as f:\n         for i in itertools.count(1):\n             board = next_board(f)\n             if board is None:\n                 break\n             state = determine_state(board)\n             if state == 'X':\n                 line = 'X won'\n             elif state == 'O':\n                 line = 'O won'\n             elif state == 'draw':\n                 line = 'Draw'\n             elif state == '.':\n                 line = 'Game has not completed'\n             print('Case #{}: {}'.format(i, line))\n \n \n main()\n
yordan	<>	16	<>	2014_2974486_5690574640250880.py	<>	import copy\n import sys\n \n \n FREE = '.'\n BOMB = '*'\n CLICK = 'c'\n \n \n class Board:\n \n 	def __init__(self, R, C, M):\n 		self.initial_M = M\n 		self.R = R\n 		self.C = C\n 		self.M = M\n 		self.matrix = [[FREE for c in range(C)] for r in range(R)]\n 		# A rectangle that says what's the current subarea we work on\n 		self.endx = len(self.matrix[0])\n 		self.endy = len(self.matrix)  # 0 < R * C\n 		self.startx = 0\n 		self.starty = 0\n \n 	def fill_row(self, row):\n 		for c in self.range_active_cols:\n 			self.matrix[row][c] = BOMB\n 		self.starty += 1\n 		self.M -= self.active_cols\n \n 	def fill_col(self, col):\n 		for r in self.range_active_rows:\n 			self.matrix[r][col] = BOMB\n 		self.startx += 1\n 		self.M -= self.active_rows\n \n 	def pprint(self):\n 		# print('startx={}, endx={}, starty={}, endy={}, M={}'\n 		# 		.format(self.startx, self.endx, self.starty, self.endy, self.M))\n 		for row in self.matrix:\n 			for cell in row:\n 				print(cell, end='')\n 			print()\n \n 	@property\n 	def active_rows(self):\n 		return self.endy - self.starty\n \n 	@property\n 	def active_cols(self):\n 		return self.endx - self.startx\n \n 	def optimize(self):\n 		while 1:\n 			if (self.active_cols <= self.active_rows\n 					and self.active_cols <= self.M):\n 				self.fill_row(self.starty)\n 			elif (self.active_rows < self.active_cols\n 					and self.active_rows <= self.M):\n 				self.fill_col(self.startx)\n 			else:\n 				break\n \n 	@property\n 	def range_active_cols(self):\n 		return range(self.startx, self.endx)\n \n 	@property\n 	def range_active_rows(self):\n 		return range(self.starty, self.endy)\n \n 	def is_free(self, row, col):\n 		return self.matrix[row][col] == FREE\n \n 	def place_bomb(self):\n 		for row in self.range_active_rows:\n 			for col in self.range_active_cols:\n 				if (self.is_free(row, col) \n 						and row + 2 < self.R\n 						and col + 2 < self.C):\n 					self.matrix[row][col] = BOMB\n 					self.M -= 1 \n 					return True\n 		for col in self.range_active_cols:\n 			for row in self.range_active_rows:\n 				if (self.is_free(row, col)\n 						and row + 2 < self.R\n 						and col + 2 < self.C):\n 					self.matrix[row][col] = BOMB\n 					self.M -= 1\n 					return True\n 		return False\n \n 	def mark_click(self):\n 		self.matrix[-1][-1] = 'c'\n \n 	def win_condition(self):\n 		click_row = len(self.matrix) - 1\n 		click_col = len(self.matrix[0]) - 1\n 		# Check the cell left of the click\n 		if (click_col - 1 >= 0\n 				and not self.is_free(click_row, click_col - 1)):\n 			return False\n \n 		if (click_row - 1 >= 0\n 				and not self.is_free(click_row - 1, click_col)):\n 			return False\n \n 		if (click_row -1 >= 0\n 				and click_col -1 >= 0\n 				and not self.is_free(click_row - 1, click_col - 1)):\n 			return False\n 		\n 		return True\n \n 	def win_cond2(self):\n 		if self.initial_M + 1 == self.C * self.R:\n 			return True\n 		return False\n \n 	def solve(self):\n 		self.optimize()\n 		while self.M > 0 and self.place_bomb():\n 			pass\n 		if self.M == 0 and (self.win_condition() or self.win_cond2()):\n 			self.mark_click()\n 			self.pprint()\n 		else:\n 			print('Impossible')\n \n \n def read_case(f):\n 	return map(int, f.readline().split())\n \n \n def main():\n 	fn = sys.argv[1]\n 	with open(fn, encoding='utf-8') as f:\n 		ncases = int(f.readline())\n 		for case in range(1, ncases + 1):\n 			R, C, M = read_case(f)\n 			print('Case #{}:'.format(case))\n 			b = Board(R, C, M)\n 			b.solve()\n \n \n def main1():\n 	b = Board(2, 1, 1)\n 	import pdb; pdb.set_trace()\n 	b.solve()\n \n \n if __name__ == '__main__':\n 	main()\n
intn	<>	17	<>	2013_2270488_2463486.py	<>	'''\n Created on 13 Apr 2013\n \n @author: mengda\n '''\n import math\n \n ls = []\n \n def isP(num):\n     num = str(int(num))\n     for i in range(len(num) / 2):\n         if num[i] <> num[-1 - i]:\n             return False\n     return True\n \n def createP(root, half_digits):\n     root = str(root)\n     for i in range(half_digits):\n         ls[i] = root[i]\n         ls[-1 - i] = root[i]\n     return int(''.join(ls))\n \n def process(A, B):\n     rlt = 0\n     a = int(math.ceil(math.sqrt(A)))\n     b = int(math.floor(math.sqrt(B)))\n     str_a = str(a)\n     half_digits = int(math.ceil(len(str_a) / 2.0))\n     root = int(str_a[:half_digits])\n     next_root = 10 ** half_digits\n     digits = len(str_a)\n     for _ in range(digits - len(ls)):\n         ls.append('')\n     while True:\n         if root == next_root:\n             if digits % 2 == 0:\n                 next_root *= 10\n                 half_digits += 1\n             else:\n                 root /= 10\n             digits += 1\n             ls.append('')\n         p = createP(root, half_digits)\n         print p,\n         if p > b:\n             print 'too large'\n             break\n         if isP(math.pow(p, 2)):\n             print 'right one!'\n             rlt += 1\n         else:\n             print \n         root += 1\n     return rlt\n \n def process1(A, B):\n     rlt = 0\n     a = int(math.ceil(math.sqrt(A)))\n     b = int(math.floor(math.sqrt(B)))\n     for i in range(a, b + 1):\n         if not isP(i):\n             continue\n         power = math.pow(i, 2)\n         if isP(power):\n             rlt += 1\n     return rlt\n \n f = open('C-small-attempt1.in', 'r')\n T = int(f.readline())\n outLine = []\n \n for i in range(1, T + 1):\n     (A, B) = map(int, f.readline().split())\n     outLine.append('Case #%d: %s\n' % (i, process1(A, B)))\n     print outLine[-1],\n \n f.close()\n outFile = open('C-S.out', 'w')\n outFile.writelines(outLine)\n outFile.close()\n
intn	<>	17	<>	2013_2270488_2449486.py	<>	'''\n Created on 13 Apr 2013\n \n @author: mengda\n '''\n expected = []\n \n def process(N, M):\n     lawn = []\n     for n in range(N):\n         lawn.append([100] * M)\n     for n in range(N):\n         highest = 0\n         for m in range(M):\n             if expected[n][m] > highest:\n                 highest = expected[n][m]\n         for m in range(M):\n             if lawn[n][m] > highest:\n                 lawn[n][m] = highest\n     for m in range(M):\n         highest = 0\n         for n in range(N):\n             if expected[n][m] > highest:\n                 highest = expected[n][m]\n         for n in range(N):\n             if lawn[n][m] > highest:\n                 lawn[n][m] = highest\n     for n in range(N):\n         for m in range(M):\n             if lawn[n][m] <> expected[n][m]:\n                 return 'NO'\n     return 'YES'\n \n f = open('B-small-attempt0.in', 'r')\n T = int(f.readline())\n outLine = []\n \n for i in range(1, T + 1):\n     expected = []\n     (N, M) = map(int, f.readline().split())\n     for _ in range(N):\n         expected.append(map(int, f.readline().split()))\n     outLine.append('Case #%d: %s\n' % (i, process(N, M)))\n     print outLine[-1],\n \n f.close()\n outFile = open('b.s.out', 'w')\n outFile.writelines(outLine)\n outFile.close()\n
intn	<>	17	<>	2012_1460488_1483488.py	<>	'''\n Created on 2012-4-14\n \n @author: hemnd\n '''\n def cal(A, B):\n     rslt = 0\n     tmp = []\n     for i in range(1, len(A)):\n         min = max = 0\n         for j in range(int(A[0:i]), int(B[0:i]) + 1):\n             sJ = str(j)\n             sMin = (sJ * (len(A) - i))[0:len(A) - i]\n             min = int(sMin)\n             if int(sMin + sJ) <= int(sJ + sMin):\n                 min += 1\n             if int(B[-i:]) >= j:\n                 max = int(B[:(len(A) - i)])\n             else:\n                 max = int(B[:(len(A) - i)]) - 1\n             if max < min:\n                 continue\n             for k in range(min, max + 1):\n                 if (sJ + str(k), str(k) + sJ) in tmp:\n                     print (sJ + str(k), str(k) + sJ), 'already there'\n                     continue\n                 else:\n                     tmp.append((sJ + str(k), str(k) + sJ))\n                     rslt += 1\n \n #            rslt = rslt + max - min + 1\n     return rslt\n \n inputFile = open('C-small-attempt2.in', 'r')\n #inputFile = open('test.txt', 'r')\n inputLines = inputFile.readlines()\n inputFile.close()\n \n T = int(inputLines[0])\n outputLines = []\n \n for i in range(1, T + 1):\n     args = inputLines[i].strip().split(' ')\n     outputLines.append('Case #%d: %d\n' % (i, cal(args[0], args[1])))\n     print outputLines[i - 1],\n \n outputFile = open('C-small.out', 'w')\n outputFile.writelines(outputLines)\n outputFile.close()\n
intn	<>	17	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/env python\n import sys\n \n \n def process(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\n 	rlt = 'Volunteer cheated!'\n 	found = False\n 	for i in arrange_1[chosen_row_1]:\n 		if i in arrange_2[chosen_row_2]:\n 			if not found:\n 				rlt = i\n 				found = True\n 			else:\n 				rlt = 'Bad magician!'\n 				break\n 	return rlt\n \n input_file = open(sys.argv[1], 'r')\n T = int(input_file.readline())\n for i in range(T):\n 	chosen_row_1 = int(input_file.readline()) - 1\n 	arrange_1 = []\n 	arrange_1.append(map(int, input_file.readline().split()))\n 	arrange_1.append(map(int, input_file.readline().split()))\n 	arrange_1.append(map(int, input_file.readline().split()))\n 	arrange_1.append(map(int, input_file.readline().split()))\n 	chosen_row_2 = int(input_file.readline()) - 1\n 	arrange_2 = []\n 	arrange_2.append(map(int, input_file.readline().split()))\n 	arrange_2.append(map(int, input_file.readline().split()))\n 	arrange_2.append(map(int, input_file.readline().split()))\n 	arrange_2.append(map(int, input_file.readline().split()))\n 	print 'Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\n
intn	<>	17	<>	2012_1460488_1483485.py	<>	'''\n Created on 2012-4-14\n \n @author: hemnd\n '''\n dict = {}\n strs1 = ['our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up']\n strs0 = ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv']\n \n for i in range(3):\n     for j in range(len(strs1[i])):\n         c = strs0[i][j]\n         if c == ' ':\n             continue\n         e = strs1[i][j]\n         try:\n             dict[c]\n             print c, '=', dict[c], e\n         except:\n             dict[c] = e\n             print c, '=', e\n \n for k in dict.keys():\n     print k, dict[k]\n     \n dict['q'] = 'z'\n dict['z'] = 'q'\n dict[' '] = ' '\n \n def trans(s):\n     rslt = ''\n     for i in range(len(s) - 1):\n         rslt += dict[s[i]]\n     return rslt\n \n #inputFile = open('A-small-practice.in', 'r')\n inputFile = open('A-small-attempt0.in', 'r')\n inputLines = inputFile.readlines()\n inputFile.close()\n \n N = int(inputLines[0])\n outputLines = []\n \n for i in range(1, N + 1):\n     outputLines.append('Case #%d: %s\n' % (i, trans(inputLines[i])))\n     print outputLines[i - 1],\n \n outputFile = open('A-small-practice.out', 'w')\n outputFile.writelines(outputLines)\n outputFile.close()\n
intn	<>	17	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/env python\n import sys\n \n \n def process(C, F, X):\n 	speed = 2.0\n 	time = 0.0\n 	while True:\n 		if C / speed + X / (speed + F) > X / speed:\n 			time += X / speed\n 			break\n 		time += C / speed\n 		speed += F\n 	return round(time, 7)\n \n input_file = open(sys.argv[1], 'r')\n T = int(input_file.readline())\n for i in range(T):\n 	(C, F, X) = map(float, input_file.readline().split())\n 	print 'Case #%d:' % (i + 1), process(C, F, X)\n
intn	<>	17	<>	2013_2270488_2453486.py	<>	'''\n Created on 13 Apr 2013\n \n @author: mengda\n '''\n board = []\n \n def whoIsWinner(num):\n     if num == 4000 or num == 3010:\n         return 'X'\n     if num == 400 or num == 310:\n         return 'O'\n     return False\n \n def process(board):\n     full = True\n     newboard = []\n     for i in range(4):\n         line = []\n         for j in range(4):\n             c = board[i][j]\n             if   c == 'X':\n                 line.append(1000)\n             elif c == 'O':\n                 line.append(100)\n             elif c == 'T':\n                 line.append(10)\n             elif c == '.':\n                 line.append(1)\n                 full = False\n         newboard.append(line)\n     board = newboard\n     for i in range(4):\n         sumH = 0\n         sumV = 0\n         for j in range(4):\n             sumH += board[i][j]\n             sumV += board[j][i]\n         winner = whoIsWinner(sumH)\n         if winner:\n             return winner + ' won'\n         winner = whoIsWinner(sumV)\n         if winner:\n             return winner + ' won'\n     sumD0 = board[0][0] + board[1][1] + board[2][2] + board[3][3]\n     winner = whoIsWinner(sumD0)\n     if winner:\n         return winner + ' won'\n     sumD1 = board[3][0] + board[2][1] + board[1][2] + board[0][3]\n     winner = whoIsWinner(sumD1)\n     if winner:\n         return winner + ' won'\n     if full:\n         return 'Draw'\n     return 'Game has not completed'\n \n f = open('A-small-attempt0.in', 'r')\n N = int(f.readline())\n outLine = []\n \n for i in range(1, N + 1):\n     board = []\n     for j in range(4):\n         board.append(f.readline())\n     outLine.append('Case #%d: %s\n' % (i, process(board)))\n     f.readline()\n     print outLine[-1],\n \n f.close()\n outFile = open('1.out', 'w')\n outFile.writelines(outLine)\n outFile.close()\n
intn	<>	17	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/env python\n import sys\n \n def put_mines_last_step(R, C, M, grid):\n 	if M == 0:\n 		return\n 	R -= 1\n 	C -= 1\n 	grid[R][C] = '*'\n 	M -= 1\n 	r = R - 1\n 	c = C - 1\n 	while M > 0:\n 		if r > c:\n 			grid[r][C] = '*'\n 			r -= 1\n 		else:\n 			grid[R][c] = '*'\n 			c -= 1\n 		M -= 1\n \n def put_mines(R, C, M, grid):\n 	if R > C:\n 		if M < C:\n 			put_mines_last_step(R, C, M, grid)\n 			return\n 		for i in range(C):\n 			grid[R - 1][i] = '*'\n 		put_mines(R - 1, C, M - C, grid)\n 		return\n 	if M < R:\n 		put_mines_last_step(R, C, M, grid)\n 		return\n 	for i in range(R):\n 		grid[i][C - 1] = '*'\n 	put_mines(R, C - 1, M - R, grid)\n 	return\n \n def process(R, C, M):\n 	rlt = ''\n 	grid = []\n 	for i in range(R):\n 		grid.append(['.'] * C)\n 	put_mines(R, C, M, grid)\n 	if not C == 1:\n 		for i in range(R):\n 			if not grid[i][0] == '.':\n 				break\n 			if not grid[i][1] == '.':\n 				return '\nImpossible'\n 	if not R == 1:\n 		for i in range(C):\n 			if not grid[0][i] == '.':\n 				break\n 			if not grid[1][i] == '.':\n 				return '\nImpossible'\n 	grid[0][0] = 'c'\n 	for i in grid:\n 		rlt += '\n' + ''.join(i)\n 	return rlt\n \n input_file = open(sys.argv[1], 'r')\n T = int(input_file.readline())\n for i in range(T):\n 	(R, C, M) = map(int, input_file.readline().split())\n 	print 'Case #%d:' % (i + 1), process(R, C, M)\n
radkokotev	<>	18	<>	2013_2270488_2463486.py	<>	lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,\n     100020001,102030201,104060401,121242121,123454321,125686521,400080004,\n     404090404,10000200001,10221412201,12102420121,12345654321,40000800004,\n     1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,\n     1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,\n     1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,\n     102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,\n     123456787654321,400000080000004]\n \n \n def solve(lo,hi):\n     global lst\n     count = 0\n     for i in range(len(lst)):\n         if (lst[i] >= lo and lst[i] <= hi ):\n             count += 1\n     return count\n \n fname = raw_input("name of file: ")\n oname = raw_input("output file name:")\n f = open(fname,"r")\n out = open(oname,"w")\n n = int(f.readline()[:-1])\n case_num = 1\n for line in f:\n     args = line[:-1].split()\n     lo = int(args[0])\n     hi = int(args[1])\n     out.write("Case #%d: %d\n" %(case_num,solve(lo,hi)))\n     case_num += 1\n     \n out.close()\n f.close()\n     \n
radkokotev	<>	18	<>	2013_2270488_2449486.py	<>	fileName = raw_input("File name: ")\n f = open(fileName,"r")\n \n \n n = int(f.readline()[:-1])\n \n def check_row(board, index):\n     row = board[index]\n     M = row[0]\n     index = 0\n     for i in range(len(row)):\n         num = row[i]\n         if(num > M):\n             M = num\n             index = i\n     for i in range(len(row)):\n         num = row[i]\n         if(num < M):\n             if not check_col(board,i,num):\n                 return False\n     return True\n \n \n def check_col(board,index,number):\n     for i in range(len(board)):\n         if board[i][index] > number:\n             return False\n     return True\n \n def check_all(board):\n     for i in range(len(board)):\n         if not check_row(board, i):\n             return False\n     return True    \n  \n outputFileName = raw_input("output file name: ")\n of = open(outputFileName,"w")\n \n for i in range(n):\n     board = []\n     mn = f.readline()[:-1].split()\n     m = int(mn[0])\n     n = int(mn[1])\n     for j in range(m): \n         row = f.readline()[:-1].split()\n         #print row\n         row_lst = []\n         for s in row:\n             row_lst += [int(s)]\n         board += [row]\n     if check_all(board):\n         of.write( "Case #%d: %s\n" %(i+1, "YES"))\n     else:\n         of.write( "Case #%d: %s\n" %(i+1, "NO"))\n \n of.close()\n f.close()\n \n #print might_have_finished, boards\n \n ##for i in range(n): # print out\n ##    print "Case #%d: %s" %(i+1, translate(cases[i]))\n     \n     \n \n \n     \n
radkokotev	<>	18	<>	2012_1460488_1483488.py	<>	from string import *\n \n def compute(A,B):\n     start = A\n \n     count = 0\n \n     while start < B:\n         temp = str(start)+str(start)[:len(str(start))-1]\n         for i in range (len(str(start))):\n             if int(temp[i:len(str(start))+i]) > start and int(temp[i:len(str(start))+i]) <= B:\n                 count += 1\n         \n         start += 1\n \n     return count\n         \n fileName = raw_input("File name: ")\n f = open(fileName,"r")\n n = int(f.readline()[:-1])\n i=0\n for line in f:\n \n     items = (line[:-1]).split()\n     #items.split()\n \n     A = int(items[0])\n     B = int(items[1])\n     print "Case #%d: %d" %(i+1,compute(A,B))\n     i+=1\n     \n f.close()\n
radkokotev	<>	18	<>	2014_2974486_5756407898963968.py	<>	filename = raw_input("Name of file: ")\n f = open(filename, "r")\n o = open(filename + ".out", "w")\n \n \n T = int(f.readline()[:-1])\n ## Code starts here\n \n many_possible = "Bad magician!"\n zero_possible = "Volunteer cheated!"\n \n for t in range(1, T + 1):\n     first = int(f.readline()[:-1]) - 1\n     grid1 = []\n     for i in range(4):\n         grid1 += [f.readline()[:-1].split(" ")]\n         \n     second = int(f.readline()[:-1]) - 1\n     grid2 = []\n     for i in range(4):\n         grid2 += [f.readline()[:-1].split(" ")]\n \n     possible = []\n     for num in grid1[first]:\n         if num in grid2[second]:\n             possible += [num]\n \n     if len(possible) == 1:\n         o.write("Case #%d: %s\n" %(t, possible[0]))\n     elif len(possible) == 0:\n         o.write("Case #%d: %s\n" %(t, zero_possible))\n     else:\n         o.write("Case #%d: %s\n" %(t, many_possible))\n         \n     \n ## code ends here\n \n o.close()\n f.close()\n
radkokotev	<>	18	<>	2012_1460488_1483485.py	<>	from string import *\n dictionary = {\n     "a":"y",\n     "b":"h",\n     "c":"e",\n     "d":"s",\n     "e":"o",\n     "f":"c",\n     "g":"v",\n     "h":"x",\n     "i":"d",\n     "j":"u",\n     "k":"i",\n     "l":"g",\n     "m":"l",\n     "n":"b",\n     "o":"k",\n     "p":"r",\n     "q":"z",\n     "r":"t",\n     "s":"n",\n     "t":"w",\n     "u":"j",\n     "v":"p",\n     "w":"f",\n     "x":"m",\n     "y":"a",\n     "z":"q",\n     " ":" "    \n     }\n \n def translate(sen):\n     \n     new_sen = ""\n \n     for char in sen: #translate each charecter\n         new_sen += dictionary[char]\n         \n     return new_sen\n \n fileName = raw_input("File name: ")\n f = open(fileName,"r")\n \n n = int(f.readline()[:-1])\n cases = [] #keeps the input msgs\n \n for i in range(n):\n     cases += [f.readline()[:-1]]\n \n f.close()\n \n \n for i in range(n): # print out\n     print "Case #%d: %s" %(i+1, translate(cases[i]))\n     \n     \n \n \n     \n
radkokotev	<>	18	<>	2014_2974486_5709773144064000.py	<>	filename = raw_input("Name of file: ")\n infile = open(filename, "r")\n outfile = open(filename + ".out", "w")\n \n \n T = int(infile.readline()[:-1])\n ## Code starts here\n \n \n def getMinTime(c, f, x):\n     p0 = 2.0\n     s_prev = x / p0\n     s_curr = c / p0\n     prev_item = 0\n     next_item = x / (p0 + f)\n     n = 1\n     while s_prev + prev_item > s_curr + next_item:\n         s_prev = s_curr\n         prev_item = next_item\n         s_curr += c / (p0 + (n * f))\n         next_item = x / (p0 + ((n + 1) * f))\n         n += 1\n     return s_prev + prev_item\n \n for t in range(1, T + 1):\n     items = infile.readline()[:-1].split(" ")\n     c = float(items[0])\n     f = float(items[1])\n     x = float(items[2])\n     time = getMinTime(c, f, x)\n     outfile.write("Case #%d: %.7f\n" %(t, time))\n     \n         \n     \n ## code ends here\n \n outfile.close()\n infile.close()\n
radkokotev	<>	18	<>	2013_2270488_2453486.py	<>	fileName = raw_input("File name: ")\n f = open(fileName,"r")\n \n \n n = int(f.readline()[:-1])\n boards = []\n \n def check_tuple(row):\n     has_o = False\n     has_x = False\n     for char in row:\n         if(char == "."):\n             return (False, "Game has not completed")\n         if(char == "x" or char == "X"):\n             has_x = True\n         if(char == "o" or char == "O"):\n             has_o = True\n         \n     if has_o and has_x:\n         return (False, "Draw")\n     if has_o:\n         return (True, "O won")\n     return (True, "X won")\n \n def check_rows(board):\n     for row in board:\n         result = check_tuple(row)\n         if result[0]:\n             return result\n     return (False, "Unknown result")\n \n def check_columns(board):\n     for i in range(len(board)):\n         col = ""\n         col += board[0][i]\n         col += board[1][i]\n         col += board[2][i]\n         col += board[3][i]\n         result = check_tuple(col)\n         if result[0]:\n             return result\n     return (False, "Unknown result")\n \n def check_diagonals(board):\n     main_diag = ""\n     main_diag += board[0][0]\n     main_diag += board[1][1]\n     main_diag += board[2][2]\n     main_diag += board[3][3]\n     result = check_tuple(main_diag)\n     if result[0]:\n         return result\n     \n     sec_diag = ""\n     sec_diag += board[0][3]\n     sec_diag += board[1][2]\n     sec_diag += board[2][1]\n     sec_diag += board[3][0]\n \n     result = check_tuple(sec_diag)\n     if result[0]:\n         return result\n \n     return (False,"Unknown reason")\n \n     \n             \n     \n \n def check_board(board,might_have_finished):\n     result = check_rows(board)\n     if result[0]:\n         return result[1]\n     \n     result = check_columns(board)\n     if result[0]:\n         return result[1]\n     \n     result = check_diagonals(board)\n     if result[0]:\n         return result[1]\n \n     if(might_have_finished):\n         return "Game has not completed"\n     return "Draw"\n     \n     \n     \n     \n     \n \n \n for i in range(n):\n     board = []\n     might_have_finished = False\n     for j in range(4): \n         row = f.readline()[:-1]\n         #print row\n         #row_lst = [[row[0]],[row[1]],[row[2]],[row[3]]]\n         if "." in row:\n             might_have_finished = True\n         board += [row]\n     print "Case #%d: %s" %(i+1, check_board(board,might_have_finished))\n     f.readline()\n \n f.close()\n #print might_have_finished, boards\n \n ##for i in range(n): # print out\n ##    print "Case #%d: %s" %(i+1, translate(cases[i]))\n     \n     \n \n \n     \n
radkokotev	<>	18	<>	2014_2974486_5690574640250880.py	<>	filename = raw_input("Name of file: ")\n infile = open(filename, "r")\n outfile = open(filename + ".out", "w")\n \n \n T = int(infile.readline()[:-1])\n ## Code starts here\n \n def addMinesDiagonally(r, c, m):\n     field = []\n     for i in range (r):\n         row = []\n         for j in range(c):\n             row += ["."]\n         field += [row]\n         \n     for i in range (r + c):\n         ver = min (i, r - 1)\n         hor = max (0, 1 + i - r)\n         while ver >= 0 and hor <= c - 1 and m > 0:\n             if m == 1 and hor == c - 2 and ver == r - 2:\n                 ver -= 1\n                 hor += 1\n             field[ver][hor] = "*"\n             ver -= 1\n             hor += 1\n             m -= 1\n         \n     return field\n \n def isPossible(field):\n     if field[-1][-1] != ".":\n         return False\n     up = True\n     left = True\n     diag = True\n     if len(field) > 1 and field[-2][-1] != ".":\n             up = len(field[-1]) <= 1\n     if len(field[-1]) > 1 and field[-1][-2] != ".":\n             left = len(field) <= 1\n     if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != ".":\n         diag = False\n     return (up and left and diag) or \\n            ((not up) and (not left) and (not diag))\n     \n \n for t in range(1, T + 1):\n     items = infile.readline()[:-1].split(" ")\n     r = int(items[0])\n     c = int(items[1])\n     m = int(items[2])\n     field = addMinesDiagonally(r, c, m)\n     if isPossible(field):\n         field[-1][-1] = "c"\n         s = ""\n         for line in field:\n             for cell in line:\n                 s += cell\n             s += "\n"\n         outfile.write("Case #%d:\n%s\n" %(t, s[:-1]))\n     else:\n         s = "IMPOSSIBLE!!!!\n"\n         for line in field:\n             for cell in line:\n                 s += cell\n             s += "\n"\n         outfile.write("Case #%d:\n%s\n" %(t, s[:-1]))\n         #outfile.write("Case #%d:\n%s\n" %(t, "Impossible"))\n     \n         \n     \n ## code ends here\n \n outfile.close()\n infile.close()\n
caethan	<>	19	<>	2013_2270488_2463486.py	<>	#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n #for the Google Code Jam programming contest\n \n ###############################################################################\n # Imports go here\n ###############################################################################\n \n from __future__ import division\n import numpy as np\n import math\n \n ###############################################################################\n # Global variables (for caching, etc.) go here\n ###############################################################################\n \n #Set up the input/output files: problem-tagsuffix.in / *.out\n problem = "C"\n tag = "small" #commonly sample, small, or large\n #tag = "large"\n #tag = "sample"\n suffix = "-attempt0" #used sometimes for indexing later input files\n #suffix = ""\n #From http://oeis.org/A002779/b002779.txt\n #Lazy route for the first two sets!\n #Numbers that are both squares and palindromes\n table_of_fairs = np.array([0, 1, 4, 9, 121, 484, 676, 10201, 12321, 14641, \n 40804, 44944, 69696, 94249, 698896, 1002001, 1234321, 4008004, 5221225, 6948496, \n 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, \n 404090404, 522808225, 617323716, 942060249, 10000200001, 10221412201, 12102420121, \n 12345654321, 40000800004, 637832238736, 1000002000001, 1002003002001, 1004006004001, \n 1020304030201, 1022325232201, 1024348434201, 1086078706801, 1210024200121, \n 1212225222121, 1214428244121, 1230127210321, 1232346432321, 1234567654321, \n 1615108015161, 4000008000004, 4004009004004, 4051154511504, 5265533355625, \n 9420645460249, 100000020000001, 100220141022001, 102012040210201, 102234363432201, \n 121000242000121, 121242363242121, 123212464212321, 123456787654321, \n 123862676268321, 144678292876441, 165551171155561, 400000080000004, \n 900075181570009, 4099923883299904, 10000000200000001, 10002000300020001, \n 10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, \n 10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, \n 10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, \n 12120030703002121, 12122232623222121, 12124434743442121, 12321024642012321, \n 12323244744232321, 12341234943214321, 12343456865434321, 12345678987654321, \n 40000000800000004, 40004000900040004, 94206450305460249, 1000000002000000001, \n 1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, \n 1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, \n 1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, \n 1232344458544432321, 1234323468643234321, 4000000008000000004, 4253436912196343524, \n 6158453974793548516, 100000000020000000001, 100002000030000200001, 100004000060000400001, \n 100020201040102020001, 100022201252102220001, 100024201484102420001, \n 100200120040021002001, 100202122050221202001, 100204124080421402001, \n 100220341262143022001, 100222343474343222001, 102010002040200010201, \n 102012022050220210201, 102014042080240410201, 102030405060504030201, \n 102032425272524230201, 102132537636735231201, 102210100272001012201, 102212122262221212201, \n 102214144272441412201, 102230523292325032201, 102232545484545232201, 102234567696765432201, \n 104190107303701091401, 121000000242000000121, 121002200252002200121, 121004400282004400121, \n 121020021070120020121, 121022221262122220121, 121024421474124420121, 121220122262221022121, \n 121222324272423222121, 121240161292161042121, 121242363484363242121, 121244565696565442121, \n 123210002464200012321, 123212222474222212321, 123230205292502032321, 123232425484524232321, \n 123234645696546432321, 123432124686421234321, 123434346696643434321, 184398883818388893481, \n 400000000080000000004, 400004000090000400004, 522815090696090518225, 906086675171576680609, \n 942064503484305460249, 6916103777337773016196, 10000000000200000000001, 10000220001410002200001, \n 10002002100400120020001, 10002222123632122220001, 10020010200400201002001, 10020230421612403202001, \n 10022014302620341022001, 10022234545854543222001, 10201000020402000010201, 10201222221612222210201, \n 10203022140604122030201, 10203244363836344230201, 10221210222622201212201, 10221432643834623412201, \n 10223234344844343232201, 10224609234443290642201, 12100000002420000000121, 12100242003630024200121,\n 12102202302620320220121, 12102444325852344420121, 12122010222622201022121, 12122252443834425222121, \n 12124214524842541242121, 12321000024642000012321, 12321244225852244212321, 12323222344844322232321, \n 12343210246864201234321, 12384043938083934048321, 12599536942224963599521, 16593841302620314839561, \n 40000000000800000000004, 1000000000002000000000001, 1000002000003000002000001, \n 1000004000006000004000001, 1000020200104010020200001, 1000022200125210022200001, 1000024200148410024200001, 1000200030004000300020001, 1000202030205020302020001, 1000204030408040304020001, 1000220232126212320220001, 1000222232347432322220001, 1002001002004002001002001, 1002003004005004003002001, 1002005006008006005002001, 1002021222306032221202001, 1002023224327234223202001, 1002201232026202321022001, 1002203234227224323022001, 1002221454348434541222001, 1002223456569656543222001, 1020100000204020000010201, 1020102020205020202010201, 1020104040208020404010201, 1020120402306032040210201, 1020122422327232242210201, 1020300010207020100030201, 1020302030406040302030201, 1020304050607060504030201, 1020320414309034140230201, 1020322434528254342230201, 1020324454749474544230201, 1022121002226222001212201, 1022123024227224203212201, 1022141424528254241412201, 1022143446549456443412201, 1022321210249420121232201, 1022323232448442323232201, 1022325254649464525232201, 1210000000024200000000121, 1210002200025200022000121, 1210004400028200044000121, 1210020020107010200200121, 1210022220126210222200121, 1210024420147410244200121, 1210220032026202300220121, 1210222232227222322220121, 1210242254148414522420121, 1210244454369634544420121, 1212201002226222001022121, 1212203204227224023022121, 1212221040509050401222121, 1212223242528252423222121, 1212225444549454445222121, 1212421234248424321242121, 1212423436449446343242121, 1232100000246420000012321, 1232102220247420222012321, 1232120202329232020212321, 1232122422348432242212321, 1232124642369632464212321, 1232322032448442302232321, 1232324252649462524232321, 1234321002468642001234321, 1234323224469644223234321, 1821056104269624016501281, 4000000000008000000000004, 4000004000009000004000004, 4618627222542452227268164, 6942236477330337746322496, 9420645034800084305460249, 40460195511188111559106404, 100000000000020000000000001, 100000220000141000022000001, 100002002010040010200200001, 100002222012363210222200001, 100020001200040002100020001, 100020221222161222122020001, 100022003410262014300220001, 100022223434585434322220001, 100200100020040020001002001, 100200320240161042023002001, 100202104032060230401202001, 100202324254383452423202001, 100220121220262022121022001, 100220341462383264143022001, 100222125432484234521222001, 102010000002040200000010201, 102010222202161202222010201, 102012022032060230220210201, 102012244234383432442210201, 102030201204060402102030201, 102030423426181624324030201, 102032223434282434322230201, 102212100022262220001212201, 102212322442383244223212201, 102214124054282450421412201, 102232321224484422123232201, 121000000000242000000000121, 121000242000363000242000121, 121002202210262012202200121, 121002444212585212444200121, 121022001220262022100220121, 121022243242383242342220121, 121024203630484036302420121, 121220100022262220001022121, 121220342242383242243022121, 121222304234282432403222121, 121242121242484242121242121, 123210000002464200000012321, 123210244202585202442012321, 123212222232484232222212321, 123232201224484422102232321, 123432100024686420001234321, 400000000000080000000000004, 923860899791363197998068329, 4872133543202112023453312784, 9658137819052882509187318569, 10000000000000200000000000001, 10000002000000300000020000001, 10000004000000600000040000001, 10000020200010401000202000001, 10000022200012521000222000001, 10000024200014841000242000001, 10000200021000400012000200001, 10000202021020502012020200001, 10000204021040804012040200001, 10000220221212621212202200001, 10000222221234743212222200001, 10002000102000400020100020001, 10002002102200500220120020001, 10002004102400800420140020001, 10002020304030603040302020001, 10002022304232723240322020001, 10002200143002620034100220001, 10002202143222722234120220001, 10002220345234843254302220001, 10002222345456965454322220001, 10020010000200400200001002001, 10020012002200500220021002001, 10020014004200800240041002001, 10020030220410601402203002001, 10020032222412721422223002001, 10020210221220602212201202001, 10020212223240704232221202001, 10020230441632823614403202001, 10020232443654945634423202001, 10022010100002720000101022001, 10022012102202620220121022001, 10022014104402720440141022001, 10022030322230903222303022001, 10022032324432823442323022001, 10022034326634943662343022001, 10022210341004940014301222001, 10022212343224842234321222001, 10022214345444944454341222001, 10201000000020402000000010201, 10201002020020502002020010201, 10201004040020802004040010201, 10201020402030603020402010201, 10201022422032723022422010201, 10201200001200700210000210201, 10201202021220602212020210201, 10201204041240704214040210201, 10201220403410901430402210201, 10201222423432823432422210201, 10201224443454945434442210201, 10203020102040604020102030201, 10203022122240704222122030201, 10203040506070807060504030201, 10203042526272927262524030201, 10203220123022922032102230201, 10203222143242824234122230201, 10203224163462926436142230201, 10221210000222622200001212201, 10221212022222722222021212201, 10221230422432823422403212201, 10221232444434943444423212201, 10221412221442824412221412201, 10221414243462926434241412201, 10223232102244844220123232201, 10223234124444944442143232201, 12100000000002420000000000121, 12100002200002520000220000121, 12100004400002820000440000121, 12100020020010701002002000121, 12100022220012621002222000121, 12100024420014741002442000121, 12100220023002620032002200121, 12100222223022722032222200121, 12100242243214841234224200121, 12100244443236963234444200121, 12102200102202620220100220121, 12102202302402720420320220121, 12102220124030903042102220121, 12102222324232823242322220121, 12102224524434943442542220121, 12102420145204840254102420121, 12102422345424942454322420121, 12122010000222622200001022121, 12122012202222722220221022121, 12122032240432823404223022121, 12122034442434943424443022121, 12122230223242824232203222121, 12122232425262926252423222121, 12124212102424842420121242121, 12124214304624942640341242121, 12321000000024642000000012321, 12321002220024742002220012321, 12321020202032923020202012321, 12321022422034843022422012321, 12321024642036963024642012321, 12321222023224842232022212321, 12321224243244944234242212321, 12323220102244844220102232321, 12323222322444944422322232321, 12343210000246864200001234321, 12343212222246964222221234321, 16799008923862526832980099761, 40000000000000800000000000004, 40000004000000900000040000004, 44431002775280908257720013444, 98693567900935453900976539689, 1000000000000002000000000000001, 1000000220000014100000220000001, 1000002002001004001002002000001, 1000002222001236321002222000001, 1000020000300004000030000200001, 1000020220302216122030220200001, 1000022002321026201232002200001, 1000022222323458543232222200001, 1000200010020004000200100020001, 1000200230042016102400320020001, 1000202012221206021222102020001, 1000202232243438343422322020001, 1000220012320026200232100220001, 1000220232344238324432320220001, 1000222014541248421454102220001, 1002001000002004002000001002001, 1002001220222016102220221002001, 1002003004005006005004003002001, 1002003224225238325224223002001, 1002021020302206022030201202001, 1002021240524418144250421202001, 1002023024325228225234203202001, 1002201210022026202200121022001, 1002201430264038304620341022001, 1002203214225228225224123022001, 1002221232322248422232321222001, 1020100000000204020000000010201, 1020100222200216120022220010201, 1020102022021206021202202010201, 1020102244221438341224422010201, 1020120200302206022030020210201, 1020120422504418144052240210201, 1020122222343228223432222210201, 1020302010020406040200102030201, 1020302232242418142422322030201, 1020304032241608061422304030201, 1020322212322428242232122230201, 1022121000002226222000001212201, 1022121222422238322242221212201, 1022123024025228225204203212201, 1022141220304428244030221412201, 1022323210022448442200123232201, 1210000000000024200000000000121, 1210000242000036300002420000121, 1210002202201026201022022000121, 1210002444201258521024442000121, 1210022000320026200230002200121, 1210022242322238322232422200121, 1210024202541048401452024200121, 1210220010022026202200100220121, 1210220252044038304402520220121, 1210222212423228223242122220121, 1210242012342048402432102420121, 1212201000002226222000001022121, 1212201242222238322222421022121, 1212203204205228225024023022121, 1212223020322428242230203222121, 1212421210024248424200121242121, 1232100000000246420000000012321, 1232100244200258520024420012321, 1232102222221248421222222012321, 1232122200322248422230022212321, 1232322010022448442200102232321, 1234321000002468642000001234321, 4000000000000008000000000000004, 4844486878939076709398786844484, 6574372239019762679109322734756, 9403095533541415141453355903049, 9659504223792743472973224059569, 9848294822582726272852284928489\n ])\n \n #and here we've filtered the table\n filtered_table = np.array([0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001,\n        1234321, 4008004, 100020001, 102030201, 104060401, 121242121,\n        123454321, 125686521, 400080004, 404090404, 10000200001,\n        10221412201, 12102420121, 12345654321, 40000800004, 1000002000001,\n        1002003002001, 1004006004001, 1020304030201, 1022325232201,\n        1024348434201, 1210024200121, 1212225222121, 1214428244121,\n        1232346432321, 1234567654321, 4000008000004, 4004009004004,\n        100000020000001, 100220141022001, 102012040210201, 102234363432201,\n        121000242000121, 121242363242121, 123212464212321, 123456787654321,\n        400000080000004, 10000000200000001, 10002000300020001,\n        10004000600040001, 10020210401202001, 10022212521222001,\n        10024214841242001, 10201020402010201, 10203040504030201,\n        10205060806050201, 10221432623412201, 10223454745432201,\n        12100002420000121, 12102202520220121, 12104402820440121,\n        12122232623222121, 12124434743442121, 12321024642012321,\n        12323244744232321, 12343456865434321, 12345678987654321,\n        40000000800000004, 40004000900040004, 1000000002000000001,\n        1000220014100220001, 1002003004003002001, 1002223236323222001,\n        1020100204020010201, 1020322416142230201, 1022123226223212201,\n        1022345658565432201, 1210000024200000121, 1210242036302420121,\n        1212203226223022121, 1212445458545442121, 1232100246420012321,\n        1232344458544432321, 1234323468643234321, 4000000008000000004,\n        100000000020000000001, 100002000030000200001, 100004000060000400001,\n        100020201040102020001, 100022201252102220001, 100024201484102420001,\n        100200120040021002001, 100202122050221202001, 100204124080421402001,\n        100220341262143022001, 100222343474343222001, 102010002040200010201,\n        102012022050220210201, 102014042080240410201, 102030405060504030201,\n        102032425272524230201, 102212122262221212201, 102214144272441412201,\n        102232545484545232201, 102234567696765432201, 121000000242000000121,\n        121002200252002200121, 121004400282004400121, 121022221262122220121,\n        121024421474124420121, 121220122262221022121, 121222324272423222121,\n        121242363484363242121, 121244565696565442121, 123210002464200012321,\n        123212222474222212321, 123232425484524232321, 123234645696546432321,\n        123432124686421234321, 123434346696643434321, 400000000080000000004,\n        400004000090000400004, 10000000000200000000001,\n        10000220001410002200001, 10002002100400120020001,\n        10002222123632122220001, 10020010200400201002001,\n        10020230421612403202001, 10022014302620341022001,\n        10022234545854543222001, 10201000020402000010201,\n        10201222221612222210201, 10203022140604122030201,\n        10203244363836344230201, 10221210222622201212201,\n        10221432643834623412201, 10223234344844343232201,\n        12100000002420000000121, 12100242003630024200121,\n        12102202302620320220121, 12102444325852344420121,\n        12122010222622201022121, 12122252443834425222121,\n        12124214524842541242121, 12321000024642000012321,\n        12321244225852244212321, 12323222344844322232321,\n        12343210246864201234321, 40000000000800000000004,\n        1000000000002000000000001, 1000002000003000002000001,\n        1000004000006000004000001, 1000020200104010020200001,\n        1000022200125210022200001, 1000024200148410024200001,\n        1000200030004000300020001, 1000202030205020302020001,\n        1000204030408040304020001, 1000220232126212320220001,\n        1000222232347432322220001, 1002001002004002001002001,\n        1002003004005004003002001, 1002005006008006005002001,\n        1002021222306032221202001, 1002023224327234223202001,\n        1002201232026202321022001, 1002203234227224323022001,\n        1002221454348434541222001, 1002223456569656543222001,\n        1020100000204020000010201, 1020102020205020202010201,\n        1020104040208020404010201, 1020120402306032040210201,\n        1020122422327232242210201, 1020302030406040302030201,\n        1020304050607060504030201, 1020322434528254342230201,\n        1020324454749474544230201, 1022121002226222001212201,\n        1022123024227224203212201, 1022141424528254241412201,\n        1022143446549456443412201, 1022323232448442323232201,\n        1022325254649464525232201, 1210000000024200000000121,\n        1210002200025200022000121, 1210004400028200044000121,\n        1210022220126210222200121, 1210024420147410244200121,\n        1210220032026202300220121, 1210222232227222322220121,\n        1210242254148414522420121, 1210244454369634544420121,\n        1212201002226222001022121, 1212203204227224023022121,\n        1212223242528252423222121, 1212225444549454445222121,\n        1212421234248424321242121, 1212423436449446343242121,\n        1232100000246420000012321, 1232102220247420222012321,\n        1232122422348432242212321, 1232124642369632464212321,\n        1232322032448442302232321, 1232324252649462524232321,\n        1234321002468642001234321, 1234323224469644223234321,\n        4000000000008000000000004, 4000004000009000004000004,\n        100000000000020000000000001, 100000220000141000022000001,\n        100002002010040010200200001, 100002222012363210222200001,\n        100020001200040002100020001, 100020221222161222122020001,\n        100022003410262014300220001, 100022223434585434322220001,\n        100200100020040020001002001, 100200320240161042023002001,\n        100202104032060230401202001, 100202324254383452423202001,\n        100220121220262022121022001, 100220341462383264143022001,\n        100222125432484234521222001, 102010000002040200000010201,\n        102010222202161202222010201, 102012022032060230220210201,\n        102012244234383432442210201, 102030201204060402102030201,\n        102030423426181624324030201, 102032223434282434322230201,\n        102212100022262220001212201, 102212322442383244223212201,\n        102214124054282450421412201, 102232321224484422123232201,\n        121000000000242000000000121, 121000242000363000242000121,\n        121002202210262012202200121, 121002444212585212444200121,\n        121022001220262022100220121, 121022243242383242342220121,\n        121024203630484036302420121, 121220100022262220001022121,\n        121220342242383242243022121, 121222304234282432403222121,\n        121242121242484242121242121, 123210000002464200000012321,\n        123210244202585202442012321, 123212222232484232222212321,\n        123232201224484422102232321, 123432100024686420001234321,\n        400000000000080000000000004, 10000000000000200000000000001,\n        10000002000000300000020000001, 10000004000000600000040000001,\n        10000020200010401000202000001, 10000022200012521000222000001,\n        10000024200014841000242000001, 10000200021000400012000200001,\n        10000202021020502012020200001, 10000204021040804012040200001,\n        10000220221212621212202200001, 10000222221234743212222200001,\n        10002000102000400020100020001, 10002002102200500220120020001,\n        10002004102400800420140020001, 10002020304030603040302020001,\n        10002022304232723240322020001, 10002200143002620034100220001,\n        10002202143222722234120220001, 10002220345234843254302220001,\n        10002222345456965454322220001, 10020010000200400200001002001,\n        10020012002200500220021002001, 10020014004200800240041002001,\n        10020030220410601402203002001, 10020032222412721422223002001,\n        10020210221220602212201202001, 10020212223240704232221202001,\n        10020230441632823614403202001, 10020232443654945634423202001,\n        10022012102202620220121022001, 10022014104402720440141022001,\n        10022032324432823442323022001, 10022034326634943662343022001,\n        10022212343224842234321222001, 10022214345444944454341222001,\n        10201000000020402000000010201, 10201002020020502002020010201,\n        10201004040020802004040010201, 10201020402030603020402010201,\n        10201022422032723022422010201, 10201202021220602212020210201,\n        10201204041240704214040210201, 10201222423432823432422210201,\n        10201224443454945434442210201, 10203020102040604020102030201,\n        10203022122240704222122030201, 10203040506070807060504030201,\n        10203042526272927262524030201, 10203222143242824234122230201,\n        10203224163462926436142230201, 10221210000222622200001212201,\n        10221212022222722222021212201, 10221230422432823422403212201,\n        10221232444434943444423212201, 10221412221442824412221412201,\n        10221414243462926434241412201, 10223232102244844220123232201,\n        10223234124444944442143232201, 12100000000002420000000000121,\n        12100002200002520000220000121, 12100004400002820000440000121,\n        12100022220012621002222000121, 12100024420014741002442000121,\n        12100220023002620032002200121, 12100222223022722032222200121,\n        12100242243214841234224200121, 12100244443236963234444200121,\n        12102200102202620220100220121, 12102202302402720420320220121,\n        12102222324232823242322220121, 12102224524434943442542220121,\n        12102420145204840254102420121, 12102422345424942454322420121,\n        12122010000222622200001022121, 12122012202222722220221022121,\n        12122032240432823404223022121, 12122034442434943424443022121,\n        12122230223242824232203222121, 12122232425262926252423222121,\n        12124212102424842420121242121, 12124214304624942640341242121,\n        12321000000024642000000012321, 12321002220024742002220012321,\n        12321022422034843022422012321, 12321024642036963024642012321,\n        12321222023224842232022212321, 12321224243244944234242212321,\n        12323220102244844220102232321, 12323222322444944422322232321,\n        12343210000246864200001234321, 12343212222246964222221234321,\n        40000000000000800000000000004, 40000004000000900000040000004,\n        1000000000000002000000000000001, 1000000220000014100000220000001,\n        1000002002001004001002002000001, 1000002222001236321002222000001,\n        1000020000300004000030000200001, 1000020220302216122030220200001,\n        1000022002321026201232002200001, 1000022222323458543232222200001,\n        1000200010020004000200100020001, 1000200230042016102400320020001,\n        1000202012221206021222102020001, 1000202232243438343422322020001,\n        1000220012320026200232100220001, 1000220232344238324432320220001,\n        1000222014541248421454102220001, 1002001000002004002000001002001,\n        1002001220222016102220221002001, 1002003004005006005004003002001,\n        1002003224225238325224223002001, 1002021020302206022030201202001,\n        1002021240524418144250421202001, 1002023024325228225234203202001,\n        1002201210022026202200121022001, 1002201430264038304620341022001,\n        1002203214225228225224123022001, 1002221232322248422232321222001,\n        1020100000000204020000000010201, 1020100222200216120022220010201,\n        1020102022021206021202202010201, 1020102244221438341224422010201,\n        1020120200302206022030020210201, 1020120422504418144052240210201,\n        1020122222343228223432222210201, 1020302010020406040200102030201,\n        1020302232242418142422322030201, 1020304032241608061422304030201,\n        1020322212322428242232122230201, 1022121000002226222000001212201,\n        1022121222422238322242221212201, 1022123024025228225204203212201,\n        1022141220304428244030221412201, 1022323210022448442200123232201,\n        1210000000000024200000000000121, 1210000242000036300002420000121,\n        1210002202201026201022022000121, 1210002444201258521024442000121,\n        1210022000320026200230002200121, 1210022242322238322232422200121,\n        1210024202541048401452024200121, 1210220010022026202200100220121,\n        1210220252044038304402520220121, 1210222212423228223242122220121,\n        1210242012342048402432102420121, 1212201000002226222000001022121,\n        1212201242222238322222421022121, 1212203204205228225024023022121,\n        1212223020322428242230203222121, 1212421210024248424200121242121,\n        1232100000000246420000000012321, 1232100244200258520024420012321,\n        1232102222221248421222222012321, 1232122200322248422230022212321,\n        1232322010022448442200102232321, 1234321000002468642000001234321,\n        4000000000000008000000000000004], dtype=object)\n \n ###############################################################################\n # Helper functions go here\n ###############################################################################\n \n def read_input(infile):\n     """This function should take an open input file, load in all of the\n     relevant information for a single case of the problem, and output it\n     as a single object.    \n     """\n     #Some utility functions to read in particular types of input\n     def read_int():\n         return int(infile.readline().strip())\n     def read_ints():\n         return np.array(infile.readline().split(), dtype=int)\n     def read_bigints():\n         line = infile.readline().split()\n         return np.array(map(lambda x: int(x), line))\n     def read_float():\n         return float(infile.readline().strip())\n     def read_floats():\n         return np.array(infile.readline().split(), dtype=float)\n     def read_string():\n         return infile.readline().strip()\n     def read_strings():\n         return np.array(infile.readline().split(), dtype=object) #change the dtype?\n     \n     A, B = read_bigints()\n     \n     return (A, B)\n \n def is_palindrome(num):\n     digits = []\n     num = int(num)\n     while num > 0:\n         digits.append(num % 10)\n         num = num / 10 #n.b. int division (discard remainder)\n \n     return digits == digits[::-1]\n \n     for i in range(len(digits) / 2): #n.b. int division (skips center)\n         if digits[i] != digits[-i+1]:\n             return False\n     return True\n \n def solve_case_simple(case):\n     A, B = case\n     \n     if B > table_of_fairs[-1]:\n         raise ValueError, "Ranges too big for lookup table!"\n     \n     valid = (A <= filtered_table) * (filtered_table <= B)\n     return valid.sum()\n \n def solve_case(case):\n     """Take the input data (structured in case) and perform any necessary\n     calculations to obtain the desired output, formatted as the appropriate\n     string.    \n     """\n     \n     output = solve_case_simple(case)\n     return output\n \n ###############################################################################\n # Main execution path\n ###############################################################################\n \n if __name__ == "__main__":\n     #Open up the input & output files\n     infile = open("%s-%s%s.in" % (problem, tag, suffix), 'r')\n     outfile = open("%s-%s%s.out" % (problem, tag, suffix), 'w')\n     \n     #Read in the number of cases (the first input line) to iterate through\n     cases = int(infile.readline().strip('\n'))\n     for i in range(cases):\n         \n         #Read in the input data for this case\n         case = read_input(infile)\n         \n         #Solve the problem for this case\n         output = solve_case(case)\n         \n         #Write out the output of this case\n         outfile.write('Case #%i: %s\n' % (i+1, output))\n         print 'Case #%i: %s\n' % (i+1, output)\n     \n     #Close files\n     infile.close()\n     outfile.close()
caethan	<>	19	<>	2013_2270488_2449486.py	<>	#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n #for the Google Code Jam programming contest\n \n ###############################################################################\n # Imports go here\n ###############################################################################\n \n from __future__ import division\n import numpy as np\n \n ###############################################################################\n # Global variables (for caching, etc.) go here\n ###############################################################################\n \n #Set up the input/output files: problem-tagsuffix.in / *.out\n problem = "B"\n tag = "small" #commonly sample, small, or large\n #tag = "large"\n #tag = "sample"\n suffix = "-attempt0" #used sometimes for indexing later input files\n #suffix = ""\n \n ###############################################################################\n # Helper functions go here\n ###############################################################################\n \n \n def read_input(infile):\n     """This function should take an open input file, load in all of the\n     relevant information for a single case of the problem, and output it\n     as a single object.    \n     """\n     #Some utility functions to read in particular types of input\n     def read_int():\n         return int(infile.readline().strip())\n     def read_ints():\n         return np.array(infile.readline().split(), dtype=int)\n     def read_float():\n         return float(infile.readline().strip())\n     def read_floats():\n         return np.array(infile.readline().split(), dtype=float)\n     def read_string():\n         return infile.readline().strip()\n     def read_strings():\n         return np.array(infile.readline().split(), dtype=object) #change the dtype?\n     \n     N, M = read_ints()\n     \n     lawn = np.empty((N, M), dtype=int)\n     for i in range(N):\n         row = read_ints()\n         assert len(row) == M\n         lawn[i,:] = row\n     \n     return lawn\n \n def solve_case(case):\n     """Take the input data (structured in case) and perform any necessary\n     calculations to obtain the desired output, formatted as the appropriate\n     string.    \n     """\n     \n     lawn = case\n     undefined = np.zeros(lawn.shape, dtype=bool)\n     \n     colvals, rowvals = np.meshgrid(range(lawn.shape[1]), range(lawn.shape[0]))\n     \n     while not undefined.all():\n         #Find the lowest still-defined point in the lawn\n         valid = undefined == False\n         minval = lawn[valid].min()\n     \n         minindex = np.where(lawn[valid] == minval)[0][0]\n         minrow = rowvals[valid][minindex]\n         mincol = colvals[valid][minindex]\n         #Check to see if this point's row could have been mowed\n         if (lawn[minrow,:][valid[minrow,:]] == minval).all():\n             #Undefine this row\n             undefined[minrow,:] = True\n             continue\n         \n         #Otherwise, check to see if this point's column could have been mowed\n         if (lawn[:,mincol][valid[:,mincol]] == minval).all():\n             #Undefine this column\n             undefined[:,mincol] = True\n             continue\n         \n         #Otherwise, it's invalid!\n         return "NO"\n     \n     return "YES"\n \n ###############################################################################\n # Main execution path\n ###############################################################################\n \n if __name__ == "__main__":\n     #Open up the input & output files\n     infile = open("%s-%s%s.in" % (problem, tag, suffix), 'r')\n     outfile = open("%s-%s%s.out" % (problem, tag, suffix), 'w')\n     \n     #Read in the number of cases (the first input line) to iterate through\n     cases = int(infile.readline().strip('\n'))\n     for i in range(cases):\n         \n         #Read in the input data for this case\n         case = read_input(infile)\n         \n         #Solve the problem for this case\n         output = solve_case(case)\n         \n         #Write out the output of this case\n         outfile.write('Case #%i: %s\n' % (i+1, output))\n         print 'Case #%i: %s\n' % (i+1, output)\n     \n     #Close files\n     infile.close()\n     outfile.close()
caethan	<>	19	<>	2012_1460488_1483488.py	<>	#Code copyright Brett Olsen, 2012\n \n #Standard imports\n import numpy as N\n \n #Some switching behavior to set standard input/output files\n #Set these three variables to adjust behavior\n case = 1\n problem = "C"\n practice = False\n \n if practice:\n     practice = "-practice"\n else:\n     practice = "-attempt0"\n if case == 0:\n     infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')\n     outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')        \n elif case == 1:\n     infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')\n     outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')    \n elif case == 2:\n     infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')\n     outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')   \n else:\n     raise ValueError, 'Invalid case'\n     \n def permute(num, maxval):\n     assert type(num) == int\n     output = []\n     digits = int(N.ceil(N.log10(num)))\n     current = num\n     for i in range(digits-1):\n         current = current / 10 + 10**(digits-1) * (current % 10)\n         if current <= num: #We only want permutations greater than num (for uniqueness)\n             continue\n         if current > maxval: #only permutations less than the maximum value\n             continue\n         if current not in output:\n             output.append(current)\n #    return output\n     return len(output)\n     \n def count_recycled(A, B):\n     count = 0\n     for num in xrange(A, B+1):\n         count += permute(num, B)\n     return count\n     \n #Read in the number of cases (the first input line) we need to iterate through\n cases = int(infile.readline().strip('\n'))\n for i in range(cases):\n ##################NEW CODE GOES HERE###########################################    \n     #Read in all relevant data for each case\n     A, B = infile.readline().split()\n     A = int(A)\n     B = int(B)\n     \n     #Do calculations to generate the output\n     output = '%i' % count_recycled(A, B)\n     \n ##################NEW CODE GOES HERE###########################################    \n     #Write out the results for this case\n     outfile.write('Case #%i: %s\n' % (i+1, output))\n     \n #Close files\n infile.close()\n outfile.close()
caethan	<>	19	<>	2014_2974486_5756407898963968.py	<>	#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n #for the Google Code Jam programming contest\n \n ###############################################################################\n # Imports go here\n ###############################################################################\n \n #For faster numerical analysis\n import numpy as np\n \n import sys\n \n #Needed for the memoization decorator\n import collections\n import functools\n \n ###############################################################################\n # Global variables (for caching, etc.) go here\n ###############################################################################\n \n ###############################################################################\n # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\n ###############################################################################\n \n class memoize(object):\n    """Decorator. Caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned\n    (not reevaluated).\n    """\n    def __init__(self, func):\n       self.func = func\n       self.cache = {}\n    def __call__(self, *args):\n       if not isinstance(args, collections.Hashable):\n          # uncacheable. a list, for instance.\n          # better to not cache than blow up.\n          return self.func(*args)\n       if args in self.cache:\n          return self.cache[args]\n       else:\n          value = self.func(*args)\n          self.cache[args] = value\n          return value\n    def __repr__(self):\n       '''Return the function's docstring.'''\n       return self.func.__doc__\n    def __get__(self, obj, objtype):\n       '''Support instance methods.'''\n       return functools.partial(self.__call__, obj)\n \n ###############################################################################\n # Functions\n ###############################################################################\n \n def precalculate():\n     """Perform any calculations that need to be performed before the main path\n     (e.g., preparing lookup tables, etc.)\n     \n     N.B. Make sure you make any important variables global so that other\n     functions can access them.\n     """\n     pass\n \n def read_input(infile):\n     """This function should take an open input file, load in all of the\n     relevant information for a single case of the problem, and output it\n     as a single object.    \n     """\n     #Some utility functions to read in particular types of input\n     def read_int():\n         return int(infile.readline().strip())\n     def read_ints():\n         return np.array(infile.readline().split(), dtype=int)\n     def read_bigints(): #For ints that won't fit directly in an int32 array\n         line = infile.readline().split()\n         return np.array(map(lambda x: int(x), line))\n     def read_float():\n         return float(infile.readline().strip())\n     def read_floats():\n         return np.array(infile.readline().split(), dtype=float)\n     def read_string():\n         return infile.readline().strip()\n     def read_strings():\n         return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n     \n     ans1 = read_int()\n     grid1 = np.zeros((4,4), dtype=int)\n     for i in range(4):\n         grid1[i] = read_ints()\n     \n     ans2 = read_int()\n     grid2 = np.zeros((4,4), dtype=int)\n     for i in range(4):\n         grid2[i] = read_ints()\n     \n     \n     case = (ans1, grid1, ans2, grid2)\n     \n     return case\n \n def solve_case(case):\n     """Take the input data (structured in case) and perform any necessary\n     calculations to obtain the desired output, formatted as the appropriate\n     string.    \n     """\n     \n     ans1, grid1, ans2, grid2 = case\n     \n     valid = set(grid1[ans1-1]) & set(grid2[ans2-1])\n     \n     #print valid\n     #print ans1, grid1, ans2, grid2\n     #print grid1[ans1], grid2[ans2]\n     \n     if len(valid) == 1:\n         output = valid.pop()\n     elif len(valid) > 1:\n         output = "Bad magician!"\n     elif len(valid) < 1:\n         output = "Volunteer cheated!"\n     return output\n \n ###############################################################################\n # Main execution path\n ###############################################################################\n \n if __name__ == "__main__":\n     #Do any pre-calculations required\n     precalculate()\n     \n     #Open up the input & output files based on the provided input file\n     assert len(sys.argv) == 2 #only one argument\n     assert sys.argv[1][-3:] == ".in" #input must end with .in\n     infile = open("%s" % sys.argv[1], 'r')\n     outfile = open("%s.out" % sys.argv[1][:-3], 'w')\n     \n     #Read in the number of cases (the first input line) to iterate through\n     cases = int(infile.readline().strip('\n'))\n     for i in range(cases):\n         \n         #Read in the input data for this case\n         case = read_input(infile)\n         \n         #Solve the problem for this case\n         output = solve_case(case)\n         \n         #Write out the output of this case\n         outfile.write('Case #%i: %s\n' % (i+1, output))\n         print 'Case #%i: %s\n' % (i+1, output)\n     \n     #Close files\n     infile.close()\n     outfile.close()
caethan	<>	19	<>	2012_1460488_1483485.py	<>	#Code copyright Brett Olsen, 2012\n \n #Standard imports\n import numpy as N\n from string import translate, maketrans\n \n #Some switching behavior to set standard input/output files\n #Set these three variables to adjust behavior\n case = 1\n problem = "A"\n practice = False\n \n if practice:\n     practice = "-practice"\n else:\n     practice = "-attempt0"\n if case == 0:\n     infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')\n     outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')        \n elif case == 1:\n     infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')\n     outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')    \n elif case == 2:\n     infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')\n     outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')   \n else:\n     raise ValueError, 'Invalid case'\n     \n alpha = 'abcdefghijklmnopqrstuvwxyz '\n trans = 'ynficwlbkuomxsevzpdrjgthaq '\n table = maketrans(trans, alpha)\n     \n #Read in the number of cases (the first input line) we need to iterate through\n cases = int(infile.readline().strip('\n'))\n for i in range(cases):\n ##################NEW CODE GOES HERE###########################################    \n     #Read in all relevant data for each case\n     instr = infile.readline().strip('\n')\n     \n     #Do calculations to generate the output\n     \n     output = translate(instr, table)\n     \n     \n ##################NEW CODE GOES HERE###########################################    \n     #Write out the results for this case\n     outfile.write('Case #%i: %s\n' % (i+1, output))\n     \n #Close files\n infile.close()\n outfile.close()
caethan	<>	19	<>	2013_2270488_2453486.py	<>	#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n #for the Google Code Jam programming contest\n \n ###############################################################################\n # Imports go here\n ###############################################################################\n \n from __future__ import division\n import numpy as np\n \n ###############################################################################\n # Global variables (for caching, etc.) go here\n ###############################################################################\n \n #Set up the input/output files: problem-tagsuffix.in / *.out\n problem = "A"\n tag = "small" #commonly sample, small, or large\n suffix = "-attempt1" #used sometimes for indexing later input files\n \n ###############################################################################\n # Helper functions go here\n ###############################################################################\n \n def read_input(infile):\n     """This function should take an open input file, load in all of the\n     relevant information for a single case of the problem, and output it\n     as a single object.    \n     """\n     #Some utility functions to read in particular types of input\n     def read_int():\n         return int(infile.readline().strip())\n     def read_ints():\n         return np.array(infile.readline().split(), dtype=int)\n     def read_float():\n         return float(infile.readline().strip())\n     def read_floats():\n         return np.array(infile.readline().split(), dtype=float)\n     def read_string():\n         return infile.readline().strip()\n     def read_strings():\n         return np.array(infile.readline().split(), dtype=object) #change the dtype?\n     \n     board = np.empty((4,4), dtype=int)\n     \n     dic = {'X': 1, 'T': 2, 'O': 3, '.': 4}\n     \n     #Read in rows\n     for i in range(4):\n         line = read_string()\n         for j in range(4):\n             board[i,j] = dic[line[j]]\n     infile.readline()\n     \n     return board\n \n def iswin(row):\n     if 4 in row:\n         return None #gap\n     if (row <= 2).all():\n         return "X won"\n     if (row >= 2).all():\n         return "O won"\n     return None\n \n def solve_case(case):\n     """Take the input data (structured in case) and perform any necessary\n     calculations to obtain the desired output, formatted as the appropriate\n     string.    \n     """\n     \n     board = case\n \n     #Look for win conditions\n     for i in range(4):\n         row = board[i,:]\n         if iswin(row) is not None:\n             return iswin(row)\n         \n     for i in range(4):\n         col = board[:,i]\n         if iswin(col) is not None:\n             return iswin(col)\n         \n     vals = np.arange(4)\n     diag = board[vals,vals]\n     if iswin(diag) is not None:\n         return iswin(diag)\n     \n     diag = board[vals, vals[::-1]]\n     if iswin(diag) is not None:\n         return iswin(diag)\n \n     #Check if the board is completed (has empty squares left)\n     if 4 in board:\n         return "Game has not completed"\n     \n     return "Draw"\n \n ###############################################################################\n # Main execution path\n ###############################################################################\n \n if __name__ == "__main__":\n     #Open up the input & output files\n     infile = open("%s-%s%s.in" % (problem, tag, suffix), 'r')\n     outfile = open("%s-%s%s.out" % (problem, tag, suffix), 'w')\n     \n     #Read in the number of cases (the first input line) to iterate through\n     cases = int(infile.readline().strip('\n'))\n     for i in range(cases):\n         \n         #Read in the input data for this case\n         case = read_input(infile)\n         \n         #Solve the problem for this case\n         output = solve_case(case)\n         \n         #Write out the output of this case\n         outfile.write('Case #%i: %s\n' % (i+1, output))\n         print 'Case #%i: %s\n' % (i+1, output)\n     \n     #Close files\n     infile.close()\n     outfile.close()
caethan	<>	19	<>	2014_2974486_5690574640250880.py	<>	#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n #for the Google Code Jam programming contest\n \n ###############################################################################\n # Imports go here\n ###############################################################################\n \n #For faster numerical analysis\n import numpy as np\n \n import sys\n \n #Needed for the memoization decorator\n import collections\n import functools\n \n ###############################################################################\n # Global variables (for caching, etc.) go here\n ###############################################################################\n \n ###############################################################################\n # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\n ###############################################################################\n \n class memoize(object):\n    """Decorator. Caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned\n    (not reevaluated).\n    """\n    def __init__(self, func):\n       self.func = func\n       self.cache = {}\n    def __call__(self, *args):\n       if not isinstance(args, collections.Hashable):\n          # uncacheable. a list, for instance.\n          # better to not cache than blow up.\n          return self.func(*args)\n       if args in self.cache:\n          return self.cache[args]\n       else:\n          value = self.func(*args)\n          self.cache[args] = value\n          return value\n    def __repr__(self):\n       '''Return the function's docstring.'''\n       return self.func.__doc__\n    def __get__(self, obj, objtype):\n       '''Support instance methods.'''\n       return functools.partial(self.__call__, obj)\n \n ###############################################################################\n # Functions\n ###############################################################################\n \n def precalculate():\n     """Perform any calculations that need to be performed before the main path\n     (e.g., preparing lookup tables, etc.)\n     \n     N.B. Make sure you make any important variables global so that other\n     functions can access them.\n     """\n     pass\n \n def read_input(infile):\n     """This function should take an open input file, load in all of the\n     relevant information for a single case of the problem, and output it\n     as a single object.    \n     """\n     #Some utility functions to read in particular types of input\n     def read_int():\n         return int(infile.readline().strip())\n     def read_ints():\n         return np.array(infile.readline().split(), dtype=int)\n     def read_bigints(): #For ints that won't fit directly in an int32 array\n         line = infile.readline().split()\n         return np.array(map(lambda x: int(x), line))\n     def read_float():\n         return float(infile.readline().strip())\n     def read_floats():\n         return np.array(infile.readline().split(), dtype=float)\n     def read_string():\n         return infile.readline().strip()\n     def read_strings():\n         return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n     \n     R, C, M = read_ints()\n     \n     return R, C, M\n \n def solve_case(case):\n     """Take the input data (structured in case) and perform any necessary\n     calculations to obtain the desired output, formatted as the appropriate\n     string.    \n     """\n     R, C, M = case\n     \n     free = R * C - M\n     assert free >= 1\n     \n     board = np.zeros((R, C), dtype=int) - 1\n     \n     def write_board(board):\n         d = {0:'.', 1:'c', 2:'*'}\n         s = "\n"\n         for row in board:\n             for num in row:\n                 try:\n                     s += d[num]\n                 except KeyError:\n                     #s += "X"\n                     raise ValueError("Board not filled in!")\n             s += "\n"\n         return s\n     \n     #Clicking in the corner is always optimal!\n     board[0,0] = 1\n     \n     #Always possible with no mines!\n     if M == 0:\n         board[board == -1] = 0\n         return write_board(board)\n     \n     #Always possible with one free square, if you click on the free square.\n     if free == 1:\n         #Fill all the empty squares in with mines\n         board[board == -1] = 2\n         return write_board(board)\n         \n     \n     #Fill in the shortest sides while we have enough mines to do so:\n     while min(R, C) <= M:\n         if R < C:\n             board[:,C-1] = 2\n             C -= 1\n             M -= R\n         elif C <= R:\n             board[R-1,:] = 2\n             R -= 1\n             M -= C\n     \n     def cascades(board, r, c):\n         rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\n         cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\n         for r in rows:\n             for c in cols:\n                 if board[r,c] == 2: #Mine next to given position\n                     return False\n         return True\n     \n     #If we have no mines left, we win as long as the initial click cascades:\n     if M == 0:\n         board[board == -1] = 0\n         if cascades(board, 0, 0):\n             return write_board(board)\n         else:\n             return "\nImpossible"\n     \n     #Now we have a rectangular free space with less than a full row or column\n     #to fill.\n     \n     #If there's so many mines that we fill in all but one square on either\n     #the row or column, it can't be done.\n     if M > (R + C - 5):\n         return "\nImpossible"\n         \n     if M > 0 and (R <= 2 or C <= 2):\n         return "\nImpossible"\n         \n     #Otherwise, we fill in mines from the corner opposite to the click\n     print M, R + C - 5\n     fill_num = min(M, R - 2)\n     print M, fill_num\n     board[(R - fill_num):,C-1] = 2\n     M -= fill_num\n     \n     fill_num = min(M, C - 3)\n     print M, fill_num\n     board[R-1,(C - fill_num - 1):] = 2\n     M -= fill_num\n     #assert M == 0\n     \n     board[board == -1] = 0\n     return write_board(board)\n \n ###############################################################################\n # Main execution path\n ###############################################################################\n \n if __name__ == "__main__":\n     #Do any pre-calculations required\n     precalculate()\n     \n     #Open up the input & output files based on the provided input file\n     assert len(sys.argv) == 2 #only one argument\n     assert sys.argv[1][-3:] == ".in" #input must end with .in\n     infile = open("%s" % sys.argv[1], 'r')\n     outfile = open("%s.out" % sys.argv[1][:-3], 'w')\n     \n     #Read in the number of cases (the first input line) to iterate through\n     cases = int(infile.readline().strip('\n'))\n     for i in range(cases):\n         \n         #Read in the input data for this case\n         case = read_input(infile)\n         \n         #Solve the problem for this case\n         output = solve_case(case)\n         \n         #Write out the output of this case\n         outfile.write('Case #%i: %s\n' % (i+1, output))\n         print 'Case #%i: %s\n' % (i+1, output)\n     \n     #Close files\n     infile.close()\n     outfile.close()
kmod	<>	20	<>	2013_2270488_2463486.py	<>	import math\n import sys\n \n def ispal(n):\n     s = str(n)\n     return s == s[::-1]\n \n def ispalsq(n):\n     sqrt = int(math.sqrt(n) + .01)\n     if sqrt ** 2 != n:\n         return False\n     return ispal(n) and ispal(sqrt)\n \n def search(s, l, idx):\n     if l % 2 == 0:\n         m = s + s[::-1]\n     else:\n         m = s[:-1] + s[::-1]\n     assert ispal(m)\n     n = int(m) ** 2\n     if not ispal(n):\n         # print m, False\n         return 0\n     # print m, int(m)**2\n \n     r = 1 if (a <= n <= b) else 0\n     for i in xrange(idx, len(s)):\n         s2 = list(s)\n         s2[i] = str(int(s2[i])+1)\n         s2 = ''.join(s2)\n         r += search(s2, l, i)\n     return r\n \n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     for _t in xrange(t):\n         a, b = map(int, f.readline().split())\n \n         total = 0\n         for l in xrange(1, 150):\n             if 10 ** (l-1) > b:\n                 break\n             total += search("1" + "0" * ((l-1)/2), l, 0)\n         print "Case #%d: %d" % (_t+1, total)\n \n
kmod	<>	20	<>	2013_2270488_2449486.py	<>	import sys\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     for _t in xrange(t):\n         n, m = map(int, f.readline().split())\n         b = []\n         for i in xrange(n):\n             b.append(map(int, f.readline().split()))\n             assert len(b[-1]) == m\n         # print b\n \n         max_h = [0] * n\n         max_v = [0] * m\n \n         for i in xrange(n):\n             for j in xrange(m):\n                 t = b[i][j]\n                 max_h[i] = max(max_h[i], t)\n                 max_v[j] = max(max_v[j], t)\n         can = True\n         for i in xrange(n):\n             if not can:\n                 break\n             for j in xrange(m):\n                 t = b[i][j]\n                 if max_h[i] > t and max_v[j] > t:\n                     can = False\n                     break\n \n         print "Case #%d: %s" % (_t+1, "YES" if can else "NO")\n
kmod	<>	20	<>	2012_1460488_1483488.py	<>	import sys\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     for _t in xrange(t):\n         a, b = map(int, f.readline().split())\n \n         total = 0\n         for i in xrange(a, b):\n             # print i\n             s = set()\n             cs = str(i)\n             for j in xrange(1, len(cs)):\n                 k = int(cs[j:] + cs[:j])\n                 if i < k <= b:\n                     s.add(k)\n             # print s\n             # print\n             total += len(s)\n \n         print "Case #%d: %d" % (_t + 1, total)\n
kmod	<>	20	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     T = int(f.readline())\n     for _T in xrange(T):\n         a1 = int(f.readline())\n         l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n         a2 = int(f.readline())\n         l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n \n         poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n \n         print "Case #%d:" % (_T + 1),\n         if len(poss) == 0:\n             print "Volunteer cheated!"\n         elif len(poss) == 1:\n             print poss[0]\n         else:\n             print "Bad magician!"\n
kmod	<>	20	<>	2012_1460488_1483485.py	<>	import sys\n \n d = {\n         'a':'y',\n         'o':'e',\n         'z':'q',\n         ' ':' ',\n         'r':'p',\n         'l':'m',\n         'n':'s',\n         'g':'l',\n         'u':'j',\n         'e':'c',\n         'i':'k',\n         's':'d',\n         'm':'x',\n         'p':'v',\n         't':'r',\n         'd':'i',\n         'b':'n',\n         'h':'b',\n         'w':'t',\n         'y':'a',\n         'x':'h',\n         'f':'w',\n         'c':'f',\n         'k':'o',\n         'j':'u',\n         'v':'g',\n         'q':'z',\n         '\n':'\n',\n         }\n \n r = dict((v,k) for (k,v) in d.items())\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     f.readline()\n     i = 1\n     for l in f:\n         sys.stdout.write("Case #%d: " % i)\n         for c in l:\n             # sys.stdout.write(r.get(c, '?'))\n             sys.stdout.write(r[c])\n         i += 1\n \n
kmod	<>	20	<>	2014_2974486_5709773144064000.py	<>	import sys\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     T = int(f.readline())\n     for _T in xrange(T):\n         C, F, X = map(float, f.readline().split())\n \n         cps = 2.0\n         t = 0.0\n         best_t = X / cps\n \n         while True:\n             t += C / cps\n             if t >= best_t:\n                 break\n \n             cps += F\n             best_t = min(best_t, t + X / cps)\n \n         print "Case #%d: %.7f" % (_T+1, best_t)\n
kmod	<>	20	<>	2013_2270488_2453486.py	<>	import sys\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     for _t in xrange(t):\n         m = []\n         for i in xrange(4):\n             l = f.readline().strip()\n             assert len(l) == 4\n             m.append(l)\n         f.readline()\n \n         def check(x, y, dx, dy):\n             s = set()\n             for i in xrange(4):\n                 s.add(m[x][y])\n                 x += dx\n                 y += dy\n             # print x, y, dx, dy, s\n             if 'T' in s:\n                 s.remove('T')\n             if '.' in s:\n                 return None\n             if len(s) == 1:\n                 return list(s)[0]\n             return None\n \n         winner = None\n         for i in xrange(4):\n             winner = winner or check(0, i, 1, 0)\n             winner = winner or check(i, 0, 0, 1)\n         winner = winner or check(0, 0, 1, 1)\n         winner = winner or check(0, 3, 1, -1)\n \n         print "Case #%d:" % (_t+1),\n         if winner:\n             print "%s won" % winner\n         elif any('.' in l for l in m):\n             print "Game has not completed"\n         else:\n             print "Draw"\n
kmod	<>	20	<>	2014_2974486_5690574640250880.py	<>	import sys\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     T = int(f.readline())\n     for _T in xrange(T):\n         R, C, M = map(int, f.readline().split())\n \n         # print R, C, M\n         print "Case #%d:" % (_T+1)\n \n         left = R * C - M\n \n         if R == 1:\n             s = 'c'\n             s += '.' * (left - 1)\n             s += '*' * M\n             print s\n             continue\n         if C == 1:\n             print 'c'\n             for i in xrange(left - 1):\n                 print '.'\n             for i in xrange(M):\n                 print '*'\n             continue\n \n         if left == 1:\n             print 'c' + '*' * (C-1)\n             for i in xrange(R-1):\n                 print '*' * C\n             continue\n \n         if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n             print "Impossible"\n             continue\n         if R == 2:\n             assert left not in (2, 3, 5, 7)\n             assert left >= 4\n             print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n             print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n             continue\n         if C == 2:\n             assert left >= 4\n             assert left not in (2, 3, 5, 7)\n             print 'c.'\n             left -= 2\n             R -= 1\n             while left:\n                 print '..'\n                 left -= 2\n                 R -= 1\n             assert R >= 0\n             while R:\n                 print '**'\n                 R -= 1\n             continue\n \n         assert R >= 3\n         assert C >= 3\n \n         if left == 4:\n             print 'c.' + '*' * (C-2)\n             print '..' + '*' * (C-2)\n             for i in xrange(R-2):\n                 print '*' * C\n             continue\n \n         if left in (2, 3, 5, 7):\n             print "Impossible"\n             continue\n \n         assert left >= 6\n \n         cols = max(3, (left + R-1) // R)\n \n         if left % cols == 1:\n             assert left >= 10\n \n             print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n             left -= cols\n             R -= 1\n \n             while left > cols + 1:\n                 print '.' * cols + '*' * (C - cols)\n                 left -= cols\n                 R -= 1\n             assert left == cols + 1\n             print '.' * (cols - 1) + '*' * (C - cols + 1)\n             print '.' * (2) + '*' * (C - 2)\n             R -= 2\n \n             assert R >= 0\n \n             while R:\n                 print '*' * C\n                 R -= 1\n             continue\n         else:\n             assert left >= 6\n \n             print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n             left -= cols\n             R -= 1\n \n             while left > cols:\n                 print '.' * cols + '*' * (C - cols)\n                 left -= cols\n                 R -= 1\n             assert left >= 2\n             print '.' * (left) + '*' * (C - left)\n             R -= 1\n \n             assert R >= 0\n \n             while R:\n                 print '*' * C\n                 R -= 1\n             continue\n \n         1/0\n
ziyan	<>	21	<>	2013_2270488_2463486.py	<>	\n import sys\n import math\n \n def is_fair(n):\n     n = str(n)\n     for i in range(long(len(n) / 2)):\n         if n[i] != n[len(n) - i - 1]:\n             return False\n     return True\n \n def is_square_and_fair(n):\n     if not is_fair(n): return False\n     root = math.sqrt(n)\n     if root != math.floor(root): return False\n     if not is_fair(long(root)): return False\n     return True\n \n def process():\n     a, b = sys.stdin.readline().split()\n     a = long(a)\n     b = long(b)\n     \n     count = 0\n     for i in range(a, b + 1):\n         if is_square_and_fair(i): count = count + 1\n \n     return count\n \n def main():\n \n     count = int(sys.stdin.readline())\n     for index in range(count):\n         result = process()\n         print "Case #%d: %s" % (index + 1, result)\n \n if __name__ == '__main__':\n     main()\n
ziyan	<>	21	<>	2013_2270488_2449486.py	<>	\n import sys\n \n def process():\n     height, width = sys.stdin.readline().split()\n     width = int(width)\n     height = int(height)\n \n     lawn = [[0 for c in range(width)] for r in range(height)]\n     mark = [[0 for c in range(width)] for r in range(height)]\n     settings = []\n \n     for r in range(height):\n         row = sys.stdin.readline().split()\n         for c in range(width):\n             h = int(row[c])\n             lawn[r][c] = h\n             if h not in settings: settings.append(h)\n \n     settings = sorted(settings)\n \n     for i in range(len(settings)):\n         h = settings[i]\n         h_next = 0\n         if i < len(settings) - 1:\n             h_next = settings[i + 1]\n \n         # check row\n         for r in range(height):\n             count = 0\n             for c in range(width):\n                 if lawn[r][c] == h: count = count + 1\n             if count == width:\n                 for c in range(width): mark[r][c] = h\n \n         # check col\n         for c in range(width):\n             count = 0\n             for r in range(height):\n                 if lawn[r][c] == h: count = count + 1\n             if count == height:\n                 for r in range(height): mark[r][c] = h\n \n         # anything left?\n         for c in range(width):\n             for r in range(height):\n                 if lawn[r][c] == h:\n                     if mark[r][c] != h: return "NO"\n                     lawn[r][c] = h_next\n \n     return "YES"\n \n         \n \n def main():\n \n     count = int(sys.stdin.readline())\n     for index in range(count):\n         result = process()\n         print "Case #%d: %s" % (index + 1, result)\n \n if __name__ == '__main__':\n     main()\n
ziyan	<>	21	<>	2012_1460488_1483488.py	<>	import sys\n \n def find_recycled_pairs(A, B):\n     count = 0\n     l = len(str(A))\n     for i in range(A, B + 1):\n         variants = []\n         for d in range(1, l):\n             fixed = str(i)[:d]\n             moving = str(i)[-(l - d):]\n             j = int(moving + fixed)\n             if j != i and len(str(i)) == len(str(j)) and j in range(A, B + 1) and j not in variants:\n                 variants.append(j)\n                 #print '%s -> %s' % (fixed + moving, moving + fixed)\n                 count = count + 1\n     return count / 2\n \n \n def find_recycled_pairs_efficient(A, B):\n     count = 0\n     sa = str(A)\n     sb = str(B)\n     l = len(sa)\n     for fixed in range(1, l):\n         moving = l - fixed\n         x = int(sa[:fixed])\n         y = int(sb[:fixed])\n         m = int(sa[-fixed:])\n         n = int(sb[-fixed:])\n         j = int(sa[:moving])\n         k = int(sb[:moving])\n         print '%i fixed: x = %i, m = %i, n = %i, y = %i, j = %i, k = %i' % (fixed, x, m, n, y, j, k)\n \n         if int(str(y) + str(k)) >= B:\n             k1 = int(sb[-moving:])\n             print 'k1 - j = %i - %i' % (k1, j)\n             if k1 > j:\n                 count = count + (k1 - j)\n         if int(str(x) + str(j)) <= A:\n             j1 = int(sa[-moving:])\n             print 'k - j1 = %i - %i' % (k, j1)\n             if k > j1:\n                 count = count + (k - j1)\n \n         if len(str(k)) >= len(str(x)):\n             count = count + (y - x) * (k - j)\n         else:\n             count = count + (y - x - 1) * (k - j + 1)\n \n         if x < m:\n             count = count - (m - x - 1)\n         if y > n:\n             count = count - (y - n - 1)\n \n     return count / 2\n \n def main():\n \n     case_count = int(sys.stdin.readline())\n \n     for case_index in range(1, case_count + 1):\n         (A, B) = sys.stdin.readline().strip().split(' ')\n         A = int(A)\n         B = int(B)\n         assert len(str(A)) == len(str(B))\n         print 'Case #%i: %s' % (case_index, find_recycled_pairs(A, B))\n \n if __name__ == '__main__':\n     main()
ziyan	<>	21	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n \n def main():\n     cases = int(sys.stdin.readline())\n \n     for case in range(cases):\n         row1 = int(sys.stdin.readline())\n         arrangement1 = [\n             map(int, sys.stdin.readline().split())\n             for _ in range(4)\n         ]\n         chosen1 = set(arrangement1[row1 - 1])\n \n         row2 = int(sys.stdin.readline())\n         arrangement2 = [\n             map(int, sys.stdin.readline().split())\n             for _ in range(4)\n         ]\n         chosen2 = set(arrangement2[row2 - 1])\n \n         chosen = chosen1 & chosen2\n \n         if not chosen:\n             print 'Case #%d: Volunteer cheated!' % (case + 1)\n         elif len(chosen) != 1:\n             print 'Case #%d: Bad magician!' % (case + 1)\n         else:\n             print 'Case #%d: %d' % (case + 1, chosen.pop())\n \n if __name__ == '__main__':\n     main()\n
ziyan	<>	21	<>	2012_1460488_1483485.py	<>	import sys\n \n cipher = dict()\n \n def learn(encrypted_text, clear_text):\n     for encrypted_letter, clear_letter in zip(encrypted_text, clear_text):\n         if encrypted_letter in cipher:\n             assert cipher[encrypted_letter] == clear_letter\n         cipher[encrypted_letter] = clear_letter\n \n def test():\n     alphabet = 'abcdefghijklmnopqrstuvwxyz '\n     for letter in alphabet:\n         if letter not in cipher.keys():\n             print 'Googlerese letter %s does not have corresponding English letter.' % letter\n         if letter not in cipher.values():\n             print 'English letter %s not found in cipher dictionary values.' % letter\n     if len(cipher.keys()) != len(alphabet):\n         print 'Size of cipher dictionary and alphabet mismatch.'\n \n def decrypt(text):\n     decrypted_text = ''\n     for letter in text:\n         assert letter in cipher\n         decrypted_text += cipher[letter]\n     return decrypted_text\n \n def main():\n     learn(' yeqz', ' aozq')\n     learn('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand')\n     learn('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities')\n     learn('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')\n     test()\n \n     case_count = int(sys.stdin.readline())\n \n     for case_index in range(1, case_count + 1):\n         print 'Case #%i: %s' % (case_index, decrypt(sys.stdin.readline().strip()))\n \n if __name__ == '__main__':\n     main()
ziyan	<>	21	<>	2014_2974486_5709773144064000.py	<>	import sys\n import Queue\n \n \n def click(C, F, X):\n     states = Queue.PriorityQueue()\n \n     # (time, rate, is_done)\n     states.put((0.0, 2.0, False))\n     while not states.empty():\n         time, rate, is_done = states.get()\n \n         # done\n         if is_done:\n             return time\n \n         # two ways to move forward\n         # 1. wait\n         states.put((\n             time + X / rate,\n             rate,\n             True\n         ))\n \n         # 2. wait for a farm\n         states.put((\n             time + C / rate,\n             rate + F,\n             False\n         ))\n \n     return None\n \n def main():\n     cases = int(sys.stdin.readline())\n \n     for case in range(cases):\n         C, F, X = map(float, sys.stdin.readline().split())\n         print 'Case #%d: %.7f' % (case + 1, click(C, F, X))\n \n if __name__ == '__main__':\n     main()\n
ziyan	<>	21	<>	2013_2270488_2453486.py	<>	\n import sys\n \n def process():\n     empty = 0\n     board = [['.', '.', '.', '.'] for i in range(4)]\n     for r in range(4):\n         row = sys.stdin.readline()\n         for c in range(4):\n             board[r][c] = row[c]\n             if row[c] == '.': empty = empty + 1\n     sys.stdin.readline()\n \n     # print board\n \n     # check rows\n     for r in range(4):\n         x = 0\n         o = 0\n         for c in range(4):\n             if board[r][c] == 'X':\n                 x = x + 1\n             if board[r][c] == 'O':\n                 o = o + 1\n             if board[r][c] == 'T':\n                 x = x + 1\n                 o = o + 1\n         if x == 4: return "X won"\n         if o == 4: return "O won"\n \n     for c in range(4):\n         x = 0\n         o = 0\n         for r in range(4):\n             if board[r][c] == 'X':\n                 x = x + 1\n             if board[r][c] == 'O':\n                 o = o + 1\n             if board[r][c] == 'T':\n                 x = x + 1\n                 o = o + 1\n         if x == 4: return "X won"\n         if o == 4: return "O won"\n \n     x = 0\n     o = 0\n     for c in range(4):\n         r = c\n         if board[r][c] == 'X':\n             x = x + 1\n         if board[r][c] == 'O':\n             o = o + 1\n         if board[r][c] == 'T':\n             x = x + 1\n             o = o + 1\n \n     if x == 4: return "X won"\n     if o == 4: return "O won"\n \n     x = 0\n     o = 0\n     for c in range(4):\n         r = 3 - c\n         if board[r][c] == 'X':\n             x = x + 1\n         if board[r][c] == 'O':\n             o = o + 1\n         if board[r][c] == 'T':\n             x = x + 1\n             o = o + 1\n \n     if x == 4: return "X won"\n     if o == 4: return "O won"\n \n     if empty == 0: return "Draw"\n \n     return "Game has not completed"\n \n         \n \n def main():\n \n     count = int(sys.stdin.readline())\n     for index in range(count):\n         result = process()\n         print "Case #%d: %s" % (index + 1, result)\n \n if __name__ == '__main__':\n     main()\n
ziyan	<>	21	<>	2014_2974486_5690574640250880.py	<>	import sys\n import random\n \n NEIGHBOURS = [\n     (-1, -1), (-1, 0), (-1, 1),\n     ( 0, -1),          ( 0, 1),\n     ( 1, -1), ( 1, 0), ( 1, 1),\n ]\n \n MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n \n def valid(size, location, changes):\n     y, x = location\n     for y1, x1 in changes:\n         y1 += y\n         x1 += x\n         if y1 < 0 or y1 >= size[0]:\n             continue\n         if x1 < 0 or x1 >= size[1]:\n             continue\n         yield (y1, x1)\n \n def click(size, grid, location):\n     y, x = location\n     if grid[y][x] is 0:\n         return None\n \n     grid = [row[:] for row in grid]\n     grid[y][x] = 0\n \n     for y, x in valid(size, location, NEIGHBOURS):\n         if grid[y][x]:\n             grid[y][x] = False\n \n     return grid\n \n def sweep(R, C, M):\n     # create initial grid\n     grid = [[True] * C for _ in range(R)]\n     size = (R, C)\n \n     if M + 1 == R * C:\n         grid[0][0] = False\n         return grid, (0, 0)\n \n     # start by click top left\n     states = []\n     for y in range(R):\n         for x in range(C):\n             location = (y, x)\n             states.append((click(size, grid, location), location))\n \n     while states:\n         grid, location = states.pop(0)\n \n         mines_count = sum([sum(row) for row in grid])\n         if mines_count == M:\n             return grid, location\n \n         if mines_count < M:\n             continue\n \n         for new_location in valid(size, location, NEIGHBOURS):\n             new_grid = click(size, grid, new_location)\n             if new_grid:\n                 states.insert(0, (new_grid, new_location))\n \n     return None\n \n def validate(size, grid, location):\n \n     result = [row[:] for row in grid]\n \n     y, x = location\n     result[y][x] = sum([\n         grid[y1][x1]\n         for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n     ])\n     assert result[y][x] == 0\n \n     seen = set([location])\n     locations = set([location])\n \n     while locations:\n         location = locations.pop()\n         for y, x in valid(size, location, NEIGHBOURS):\n             assert grid[y][x] is not True\n             result[y][x] = sum([\n                 grid[y1][x1]\n                 for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n             ])\n             if result[y][x] == 0 and (y, x) not in seen:\n                 locations.add((y, x))\n                 seen.add((y, x))\n \n     for row in result:\n         for col in row:\n             assert col is not False\n     #print result\n \n     for y, row in enumerate(result):\n         output = ''\n         for x, col in enumerate(row):\n             if col is True:\n                 output += '*'\n             else:\n                 output += str(col)\n         print output\n \n \n def process(case, R, C, M):\n     result = sweep(R, C, M)\n \n     print 'Case #%d:' % (case + 1)\n     #print R, C, M\n     if not result:\n         #print R, C, M\n         print 'Impossible'\n         return\n \n     grid, location = result\n     for y, row in enumerate(grid):\n         output = ''\n         for x, col in enumerate(row):\n             if (y, x) == location:\n                 output += 'c'\n             elif col:\n                 output += '*'\n             #elif col is 0:\n             #    output += '0'\n             else:\n                 output += '.'\n         print output\n \n     #validate((R, C), grid, location)\n \n \n def main():\n     #for R in range(1, 6):\n     #    for C in range(1, 6):\n     #        for M in range(R * C):\n     #            process(0, R, C, M)\n     #return\n     #for M in range(1, 25):\n     #    process(M - 1, 5, 5, M)\n     #return\n     cases = int(sys.stdin.readline())\n \n     for case in range(cases):\n         R, C, M = map(int, sys.stdin.readline().split())\n         process(case, R, C, M)\n \n     return\n     for case in range(100):\n         R = random.randrange(51) + 1\n         C = random.randrange(51) + 1\n         M = random.randrange(R * C - 1) + 1\n         process(case * 100000 + M - 1, R, C, M)\n \n \n if __name__ == '__main__':\n     main()\n
pek	<>	22	<>	2013_2270488_2463486.py	<>	import sys\n import bisect\n \n def is_palindrome(n):\n     s = str(n)\n     return s == s[::-1] \n \n palindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]\n all_palindromes = palindromes[1] + palindromes[2]\n limit = [100]\n \n palindromic_squares = []\n psqtop = 0\n psqix = 0\n \n stdin = sys.stdin\n for c in xrange(int(stdin.readline())):\n     a,b = map(int, stdin.readline().split())\n \n     while psqtop < b:\n         while psqix >= len(all_palindromes):\n             ps = []\n             pp = 10 ** (len(palindromes)-1) + 1\n             for i in range(1,10):\n                 for p in palindromes[-2]:\n                     ps.append(i * pp + 10 * p) \n             palindromes.append(ps)\n             all_palindromes.extend(ps)\n \n         sq = all_palindromes[psqix] * all_palindromes[psqix]\n         if is_palindrome(sq):\n             palindromic_squares.append(sq)\n         psqix  += 1\n         psqtop = sq\n \n     aix = bisect.bisect_left(palindromic_squares, a)\n     bix = bisect.bisect_right(palindromic_squares, b)\n \n     print "Case #%i: %i" % (c+1, bix-aix) \n
pek	<>	22	<>	2013_2270488_2449486.py	<>	import sys\n \n stdin = sys.stdin\n for c in xrange(int(stdin.readline())):\n     n,m = map(int, stdin.readline().split())\n     rows = [map(int, stdin.readline().split()) for i in xrange(n)]\n     cols = [[row[i] for row in rows] for i in xrange(m)]\n \n     rowmaxs = [max(x) for x in rows]\n     colmaxs = [max(x) for x in cols]\n \n     verdict = "YES"\n     for i in xrange(n):\n         for k in xrange(m):\n             if min(rowmaxs[i], colmaxs[k]) > rows[i][k]:\n                 verdict = "NO"\n                 break\n \n         if verdict == "NO": break\n \n     print "Case #%i: %s" % (c+1, verdict)\n
pek	<>	22	<>	2012_1460488_1483488.py	<>	from sys import stdin\n import math\n \n pots = [int(10**k) for k in xrange(0,16)]\n \n T = int(stdin.readline())\n \n for i in xrange(1,T+1):\n 	a,b = map(int, stdin.readline().split())\n 	t = 0\n 	m = len(str(a))\n \n 	pp = int(10**m)\n \n 	for n in xrange(a,b):\n 		ss = []\n 		q = 1\n 		p = pp\n 		for j in xrange(1,m):\n 			q *= 10\n 			p /= 10\n 			r = (n % p) * q + (n /p)\n 			if n < r and r <= b and not r in ss: \n 				ss.append(r)\n 				t += 1\n \n \n 	print "Case #%d: %d" % (i,t)\n \n
pek	<>	22	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n \n lines = [map(int, line.strip().split(" ")) for line in open(sys.argv[1]).readlines()]\n [count] = lines[0]\n assert count * 10 + 1 == len(lines)\n \n for i in xrange(count):\n     base = i*10\n     [n1] = lines[base+1]\n     [n2] = lines[base+6]\n     row1 = set(lines[base+1+n1])\n     row2 = set(lines[base+6+n2])\n     common = row1.intersection(row2)\n     print "Case #%s:" % (i+1),\n     if len(common) == 1:\n         print list(common)[0]\n     elif not common:\n         print "Volunteer cheated!"\n     else:\n         print "Bad magician!"\n
pek	<>	22	<>	2012_1460488_1483485.py	<>	import sys\n \n googlerese = """\n y qee\n ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv\n z\n """\n \n plain = """\n a zoo\n our language is impossible to understand\n there are twenty six factorial possibilities\n so it is okay if you want to just give up\n q\n """\n \n gtos = {}\n stog = {}\n \n for s,g in zip(plain, googlerese):\n 	gtos[g] = s\n 	stog[s] = g\n \n #for c in "abcdefghijklmnopqrstuvwxyz":\n #	print c, stog.get(c, None), gtos.get(c,None)\n \n f = sys.stdin\n \n t = int(f.readline())\n \n for i in xrange(0,t):\n 	line = f.readline().strip()\n 	print "Case #%d: %s" % (i+1, "".join([gtos.get(c,c) for c in line]))\n \n
pek	<>	22	<>	2014_2974486_5709773144064000.py	<>	import sys\n \n lines = [line.strip() for line in open(sys.argv[1])]\n count = int(lines[0])\n \n for i in xrange(count):\n     farm_cost,farm_production,target = map(float, lines[i+1].split())\n     seconds = 0\n     production = 2\n     best = float("inf")\n     while True:\n         best = min(best, seconds + target / production)\n         seconds += farm_cost / production\n         if seconds >= best: break\n         production += farm_production\n \n     print "Case #%s: %.7f" % (i+1, best)\n
pek	<>	22	<>	2013_2270488_2453486.py	<>	import sys\n \n stdin = sys.stdin\n ixs = range(4)\n for i in xrange(int(stdin.readline())):\n     print "Case #%i: " % (i+1),\n     rows = [stdin.readline()[:4] for i in ixs]\n \n     cols = [[row[i] for row in rows] for i in ixs]\n     diags = [\n         [rows[i][i] for i in ixs],\n         [rows[i][3-i] for i in ixs]\n     ]\n     notdone = False\n     for row in rows + cols + diags:\n         x = None\n         for t in row:\n             if t == '.':\n                 notdone = True\n                 break\n             elif t == 'T':\n                 continue\n             elif x is not None and x != t:\n                 break\n             else:\n                 x = t\n         else:\n             print x, "won"\n             break\n     else:\n         if notdone: print "Game has not completed"\n         else:       print "Draw"\n \n     stdin.readline()\n
pek	<>	22	<>	2014_2974486_5690574640250880.py	<>	import sys\n \n lines = [line.strip() for line in open(sys.argv[1])]\n count = int(lines[0])\n \n for i in xrange(count):\n     R,C,M = map(int, lines[i+1].split())\n     print "Case #%s:" % (i+1)\n \n     w = max(R,C)\n     h = min(R,C)\n     X = R*C - M\n     assert X > 0\n \n     if X == 1:\n         rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\n     elif h == 1:\n         rows = ['c' + '.' * (X-1) + '*' * M]\n     elif X == 4:\n             rows = [\n                 'c.' + '*' * (w-2),\n                 '..' + '*' * (w-2),\n             ] + ['*' * w] * (h-2)\n     elif h == 2:\n         if X%2 == 1 or X == 2:\n             rows = None\n         else:\n             rows = [\n                 'c' + '.' * (X/2-1) + '*' * (M/2),\n                 '.' + '.' * (X/2-1) + '*' * (M/2)\n             ]\n     elif X <= 5 or X == 7:\n         rows = None\n \n     elif X%2 == 0 and X <= w*2:\n         r = X/2\n         rows = [\n             'c' + '.' * (r - 1) + '*' * (w-r),\n                   '.' * r       + '*' * (w-r),\n         ] + ['*' * w] * (h-2)\n \n     elif X <= w*3 and (X % 3) != 1:\n         n = (X+1) / 3\n         t = X - 2*n\n         rows = [\n             'c' + '.' * (n-1) + '*' * (w-n),\n                   '.' * n     + '*' * (w-n),\n                   '.' * t     + '*' * (w-t)\n         ] + ['*' * w] * (h-3)\n     else:\n         n = X / w\n         t = X % w\n         if t == 1:\n             rows = (\n                     ['c' + (w-1) * '.']\n                 +   ['.' * w] * (n-2)\n                 +   ['.' * (w-1) + '*']\n                 +   ['..' + '*' * (w-2)]\n                 +   ['*' * w] * (h - n - 1)\n             )\n         else:\n             k = 1 if t == 0 else 0\n             rows = (\n                     ['c' + (w-1) * '.']\n                 +   ['.' * w] * (n-1)\n                 +   ['.' * t + '*' * (w-t)] * (1 - k)\n                 +   ['*' * w] * (h - n - 1 + k)\n             )\n \n     if rows:\n         if R > C:\n             rows = ["".join(row[i] for row in rows) for i in xrange(R)]\n \n         for row in rows:\n             print row\n \n         assert len(rows) == R\n         assert len(rows[0]) == C\n         assert sum(1 for row in rows for col in row if col == '*') == M\n \n     else:\n         print "Impossible"\n \n
pyronimous	<>	23	<>	2013_2270488_2463486.py	<>	import math\n \n fin = open('C-small-attempt0.in', 'r')\n fout = open('ass3.out', 'w')\n \n T = int(fin.readline())\n \n def perfsq(n):\n     sq = int(math.sqrt(n))\n     if n == sq * sq:\n         return sq\n     return 0\n \n def palindrome(n):\n     s = str(n)\n     return (s == s[::-1])\n \n def getpal(n):\n     if n == 1:\n         for i in range(10):\n             yield i\n     else:\n         n2 = n / 2\n         for x in xrange(10 ** (n2 - 1), 10 ** n2):\n             s = str(x)\n             if n % 2:\n                 for i in range(10):\n                     ns = s + str(i) + s[::-1]\n                     yield int(ns)\n             else:\n                 ns = s + s[::-1]\n                 yield int(ns)\n \n for i in range(T):\n     A, B = map(int, fin.readline().split())\n \n     ret = 0\n     for j in range(len(str(A)), len(str(B)) + 1):\n         for x in getpal(j):\n             if x < A:\n                 continue\n             if x > B:\n                 break\n             sq = perfsq(x)\n             if sq and palindrome(sq):\n                 ret += 1\n     fout.write('Case #%i: %i\n' % (i + 1, ret))\n
pyronimous	<>	23	<>	2013_2270488_2449486.py	<>	fin = open('B-small-attempt0.in', 'r')\n fout = open('ass2.out', 'w')\n \n \n T = int(fin.readline())\n \n def check(lawn, r, c):\n     h, v = True, True\n     for i in range(len(lawn[0])):\n         if i == c:\n             continue\n         if lawn[r][i] > lawn[r][c]:\n             h = False\n             break\n     for i in range(len(lawn)):\n         if i == r:\n             continue\n         if lawn[i][c] > lawn[r][c]:\n             v = False\n     return (h or v)\n \n for i in range(T):\n     N, M = map(int, fin.readline().split())\n     lawn = []\n     for j in range(N):\n         lawn.append( map(int, fin.readline().split()) )\n \n     n = i + 1\n     ret = True\n     for j in range(len(lawn)):\n         if not ret: break\n         for k in range(len(lawn[0])):\n             if not check(lawn, j, k):\n                 ret = False\n                 fout.write('Case #%i: NO\n' % n)\n                 break\n     if ret:\n         fout.write('Case #%i: YES\n' % n)
pyronimous	<>	23	<>	2012_1460488_1483488.py	<>	input_file = 'C-small-attempt4.in'\n #input_file = 'c_sample.in'\n output_file = 'c.out'\n \n \n def solvecase(inp):\n 	A, B = [int(n) for n in inp.split()]\n 	\n 	def shift(s):\n 		return s[-1] + s[:-1]\n 	\n 	ret = 0\n 	for n in range(A, B + 1):\n 		sn = str(n)\n 		sm = sn\n 		rep = []\n 		for i in range(len(sn) - 1):\n 			sm = shift(sm)\n 			if not (sm in rep) and (B >= int(sm) > n):\n 				ret += 1\n 				rep.append(sm)\n 	return ret\n \n \n lines = open(input_file, 'r').readlines()\n out = open(output_file, 'w')\n \n for i, l in enumerate(lines[1:]):\n 	sout = 'Case #%i: %i' % (i + 1, solvecase(l))\n 	print sout\n 	out.write(sout + '\n')\n \n out.close()\n
pyronimous	<>	23	<>	2014_2974486_5756407898963968.py	<>	\n \n INPUT = 'A-small-attempt0.in'\n OUTPUT = 'A-small-attempt0.out'\n \n \n def solve(answer1, arr1, answer2, arr2):\n     ret = None\n \n     for card in arr1[answer1 - 1]:\n         if card in arr2[answer2 - 1]:\n             if ret is not None:\n                 return 'Bad magician!'\n             else:\n                 ret = card\n     if ret is None:\n         return 'Volunteer cheated!'\n     return ret\n \n if __name__ == '__main__':\n     inp = open(INPUT)\n     out = open(OUTPUT, 'w')\n     \n     T = int(inp.readline())\n \n     def read_answer_and_arr():\n         answer = int(inp.readline())\n         arr = []\n         for i in range(4):\n             arr.append( map(int, inp.readline().split()) )\n         return answer, arr\n \n     for case in range(T):\n         answer1, arr1 = read_answer_and_arr()\n         answer2, arr2 = read_answer_and_arr()\n \n         out.write('Case #%i: %s\n' % \\n                         (case + 1, solve(answer1, arr1, answer2, arr2)))\n
pyronimous	<>	23	<>	2012_1460488_1483485.py	<>	\n input_file = 'A-small-attempt0.in'\n output_file = 'a_out'\n \n googlerese = ''.join([\n 	'ejp mysljylc kd kxveddknmc re jsicpdrysi',\n 	'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',\n 	'de kr kd eoya kw aej tysr re ujdr lkgc jv',\n 	'y qee', 'z'\n ])\n \n english = ''.join([\n 	'our language is impossible to understand',\n 	'there are twenty six factorial possibilities',\n 	'so it is okay if you want to just give up',\n 	'a zoo', 'q'\n ])\n \n alphabet = {}\n \n for g, e in zip(googlerese, english):\n 	alphabet[g] = e\n \n lines = open(input_file, 'r').readlines()\n out = open(output_file, 'w')\n \n for i, l in enumerate(lines[1:]):\n 	trans = 'Case #%i: %s' % (\n 		i + 1, \n 		''.join([alphabet[c] for c in l if c in alphabet]))\n 	print trans\n 	out.write(trans + '\n')\n \n out.close()\n \n 	\n 	\n \n
pyronimous	<>	23	<>	2014_2974486_5709773144064000.py	<>	\n \n INPUT = 'B-small-attempt1.in'\n OUTPUT = 'B-small-attempt1.out'\n \n \n def solve(C, F, X):\n \n     cps = 2.0\n     farm_time = 0.0\n     time = X / cps\n     \n     while True:\n         farm_time += C / cps\n         cps += F\n         ntime = farm_time + X / cps\n         if ntime < time:\n             time = ntime\n         else:\n             break\n     return time\n \n \n if __name__ == '__main__':\n     inp = open(INPUT)\n     out = open(OUTPUT, 'w')\n     \n     T = int(inp.readline())\n \n     for case in range(T):\n         sol = solve(*map(float, inp.readline().split()))\n         out.write('Case #%i: %.7f\n' % (case + 1, sol))
pyronimous	<>	23	<>	2013_2270488_2453486.py	<>	\n fin = open('A-small-attempt0.in', 'r')\n fout = open('ass1.out', 'w')\n \n N = int(fin.readline())\n \n for i in range(N):\n     field = []\n     for j in range(4):\n         field.append(fin.readline())\n     fin.readline()\n \n     for j in range(4):\n         field.append([field[ln][j] for ln in range(4)])\n     field.append([field[x][x] for x in range(4)])\n     field.append([field[x][3 - x] for x in range(4)])\n \n     \n     hasdot = False\n     winner = None\n     for ln in field:\n         if '.' in ln:\n             hasdot = True\n             continue\n         if 'X' in ln and not ('O' in ln):\n             winner = 'X'\n             break\n         if 'O' in ln and not ('X' in ln):\n             winner = 'O'\n             break\n     n = i + 1\n     if not (winner or hasdot):\n         fout.write('Case #%i: Draw\n' % n)\n     elif not winner and hasdot:\n         fout.write('Case #%i: Game has not completed\n' % n)\n     else:\n         fout.write('Case #%i: %s won\n' % (n, winner))
pyronimous	<>	23	<>	2014_2974486_5690574640250880.py	<>	\n \n INPUT = 'C-small-attempt0.in'\n OUTPUT = 'C-small-attempt0.out'\n \n \n def solve(R, C, M):\n     grid = [[0 for c in range(C)] for r in range(R)]\n \n     def get_cell(cell_r, cell_c):\n         if not(0 <= cell_r < R):\n             return None\n         if not(0 <= cell_c < C):\n             return None\n         return grid[cell_r][cell_c]\n \n     def for_each_neighbour(cell_r, cell_c, func):\n         ret = []\n         coords = (\n             (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\n             (cell_r, cell_c - 1), (cell_r, cell_c + 1),\n             (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\n         )\n         for nb in coords:\n             if get_cell(nb[0], nb[1]) is not None:\n                 ret.append(func(nb[0], nb[1]))\n         return ret\n \n     def mark_dirty(cell_r, cell_c):\n         if grid[cell_r][cell_c] != '*':\n             grid[cell_r][cell_c] += 1\n     \n     def unmark_dirty(cell_r, cell_c):\n         if grid[cell_r][cell_c] != '*':\n             grid[cell_r][cell_c] -= 1\n \n     def check_empty_neighbours(cell_r, cell_c):\n         return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\n \n     def click():\n         for i, row in enumerate(grid):\n             for j, cell in enumerate(row):\n                 if cell != '*':\n                     if cell == 0 or ((R * C - M) == 1):\n                         grid[i][j] = 'c'\n                         return\n \n     def place_mine():\n         for i, row in enumerate(grid):\n             for j, cell in enumerate(row):\n                 if cell == '*':\n                     continue\n                 prevstate = grid[i][j]\n                 grid[i][j] = '*'\n                 for_each_neighbour(i, j, mark_dirty)\n                 if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\n                     grid[i][j] = prevstate\n                     for_each_neighbour(i, j, unmark_dirty)\n                 else:\n                     return True\n         return False\n \n     for m in range(M):\n         if not place_mine():\n             return 'Impossible\n'\n \n     click()\n \n     ret = ''\n     for row in grid:\n         ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\n'\n \n     return ret\n \n \n if __name__ == '__main__':\n     inp = open(INPUT)\n     out = open(OUTPUT, 'w')\n     \n     T = int(inp.readline())\n \n     for case in range(T):\n         sol = solve(*map(int, inp.readline().split()))\n         out.write('Case #%i:\n%s' % (case + 1, sol))
bastiandantilus	<>	24	<>	2013_2270488_2463486.py	<>	import sys\n import math\n \n def is_square(n):\n     if n in square:\n         return True\n     if is_fair(n):\n         root = int(math.sqrt(n))\n         if root**2 != n:\n             return False\n         ss = is_fair(root)\n         if ss: square.add(n)\n         return ss\n     return False\n \n def is_fair(n):\n     if n in fair:\n         return True\n     if n in unfair:\n         return False\n     sn = str(n)\n     l = len(sn)\n     mid = math.ceil(n/2)\n     if sn[0:mid] == sn[mid::-1]:\n         fair.add(n)\n         return True\n     else:\n         unfair.add(n)\n         return False\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n             \n     fair = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])\n     unfair = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n     square = set([1, 4])\n \n     t = int(f.readline())\n     for _t in range(t):\n         s = f.readline()\n         if s:\n             x, y = s.split()\n             Total = sum([is_square(n) for n in range(int(x), int(y)+1)])             \n             print ("Case #" + str(_t+1) + ": " + str(Total))\n     \n \n
bastiandantilus	<>	24	<>	2013_2270488_2449486.py	<>	import sys\n \n def decode_data(input, x, y, z):\n     rotated = zip(*input[::-1])\n     #for row in rotated:\n         #print (row)\n     #for row in input:\n         #print (row)\n     for i in range(x):\n         for j in range(y):\n             if not input[i][j] == "1":\n                 continue            \n             if sum((int(xx) for xx in input[i])) != y and \\n                sum((int(xx) for xx in rotated[j])) != x:\n                 return "NO"\n     return "YES"\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     for _t in range(t):\n         x, y = f.readline().split()\n         s = [f.readline().split() for i in range(int(x))]\n         print ("Case #" + str(_t+1) + ": " + decode_data(s, int(x), int(y), 2))\n     \n \n
bastiandantilus	<>	24	<>	2012_1460488_1483488.py	<>	import sys\n \n def digits(number, base = 10):\n   while number:\n     yield number % base\n     number //= base\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())    \n     for _t in range(t):\n         s = f.readline()\n         s = s.split()\n         A = int(s[0])\n         B = int(s[1])\n         score = 0\n         #print (A, B, [x for x in range(A, B)][-1])\n         for i in range(A, B):\n             #print (A, B, [x for x in range(i+1, B+1)][-1])\n             for j in range(i+1, B+1):\n                 id = [d for d in digits(i)]\n                 jd = [d for d in digits(j)]\n                 if  sorted(id) == sorted(jd):\n                     checklist = [jd[n:] + jd[:n] for n in range(len(id))]\n                     if id in checklist:\n                         score +=1\n                     #print(checklist)\n         print ("Case #" + str(_t+1) + ": " + str(score))\n     \n \n
bastiandantilus	<>	24	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     for _t in range(t):\n         X = int(f.readline())\n         cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\n         row = cardsX[X-1]\n         Y = int(f.readline())\n         cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\n         column = cardsY[Y-1]\n         card = [x for x in row if x in column]\n         if len(card) > 1:\n             answer = "Bad magician!"\n         elif len(card) == 0:\n             answer = "Volunteer cheated!"\n         else:\n             answer = str(card[0])\n         print ("Case #" + str(_t+1) + ": " + answer)\n     \n \n
bastiandantilus	<>	24	<>	2012_1460488_1483485.py	<>	import sys\n \n library = {'a': 'y', 'o': 'e', 'z': 'q', 'q' : 'z'}\n \n def parse_example(input, output):\n     for key, value in zip(input, output):\n         library[key] = value\n \n parse_example("ejp mysljylc kd kxveddknmc re jsicpdrysi", "our language is impossible to understand")\n parse_example("rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd", "there are twenty six factorial possibilities")\n parse_example("de kr kd eoya kw aej tysr re ujdr lkgc jv", "so it is okay if you want to just give up")\n \n def decode_data(input):\n     output = ""\n     for letter in input:\n         if letter in library:\n             output += library[letter]\n     return output\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     d = {'O':0, 'B':1}\n     for _t in range(t):\n         s = f.readline()\n         print ("Case #" + str(_t+1) + ": " + decode_data(s))\n     \n \n
bastiandantilus	<>	24	<>	2014_2974486_5709773144064000.py	<>	import sys\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     for _t in range(t):\n \n         C, F, X = [float(x) for x in f.readline().split()]\n \n         base = X / 2.0\n \n         new_strategy = old_strategy = base\n         time_building = 0\n         farms = 0\n         fastest_speed = 2\n         while new_strategy <= old_strategy:\n             old_strategy = new_strategy\n             time_building += C / fastest_speed\n             farms += 1\n             fastest_speed += F\n             new_strategy = time_building + X / fastest_speed\n             \n         \n         print ("Case #" + str(_t+1) + ": " + str(old_strategy))\n     \n \n
bastiandantilus	<>	24	<>	2013_2270488_2453486.py	<>	import sys\n \n def decode_data(input):\n     output = ""\n     Total = 0\n     for row in input:\n         T = row.count("T")\n         X = row.count("X")\n         O = row.count("O")\n         #print (row, T, X, O, Total)\n         if X + T == 4:\n             return "X won"\n         elif O + T == 4:\n             return "O won"\n         else:\n             Total += T + X + O\n             \n     rotated = zip(*input[::-1])\n     for row in rotated:\n         T = row.count("T")\n         X = row.count("X")\n         O = row.count("O")\n         if X + T == 4:\n             return "X won"\n         elif O + T == 4:\n             return "O won"\n \n     row = [input[x][x] for x in range(4)]\n     row.count("T")\n     X = row.count("X")\n     O = row.count("O")\n     if X + T == 4:\n         return "X won"\n     elif O + T == 4:\n         return "O won"\n \n     row = [input[3-x][x] for x in range(4)]\n     T = row.count("T")\n     X = row.count("X")\n     O = row.count("O")\n     if X + T == 4:\n         return "X won"\n     elif O + T == 4:\n         return "O won"\n \n     if Total < 16:\n         return "Game has not completed"\n     else:\n         return "Draw"\n     return output\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     for _t in range(t):\n         s = [f.readline() for i in range(4)]\n         print ("Case #" + str(_t+1) + ": " + decode_data(s))\n         f.readline()\n     \n \n
bastiandantilus	<>	24	<>	2014_2974486_5690574640250880.py	<>	import sys\n import pprint\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     for _t in range(t):\n \n         R, C, M = [int(x) for x in f.readline().split()]\n         free_spots = R * C - M - 1\n \n         if M == 0:\n             answer = [["." for x in range(C)] for y in range(R)]\n             answer[0][0] = "c"\n         elif R == 1:\n             answer = [["c"] + ["." for x in range(free_spots)] + ["*" for m in range(M)]]\n         elif C == 1:\n             answer = [["c"] + ["." for x in range(free_spots)] + ["*" for m in range(M)]]\n             answer = zip(*answer[::-1])\n         elif free_spots >= 3: # and M % R >= 2:\n             answer = [["*" for x in range(C)] for y in range(R)]\n             answer[0][0] = "c"\n             answer[0][1] = "."\n             answer[1][1] = "."\n             answer[1][0] = "."\n             free_spots -= 3\n             tr, br, c = 0, 1, 2\n             if c >= C:\n                 tr, br, c = 2, 3, 0\n             for _i in range(free_spots):\n                 #pprint.pprint(answer)\n                 if answer[tr][c] == "*":\n                     answer[tr][c] = "."\n                 elif answer[br][c] == "*":\n                     answer[br][c] = "."\n                     if c < C-1:\n                         c+=1\n                     else:\n                         tr, br = tr + 2, br + 2\n                         c = 0\n                         if br == R:\n                             br, tr = br-1, tr-1\n                 \n         else:\n             answer = ["Impossible",]\n \n         \n         \n         print ("Case #" + str(_t+1) + ":")\n         for _i in answer:\n             print "".join(_i)\n     \n \n
ronnodas	<>	25	<>	2013_2270488_2449486.py	<>	T = int(input().strip())\n \n for case in range(1,T+1):\n     N,M = [int(x) for x in input().strip().split()]\n     lawn = []\n     for r in range(N):\n         lawn.append([int(x) for x in input().strip().split()])\n     rmax = [max(row) for row in lawn]\n     cmax = [max(lawn[r][c] for r in range(N)) for c in range(M)]\n     ans = all(lawn[r][c] == min(rmax[r],cmax[c]) for r in range(N) for c in range(M))\n     ans = "YES" if ans else "NO"\n     print("Case #",case,": ",ans,sep = '')\n
ronnodas	<>	25	<>	2012_1460488_1483488.py	<>	T=int(input())\n for t in range(T):\n     a,b = [int(x) for x in input().split()]\n     count = 0\n     l = [0 for i in range(a,b+1)]\n     for n in range(a,b):\n         if l[n-a]:\n             continue\n         l[n-a]=1\n         ms = set()\n         s = str(n)\n         for i in range(len(s)):\n             m = int(s[i:]+s[:i])\n             if n<m<=b:\n                 l[m-a]=1\n                 ms.add(m)\n         case = len(ms)\n         count+= (case*(case+1))//2\n     print('Case #',t+1,': ',count,sep = '')\n
ronnodas	<>	25	<>	2014_2974486_5756407898963968.py	<>	T = int(input())\n for case in range(1,T+1):\n     row1 = int(input())\n     for i in range(1,5):\n         l = input()\n         if i==row1:\n             first = set(int(x) for x in l.split())\n     row2 = int(input())\n     for i in range(1,5):\n         l = input()\n         if i==row2:\n             second = set(int(x) for x in l.split())\n     poss = first & second\n     if len(poss) ==0:\n         ans = 'Volunteer cheated!'\n     elif len(poss) >1:\n         ans = 'Bad magician!'\n     else:\n         ans = min(poss)\n     print("Case #",case,": ",ans,sep = '')\n
ronnodas	<>	25	<>	2012_1460488_1483485.py	<>	sub = {}\n sub['y']='a'\n sub['e']='o'\n sub['q']='z'\n sub[' ']=' '\n sub['z'] = 'q'\n \n pairs = [('ejp mysljylc kd kxveddknmc re jsicpdrysi','our language is impossible to understand'), ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd','there are twenty six factorial possibilities'), ('de kr kd eoya kw aej tysr re ujdr lkgc jv','so it is okay if you want to just give up')]\n \n for (j,(a,b)) in enumerate(pairs):\n   for i in range(len(a)):\n     sub[a[i]] = b[i]\n     #print(a[i],b[i])\n \n #print(''.join(sorted(sub.keys())))\n #print(''.join(sorted(sub.values())))\n \n T=int(input())\n for i in range(T):\n   s = input().strip()\n   new = ''.join([sub[c] for c in s])\n   print('Case #',i+1,': ',new,sep = '')\n \n \n
ronnodas	<>	25	<>	2014_2974486_5709773144064000.py	<>	from decimal import Decimal\n \n T = int(input())\n for case in range(1,T+1):\n     C,F,X = (Decimal(x) for x in input().split())\n     \n     ans = X/2\n     time,rate = 0,2\n     while True:\n         if time >= ans:\n             break\n         ans = min(ans,(X/rate)+time)\n         time,rate = time+(C/rate),rate+F\n     print("Case #",case,": ",ans,sep = '')\n
ronnodas	<>	25	<>	2013_2270488_2453486.py	<>	T = int(input().strip())\n \n def check(s,ans):\n     #print(s,ans)\n     if '.' in s:\n         return ans if ans < 2 else 3\n     if 'O' not in s:\n         return 0\n     if 'X' not in s:\n         return 1\n     return ans\n \n for case in range(1,T+1):\n     ans = 2\n     answers = ["X won", "O won", "Draw", "Game has not completed"]\n     board = [0]*4\n     for r in range(4):\n         board[r] = input().strip()\n     input()\n     for row in board:\n         ans = check(row,ans)\n     for c in range(4):\n         col = ''.join(board[r][c] for r in range(4))\n         ans = check(col,ans)\n     diag = ''.join(board[r][r] for r in range(4))\n     ans = check(diag,ans)\n     diag = ''.join(board[r][3-r] for r in range(4))\n     ans = check(diag,ans)\n     print("Case #",case,": ",answers[ans],sep = '')\n
ronnodas	<>	25	<>	2014_2974486_5690574640250880.py	<>	T = int(input())\n \n def solve(R,C,M):\n     # print('solving',R,C,M)\n     if R>C:\n         flipboard = solve(C,R,M)\n         if flipboard:\n             return [[flipboard[j][i] for j in range(C)] for i in range(R)]\n         else:\n             return\n     if M==0:\n         board = [['.']*C for i in range(R)]\n         board[-1][-1] = 'c'\n         return board\n     if R == 1:\n         board = ['*' if i<M else '.' for i in range(R*C)]\n         board[-1] = 'c'\n         return [board]\n     if R == 2:\n         if R*C==M+1:\n             board = [['*']*C for i in range(R)]\n             board[-1][-1] = 'c'\n             return board\n         if (M%2) or (M+2)==(R*C):\n             return\n         board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\n         board[-1][-1] = 'c'\n         return board\n     if M>=R:\n         subboard = solve(R,C-1,M-R)\n         if subboard:\n             return [['*']+r for r in subboard]\n         return\n     if (R,C,M) == (3,3,2):\n         return\n     k = min(M,C-2)\n     board = [['*']*k+['.']*(C-k)]\n     for i in range(M-k):\n         board.append(['*']+['.']*(C-1))\n     while len(board)<R:\n         board.append(['.']*(C))\n     board[-1][-1] = 'c'\n     return board\n     \n          \n     \n \n for case in range(1,T+1):\n     print("Case #",case,": ",sep='')\n     R,C,M = (int(x) for x in input().split())\n     ans = solve(R,C,M)\n     if ans:\n         for r in ans:\n             print(''.join(r))\n     else:\n         print('Impossible')\n \n \n # for M in range(36):\n #     ans = solve(6,6,M)\n #     if ans:\n #         for r in ans:\n #             print(''.join(r))\n #     else:\n #         print('Impossible')\n
j4b	<>	26	<>	2013_2270488_2463486.py	<>	#!/usr/bin/python\n \n import sys\n import functools\n import operator\n import math\n \n def isPal(n):\n     l = str(n)\n     return l == l[::-1]\n \n def solve(a, b):\n     l = int(math.ceil(math.sqrt(a)))\n     u = int(math.floor(math.sqrt(b)))\n \n     count = 0\n     for x in range(l, u + 1):\n         if isPal(x):\n             if isPal(x*x):\n                 count += 1\n     return str(count)\n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n         result = solve(a, b)\n         print ("Case #%s: %s" % (i+1, result))\n \n         # use something like:\n         # sys.stdin.readline()\n         # [int(x) for x in sys.stdin.readline().split()]\n \n \n if __name__ == '__main__':\n     main()\n
j4b	<>	26	<>	2012_1460488_1483488.py	<>	#!/usr/bin/python\n \n import sys\n import functools\n import operator\n \n \n def solve(a,b):\n     num_recycled = 0\n     for n in range(a, b+1):\n         s = str(n)\n         pairs = []\n         for i in range(1,len(s)):\n             m = int(s[i:] + s[:i])\n             #print("checking " + str(m))\n             if n < m and m <= b and m not in pairs:\n                 num_recycled += 1\n                 pairs.append(m)\n     return num_recycled\n         \n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         [a, b] = [int(x) for x in sys.stdin.readline().split()]\n         result = solve(a,b)\n         print ("Case #%s: %s" % (i+1, result))\n \n \n if __name__ == '__main__':\n     main()\n
j4b	<>	26	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/python\n \n import sys\n import functools\n import operator\n import math\n from itertools import chain, combinations\n from heapq import heappop, heappush, _siftup\n \n def solve(row1, row2):\n     common = [x for x in row1 if x in row2]\n     num_common = len(common)\n     if num_common == 0:\n         return 'Volunteer cheated!'\n     elif num_common > 1:\n         return 'Bad magician!'\n     else:\n         return common[0]\n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         row_index1 = int(sys.stdin.readline())\n         row1 = list()\n         for j in range(4):\n             if row_index1 == j + 1:\n                 row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n             else:\n                 sys.stdin.readline()\n \n         row_index2 = int(sys.stdin.readline())\n         row2 = list()\n         for j in range(4):\n             if row_index2 == j + 1:\n                 row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n             else:\n                 sys.stdin.readline()\n \n         result = solve(row1, row2)\n         print ("Case #%s: %s" % (i+1, result))\n \n if __name__ == '__main__':\n     main()\n
j4b	<>	26	<>	2012_1460488_1483485.py	<>	#!/usr/bin/python\n \n import sys\n import functools\n import operator\n \n \n table = {'a': 'y',\n          'b': 'h',\n          'c': 'e',\n          'd': 's',\n          'e': 'o',\n          'f': 'c',\n          'g': 'v',\n          'h': 'x',\n          'i': 'd',\n          'j': 'u',\n          'k': 'i',\n          'l': 'g',\n          'm': 'l',\n          'n': 'b',\n          'o': 'k',\n          'p': 'r',\n          'q': 'z',\n          'r': 't',\n          's': 'n',\n          't': 'w',\n          'u': 'j',\n          'v': 'p',\n          'w': 'f',\n          'x': 'm',\n          'y': 'a',\n          'z': 'q',\n          ' ': ' ',\n          '\n': ''}\n \n def solve(s):\n     return ''.join([table[c] for c in s])\n         \n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         # use something like:\n         # sys.stdin.readline()\n         # [int(x) for x in sys.stdin.readline().split()]\n         result = solve(sys.stdin.readline())\n         print ("Case #%s: %s" % (i+1, result))\n \n \n if __name__ == '__main__':\n     main()\n
j4b	<>	26	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/python\n \n import sys\n import functools\n import operator\n import math\n from itertools import chain, combinations\n from heapq import heappop, heappush, _siftup\n \n def solve(C, F, X):\n     rate = 2.0\n     time_to_win = X / rate\n \n     time_used = C / rate\n     rate += F\n     time_to_win_new = time_used + X / rate\n \n     while time_to_win_new < time_to_win:\n         time_to_win = time_to_win_new\n         \n         time_used += C / rate\n         rate += F\n         time_to_win_new = time_used + X / rate\n \n     return time_to_win\n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         [C, F, X] = [float(x) for x in sys.stdin.readline().rstrip().split()]\n \n         result = solve(C, F, X)\n         print ("Case #%s: %.7f" % (i+1, result))\n \n if __name__ == '__main__':\n     main()\n
j4b	<>	26	<>	2013_2270488_2453486.py	<>	#!/usr/bin/python\n \n import sys\n import functools\n import operator\n \n def result(l):\n     xcount = 0\n     ocount = 0\n     empty = False\n     for field in l:\n         if field == 'X' or field == 'T':\n             xcount += 1\n         if field == 'O' or field == 'T':\n             ocount += 1\n         if field == '.':\n             empty = True\n \n     if xcount == 4:\n         return 'X'\n     if ocount == 4:\n         return 'O'\n     if empty:\n         return '.'\n     else:\n         return ''\n \n def solve(M):\n     # check rows\n     empty = False\n     for i in range(4):\n         r = result(M[i])\n         if (r == 'X' or r == 'O'):\n             return r + ' won'\n         if r == '.':\n             empty = True\n \n     # check columns\n     for i in range(4):\n         r = result([M[j][i] for j in range(4)])\n         if (r == 'X' or r == 'O'):\n             return r + ' won'\n \n     # check diagonals\n     r = result([M[i][i] for i in range(4)])\n     if (r == 'X' or r == 'O'):\n         return r + ' won'\n     r = result([M[i][3-i] for i in range(4)])\n     if (r == 'X' or r == 'O'):\n         return r + ' won'\n \n     # determine whether it's a draw\n     if empty:\n         return 'Game has not completed'\n     else:\n         return 'Draw'\n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         M = []\n         for j in range(4):\n             M += [list(sys.stdin.readline().rstrip())]\n         sys.stdin.readline()\n         result = solve(M)\n         print ("Case #%s: %s" % (i+1, result))\n \n if __name__ == '__main__':\n     main()\n
j4b	<>	26	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/python\n \n import sys\n import functools\n import operator\n import math\n from itertools import chain, combinations\n from heapq import heappop, heappush, _siftup\n \n def neighbours(grid, (i, j), n, m):\n     for a in range(max(i-1, 0), min(i+2, n)):\n         for b in range(max(j-1, 0), min(j+2, m)):\n             if (a != i or b != j):\n                 yield (a, b)\n \n def isGridCorrect(grid):\n     g = list(grid)\n     n = len(g)\n     m = len(g[0])\n     queue = [(0, 0)]\n \n     while queue:\n         v = queue.pop(0)\n         g[v[0]][v[1]] = 'r'\n         bomb = False\n         for (i, j) in neighbours(g, v, n, m):\n             if g[i][j] == '*':\n                 bomb = True\n         if not bomb:\n             for (i, j) in neighbours(g, v, n, m):\n                 if g[i][j] != 'r':\n                     #print('append')\n                     queue.append((i, j))\n \n     for i in range(n):\n         for j in range(m):\n             if g[i][j] != 'r' and g[i][j] != '*':\n                 #print draw(g)\n                 return 'WRONG'\n \n     return 'Right'\n \n def createGrid(R, C, s):\n     field = []\n     for i in range(R):\n         field.append([s] * C)\n     field[0][0] = 'c'\n     return field\n \n def draw(grid):\n     s = ""\n     for row in grid:\n         s += "\n" + ''.join(row)\n     return s\n \n def reduceRows(grid, k, l, M):\n     if k <= 2:\n         return (grid, k, l, M)\n     \n     #num_rows = M / l\n     #lowest = max(k - num_rows, 2)\n     #num_rows = k - lowest\n \n     #print('k: ' + str(k))\n     #print('l: ' + str(l))\n     for j in range(l):\n         #print grid\n         #print i, j\n         grid[k-1][j] = '*'\n     k -= 1\n     M -= l\n     return (grid, k, l, M)\n \n def reduceCols(grid, k, l, M):\n     if l <= 2:\n         return (grid, k, l, M)\n     \n     #num_cols = M / k\n     #lowest = max(l - num_cols, 2)\n     #num_cols = l - lowest\n \n     for i in range(k):\n         grid[i][l-1] = '*'\n     l -= 1\n     M -= k\n     return (grid, k, l, M)\n \n def solve(R, C, M):\n     mp = M\n     if M == 0:\n         f = createGrid(R, C, '.')\n         #print(isGridCorrect(f))\n         return draw(f)\n     elif M == R*C - 1:\n         f = createGrid(R, C, '*')\n         #print(isGridCorrect(f))\n         return draw(f)\n     elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):\n         return "\n" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n     elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):\n         return "\n" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n     else:\n         grid = createGrid(R, C, '.')\n \n         #print('R: ' + str(R))\n         #print('C: ' + str(C))\n \n         k = R\n         l = C\n \n         while (M >= l and k > 2) or (M >= k and l > 2):\n             if l >= k:\n                 #print('l >= k')\n                 (grid, k, l, M) = reduceCols(grid, k, l, M)\n                 #print grid\n                 #print k, l, M\n             elif k > l:\n                 #print('k > l')\n                 (grid, k, l, M) = reduceRows(grid, k, l, M)\n                 #print grid\n                 #print k, l, M\n \n         #print(grid)\n         #print M\n \n         if M == 0:\n             #print(isGridCorrect(grid))\n             return draw(grid)\n         if M < l - 1 and k > 2:\n             for j in range(l - M, l):\n                 grid[k-1][j] = '*'\n         elif M < k - 1 and l > 2:\n             for i in range(k - M, k):\n                 grid[i][l-1] = '*'\n         elif l > 3 and k > 3:\n             for i in range(2, k):\n                 grid[i][l-1] = '*'\n             M -= k - 2\n             for j in range(l - M - 1, l - 1):\n                 grid[k-1][j] = '*'\n         else:\n             return "\n" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n \n         #print(isGridCorrect(grid))\n         return draw(grid)\n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n \n         result = solve(R, C, M)\n         print ("Case #%s:%s" % (i+1, result))\n \n if __name__ == '__main__':\n     main()\n
anavaleije	<>	27	<>	2013_2270488_2463486.py	<>	import sys, math\n \n def isPalindrome(n):\n 	n = str(n)	\n 	for i in xrange(len(n)/2):\n 		if n[i] != n[(-i-1)]:\n 			return False\n 	return True\n \n ##########################################################\n # Main\n \n inputFileName = sys.argv[1]\n \n f = file(inputFileName)\n fout = file("output.txt", "w")\n \n T = eval(f.readline())\n \n for case in xrange(T):\n 	data = f.readline().split()\n 	A = eval(data[0])\n 	B = eval(data[1])\n \n 	i = A\n 	found = []\n 	while i <= B:\n 		if isPalindrome(i):\n 			sqrtI = math.sqrt(i)\n 			if sqrtI == int(sqrtI):\n 				if isPalindrome(int(sqrtI)):\n 					found.append(i)\n 		i += 1\n \n 	##### Output writing\n 	fout.write("Case #%d: %d\n" %(case + 1, len(found)))\n
anavaleije	<>	27	<>	2013_2270488_2449486.py	<>	import sys\n \n def testLine(i, lawn):\n 	return (2 not in lawn[i])\n \n def testColumn(j, lawn):\n 	possible = True\n 	for line in lawn:\n 		if line[j] == 2:\n 			possible = False\n 			break\n 	return possible\n \n ##########################################################\n # Main\n \n inputFileName = sys.argv[1]\n \n f = file(inputFileName)\n fout = file("output.txt", "w")\n \n T = eval(f.readline())\n \n for case in xrange(T):\n 	data = f.readline().split()\n 	N = eval(data[0])\n 	M = eval(data[1])\n 	possible = True\n 	if N == 1 or M == 1:\n 		for i in xrange(N):\n 			f.readline()\n 	else:\n 		lawn = []\n 		for i in xrange(N):\n 			line = f.readline().strip().split()\n 			for j in xrange(M):\n 				line[j] = eval(line[j])\n 			lawn.append(line)\n 		i = 0\n 		while i < N and possible:\n 			for j in xrange(M):\n 				if lawn[i][j] == 1:\n 					if not testLine(i, lawn):\n 						if not testColumn(j, lawn):\n 							possible = False\n 			i += 1\n \n 	##### Output writing\n 	fout.write("Case #%d: " %(case + 1))\n 	if possible:\n 		fout.write("YES\n")\n 	else:\n 		fout.write("NO\n")\n
anavaleije	<>	27	<>	2012_1460488_1483488.py	<>	def find_recycled(n, b):\n 	ns = str(n)\n 	reclist = []\n 	for i in xrange(1, len(ns), 1):\n 		nrec = ns[i:len(ns)] + ns[0:i]\n 		if nrec[0] != "0":\n 			nrec = eval(nrec)\n 			if nrec <= b and nrec > n and (n, nrec) not in reclist:\n 				reclist.append((n,nrec))\n 	return len(reclist)\n \n inp = file("input.in")\n T = eval(inp.readline())\n out = file("output.txt", "w")\n \n for i in xrange(T):\n 	a, b = inp.readline().strip().split()\n 	a = eval(a)\n 	b = eval(b)\n 	nrec = 0\n 	reclist = []\n 	for n in xrange(a, b):\n 		if n > 11:\n 			nrec += find_recycled(n, b)\n 	out.write("Case #%d: %d\n" %(i + 1, nrec))\n 			\n
anavaleije	<>	27	<>	2014_2974486_5756407898963968.py	<>	import sys	\n \n inputFileName = sys.argv[1]\n \n f = file(inputFileName)\n fout = file("output.txt", "w")\n \n T = eval(f.readline())\n \n for case in xrange(T):\n \n 	####First question\n 	A1 = int(f.readline().strip())\n \n 	for i in xrange(4):\n 		if i == A1 - 1:\n 			possibles1 = f.readline().strip().split(" ")\n 		else:\n 			f.readline().strip().split(" ")\n \n 	####Second question\n 	A2 = int(f.readline().strip())\n \n 	for i in xrange(4):\n 		if i == A2 - 1:\n 			possibles2 = f.readline().strip().split(" ")\n 		else:\n 			f.readline().strip().split(" ")\n \n 	final = []\n 	for item in possibles2:\n 		if item in possibles1:\n 			final.append(item)\n \n 	##### Output writing\n 	if len(final) == 0:	\n 		fout.write("Case #%d: Volunteer cheated!\n" %(case + 1))\n 	elif len(final) == 1:\n 		fout.write("Case #%d: %s\n" %(case + 1, final[0]))\n 	else:\n 		fout.write("Case #%d: Bad magician!\n" %(case + 1))\n
anavaleije	<>	27	<>	2012_1460488_1483485.py	<>	# Making up a dictionary\n # Sample\n googlerese = "ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv"\n english = "our language is impossible to understand there are twenty six factorial possibilities so it is okay if you want to just give up"\n # Hints\n d = {"y":"a", "e":"o", "q":"z"}\n \n for i in xrange(len(googlerese)):\n 	d[googlerese[i]] = english[i]\n \n # One letter still missing: z:q\n d["z"] = "q"\n \n inp = file("input.in")\n n = eval(inp.readline())\n out = file("output.txt", "w")\n \n for i in xrange(n):\n 	G = inp.readline().strip()\n 	S = ""\n 	for letter in G:\n 		S += d[letter]\n 	out.write("Case #%d: " %(i + 1) + S + "\n")\n
anavaleije	<>	27	<>	2014_2974486_5709773144064000.py	<>	import sys\n \n def oneMoreFarm(C, F, nFarms):\n 	return C/(2.0 + nFarms*F)\n 	\n \n ##########################################################\n # Main\n \n inputFileName = sys.argv[1]\n \n f = file(inputFileName)\n fout = file("output.txt", "w")\n \n T = int(f.readline().strip())\n \n for case in xrange(T):\n \n 	data = f.readline().split()\n 	C = eval(data[0])\n 	F = eval(data[1])\n 	X = eval(data[2])\n \n 	tmin = X/2.0\n 	foundMin = False\n \n 	S = 0\n 	nFarms = 0\n \n 	while not foundMin:\n 		nFarms += 1\n 		S += oneMoreFarm(C, F, nFarms - 1)\n 		t = S + X/(2.0 + nFarms*F)\n 		if t < tmin:\n 			tmin = t\n 		else:\n 			foundMin = True\n \n 	##### Output writing\n 	fout.write("Case #%d: %.7f\n" %(case + 1, tmin))\n
anavaleije	<>	27	<>	2014_2974486_5690574640250880.py	<>	import sys\n \n def transpose(result, R, C):\n 	resultSplitted = result.split("\n")\n 	aux = R*[""]\n 	for i in xrange(R):\n 		for j in xrange(C):\n 		    aux[i] += resultSplitted[j][i]\n 		aux[i] += "\n"\n 	result = ""\n 	for item in aux:\n 		result += item + "\n"\n 	return result.strip()\n \n ##########################################################\n # Main\n \n inputFileName = sys.argv[1]\n \n f = file(inputFileName)\n fout = file("output.txt", "w")\n \n T = int(f.readline())\n \n for case in xrange(T):\n 	data = f.readline().strip().split(" ")\n 	R = int(data[0])\n 	C = int(data[1])\n 	M = int(data[2])\n \n 	result = ""\n \n 	x = min(R,C)\n 	y = max(R,C)\n \n 	#if x == 2 and M%2 == 1 and M < R*C - 1:\n 	#	result = "Impossible"\n 	#elif x == 3 and M > y and M != R*C - 1:\n #		result = "Impossible"\n 	if M > (y - 2)*x and M != y*x - 1:\n 		N = M - (y-2)*x\n 		if N%2 == 1 or y*x - M == 2:\n 			result = "Impossible"\n 	if result != "Impossible":\n 		i = 0\n 		while M > 0: # 2\n 			if i < y - 2:\n 				if M >= x:\n 					result += x*"*" + "\n"\n 					M -= x\n 					i += 1\n 				elif M <= x - 2:\n 					result += M*"*" + (x - M) * "." + "\n"\n 					M = 0\n 					i += 1\n 				elif i + 2 < y - 1:\n 					result += (M-1)*"*" + (x - M + 1) * "." + "\n" + "*" + (x-1)*"." + "\n"\n 					M = 0\n 					i += 2\n 				else:\n 					result = "Impossible"\n 					break\n 			else:\n 				if M%2 != 0:\n 					result += x*"*" + "\n"\n 					result += (x-1)*"*" + "c"\n 				else:\n 					n = M/2\n 					result += n*"*" + (x-n)*"." + "\n"\n 					result += n*"*" + (x-n-1)*"." + "c"\n 				M = 0\n 				i += 2\n 					\n 		while i <= y - 1 and result != "Impossible":\n 			if i == y - 1:\n 				result += (x-1)*"." + "c"\n 			else:\n 				result += x*"." + "\n"\n 			i += 1\n 	\n 	if R < C and result != "Impossible":\n 		result = transpose(result, R, C)\n \n 	##### Output writing\n 	fout.write("Case #%d:\n%s\n" %(case + 1, result))\n
netsuso	<>	28	<>	2013_2270488_2463486.py	<>	#!/usr/bin/python3\n #\n # Some notes:\n # - It's better to find palindromes in the square rooted numbers (there will be a lot fewer)\n # - It's also much faster to generate the palindromes than to detect if a random number is a palindrome\n #   - Number of palindromes with n digits: 10^(ceil(n/2))\n #   - E.g, 3 digits => 10^2  -  4 digits => 10^2  -  5 digits => 10^3\n # - So the problem is reduced to generate the palindromes which are still palindromes when squared\n #\n # - And how to detect is a squared palindrome is still a palindrome? Easy, let's draw a multiplication:\n #          1 2 1\n #          1 2 1\n #       --------\n #          1 2 1\n #        2 4 2\n #      1 2 1\n #      ---------\n #      1 4 6 4 1\n #\n #   - The extreme case is the central column. If the sum is >=10, then resulting number will not be a palindrome\n #   - As the original number is a palindrome, this central column will always be the sum of the squares of all\n #     the digits in the number. E.g: 121 => 1^2 + 2^2 + 1^2 = 1 + 4 + 1 = 6 => less than 10 => square is a palindrome\n #   - This means that palindromes with digits 4-9 can never become a palindrome when squared\n #   - 3 can only appear once => 3 is the only valid number containing digit 3\n #   - 2 can appear at most twice:\n #     - 2 twos + 0/1 one (in this case 2 have to be the first and last digit)\n #     - 1 two + 0/2/4 ones (in this case 2 has to be in the middle position)\n #   - 1 can appear alone up to 9 times\n #   - 0 can appear as many times as you want\n #\n \n \n import sys\n import math\n \n # This is the same as findpalindromes, but much faster (it just calculates the combinations\n # instead of obtaining all the actual numbers)\n def calculatepalindromes(ndigits):\n     # Special case: only 1 digit\n     if ndigits == 1:\n         return 3\n \n     result = 0\n     isEven = ndigits % 2 == 0\n     fillingdigits = math.floor((ndigits - 2)/2)\n \n     # Palindromes with 2's\n     if isEven:\n         result += 1\n     else:\n         result += 3\n \n     # Palindromes with only 1's\n     for numones in range(0, min(6, fillingdigits) + 1):\n         combinations = int(math.factorial(fillingdigits) / (math.factorial(fillingdigits-numones) * math.factorial(numones)))\n         result += combinations\n         if not isEven:\n             result += combinations\n \n     return result\n \n \n def findpalindromes(ndigits):\n     # Special case: only 1 digit\n     if ndigits == 1:\n         return [1, 2, 3]\n \n     result = []\n     isEven = ndigits % 2 == 0\n     fillingdigits = math.floor((ndigits - 2)/2)\n \n     # Palindromes with 2's\n     if isEven:\n         result.append(int("2" + "0"*(fillingdigits*2) + "2"))\n     else:\n         result.append(int("2" + "0"*fillingdigits + "0" + "0"*fillingdigits + "2"))\n         result.append(int("2" + "0"*fillingdigits + "1" + "0"*fillingdigits + "2"))\n         result.append(int("1" + "0"*fillingdigits + "2" + "0"*fillingdigits + "1"))\n \n     # Palindromes with only 1's\n     for numones in range(0, min(6, fillingdigits)+1):\n         ones = fillOnes([], fillingdigits, numones)\n         for o in ones:\n             if isEven:\n                 result.append(int("1" + "".join(o) + "".join(list(reversed(o))) + "1"))\n             else:\n                 result.append(int("1" + "".join(o) + "0" + "".join(list(reversed(o))) + "1"))\n                 result.append(int("1" + "".join(o) + "1" + "".join(list(reversed(o))) + "1"))\n \n     return result\n \n def fillOnes(combination, size, remainingOnes):\n     if len(combination) == size:\n         return [combination]\n     result = []\n     if remainingOnes > 0:\n         c = combination + ["1"]\n         result += fillOnes(c, size, remainingOnes - 1)\n     if remainingOnes < size - len(combination):\n         c = combination + ["0"]\n         result += fillOnes(c, size, remainingOnes)\n     return result\n \n \n \n ncases = int(sys.stdin.readline())\n \n for t in range(1, ncases+1):\n     fairsquare = 0\n     (a, b) = sys.stdin.readline().strip().split(" ")\n     intA = int(a)\n     intB = int(b)\n     ndigitsA = len(a)\n     ndigitsB = len(b)\n     ndigitsARooted = math.ceil(ndigitsA/2)\n     ndigitsBRooted = math.ceil(ndigitsB/2)\n \n     if ndigitsBRooted == ndigitsARooted:\n         palindromes = findpalindromes(ndigitsARooted)\n         for p in palindromes:\n             if p ** 2 >= intA and p ** 2 <= intB:\n                 fairsquare +=1\n     else:\n         palindromes = findpalindromes(ndigitsARooted)\n         for p in palindromes:\n             if p ** 2 >= intA:\n                 fairsquare +=1\n \n         for i in range(ndigitsARooted + 1, ndigitsBRooted):\n             fairsquare += calculatepalindromes(i)\n \n         palindromes = findpalindromes(ndigitsBRooted)\n         for p in palindromes:\n             if p ** 2 <= intB:\n                 fairsquare +=1\n \n     print("Case #%d: %d" % (t, fairsquare))\n
netsuso	<>	28	<>	2013_2270488_2449486.py	<>	#!/usr/bin/python3\n \n import sys\n \n ncases = int(sys.stdin.readline())\n \n for t in range(1, ncases+1):\n     (n, m) = [int(x) for x in sys.stdin.readline().strip().split(" ")]\n     lawn = []\n     cuttable = []\n     for row in range(0, n):\n         lawn.append([int(x) for x in sys.stdin.readline().strip().split(" ")])\n         cuttable.append([False for x in range(0, m)])\n \n     # Find cuttable squares in rows\n     for row in range(0, n):\n         rowdata = lawn[row]\n         maxheight = max(rowdata)\n         for col in range(0, m):\n             if lawn[row][col] == maxheight:\n                 cuttable[row][col] = True\n \n     # Find cuttable squares in columns\n     for col in range(0, m):\n         coldata = [x[col] for x in lawn]\n         maxheight = max(coldata)\n         for row in range(0, n):\n             if lawn[row][col] == maxheight:\n                 cuttable[row][col] = True\n \n     # Find if there's any square that is not cuttable\n     result = True\n     for row in range(0, n):\n         for col in range(0, m):\n             if not cuttable[row][col]:\n                 result = False\n                 break\n         if result == False:\n             break\n \n     if result == False:\n         print("Case #%d: NO" % t)\n     else:\n         print("Case #%d: YES" % t)\n
netsuso	<>	28	<>	2012_1460488_1483488.py	<>	#!/usr/bin/python3\n \n import sys\n \n def findrecycled(num, A, B):\n 	strnum = str(num)\n 	results = {}\n 	for i in range(1, len(strnum)):\n 		strrecycled = strnum[i:] + strnum[0:i]\n 		recycled = int(strrecycled)\n 		if recycled > num and recycled >= A and recycled <= B:\n 			results["%d_%d" % (num, recycled)] = 1\n 	return len(results)\n \n # Ignore the number of cases\n sys.stdin.readline()\n \n casenum = 0\n for line in sys.stdin:\n 	casenum += 1\n \n 	data = line.strip().split(' ')\n 	A = int(data[0])\n 	B = int(data[1])\n \n 	count = 0\n 	for num in range(A, B):\n 		count += findrecycled(num, A, B)\n \n 	print("Case #%d: %d" % (casenum, count))\n
netsuso	<>	28	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/python3\n \n import sys\n \n ncases = int(sys.stdin.readline().strip())\n \n def read_arrangement():\n     arr = []\n     for row in range(0,4):\n         arr.append(sys.stdin.readline().strip().split(' '))\n     return arr\n \n for t in range(1, ncases+1):\n     answer1 = int(sys.stdin.readline().strip())\n     arrang1 = read_arrangement()\n     answer2 = int(sys.stdin.readline().strip())\n     arrang2 = read_arrangement()\n \n     row1 = arrang1[answer1-1]\n     row2 = arrang2[answer2-1]\n \n     intersect = set(row1) & set(row2)\n \n     if len(intersect) == 1:\n         print("Case #{0}: {1}".format(t, intersect.pop()))\n     elif len(intersect) == 0:\n         print("Case #{0}: Volunteer cheated!".format(t))\n     else:\n         print("Case #{0}: Bad magician!".format(t))\n
netsuso	<>	28	<>	2012_1460488_1483485.py	<>	#!/usr/bin/python3\n \n import sys\n \n reverseMappings = {\n 'a': 'y',\n 'b': 'h',\n 'c': 'e',\n 'd': 's',\n 'e': 'o',\n 'f': 'c',\n 'g': 'v',\n 'h': 'x',\n 'i': 'd',\n 'j': 'u',\n 'k': 'i',\n 'l': 'g',\n 'm': 'l',\n 'n': 'b',\n 'o': 'k',\n 'p': 'r',\n 'q': 'z',\n 'r': 't',\n 's': 'n',\n 't': 'w',\n 'u': 'j',\n 'v': 'p',\n 'w': 'f',\n 'x': 'm',\n 'y': 'a',\n 'z': 'q',\n ' ': ' '\n }\n \n def reverse(string):\n 	return ''.join([reverseMappings[c] for c in string])\n \n # Ignore number of tests\n sys.stdin.readline()\n \n casenum=0\n for line in sys.stdin:\n 	casenum += 1\n 	reversed = reverse(line.strip())\n 	print("Case #%d: %s" % (casenum, reversed))\n
netsuso	<>	28	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/python3\n \n import sys\n \n ncases = int(sys.stdin.readline().strip())\n \n for t in range(1, ncases+1):\n     values = sys.stdin.readline().split()\n     c = float(values[0])\n     f = float(values[1])\n     x = float(values[2])\n     r = 2\n \n     time = 0\n \n     while True:\n         tdirect = x/r\n         tfactory = c/r + x/(r+f)\n \n         if tdirect<tfactory:\n             time += tdirect\n             break\n         else:\n             time += c/r\n             r += f\n \n     print("Case #{0}: {1:.7f}".format(t, time))\n
netsuso	<>	28	<>	2013_2270488_2453486.py	<>	#!/usr/bin/python3\n \n import sys\n \n ncases = int(sys.stdin.readline())\n \n for t in range(1, ncases+1):\n     board = []\n     winner = False\n     numDots = 0\n \n     # Fill the board while finding the winning rows\n     for row in range(0, 4):\n         rowdata = sys.stdin.readline().strip()\n         board.append([])\n         numX = 0\n         numO = 0\n         for col in range(0, 4):\n             value = rowdata[col]\n             if value == ".":\n                 numDots += 1\n             if value == "X":\n                 numX += 1\n             if value == "O":\n                 numO += 1\n             if value == "T":\n                 numX += 1\n                 numO += 1\n             board[row].append(value)\n         if numX == 4:\n             winner = True\n             print("Case #%d: X won" % t)\n             break\n         if numO == 4:\n             winner = True\n             print("Case #%d: O won" % t)\n             break\n     while sys.stdin.readline().strip() != "": pass\n \n     if winner == True: continue\n \n     # Find columns\n     for col in range(0, 4):\n         numX = 0\n         numO = 0\n         for row in range(0, 4):\n             value = board[row][col]\n             if value == "X":\n                 numX += 1\n             if value == "O":\n                 numO += 1\n             if value == "T":\n                 numX += 1\n                 numO += 1\n         if numX == 4:\n             winner = True\n             print("Case #%d: X won" % t)\n             break\n         if numO == 4:\n             winner = True\n             print("Case #%d: O won" % t)\n             break\n \n     if winner == True: continue\n \n     # Find first diagonal\n     numX = 0\n     numO = 0\n     for rowcol in range(0, 4):\n         value = board[rowcol][rowcol]\n         if value == "X":\n             numX += 1\n         if value == "O":\n             numO += 1\n         if value == "T":\n             numX += 1\n             numO += 1\n     if numX == 4:\n         print("Case #%d: X won" % t)\n         continue\n     if numO == 4:\n         print("Case #%d: O won" % t)\n         continue\n \n     # Find second diagonal\n     numX = 0\n     numO = 0\n     for rowcol in range(0, 4):\n         value = board[rowcol][3-rowcol]\n         if value == "X":\n             numX += 1\n         if value == "O":\n             numO += 1\n         if value == "T":\n             numX += 1\n             numO += 1\n     if numX == 4:\n         print("Case #%d: X won" % t)\n         continue\n     if numO == 4:\n         print("Case #%d: O won" % t)\n         continue\n \n     # Final case\n     if numDots == 0:\n         print("Case #%d: Draw" % t)\n     else:\n         print("Case #%d: Game has not completed" % t)\n \n
netsuso	<>	28	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/python3\n #\n # Algorithm:\n # - For boards with one row: you need at least 1 free cells\n # - For boards with two rows, you need either 1 or at least 4 free cells\n #   - It needs to be an even number!\n # - For general boards, you need either 1 or at least 4 free cells (except 5 or 7)\n #\n # - To fill the board, you cannot have a row or a column with only one\n #   free cell, so you fill it in groups of two.\n #\n #   - First you start with the minimum of 4:\n #       c . * * * *\n #       . . * * * *\n #       * * * * * *\n #\n #   - Then you fill next columns and rows two by two:\n #       c . % * * *\n #       . . % * * *\n #       * * * * * *\n #\n #       c . . * * *\n #       . . . * * *\n #       % % * * * *\n #\n #       c . . % * *\n #       . . . % * *\n #       . . * * * *\n #\n #   - In case there's a pending free cell, you simply fill it in the inner board:\n #       c . . . * *\n #       . . . . * *\n #       . . % * * *\n #\n #   - In case you fill the outer border, you simply start filling the inner board:\n #       c . . . . %\n #       . . . . . %\n #       . . * * * *\n #\n #       c . . . . .\n #       . . . . . .\n #       . . % * * *\n #\n \n import sys\n \n ncases = int(sys.stdin.readline().strip())\n \n def print_board(r, c, free):\n     board = {}\n     for row in range(0, r):\n         board[row] = {}\n         for col in range(0, c):\n             board[row][col] = '*'\n \n     pending = free\n \n     if free == 1:\n         board[0][0] = '.'\n     elif r == 1 or c == 1:\n         for row in range(0, r):\n             for col in range(0, c):\n                 if pending > 0:\n                     pending -= 1\n                     board[row][col] = '.'\n     else:\n         for row in range(0,2):\n             for col in range(0,2):\n                 board[row][col] = '.'\n         pending -= 4\n         col=2\n         row=2\n \n         # First fill the outer border with groups of two\n         while pending >= 2 and (col<c or row<r):\n             if pending >= 2 and col<c:\n                 board[0][col] = '.'\n                 board[1][col] = '.'\n                 col += 1\n                 pending -= 2\n             if pending >= 2 and row<r:\n                 board[row][0] = '.'\n                 board[row][1] = '.'\n                 row += 1\n                 pending -= 2\n \n         # Now fill the inner board with the remaining free cells\n         for row in range(2, r):\n             for col in range(2, c):\n                 if pending > 0:\n                     board[row][col] = '.'\n                     pending -= 1\n \n     # The clicked one is always on the top left corner\n     board[0][0] = 'c'\n \n     # Finally print the board\n     for row in range(0, r):\n         line = ''\n         for col in range(0, c):\n             line += board[row][col]\n         print(line)\n \n \n for t in range(1, ncases+1):\n     values = sys.stdin.readline().strip().split()\n     r = int(values[0])\n     c = int(values[1])\n     m = int(values[2])\n \n     cells = r * c\n     free = cells - m\n \n     possible = False\n \n     if r == 1 or c == 1:\n         if free >= 1:\n             possible = True\n     elif r == 2 or c == 2:\n         if free == 1 or (free >= 4 and free%2 == 0):\n             possible = True\n     else:\n         if free == 1 or (free >= 4 and free != 5 and free != 7):\n             possible = True\n \n     print("Case #{0}:".format(t))\n \n     if possible:\n         print_board(r, c, free)\n     else:\n         print("Impossible")\n
binnie	<>	29	<>	2013_2270488_2463486.py	<>	import sys, itertools\n \n def get_generators_up_to_length_n(n):\n     generators = []\n     for ii in range(1, n + 1):\n         generators += get_generators_length_n(ii)\n     return generators        \n \n def get_generators_length_n(length):\n     if length % 2 == 0: return get_even_generators_length_n(length)\n     else: return get_odd_generators_length_n(length)\n \n def get_odd_generators_length_n(length):\n     if length == 1: return [1, 2, 3]\n     else: \n         n = length / 2\n         generators = []\n         for ii in range(min(n, 4)):\n             for comb in itertools.combinations(range(1, n), ii):\n                 first_half = ["1"] + ["0"] * (n-1)\n                 for jj in comb:\n                     first_half[jj] = "1"\n                 second_half = list(first_half)\n                 second_half.reverse()\n                 palin = first_half + ["0"] + second_half\n                 generators.append(int("".join([elem for elem in palin])))\n                 palin[n] = "1"\n                 generators.append(int("".join([elem for elem in palin])))\n                 if ii <= 1:\n                     palin[n] = "2"\n                     generators.append(int("".join([elem for elem in palin])))\n         generators.append(int("".join([elem for elem in (["2"] + ["0"] * (n - 1) + ["0"] + ["0"] * (n - 1) + ["2"])])))\n         generators.append(int("".join([elem for elem in (["2"] + ["0"] * (n - 1) + ["1"] + ["0"] * (n - 1) + ["2"])])))\n         generators.sort()\n         return generators\n \n def get_even_generators_length_n(length):\n     if length == 2: return [11, 22]\n     n = length / 2\n     generators = []\n     for ii in range(min(n, 4)):\n         for comb in itertools.combinations(range(1, n), ii):\n             first_half = ["1"] + ["0"] * (n-1)\n             for jj in comb:\n                 first_half[jj] = "1"\n             second_half = list(first_half)\n             second_half.reverse()\n             palin = first_half + second_half\n             generators.append(int("".join([elem for elem in palin])))\n     generators.append(int("".join([elem for elem in (["2"] + ["0"] * (length - 2) + ["2"])])))\n     generators.sort()\n     return generators\n \n def is_palin(num):\n     string = str(num)\n     length = len(string)\n     ii = 0\n     while ii < length/2:\n         if string[ii] != string[-(1+ii)]:\n             return False\n         ii += 1\n     return True\n \n def gen_fair_and_squares(upper_limit):\n     fair_and_squares = []\n     for ii in range(1, upper_limit + 1):\n         if (is_palin(ii) and is_palin(ii*ii)):\n             fair_and_squares.append(ii)\n     return fair_and_squares\n \n f = open(sys.argv[1])\n T = int(f.readline())\n gens = get_generators_up_to_length_n(60)\n squares = map(lambda x: x*x, gens)\n \n for t in range(T):\n     A, B = map(int, f.readline().strip().split())\n     total = 0\n     for elem in squares:\n         assert(is_palin(elem))\n         if elem >= A and elem <= B: total += 1\n         if elem > B:\n             break\n \n     print "Case #%d:" % (t + 1), total\n
binnie	<>	29	<>	2013_2270488_2449486.py	<>	import sys\n \n f = open(sys.argv[1])\n T = int(f.readline())\n for t in range(T):\n     N, M = map(int, f.readline().strip().split())\n     grass_lengths = []\n     for nn in range(N):\n         grass_lengths.append(map(int, f.readline().strip().split())) # Read in all grass heights\n \n     x_max = [0] * M\n     y_max = [0] * N\n     for xx in range(M):\n         for yy in range(N):\n             height = grass_lengths[yy][xx]\n             x_max[xx] = max(x_max[xx], height)  # Update the max required height for column x\n             y_max[yy] = max(y_max[yy], height)  # Update the max required height for row y\n \n     impossible = False\n     for xx in range(M):\n         for yy in range(N):\n             height = grass_lengths[yy][xx]\n             if (x_max[xx] > height and y_max[yy] > height): # Can we cut this row down to this level?\n                 impossible = True\n \n     print "Case #%d:" % (t + 1), "NO" if impossible else "YES"\n
binnie	<>	29	<>	2012_1460488_1483488.py	<>	import sys\n \n def recycle(num):\n     x = str(num)\n     recycles = []\n     for ii in range(1, len(x)):\n         recycles.append(x[ii:] + x[:ii])    \n     return recycles\n \n f = open(sys.argv[1])\n T = int(f.readline())\n for t in range(T):\n     A, B = map(int, f.readline().split())\n     total = 0\n     debugs = []\n     for ii in range(A,B):\n         recycles_ii = recycle(ii)\n         recycles_ii = (filter(lambda x: int(x) > ii and int(x) <= B, recycles_ii))\n         total += len(recycles_ii)\n         for elem in recycles_ii:\n             debugs.append((ii, int(elem)))   \n     print "Case #%d:" % (t + 1), len(set(debugs))\n
binnie	<>	29	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n f = open(sys.argv[1])\n T = int(f.readline())\n for test in range(T):\n     first_row_index = int(f.readline())\n     first_row = []\n     for ii in range(4):\n         if (ii + 1) == first_row_index:\n             first_row = f.readline().strip().split()\n         else:\n             f.readline()\n     second_row_index = int(f.readline())\n     second_row = []\n     for ii in range(4):\n         if (ii + 1) == second_row_index:\n             second_row = f.readline().strip().split()\n         else:\n             f.readline()\n     combined = [val for val in first_row if val in second_row]\n \n     print "Case #%d:" % (test + 1), "Bad magician!" if len(combined) > 1 else "Volunteer cheated!" if len(combined) == 0 else combined[0]\n \n \n
binnie	<>	29	<>	2014_2974486_5709773144064000.py	<>	import sys\n from decimal import *\n \n f = open(sys.argv[1])\n T = int(f.readline())\n for test in range(T):\n     data = f.readline().split()\n     C = Decimal(data[0])\n     F = Decimal(data[1])\n     X = Decimal(data[2])\n     curr_rate = Decimal(2)\n     best_time = Decimal(10**100)\n     curr_time = Decimal(0)\n     while curr_time < best_time:\n         poss_finish_time = curr_time + X / curr_rate\n         if poss_finish_time < best_time:\n             best_time = poss_finish_time\n \n         curr_time += C / curr_rate\n         curr_rate += F\n \n     print "Case #%d: %.7f" % (test + 1, best_time)\n
binnie	<>	29	<>	2013_2270488_2453486.py	<>	import sys\n \n def hasWon(game, player):\n     for ii in range(4):\n         success = True\n         for jj in range(4): # Has the player won in row ii\n             if game[4*ii + jj] != player and game[4*ii + jj] != "T":\n                 success = False\n         if success: return True\n         success = True\n         for jj in range(4): # Has the player won in column ii\n             if game[4*jj + ii] != player and game[4*jj + ii] != "T":\n                 success = False\n         if success: return True\n     \n     success = True\n     for ii in range(4):\n         if game[ii*5] != player and game[ii*5] != "T":\n             success = False\n     if success: return True\n     success = True\n     for ii in range(4):\n         if game[3+ii*3] != player and game[3+ii*3] != "T":\n             success = False\n     if success: return True\n     return False\n \n def gameOver(game):\n     ret_val = True\n     for ii in range(16):\n         if game[ii] == ".":\n             ret_val = False\n     return ret_val\n \n f = open(sys.argv[1])\n T = int(f.readline())\n for t in range(T):\n     game = []\n     for ii in range(4):\n         for elem in f.readline().strip():\n             game.append(elem)\n \n     if hasWon(game, "O"):\n         print "Case #%d:" % (t + 1), "O won"\n     elif hasWon(game, "X"):\n         print "Case #%d:" % (t + 1), "X won"\n     elif gameOver(game):\n         print "Case #%d:" % (t + 1), "Draw"\n     else:\n         print "Case #%d:" % (t + 1), "Game has not completed"\n \n     f.readline()\n
binnie	<>	29	<>	2014_2974486_5690574640250880.py	<>	import sys\n \n f = open(sys.argv[1])\n T = int(f.readline())\n for test in range(T):\n     R, C, M = map(int, f.readline().strip().split())\n     Rorig = R\n     Corig = C\n     impossible = False\n     grid = [['.' for i in range(C)] for j in range(R)]\n     #print grid\n \n     curr_coord = [0,0]\n     while M > 0 and not impossible:\n         #print curr_coord, M, grid\n         if (C > R): # more columns - fill one in\n             num_mines_in_column = R\n             if M < R:\n                 num_mines_in_column = min(R - 2, M)\n             if num_mines_in_column <= 0:\n                 impossible = True\n                 break\n             for ii in range(num_mines_in_column):\n                 grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n             C -= 1\n             curr_coord[1] += 1\n             M -= num_mines_in_column\n         else:\n             num_mines_in_row = C\n             if M < C:\n                 num_mines_in_row = min(C - 2, M)\n             if num_mines_in_row <= 0:\n                 impossible = True\n                 break\n             for ii in range(num_mines_in_row):\n                 grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n             R -= 1\n             curr_coord[0] += 1\n             M -= num_mines_in_row\n \n     #print grid\n     print "Case #%d:" % (test + 1)\n     if impossible:\n         print "Impossible"\n     else:\n         for ii in range(Rorig):\n             for jj in range(Corig):\n                 if grid[ii][jj] == '.':\n                     if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                         grid[ii][jj] = 'dirty'\n                     elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                         grid[ii][jj] = 'dirty'\n                     elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                         grid[ii][jj] = 'dirty'\n         #print grid\n \n         for ii in range(Rorig):\n             for jj in range(Corig):\n                 if grid[ii][jj] == 'dirty':\n                     if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                         grid[ii][jj] = '.'\n                     elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                         grid[ii][jj] = '.'\n                     elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                         grid[ii][jj] = '.'\n                     else:\n                         if ii != Rorig - 1 or jj != Corig - 1:\n                             impossible = True\n         #print grid\n \n         if impossible:\n             print "Impossible"\n         else:\n             grid[Rorig-1][Corig-1] = 'c'\n \n             for ii in range(Rorig):\n                 print " ".join([val for val in grid[ii]])\n \n \n
amv	<>	30	<>	2013_2270488_245348614_pert.py	<>	# python 3\n import string\n import itertools\n import sys\n \n P1 = 'X'\n P2 = 'O'\n PA = 'T'\n EMPTY = '.'\n \n def no_empty_fields(board):\n     for row in board:\n         for field in row:\n             if field==EMPTY:\n                 return False\n     return True\n \n def is_winning_series(board, r0, c0, dr, dc, player):\n     r,c = r0,c0\n     for i in range(4):\n         if board[r][c] != player and board[r][c] != PA:\n             return False\n         r,c = r+dr,c+dc\n     return True\n \n def win_condition(board, player):\n     if is_winning_series(board, 0,0, 1,1, player):\n         return True\n     if is_winning_series(board, 0,3, 1,-1, player):\n         return True\n     for i in range(4):\n         if is_winning_series(board, 0,i, 1,0, player):\n             return True\n         if is_winning_series(board, i,0, 0,1, player):\n             return True\n     return False\n \n def process_case(board):\n     for player in {P1, P2}:\n         if win_condition(board, player):\n             return '{0} won'.format(player)\n     if no_empty_fields(board):\n         return 'Draw'\n     return 'Game has not completed'\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         board = [[ch for ch in next(lines)] for i in range(4)]\n         next(lines)\n         result = process_case(board)\n         yield 'Case #{0}: {1}\n'.format(ci, result)\n     \n def line_of_numbers(s):\n     return [int(sub) for sub in s.split()]\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('A-test')\n start('A-small-attempt0')\n ##start('A-large')\n
amv	<>	30	<>	2012_1460488_148348511_pert.py	<>	import sys\n \n def translate(letter):\n     input =  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n     output = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']\n     index = input.index(letter)\n     return output[index]\n \n f = open(sys.argv[1])\n T = int(f.readline())\n for t in range(T):\n     string = []\n     A = f.readline().split()\n     for elem in A:\n         for ii in range(len(elem)):\n             string.append(translate(elem[ii]))\n         string.append(' ')           \n     print "Case #%d:" % (t + 1), ''.join(elem for elem in string)\n
amv	<>	30	<>	2012_1460488_14834854_pert.py	<>	# -*- coding: utf-8 -*-\n import sys\n \n input = """ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv"""\n \n output = """our language is impossible to understand\n there are twenty six factorial possibilities\n so it is okay if you want to just give up"""\n \n mapping = {'a': 'y', 'o': 'e', 'z': 'q', 'q': 'z'}\n \n for i, c in enumerate(input):\n     mapping[c] = output[i]\n \n \n fin = sys.stdin\n T = int(fin.readline())\n for case in range(1,T+1):\n     line = fin.readline().strip()\n \n     result = ""\n     for c in line:\n         result += mapping[c]\n #    N, M = map(int, fin.readline().split())\n \n     print "Case #%d: %s" % (case, result)\n \n
amv	<>	30	<>	2014_2974486_575640789896396816_pert.py	<>	import os\n \n class Solver(object):\n     def __init__(self):\n         pass\n     \n     def solve(self, inputs):\n         r1 = int(inputs[0])\n         cs1 = set([int(x) for x in inputs[r1].split()])\n         r2 = int(inputs[5])\n         cs2 = set([int(x) for x in inputs[5+r2].split()])\n         r = cs1.intersection(cs2)\n         cnt = len(r)\n         if 1 == cnt:\n             return max(r)\n         elif 0 == cnt:\n             return 'Volunteer cheated!'\n         else:\n             return 'Bad magician!'\n         pass\n     \n     def feed(self, inputs):\n         lines = [x.strip() for x in inputs]\n         outputs = []\n         test_case_n = int(lines[0])\n         cur = 1\n         for i in range(test_case_n):\n             i = i\n             case_line_cnt = 10\n             case_inputs = lines[cur:cur+case_line_cnt]\n             cur += case_line_cnt\n             outputs.append(self.solve(case_inputs))\n         return outputs\n \n if __name__ == '__main__':\n     iname = 'A-small-attempt0.in'\n #     iname = 'foo'\n     sample_in = '''\n     3\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 3\n 1 2 5 4\n 3 11 6 15\n 9 10 7 12\n 13 14 8 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 3\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n     '''\n     sample_out = '''\n  Case #1: 7\n Case #2: Bad magician!\n Case #3: Volunteer cheated!\n     '''\n     if os.path.exists(iname):\n         with open(iname) as f:\n             inputs = f.readlines()\n     else:\n         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n     solver = Solver()\n     outputs = solver.feed(inputs)\n     fail_flag = False\n     if os.path.exists(iname):\n         with open(iname+'.out', 'w') as f:\n             for i, v in enumerate(outputs):\n                 print >> f, 'Case #%d: %s'%(i+1, str(v))\n     else:\n         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n         for i, v in enumerate(outputs):\n             t = 'Case #%d: %s'%(i+1, str(v))\n             if t not in ans:\n                 print '!!! Wrong:', t\n                 fail_flag = True\n     print '===================================================='\n     for i, v in enumerate(outputs):\n         print 'Case #%d: %s'%(i+1, str(v))\n     print '===================================================='\n     print 'done' if not fail_flag else 'fail'\n     pass
amv	<>	30	<>	2014_2974486_569057464025088013_pert.py	<>	directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\n \n from copy import deepcopy\n import itertools\n \n \n def solve_one_case (R,C,M):\n         l = []\n         for i in range(R):\n             for j in range(C):\n                 l.append((i,j))\n \n         empty_mat = []\n         for i in range(R):\n             empty_mat.append(['.']*C)\n \n         found = False\n \n         assert (0,0) in l\n         l = l[1:]\n         l = l[::-1]\n         assert (0,0) not in l\n         \n         output = ''\n         \n         for mine_placement in itertools.combinations(l,M):\n             mat = deepcopy(empty_mat)\n             for cell in mine_placement:\n                 mat[cell[0]][cell[1]] = '*'\n             if isOneClick(mat, R, C, M):\n                 mat[0][0] = 'c'\n                 for line in mat:\n                     output += ''.join(line) + '\n'\n                 found = True\n                 return output\n             \n         if not found:\n             return 'Impossible\n'\n         \n         assert ValueError()\n         \n def solve (f_in, f_out):\n     T = int(f_in.readline())\n     for testcase in range(1,T+1):\n         line = f_in.readline()\n         R,C,M = [int(q) for q in line.split()]\n         print (testcase,R,C,M)\n \n         output = solve_one_case (R,C,M)\n         f_out.write('Case #' + str(testcase) + ':\n')\n         f_out.write(output)\n \n         \n \n \n def isOneClick (mat, R, C, M):\n ##    if mat[0][0] != '.':\n ##        return False\n ##    assert len(mat) == R\n ##    lens = [len(l) for l in mat]\n ##    assert min(lens) == C\n ##    assert max(lens) == C\n ##    assert sum([l.count('*') for l in mat]) == M\n \n     mat_cpy = deepcopy(mat)\n     oneclickcells = [(0,0)]\n     while oneclickcells:\n         node = oneclickcells.pop()\n         mat_cpy[node[0]][node[1]] = 'v'\n         if noNearbyMines(mat_cpy,node):\n             oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\n \n     #print (mat_cpy)\n     return sum([l.count('.') for l in mat_cpy]) == 0\n     \n \n def getNearbyUnvisited(mat, node):\n     R = len(mat)\n     C = len(mat[0])\n     deltas_r = [0]\n     deltas_c = [0]\n     if node[0] > 0:\n         deltas_r.append(-1)\n     if node[1] > 0:\n         deltas_c.append(-1)\n     if node[0] < R-1:\n         deltas_r.append(1)\n     if node[1] < C-1:\n         deltas_c.append(1)\n \n     ret_list = []\n     for delta_r in deltas_r:\n         for delta_c in deltas_c:\n             next_node = (node[0]+delta_r, node[1] + delta_c)\n             if mat[next_node[0]][next_node[1]] not in ['*','v']:\n                 ret_list.append((next_node[0],next_node[1]))\n \n     return ret_list\n \n def noNearbyMines(mat,node):\n     R = len(mat)\n     C = len(mat[0])\n     deltas_r = [0]\n     deltas_c = [0]\n     if node[0] > 0:\n         deltas_r.append(-1)\n     if node[1] > 0:\n         deltas_c.append(-1)\n     if node[0] < R-1:\n         deltas_r.append(1)\n     if node[1] < C-1:\n         deltas_c.append(1)\n \n     for delta_r in deltas_r:\n         for delta_c in deltas_c:\n             if mat[node[0] + delta_r][node[1] + delta_c] == '*':\n                 return False\n     return True\n     \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (directory)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', directory)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(directory+chosen_filename+'.in')\n     f_out = open(directory+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n \n ##bads = []\n ##goods = []\n ##\n ##for R in range(1,6):\n ##    for C in range(1,6):\n ##        for M in range(1,R*C+1):\n ##            print (R,C,M)\n ##            output = solve_one_case (R,C,M)\n ##            if output[0] == 'I':\n ##                bads.append((R,C,M))\n ##            else:\n ##                goods.append((R,C,M))\n ##\n
amv	<>	30	<>	2013_2270488_24634868_pert.py	<>	def checkpalin(s):\n     k = len(s)//2\n     for i in range(k):\n         if s[i]!= s[-1-i]:\n             return False\n     return True\n \n goods = [1,2,3]\n \n for i in range(1000):\n     for j in ['']+list(range(10)):\n         test = str(i)+str(j)+(str(i)[::-1])\n         if checkpalin(str(int(test)**2)):\n             goods.append(int(test))\n goods = list(set(goods))\n goods.sort()\n \n T = int(input())\n \n for case in range(1,T+1):\n     A,B = [int(x) for x in input().split()]\n     ans = 0\n     for n in goods:\n         if A <= n*n <= B:\n             ans += 1\n     print("Case #",case,": ",ans,sep='')\n
amv	<>	30	<>	2013_2270488_246348617_pert.py	<>	import sys\n import numpy as np\n \n def isPalindrome(x):\n     x = str(x)\n     if x[0] != x[-1]:\n         return 0\n     y = x[::-1]\n     if x == y:\n         return 1\n     return 0\n \n def generate():\n     digits = [str(x) for x in range(0,10)]\n     dplus = digits + [""]\n \n     for x in range(1,10):\n         y = x**2\n         if isPalindrome(y):\n             print y\n \n     for x in range(1,10**4):\n         x = str(x)\n         y = x[::-1]\n         pals = [ int(x+z+y)**2 for z in dplus ]\n         for p in pals:\n             if isPalindrome(p):\n                 print p\n \n if __name__ == "__main__":\n     #generate()\n     #break\n     f = open( sys.argv[1] )\n     sqpals = np.array([int(l) for l in f])\n     sqpals.sort()\n     f.close()\n \n     f = open( sys.argv[2] )\n     t = int(f.readline())\n     t = 1\n     for l in f:\n         a,b = [int(x) for x in l.split()]\n         mt = sqpals >= a\n         lt = sqpals <= b\n         output = sum( mt&lt )\n         print "Case #%s: %s"%(t,output)\n         t += 1\n     \n
amv	<>	30	<>	2014_2974486_570977314406400018_pert.py	<>	#!/usr/bin/python\n \n import sys\n import re\n import math\n import string\n \n f = open(sys.argv[1],'r')\n \n num = int(f.readline())\n \n for i in range(num):\n     c, e, x = [float(x) for x in f.readline().split()]\n     n = int((x*e-2*c)/(c*e))\n     if n < 0:\n         n = 0\n     t = 0\n     for j in range(n):\n         t += c/(2+j*e)\n     t += x/(2+n*e)\n     print 'Case #{}: {}'.format(i+1, t)\n
amv	<>	30	<>	2012_1460488_148348819_pert.py	<>	#\n # Google Code Jam 2012\n # Round 0: C. Recycled Numbers\n # submission by EnTerr\n #\n \n '''\n Limits: 1 <= T <= 50. A and B have the same number of digits.\n Small dataset: 1 <= A <= B <= 1000.\n Large dataset: 1 <= A <= B <= 2000000\n \n Input \n 4\n 1 9\n 10 40\n 100 500\n 1111 2222\n  	\n Output \n Case #1: 0\n Case #2: 3\n Case #3: 156\n Case #4: 287\n \n '''\n \n import psyco\n psyco.full()\n \n import sys\n from time import clock\n \n inf = open(sys.argv[1])\n def input(): return inf.readline().strip()\n \n def numRecycled(A,B):\n     ln = len(str(A))\n     rot = 10**(ln-1)\n     cnt = 0\n     for i in range(A,B+1):\n         res = set()\n         j = i\n         for _ in range(ln-1):\n             a,b = divmod(j, 10)\n             j = rot*b + a\n             if i < j <= B:\n                 res.add(j)\n         cnt += len(res)\n     return cnt\n \n for caseNo in range(1, int(input())+1):\n     #print >>sys.stderr, caseNo\n     #tm = clock()\n     print 'Case #%d:' % caseNo,\n     A,B = map(int, input().split())\n     print numRecycled(A,B)\n     #print A, B, clock() - tm\n \n
amv	<>	30	<>	2014_2974486_56905746402508806_pert.py	<>	from itertools import product\n def solve():\n     h, w, m = map(int, raw_input().split())\n     if h == 1:\n         print 'c' + '.' * (h * w - m - 1) + '*' * m\n     elif w == 1:\n         for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n             print c\n     elif h * w - m == 1:\n         print 'c' + '*' * (w - 1)\n         for _ in xrange(h-1):\n             print '*' * w\n     else:\n         m = h * w - m\n         for i in xrange(h-1):\n             for j in xrange(w-1):\n                 t = (i + 2) * 2 + (j + 2) * 2 - 4\n                 r = (i + 2) * (j + 2)\n                 if t <= m <= r:\n                     a = [['*'] * w for _ in xrange(h)]\n                     for k in xrange(i+2):\n                         a[k][0] = '.'\n                         a[k][1] = '.'\n                     for k in xrange(j+2):\n                         a[0][k] = '.'\n                         a[1][k] = '.'\n                     for y, x in product(range(2, i+2), range(2, j+2)):\n                         if y == 1 and x == 1:\n                             continue\n                         if t >= m:\n                             break\n                         a[y][x] = '.'\n                         t += 1\n                     a[0][0] = 'c'\n                     for s in a:\n                         print ''.join(s)\n                     return\n         print 'Impossible'\n for t in xrange(int(raw_input())):\n     print "Case #%d:" % (t + 1)\n     solve()\n
amv	<>	30	<>	2013_2270488_2463486.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n def isPalindrome(n):\n     cn=str(n)\n     return (cn==cn[::-1])\n \n #Precomputed\n palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]\n \n \n#  def genPalindromes(nPlaces):\n#     assert nPlaces>0\n \n#     if nPlaces==1:\n#         for i in (1,2,3): yield i\n#     elif nPlaces%2==0:\n#         for i in xrange(nPlaces/2):\n \n             \n         \n         \n \n \n \n def Solve(a,b):\n     num=0\n     for p in palinSqrt:\n         if a<= p**2 <=b: num+=1\n     return num\n \n \n \n def parse(infile):\n     a,b=map(int, infile.readline().split() )\n     return a,b\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n ########library functions\n class Categorizer(dict):\n     def __init__(self,thelist,transform,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.AddList(thelist)\n         self.trunc=trunc\n     def AddList(self,thelist):\n         for item in thelist: self.Add( item )\n     def Add(self,object):\n         cat=self.transform( object )\n         if type(cat) is float:\n             cat=round(cat,trunc)\n         if self.has_key(cat):\n             self[cat].append( object )\n         else:\n             self[cat]=[object]\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-len(x[1]))\n         total=0\n         for i in items: total+=len(i[1])\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(len(val))) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,len(count),\n                                    ("%.2f"%(len(count)*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=len(self[key])\n             avg+=len(self[key])*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=len(self[key])\n             stddev += len(self[key]) * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n         tot=0\n         for value in self.itervalues(): tot+=len(value)\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \n class Counter(dict):\n     def __init__(self,thelist,transform=None,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.trunc=trunc\n         self.AddList(thelist)\n     def AddList(self,thelist):\n         if self.transform is not None:\n             for item in thelist: self.Add( self.transform(item) )\n         else:\n             for item in thelist: self.Add( item )            \n     def Add(self,object):\n         if type(object) is float:\n             object=round(object,self.trunc)\n         if self.has_key(object):\n             self[object]+=1\n         else:\n             self[object]=1\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-x[1])\n         total=0\n         for i in items: total+=i[1]\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(val)) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=self[key]\n             avg+=self[key]*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=self[key]\n             stddev += self[key] * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n  	total=sum(self.values())\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \n def gen_primes():\n     """ Generate an infinite sequence of prime numbers.\n     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n     """\n     D = {}  \n     q = 2  \n \n     while True:\n         if q not in D:\n             yield q        \n             D[q * q] = [q]\n         else:\n             for p in D[q]:\n                 D.setdefault(p + q, []).append(p)\n             del D[q]\n \n         q += 1\n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2013_2270488_24634862_pert.py	<>	import sys\n import math\n \n \n fairsquares = []\n \n \n def read_fairsquares():\n     global fairsquares\n     f = open('fairsquares.txt')\n     for x in f:\n         fairsquares.append(int(x.strip()))\n \n \n def count_less_than(A):\n     left = 0\n     right = len(fairsquares)\n     # fairsquares[left - 1] < A <= fairsquares[right]\n     while left < right:\n         middle = (left + right) // 2\n         if fairsquares[middle] < A:\n             left = middle + 1\n         else:\n             right = middle\n     return left\n \n \n def compute(A, B):\n     count_b = count_less_than(B + 1)\n     count_a = count_less_than(A)\n     return count_b - count_a\n \n \n def parse():\n     return map(int, sys.stdin.readline().strip().split())\n \n \n if __name__ == "__main__":\n     read_fairsquares()\n     T = int(sys.stdin.readline().strip())\n     count = 1\n     part = 0\n     if len(sys.argv) == 3:\n         part = int(sys.argv[1])\n         count = int(sys.argv[2])\n     for i in xrange(T):\n         data = parse()\n         if i * count >= part * T and i * count < (part + 1) * T:\n             result = compute(*data)\n             print "Case #%d: %s" % (i + 1, result)\n
amv	<>	30	<>	2013_2270488_2449486.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n \n def Solve(n,m,heights):\n     #print heights\n     for i,j in ( (i,j) for i in xrange(n) for j in xrange(m) ):\n         if (heights[i,:]<= heights[i,j]).all(): continue\n \n         if (heights[:,j]>heights[i,j]).any(): return "NO"\n \n \n     return 'YES'\n \n \n \n def parse(infile):\n     n,m=map(int, infile.readline().split() )\n     heights=np.zeros( (n,m) )\n     for i in xrange(n):\n         heights[i,:]=np.array( map(int, infile.readline().split() ) )\n     return n,m,heights\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n ########library functions\n class Categorizer(dict):\n     def __init__(self,thelist,transform,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.AddList(thelist)\n         self.trunc=trunc\n     def AddList(self,thelist):\n         for item in thelist: self.Add( item )\n     def Add(self,object):\n         cat=self.transform( object )\n         if type(cat) is float:\n             cat=round(cat,trunc)\n         if self.has_key(cat):\n             self[cat].append( object )\n         else:\n             self[cat]=[object]\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-len(x[1]))\n         total=0\n         for i in items: total+=len(i[1])\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(len(val))) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,len(count),\n                                    ("%.2f"%(len(count)*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=len(self[key])\n             avg+=len(self[key])*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=len(self[key])\n             stddev += len(self[key]) * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n         tot=0\n         for value in self.itervalues(): tot+=len(value)\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \n class Counter(dict):\n     def __init__(self,thelist,transform=None,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.trunc=trunc\n         self.AddList(thelist)\n     def AddList(self,thelist):\n         if self.transform is not None:\n             for item in thelist: self.Add( self.transform(item) )\n         else:\n             for item in thelist: self.Add( item )            \n     def Add(self,object):\n         if type(object) is float:\n             object=round(object,self.trunc)\n         if self.has_key(object):\n             self[object]+=1\n         else:\n             self[object]=1\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-x[1])\n         total=0\n         for i in items: total+=i[1]\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(val)) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=self[key]\n             avg+=self[key]*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=self[key]\n             stddev += self[key] * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n  	total=sum(self.values())\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \n def gen_primes():\n     """ Generate an infinite sequence of prime numbers.\n     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n     """\n     D = {}  \n     q = 2  \n \n     while True:\n         if q not in D:\n             yield q        \n             D[q * q] = [q]\n         else:\n             for p in D[q]:\n                 D.setdefault(p + q, []).append(p)\n             del D[q]\n \n         q += 1\n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2012_1460488_14834885_pert.py	<>	import sys\n \n def cycle_shift(in_str):\n 	return "%s%s" % (in_str[-1], in_str[:-1])\n \n def get_cyclic_shifts(num):\n 	results = []\n 	str_num = str(num)\n 	for _ in xrange(len(str_num) - 1):\n 		str_num = cycle_shift(str_num)\n 		if str_num[0] == '0':\n 			continue\n 		number = int(str_num)\n 		if not number in results:\n 			results.append(number)\n 	return results\n 	\n def get_rec_pairs(A, B):\n 	rec_pairs = []\n 	for i in xrange(A, B + 1):\n 		shifts = get_cyclic_shifts(i)\n 		for shift in shifts:\n 			if (shift > i and\n 				shift <= B):\n 				rec_pairs.append((i, shift))\n 	return rec_pairs\n 	\n def main(filepath):\n 	with file('numbers_output.txt', 'wb') as f_out:\n 		with file(filepath, 'rb') as f_in:\n 			for line_index, line in enumerate(f_in):\n 				if line_index == 0: #T\n 					continue\n 				input_list = line.strip().split(' ')\n 				A = int(input_list[0])\n 				B = int(input_list[1])\n 				\n 				rec_pairs = get_rec_pairs(A, B)\n 				result = len(rec_pairs)\n 							\n 				print\n 				print line.strip()\n 				print result\n 				\n 				f_out.write("Case #%d: %d\n" % (line_index, result))\n 				\n if __name__ == '__main__':\n 	main(sys.argv[1])
amv	<>	30	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n infile=open(sys.argv[1],'r')\n \n NumCases=int(infile.readline())\n \n for iCase in xrange(NumCases):\n \n     a,b=[int(i) for i in infile.readline().split()]\n \n \n #for iCase in xrange(1):\n #    a,b=[int(i) for i in sys.argv[1:]]\n     a_digits=[int(i) for i in str(a) ]\n     b_digits=[int(i) for i in str(b) ]\n \n     ld=len(a_digits)\n \n #    print a_digits,b_digits\n \n     result=0\n #    lowers={}\n \n     for iNum in xrange(a,b+1):\n         mystr=str(iNum)\n         myset=set()\n         for i in xrange(1,ld):\n             mystr=mystr[1:]+mystr[0]\n             iii=int(mystr)\n             if iii>iNum and iii<=b and iii not in myset:\n                 result+=1\n                 #print iNum,iii\n                 #if lowers.has_key(iii):\n                 #    lowers[iii].append(iNum)\n                 #else: lowers[iii]=[iNum]\n \n             myset.add(iii)\n             \n         \n \n \n #    for k,v in lowers.iteritems(): print k,':',v\n     print 'Case #'+str(iCase+1)+':',result\n \n
amv	<>	30	<>	2014_2974486_569057464025088020_pert.py	<>	import sys\n \n def generate_matrix(r, c, char):\n 	mat = [[char for i in range(c)] for j in range(r)]\n 	return mat\n 	\n def merge(mat1, mat2):\n 	for i in range(len(mat1)):\n 		for j in range(len(mat1[i])):\n 			mat2[i][j] = mat1[i][j]\n 	return mat2\n \n def solve(r, c, m):\n 	if 0 == m:\n 		mat = generate_matrix(r, c, '.')\n 		mat[0][0] = 'c'\n 		return mat\n 		\n 	f = r * c - m\n 	\n 	if 0 == f:\n 		return False\n 		\n 	if 1 == f:\n 		mat = generate_matrix(r, c, '*')\n 		mat[0][0] = 'c'\n 		return mat\n 		\n 	if 1 == min(r, c):\n 		mat = generate_matrix(r, c, '*')\n 		for i in range(f):\n 			mat[0 if 1 == r else i][0 if 1 == c else i] = '.'\n 		mat[0][0] = 'c'\n 		return mat\n \n 	if 2 == min(r, c):\n 		if (0 != f % 2) or (2 == f):\n 			return False\n 		mat = generate_matrix(r, c, '*')\n 		for i in range(f // 2):\n 			mat[0 if 2 == r else i][0 if 2 == c else i] = '.'\n 			mat[1 if 2 == r else i][1 if 2 == c else i] = '.'\n 		mat[0][0] = 'c'\n 		return mat\n 		\n 	if (3 == r) and (3 == c):\n 		if (4 == f) or (6 == f):\n 			mat = generate_matrix(r, c, '*')\n 			for i in range(f // 2):\n 				mat[0][i] = '.'\n 				mat[1][i] = '.'\n 			mat[0][0] = 'c'\n 			return mat\n 		if 8 == f:\n 			mat = generate_matrix(r, c, '.')\n 			mat[2][2] = '*'\n 			mat[0][0] = 'c'\n 			return mat\n 		return False\n 		\n 	rows_to_reduce = min(r - 3, m // c)\n 	if 0 < rows_to_reduce:\n 		res = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)\n 		if False == res:\n 			return False\n 		mat = merge(res, generate_matrix(r, c, '*'))\n 		return mat\n 		\n 	cols_to_reduce = min(c - 3, m // r)\n 	if 0 < cols_to_reduce:\n 		res = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)\n 		if False == res:\n 			return False\n 		mat = merge(res, generate_matrix(r, c, '*'))\n 		return mat\n 	\n 	mat = generate_matrix(r, c, '.')\n 	for i in range(min(m, r - 2)):\n 		mat[r - i - 1][c - 1] = '*'\n 	if m == r - 1:\n 		mat[r - 1][c - 2] = '*'\n 	mat[0][0] = 'c'\n 	return mat\n 			\n \n t = int(sys.stdin.readline().strip())\n \n for i in range(t):\n 	print "Case #" + str(i + 1) + ":"\n \n 	r, c, m = [int(i) for i in sys.stdin.readline().strip().split()]\n 	\n 	res = solve(r, c, m)\n 	\n 	if False == res:\n 		print "Impossible"\n 	else:\n 		for i in range(r):\n 			for j in range(c):\n 				sys.stdout.write(res[i][j])\n 			print\n
amv	<>	30	<>	2012_1460488_148348515_pert.py	<>	"""Usage:\n     X.py < X.in > X.out\n """\n \n import sys\n \n ins = """ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jvqz\n """\n \n outs = """our language is impossible to understand\n there are twenty six factorial possibilities\n so it is okay if you want to just give upzq\n """\n \n class Solver(object):\n     cache = {}\n \n     def __init__(self, infile, testcase):\n         self.testcase = testcase\n         self.S = S = infile.next().strip()\n \n         self.init_cache()\n \n     def init_cache(self):\n         if 'main' in self.cache:\n             return\n         t = {}\n         for i in xrange(len(ins)):\n             t[ins[i]] = outs[i]\n         print t\n         self.cache['main'] = t\n \n     def solve(self):\n \n         S = self.S\n         \n \n         return ''.join(self.cache['main'][c] for c in list(S))\n \n \n def main():\n     T = int(sys.stdin.next())\n     for t in xrange(T):\n         sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n \n \n if __name__ == '__main__':\n     main()\n
amv	<>	30	<>	2014_2974486_57097731440640007_pert.py	<>	#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n #for the Google Code Jam programming contest\n \n ###############################################################################\n # Imports go here\n ###############################################################################\n \n #For faster numerical analysis\n import numpy as np\n \n import sys\n \n #Needed for the memoization decorator\n import collections\n import functools\n \n ###############################################################################\n # Global variables (for caching, etc.) go here\n ###############################################################################\n \n ###############################################################################\n # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\n ###############################################################################\n \n class memoize(object):\n    """Decorator. Caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned\n    (not reevaluated).\n    """\n    def __init__(self, func):\n       self.func = func\n       self.cache = {}\n    def __call__(self, *args):\n       if not isinstance(args, collections.Hashable):\n          # uncacheable. a list, for instance.\n          # better to not cache than blow up.\n          return self.func(*args)\n       if args in self.cache:\n          return self.cache[args]\n       else:\n          value = self.func(*args)\n          self.cache[args] = value\n          return value\n    def __repr__(self):\n       '''Return the function's docstring.'''\n       return self.func.__doc__\n    def __get__(self, obj, objtype):\n       '''Support instance methods.'''\n       return functools.partial(self.__call__, obj)\n \n ###############################################################################\n # Functions\n ###############################################################################\n \n def precalculate():\n     """Perform any calculations that need to be performed before the main path\n     (e.g., preparing lookup tables, etc.)\n     \n     N.B. Make sure you make any important variables global so that other\n     functions can access them.\n     """\n     pass\n \n def read_input(infile):\n     """This function should take an open input file, load in all of the\n     relevant information for a single case of the problem, and output it\n     as a single object.    \n     """\n     #Some utility functions to read in particular types of input\n     def read_int():\n         return int(infile.readline().strip())\n     def read_ints():\n         return np.array(infile.readline().split(), dtype=int)\n     def read_bigints(): #For ints that won't fit directly in an int32 array\n         line = infile.readline().split()\n         return np.array(map(lambda x: int(x), line))\n     def read_float():\n         return float(infile.readline().strip())\n     def read_floats():\n         return np.array(infile.readline().split(), dtype=float)\n     def read_string():\n         return infile.readline().strip()\n     def read_strings():\n         return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n     \n     C, F, X = read_floats()\n     \n     case = (C, F, X)\n     \n     return case\n \n def solve_case(case):\n     """Take the input data (structured in case) and perform any necessary\n     calculations to obtain the desired output, formatted as the appropriate\n     string.    \n     """\n     C, F, X = case\n     \n     rate = 2.0\n     cookies = 0.0\n     time = 0.0\n     \n     #If it takes more cookies to buy a farm than we need to win, just wait and win:\n     if C >= X:\n         return X / rate\n     \n     while cookies < X:\n         #If we don't have enough cookies to buy a farm, we have to wait until we do\n         if cookies < C:\n             wait_time = (C - cookies) / rate\n             time += wait_time\n             cookies = C\n         #Now we do have enough cookies to buy a farm. Should we keep waiting or buy?\n         time_if_wait = (X - C) / rate\n         time_if_buy = X / (rate + F)\n         if time_if_wait < time_if_buy:\n             return time + time_if_wait\n         else:\n             rate += F\n             cookies = 0.0\n \n ###############################################################################\n # Main execution path\n ###############################################################################\n \n if __name__ == "__main__":\n     #Do any pre-calculations required\n     precalculate()\n     \n     #Open up the input & output files based on the provided input file\n     assert len(sys.argv) == 2 #only one argument\n     assert sys.argv[1][-3:] == ".in" #input must end with .in\n     infile = open("%s" % sys.argv[1], 'r')\n     outfile = open("%s.out" % sys.argv[1][:-3], 'w')\n     \n     #Read in the number of cases (the first input line) to iterate through\n     cases = int(infile.readline().strip('\n'))\n     for i in range(cases):\n         \n         #Read in the input data for this case\n         case = read_input(infile)\n         \n         #Solve the problem for this case\n         output = solve_case(case)\n         \n         #Write out the output of this case\n         outfile.write('Case #%i: %s\n' % (i+1, output))\n         print 'Case #%i: %s\n' % (i+1, output)\n     \n     #Close files\n     infile.close()\n     outfile.close()
amv	<>	30	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/env python\n import sys,os\n import numpy as np\n \n \n def Solve(F1,r1,F2,r2):\n     s1=set(F1[r1-1])\n     s2=set(F2[r2-1])\n     sx=s1.intersection(s2)\n     if len(sx)>1:\n         return "Bad magician!"\n     elif len(sx)==0:\n         return "Volunteer cheated!"\n     else:\n         return sx.__iter__().next()\n \n \n \n def parse(infile):\n     r1=int(infile.readline().strip())\n     F1=[]\n     for i in xrange(4):\n         F1.append( map(int, infile.readline().split() ))\n     r2=int(infile.readline().strip())\n     F2=[]\n     for i in xrange(4):\n         F2.append( map(int, infile.readline().split() ))\n     return F1,r1,F2,r2\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2014_2974486_575640789896396812_pert.py	<>	# coding: utf-8\n import sys\n import os.path\n import itertools\n from itertools import groupby\n import math\n \n def debug(v):\n     pass #print(v)\n \n def read(f):\n     t = tuple(int(v) for v in f.readline().split())\n     debug(t)\n     return t\n \n def answer(f, X, ans):\n     out = "Case #{}: {}".format(X, ans)\n     f.write(out)\n     f.write("\n")\n     print(out)\n \n \n \n def main(inf, outf):\n     T, = read(inf)\n     for X in range(1, T + 1):\n         row1, = read(inf)\n         cards1 = tuple(read(inf) for i in range(4))\n         row2, = read(inf)\n         cards2 = tuple(read(inf) for i in range(4))\n \n         kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n \n         if kouho:\n             if len(kouho) == 1:\n                 ans = kouho.pop()\n             else:\n                 ans = "Bad magician!"\n         else:\n             ans = "Volunteer cheated!"\n \n         answer(outf, X, ans)\n \n \n if __name__=="__main__":\n     infname = sys.argv[1]\n     outfname = os.path.splitext(infname)[0] + ".out"\n     with open(infname, "r") as inf:\n         with open(outfname, "w") as outf:\n             main(inf, outf)\n
amv	<>	30	<>	2013_2270488_245348622_pert.py	<>	\n import math\n import itertools\n import numpy\n \n def read_word(f):\n     return next(f).strip()\n \n def read_int(f, b=10):\n     return int(read_word(f), b)\n \n def read_letters(f):\n     return list(read_word(f))\n \n def read_digits(f, b=10):\n     return [int(x, b) for x in read_letters(f)]\n \n def read_words(f, d=' '):\n     return read_word(f).split(d)\n \n def read_ints(f, b=10, d=' '):\n     return [int(x, b) for x in read_words(f, d)]\n \n def read_floats(f, d=' '):\n     return [float(x) for x in read_words(f, d)]\n \n def read_arr(f, R, reader=read_ints, *args, **kwargs):\n     res = []\n     for i in range(R):\n         res.append(reader(f, *args, **kwargs))\n     return res\n \n def solve(solver, fn, out_fn=None):\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'w') as fo:\n             T = read_int(fi)\n             for i in range(T):\n                 case = read_case(fi)\n                 res = solver(case)\n                 write_case(fo, i, res)\n \n ################################################################################\n \n def read_case(f):\n     B = read_arr(f, 4, read_letters)\n     read_word(f)\n     return B\n \n def write_case(f, i, res):\n     f.write('Case #%d: '%i)\n     f.write('%s'%res)\n     f.write('\n')\n \n ################################################################################\n \n def test(a):\n     if '.' not in a and 'O' not in a:\n         return 'X won'\n     if '.' not in a and 'X' not in a:\n         return 'O won'\n \n def solve_small(case):\n     draw = True\n     for row in case:\n         if '.' in row:\n             draw = False\n         res = test(row)\n         if res:\n             return res\n     for i in range(len(case[0])):\n         col = [row[i] for row in case]\n         res = test(col)\n         if res:\n             return res\n     diag = [case[i][i] for i in range(len(case))]\n     res = test(diag)\n     if res:\n         return res\n     diag = [case[i][-i-1] for i in range(len(case))]\n     res = test(diag)\n     if res:\n         return res\n     if draw:\n         return 'Draw'\n     return 'Game has not completed'\n \n def solve_large(case):\n     return solve_small(case)\n \n DEBUG = 'i'\n \n from run import *\n
amv	<>	30	<>	2013_2270488_24494869_pert.py	<>	#!/usr/bin/python\n \n import sys\n import functools\n import operator\n \n def solve(M, a, b):\n     rowmax = [max(r) for r in M]\n     colmax = [max([M[j][i] for j in range(a)]) for i in range(b)]\n     rowmin = [min(r) for r in M]\n     colmin = [min([M[j][i] for j in range(a)]) for i in range(b)]\n \n     for i in range(a):\n         for j in range(b):\n             if M[i][j] != min(rowmax[i], colmax[j]):\n                 return 'NO'\n     return 'YES'\n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n         M = []\n         for j in range(a):\n             M += [[int(x) for x in sys.stdin.readline().split()]]\n         result = solve(M, a, b)\n         print ("Case #%s: %s" % (i+1, result))\n \n \n if __name__ == '__main__':\n     main()\n
amv	<>	30	<>	2012_1460488_14834881_pert.py	<>	def count_between(a, b):\n 	count = 0\n 	for item in range(a, b + 1):\n 		rotate = len(str(item)) - 1\n 		watch_list = [item,]\n 		rotate_count = 0\n 		item_len = len(str(item))\n 		while rotate_count < rotate:\n 			r_item = str(item)\n 			r_item = r_item[rotate_count + 1:] + r_item[:rotate_count + 1]\n 			r_item_len = len(r_item)\n 			r_item = int(r_item)\n 			if r_item not in watch_list and r_item > item and r_item <= b and r_item >= a and item_len == r_item_len:\n 				watch_list.append(r_item)\n 				count +=1\n 			rotate_count += 1\n 	return count\n \n pre_computed = [0, 36, 801, 12060, 161982, 2023578, 299997,]\n \n t = int(raw_input().strip())\n t_count = 1\n while t_count <= t:\n 	a, b = [int(x) for x in raw_input().strip().split()]\n 	#len_a = len(str(a))\n 	#len_b = len(str(b))\n 	#result = reduce(lambda x, y: x + y, pre_computed[len_a - 1:len_b -1], 0)\n 	#print result\n 	#result -= count_between(pow(10, len_a - 1), a)\n 	#print result\n 	#result += count_between(pow(10, len_b - 1), b)\n 	#print result\n 	#print 'Case #%d: %d' % (t_count, result,)\n 	print 'Case #%d: %d' % (t_count, count_between(a, b),)\n 	t_count += 1\n \n
amv	<>	30	<>	2013_2270488_24494863_pert.py	<>	#!/usr/bin/env python3\n # -*- encoding: utf-8 -*-\n \n \n def f(m):\n     max_cols = []\n     for e in zip(*m):\n         max_cols.append(max(e))\n \n     for r in m:\n         max_row = max(r)\n         for y, c in enumerate(r):\n             if c != max_row and c != max_cols[y]:\n                 return 'NO'\n     return 'YES'\n \n if __name__ == '__main__':\n     T = int(input())\n     for i in range(T):\n         n, m = map(int, input().split())\n         r = f([input().split() for i in range(n)])\n         print('Case #{}: {}'.format(i+1, r))\n
amv	<>	30	<>	2012_1460488_1483485.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n infile=open(sys.argv[1],'r')\n \n NumCases=int(infile.readline())\n \n myinput="""ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv"""\n \n myoutput=\\n """our language is impossible to understand\n there are twenty six factorial possibilities\n so it is okay if you want to just give up"""\n \n mapping={}\n mapping['q']='z'\n mapping['z']='q'\n \n \n for char,mapto in zip(myinput,myoutput):\n     if mapping.has_key(char):\n         assert mapping[char]==mapto\n     else:\n         mapping[char]=mapto\n \n #allchar=set('abcdefghijklmnopqrstuvwxyz')\n #print allchar-set( mapping.keys() )\n #print allchar-set(mapping.values() )\n \n \n \n for iCase in xrange(NumCases):\n     thestring=infile.readline().strip()\n \n     newstring=''\n     for char in thestring: newstring+=mapping[char]\n \n \n     print 'Case #'+str(iCase+1)+': '+newstring\n \n
amv	<>	30	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/env python\n import sys,os\n import numpy as np\n \n BIG_NUM=100000\n def Solve(C,F,X):\n     best_time=float('inf')\n     for n in xrange(0,BIG_NUM):\n         if n==0:\n             farm_time=0\n         else:\n             farm_time += C/(2+(n-1)*F)\n         if best_time<=farm_time: break\n         cookie_time=X/(2+n*F)\n \n         if farm_time+cookie_time<best_time:\n             best_time=farm_time+cookie_time\n \n     return '%.9f'%best_time\n \n \n \n def parse(infile):\n     C,F,X=map(float, infile.readline().split() )\n     return C,F,X\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2013_2270488_2453486.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n \n def Solve(lines):\n     hasEmpty=False\n \n     rows=[ lines[0][i]+lines[1][i]+lines[2][i]+lines[3][i] \n            for i in xrange(4) ]\n \n     diags=[ lines[0][0]+lines[1][1]+lines[2][2]+lines[3][3] ,\n             lines[0][3]+lines[1][2]+lines[2][1]+lines[3][0] ]\n \n \n     for il in lines + rows + diags:\n         if il.replace('T','X')=='XXXX': return "X won"\n         elif il.replace('T','O')=='OOOO': return "O won"\n         elif il.find('.')>=0: hasEmpty=True\n \n     \n     if hasEmpty: return "Game has not completed"\n     else: return "Draw"\n \n \n \n def parse(infile):\n     lines=[]\n     for i in xrange(4):\n         lines.append(infile.readline().strip())\n     infile.readline()\n     return (lines,)\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n ########library functions\n class Categorizer(dict):\n     def __init__(self,thelist,transform,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.AddList(thelist)\n         self.trunc=trunc\n     def AddList(self,thelist):\n         for item in thelist: self.Add( item )\n     def Add(self,object):\n         cat=self.transform( object )\n         if type(cat) is float:\n             cat=round(cat,trunc)\n         if self.has_key(cat):\n             self[cat].append( object )\n         else:\n             self[cat]=[object]\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-len(x[1]))\n         total=0\n         for i in items: total+=len(i[1])\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(len(val))) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,len(count),\n                                    ("%.2f"%(len(count)*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=len(self[key])\n             avg+=len(self[key])*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=len(self[key])\n             stddev += len(self[key]) * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n         tot=0\n         for value in self.itervalues(): tot+=len(value)\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \n class Counter(dict):\n     def __init__(self,thelist,transform=None,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.trunc=trunc\n         self.AddList(thelist)\n     def AddList(self,thelist):\n         if self.transform is not None:\n             for item in thelist: self.Add( self.transform(item) )\n         else:\n             for item in thelist: self.Add( item )            \n     def Add(self,object):\n         if type(object) is float:\n             object=round(object,self.trunc)\n         if self.has_key(object):\n             self[object]+=1\n         else:\n             self[object]=1\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-x[1])\n         total=0\n         for i in items: total+=i[1]\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(val)) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=self[key]\n             avg+=self[key]*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=self[key]\n             stddev += self[key] * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n  	total=sum(self.values())\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \n def gen_primes():\n     """ Generate an infinite sequence of prime numbers.\n     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n     """\n     D = {}  \n     q = 2  \n \n     while True:\n         if q not in D:\n             yield q        \n             D[q * q] = [q]\n         else:\n             for p in D[q]:\n                 D.setdefault(p + q, []).append(p)\n             del D[q]\n \n         q += 1\n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2013_2270488_245348610_pert.py	<>	import sys\n \n def testSymbol(symbol, game):\n 	if testLines(symbol, game):\n 		return True\n 	elif testColumns(symbol, game):\n 		return True\n 	elif testDiagonals(symbol, game):\n 		return True\n 	else:\n 		return False\n \n def testLines(symbol, game):\n 	i = 0\n 	won = False\n 	while (i < 4 and not won):\n 		line = game[i]\n 		c = line.count(symbol)\n 		if c == 4 or (c == 3 and "T" in line):\n 			won = True\n 		i += 1\n 	return won\n \n def transpose(game):\n 	for i in xrange(3):\n 		for j in xrange(i + 1, 4):\n 			aux = game[i][j]\n 			game[i][j] = game[j][i]\n 			game[j][i] = aux\n 	return game\n \n def testColumns(symbol, game):\n 	game = transpose(game)\n 	return testLines(symbol, game)\n \n def testDiagonals(symbol, game):\n 	won1 = True\n 	won2 = True\n 	i = 0\n 	while i < 4 and (won1 or won2):\n 		if game[i][i] not in [symbol, "T"]:\n 			won1 = False\n 		if game[i][3 - i] not in [symbol, "T"]:\n 			won2 = False\n 		i += 1\n 	return (won1 or won2)		\n \n inputFileName = sys.argv[1]\n \n f = file(inputFileName)\n fout = file("output.txt", "w")\n \n T = eval(f.readline())\n \n for i in xrange(T):\n 	game = []\n 	for j in xrange(4):\n 		line = f.readline().strip()\n 		gameLine = 4*[None]\n 		for k in xrange(4):\n 			gameLine[k] = line[k]\n 		game.append(gameLine)\n 	f.readline()\n 	if testSymbol("X", game):\n 		gameResult = "X"\n 	elif testSymbol("O", game):\n 		gameResult = "O"\n 	elif "." not in game[0] and "." not in game[1] and "." not in game[2] and "." not in game[3]:\n 		gameResult = "Draw\n"\n 	else:\n 		gameResult = "Game has not completed\n"\n \n 	fout.write("Case #%d: " %(i + 1))\n 	if gameResult in ["X", "O"]:\n 		fout.write("%s won\n" %(gameResult))\n 	else:\n 		fout.write(gameResult)\n
amv	<>	30	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/env python\n import sys,os\n import numpy as np\n import Queue\n \n #guaranteed that R,C>=3, and F is not 1,2,3,5,7\n def Fill(outmat,R,C,F):\n     nF=F\n     #first square\n     outmat[:2,:2]='.'\n     nF-=4\n     if nF==0: return\n \n     #next two\n     outmat[2,:2]='.'\n     nF-=2\n     if nF==0: return    \n \n     #nearly there...\n     outmat[:2,2]='.'\n     nF-=2\n     if nF==0: return\n \n     #Fill by 2 across columns\n     for iC in xrange(3,C):\n         if nF==1:\n             outmat[2,2]='.'\n             return\n         outmat[:2,iC]='.'\n         nF-=2\n         if nF==0: return\n         \n     #Fill by 2 across rows\n     for iR in xrange(3,R):\n         if nF==1:\n             outmat[2,2]='.'\n             return\n         outmat[iR,:2]='.'\n         nF-=2\n         if nF==0: return\n \n     #Now fill singly 3rd row/column\n     for iR,iC in ( (iR,iC) for iR in xrange(2,R)\n                    for iC in xrange(2,C)):\n         outmat[iR,iC]='.'\n         nF-=1\n         if nF==0: return\n     \n \n \n \n def Solve(R,C,M):\n     F=R*C-M\n     if F==0: return '\nImpossible'\n     if (R>1 and C>1 and F in (2,3)):\n         return '\nImpossible'\n \n     outmat=np.zeros( (R,C), dtype='S1')\n     outmat[:,:]='*'\n \n     if R==1:\n         for i in xrange(F):\n             outmat[0][i]='.'\n     \n     elif C==1:\n         for i in xrange(F):\n             outmat[i][0]='.'\n \n     elif F>1:\n         if F in (2,3,5,7): return "\nImpossible"\n         elif (R==2 or C==2) and F%2 != 0:\n             return "\nImpossible"\n         elif R==2:\n             outmat[:,:F/2]='.'\n         elif C==2:\n             outmat[:F/2,:]='.'\n         else: Fill(outmat,R,C,F)\n         \n     outmat[0,0]='c'\n     outmatlines=[ ''.join(x) for x in outmat ]\n     #print outmatlines\n     answer='\n'+'\n'.join(outmatlines)\n \n     Verify(answer,F)\n \n     return answer\n \n disp=[ (dx,dy) for dx in (-1,0,1)\n     for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\n \n def Verify(answer,F):\n     lines=[list(x) for x in answer.split('\n')]\n     if len(lines[0])==0: lines.pop(0)\n     R,C=len(lines),len(lines[0])\n     assert lines[0][0]=='c'\n     assert answer.count('.')+1==F\n     q=Queue.Queue()\n     q.put( (0,0) )\n \n     def adjToMine(x,y):\n         for dx,dy in disp:\n             if 0<=x+dx<R and 0<=y+dy<C:\n                 if lines[x+dx][y+dy]=='*': return True\n         return False\n                 \n \n     while not q.empty():\n         x,y=q.get()\n         for dx,dy in disp:\n             if 0<=x+dx<R and 0<=y+dy<C:\n                 if lines[x+dx][y+dy]=='c': continue\n                 lines[x+dx][y+dy]='c'\n                 if not adjToMine(x+dx,y+dy):\n                     q.put( (x+dx,y+dy) )\n \n     clicked='\n'.join([ ''.join(x) for x in lines])\n     if clicked.find('.')>=0:\n         print '\n','*'*20,"\nERROR, input:"\n         print answer\n         print 'OUTPUT:'\n         print clicked\n     \n \n \n \n def parse(infile):\n     R,C,M=map(int, infile.readline().split() )\n     return R,C,M\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2012_1460488_148348821_pert.py	<>	\n import sys\n import os\n import itertools\n import math\n import numpy\n \n __file__ = sys.argv[0]\n __path__ = os.path.dirname(__file__)\n __prob__ = os.path.basename(__path__)\n \n def pout(s, back=0):\n     f = sys._getframe(back+1)\n     d = 0\n     if 'depth' in f.f_locals:\n         d = f.f_locals['depth']\n     print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n \n def perr(s, back=0):\n     f = sys._getframe(back+1)\n     d = 0\n     if 'depth' in f.f_locals:\n         d = f.f_locals['depth']\n     ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n \n def argmin(f, s=None):\n     a = f\n     if s is None:\n         s = range(len(a))\n         f = lambda i: a[i]\n     res = None\n     for x in s:\n         y = f(x)\n         if res is None or best > y:\n             best = y\n             res = x\n     return res\n \n def argmax(f, s=None):\n     a = f\n     if s is None:\n         s = range(len(a))\n         f = lambda i: a[i]\n     res = None\n     for x in s:\n         y = f(x)\n         if res is None or best < y:\n             best = y\n             res = x\n     return res\n \n def read_word(f):\n     return next(f).strip()\n \n def read_int(f, b=10):\n     return int(read_word(f), b)\n \n def read_words(f, d=' '):\n     return read_word(f).split(d)\n \n def read_ints(f, b=10, d=' '):\n     return [int(x, b) for x in read_words(f, d)]\n \n def read_word_arr(f, R):\n     res = []\n     for i in range(R):\n         res.append(read_word(f))\n     return res\n \n def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n     res = []\n     for i in range(R):\n         res.append(read_ints(f, *args, **kwargs))\n     return numpy.array(res, dtype)\n \n def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n     global ERR_FILE\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     err_fn = fn + '.err'\n     if start_case == 0:\n         append = True\n         if os.path.exists(out_fn):\n             with open(out_fn, 'r') as f:\n                 for l in f:\n                     if l[:6] == 'Case #':\n                         start_case = int(l[6:l.index(':')])+1\n     else:\n         append = False\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'a' if append else 'w') as fo:\n             with open(err_fn, 'w') as ERR_FILE:\n                 T = read_int(fi)\n                 for i in range(T):\n                     case = read_case(fi)\n                     if i+1 < start_case:\n                         continue\n                     print('Case #%d of %d'%(i+1, T))\n                     ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                     perr('case')\n                     res = solver(case)\n                     perr('res')\n                     write_case(fo, i, res)\n                     fo.flush()\n                     if end_case is not None and i+1 == end_case:\n                         break\n \n def test(start_case=1, end_case=None):\n     fn = os.path.join(__path__, 'test')\n     solve(solve_small, fn, start_case, end_case)\n \n def small(start_case=1, end_case=None):\n     fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n     solve(solve_small, fn, start_case, end_case)\n \n def small2(start_case=1, end_case=None):\n     fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n     solve(solve_large, fn, start_case, end_case, fn + '2.out')\n \n def large(start_case=0, end_case=None):\n     fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)\n     solve(solve_large, fn, start_case, end_case)\n \n ################################################################################\n \n def read_case(f):\n     (A, B) = read_ints(f)\n     return (A, B)\n \n def write_case(f, i, res):\n     f.write('Case #%d: '%(i+1))\n     f.write('%s'%res)\n     f.write('\n')\n \n FAIL = 'NO SOLUTION'\n \n def aux(n, a, b):\n     res = 0\n     s = set()\n     for i in range(1, len(n)):\n         m = n[i:]+n[:i]\n         if m > n and m >= a and m <= b and m not in s:\n             res += 1\n             s.add(m)\n     return res\n \n def solve_small(case):\n     (A, B) = case\n     a = str(A)\n     b = str(B)\n     res = 0\n     for n in range(A, B+1):\n         res += aux(str(n), a, b)\n     return res\n \n solve_large = solve_small\n \n ##perr = pout\n ##pout = lambda s: None\n pout = perr\n
imakaramegane	<>	31	<>	2013_2270488_2463486.py	<>	# coding: utf-8\n import sys\n import os.path\n import itertools\n from itertools import groupby\n \n def read(f):\n     return list( int(v) for v in f.readline().split() )\n \n def answer(f, X, ans):\n     out = "Case #{}: {}".format(X, ans)\n     f.write(out)\n     f.write("\n")\n     print(out)\n \n def testcases(f):\n     T = int(f.readline())\n     for X in range(1, T + 1):\n         A, B = read(f)\n         yield X, A, B\n \n def ispalindrome(v):\n     s = str(v)\n     for i in range(len(s) // 2):\n         if s[i] != s[-i-1]:\n             return False\n     return True\n \n def main(inf, outf):\n     MAX = 1000\n     fslst = []\n     for i in itertools.count():\n         if ispalindrome(i):\n             squere = i * i\n             print(MAX, squere, ispalindrome(squere))\n             if squere > MAX:\n                 break\n             if ispalindrome(squere):\n                 fslst.append(squere)\n     for X, A, B in testcases(inf):\n         cnt = 0\n         for fs in fslst:\n             if A <= fs <= B:\n                 cnt += 1\n         answer(outf, X, cnt)\n \n if __name__=="__main__":\n     infname = sys.argv[1]\n     outfname = os.path.splitext(infname)[0] + ".out"\n     with open(infname, "r") as inf:\n         with open(outfname, "w") as outf:\n             main(inf, outf)\n
imakaramegane	<>	31	<>	2013_2270488_2449486.py	<>	# coding: utf-8\n import sys\n import os.path\n from itertools import groupby\n \n def read(f):\n     return list( int(v) for v in f.readline().split() )\n \n def answer(f, X, ans):\n     out = "Case #{}: {}".format(X, ans)\n     f.write(out)\n     f.write("\n")\n     print(out)\n \n def testcases(f):\n     T = int(f.readline())\n     for X in range(1, T + 1):\n         N, M = read(f)\n         GRASS = []\n         for n in range(N):\n             GRASS.append( read(f) )\n         result = yield X, N, M, GRASS\n \n def main(inf, outf):\n     for X, N, M, GRASS in testcases(inf):\n         maxN = list( max(gn) for gn in GRASS )\n         maxM = list( max( gn[m] for gn in GRASS ) for m in range(M) )\n \n         ans = "YES"\n         for n, m in ( (n, m) for m in range(M) for n in range(N) ):\n             if ( GRASS[n][m] < maxN[n] and\n                  GRASS[n][m] < maxM[m] ):\n                 ans = "NO"\n                 break\n         \n         answer(outf, X, ans)\n \n if __name__=="__main__":\n     infname = sys.argv[1]\n     outfname = os.path.splitext(infname)[0] + ".out"\n     with open(infname, "r") as inf:\n         with open(outfname, "w") as outf:\n             main(inf, outf)\n
imakaramegane	<>	31	<>	2012_1460488_1483488.py	<>	import sys\n \n def testcases():\n     with open(sys.argv[1], "r") as f:\n         f.readline()  # skip number of testcases\n         for X, T in enumerate(f, 1):\n             yield X, [int(t) for t in T.split()]\n \n def main():\n     for X, T in testcases():\n         A = T[0]\n         B = T[1]\n         y = 0\n         strA = str(A)\n         for n in range(B, A - 1, - 1):\n             b = str(n)\n             chk = set()\n             for i in range(1, len(b)):\n                 a = b[i:] + b[:i]\n                 if a not in chk and strA <= a < b:\n                     chk.add(a)\n                     y += 1\n \n         print("Case #{:d}: {:d}".format(X, y))\n \n if __name__=="__main__":\n     main()\n
imakaramegane	<>	31	<>	2012_1460488_1483485.py	<>	import sys\n \n def testcases():\n     with open(sys.argv[1], "r") as f:\n         f.readline()  # skip number of testcases\n         for X, T in enumerate(f, 1):\n             yield X, T[:-1]\n \n def main():\n     for X, T in testcases():\n         tbl = str.maketrans("abcdefghijklmnopqrstuvwxyz",\n                             "yhesocvxduiglbkrztnwjpfmaq")\n         S = T.translate(tbl)\n         print("Case #{:d}: {}".format(X, S))\n \n if __name__=="__main__":\n   main()\n   \n
imakaramegane	<>	31	<>	2014_2974486_5709773144064000.py	<>	# coding: utf-8\n import sys\n import os.path\n import itertools\n from itertools import groupby\n import math\n \n def debug(v):\n     pass#print(v)\n \n def read(f):\n     t = tuple(int(v) for v in f.readline().split())\n     debug(t)\n     return t\n \n def readf(f):\n     t = tuple(float(v) for v in f.readline().split())\n     debug(t)\n     return t\n \n def answer(f, X, ans):\n     out = "Case #{}: {}".format(X, ans)\n     f.write(out)\n     f.write("\n")\n     print(out)\n \n \n \n def main(inf, outf):\n     T, = read(inf)\n     for casenmbr in range(1, T + 1):\n         C, F, X = readf(inf)\n \n         power = 2\n         farmtime = round(C / power, 7)\n         keikatime = 0\n         totaltime = round(X / power, 7)\n \n         while True:\n             keikatime += farmtime\n             power += F\n             farmtime = round(C / power, 7)\n             nokoritime = round(X / power, 7)\n             if keikatime + nokoritime > totaltime:\n                 break\n             totaltime = keikatime + nokoritime\n \n         answer(outf, casenmbr, totaltime)\n \n \n if __name__=="__main__":\n     infname = sys.argv[1]\n     outfname = os.path.splitext(infname)[0] + ".out"\n     with open(infname, "r") as inf:\n         with open(outfname, "w") as outf:\n             main(inf, outf)\n
imakaramegane	<>	31	<>	2013_2270488_2453486.py	<>	# coding: utf-8\n import sys\n from itertools import groupby\n \n def testcases():\n     with open(sys.argv[1], "r") as f:\n         T = int(f.readline())\n         for X in range(1, T + 1):\n             BOARD = [\n                 f.readline().strip(),\n                 f.readline().strip(),\n                 f.readline().strip(),\n                 f.readline().strip(),\n             ]\n             f.readline()\n             yield X, BOARD\n \n def main():\n     for X, BOARD in testcases():\n         points = [0] * 10\n         for iR, cols in enumerate(BOARD):\n             cols = list( p(c) for c in cols )\n \n             # \n             points[iR] = sum(cols)\n \n             # c\n             for iC, c in enumerate(cols):\n                 points[4 + iC] += c  # c\n \n             # \n             points[8] += cols[0 + iR]\n             points[9] += cols[3 - iR]\n \n         status = "Draw"\n         for pp in points:\n             if pp >= 1000:\n                 status = "Game has not completed"\n             elif pp in (4, 103):\n                 status = "X won"\n                 break\n             elif pp in (40, 130):\n                 status = "O won"\n                 break\n \n         print("Case #{}: {}".format(X, status))\n \n \n def p(c):\n     if  c == 'X':\n         return 1\n     elif c == 'O':\n         return 10\n     elif c == 'T':\n         return 100\n     else:\n         return 1000\n \n if __name__=="__main__":\n     main()\n
imakaramegane	<>	31	<>	2014_2974486_5690574640250880.py	<>	# coding: utf-8\n import sys\n import os.path\n import itertools\n from itertools import groupby\n import math\n \n def debug(v):\n     pass#print(v)\n \n def read(f):\n     t = tuple(int(v) for v in f.readline().split())\n     debug(t)\n     return t\n \n def readf(f):\n     t = tuple(float(v) for v in f.readline().split())\n     debug(t)\n     return t\n \n def answer(f, X, ans):\n     out = "Case #{}:\n{}".format(X, ans)\n     f.write(out)\n     f.write("\n")\n     print(out)\n \n def answer_cells(f, X, cells):\n     out = "Case #{}:".format(X)\n     f.write(out)\n     f.write("\n")\n     print(out)\n     for row in cells:\n         out = "".join(row)\n         f.write(out)\n         f.write("\n")\n         print(out)\n \n def main(inf, outf):\n     T, = read(inf)\n     for casenmbr in range(1, T + 1):\n         R, C, M = read(inf)\n \n         if M == 0:\n             cells = [['.'] * C for i in range(R)]\n             cells[0][0] = 'c'\n             answer_cells(outf, casenmbr, cells)\n             continue\n \n         empty = R * C - M\n \n         if empty == 1:\n             cells = [['*'] * C for i in range(R)]\n             cells[0][0] = 'c'\n             answer_cells(outf, casenmbr, cells)\n             continue\n \n         if R == 1 or C == 1:\n             cells = [['.'] * C for i in range(R)]\n             m = 0\n             for r in range(R):\n                 for c in range(C):\n                     cells[r][c] = '*'\n                     m += 1\n                     if m == M:\n                         break\n                 else:\n                     continue\n                 break\n             cells[-1][-1] = 'c'\n             answer_cells(outf, casenmbr, cells)\n             continue\n \n         if empty in (2, 3, 5, 7):\n             answer(outf, casenmbr, "Impossible")\n             continue\n \n         if (R == 2 or C == 2) and empty % 2:\n             answer(outf, casenmbr, "Impossible")\n             continue\n \n         cells = [['*'] * C for i in range(R)]\n \n \n         cells[0][0] = 'c'\n         empty -= 1\n         cc = 1\n         rr = 1\n         while empty > 0:\n             if cc < C:\n                 for r in range(rr):\n                     if empty == 2 and r == rr - 1:\n                         break\n                     cells[r][cc] = '.'\n                     empty -= 1\n                     if empty == 0:\n                         break\n                 cc += 1\n             if rr < R and empty > 0:\n                 for c in range(cc):\n                     if empty == 2 and c == cc - 1:\n                         break\n                     cells[rr][c] = '.'\n                     empty -= 1\n                     if empty == 0:\n                         break\n                 rr += 1            \n \n         # cnt = 0\n         # for row in cells:\n         #     for v in row:\n         #         if v == '*':\n         #             cnt += 1\n         # if cnt != M:\n         #     raise "!"\n         answer_cells(outf, casenmbr, cells)\n \n \n if __name__=="__main__":\n     infname = sys.argv[1]\n     outfname = os.path.splitext(infname)[0] + ".out"\n     with open(infname, "r") as inf:\n         with open(outfname, "w") as outf:\n             main(inf, outf)\n
eko	<>	32	<>	2013_2270488_2463486.py	<>	import os, re, sys, math\n import unittest\n \n class Test(unittest.TestCase):\n 	def test_1(self):\n 		self.assertEqual(main(1, 4), 2)\n 	def test_2(self):\n 		self.assertEqual(main(10, 120), 0)\n 	def test_3(self):\n 		self.assertEqual(main(100, 100000000000000), 2)\n \n #tCase = sys.stdin.readline().split()\n tCase = int(sys.stdin.readline())\n \n \n def main(M, N):\n 	fns = 0\n 	num = M\n 	maior = math.sqrt(N)\n 	int_maior = 0\n 	\n 	if maior.is_integer():\n 		int_maior = int(maior) - 1\n 		if fair(N):\n 			if fair(int(maior)):\n 				fns += 1\n 	else:\n 		int_maior = int(maior)\n 		\n 	while int_maior >= 1:\n 		if fair(int_maior):\n 			quadrado = int_maior * int_maior\n 			if quadrado >= M:\n 				if fair(quadrado):\n 					fns += 1\n 		int_maior -= 1\n 	return fns\n \n def main2(M, N):\n 	fns = 0\n 	num = M\n 	#for num in xrange(M, N + 1):\n 	while num <= N:\n 		result = raiz(num)\n 		if result:\n 			if fair(num):\n 			\n 				if fair(result):\n 					fns += 1\n 					#print num\n 		#yield i\n 		num += 1\n 		#print raiz(num)\n 	return fns\n 	\n def fair(num):\n 	return str(num) == str(num)[::-1]\n 	#return True\n 	\n def raiz(num):\n 	result = math.sqrt(num)\n 	#result = 1.0\n 	if result.is_integer():\n 		return int(result)\n 	else:\n 		return False\n 	\n if __name__ == '__main__':\n 	#unittest.main()\n 	for i in xrange(tCase):	\n 		#l1 = [str(x) for x in sys.stdin.readline().split(' ')]		\n 		#print "Case #%d: %s" % (i + 1, main(l1[0], l2[0], l3[0], l4[0]))\n 		\n 		##Numbers\n 		N,M = [int(x) for x in sys.stdin.readline().split(' ')]	\n 		print "Case #%d: %d" % (i + 1, main(N,M))
eko	<>	32	<>	2013_2270488_2449486.py	<>	import os, re, sys, math\n import unittest\n from numpy import *\n \n class Test(unittest.TestCase):\n 	def test_1(self):\n 		self.assertEqual(main(1, 4), 2)\n 	def test_2(self):\n 		self.assertEqual(main(10, 120), 0)\n 	def test_3(self):\n 		self.assertEqual(main(100, 100000000000000), 2)\n \n tCase = int(sys.stdin.readline())\n \n \n def main(matriz, M, N):\n 	#print matriz\n 	\n 	for i in xrange(M):\n 		for j in xrange(N):\n 			ana = matriz[i + 1, j + 1]\n 			#print ana\n 			maiores_linha = 0\n 			for x in xrange(M + 2):\n 				if matriz[x, j + 1] > ana:\n 					maiores_linha += 1\n 			\n 			if maiores_linha == 0:\n 				continue\n 			\n 			maiores_coluna = 0 \n 			for y in xrange(N + 2):\n 				if matriz[i + 1, y] > ana:\n 					maiores_coluna += 1\n 					\n 			if maiores_linha >= 1 and maiores_coluna >= 1:\n 				#print ana, maiores_linha, maiores_coluna\n 				return 'NO'\n 				\n 	return 'YES'\n 	\n \n \n 	\n if __name__ == '__main__':\n 	#unittest.main()\n 	for i in xrange(tCase):	\n 		##Numbers\n 		N,M = [int(x) for x in sys.stdin.readline().split(' ')]\n 		\n 		matriz = zeros((N + 2, M + 2), dtype=int)\n 		\n 		for j in xrange(N + 2):\n 			matriz[j][0] = 0\n 			matriz[j][M + 1] = 0\n 			\n 		for j in xrange(M + 2):\n 			matriz[0][j] = 0\n 			matriz[N + 1][j] = 0\n 		\n 		for k in xrange(N):\n 			j = 1\n 			line = [str(x) for x in sys.stdin.readline().split(' ')]\n 			for n in line:\n 				matriz[k + 1][j] = n		\n 				j += 1\n 		#matriz = zeros((N + 2, M + 2), dtype=int)\n 		\n 		print "Case #%d: %s" % (i + 1, main(matriz, N, M))
eko	<>	32	<>	2012_1460488_1483488.py	<>	import sys, os\n import re\n \n tCase = int(sys.stdin.readline())\n \n def alien(numbers):\n 	resul = 0\n 	A = int(numbers[0])\n 	B = int(numbers[1])\n \n 	for n in range(A,B-1):\n 		for m in range(n+1,B+1):\n 			#print n,m\n 			if (len(str(n)) == len(str(m))):\n 				resul += isRecycled(str(n),str(m))\n 	\n \n \n 	return resul\n 	\n def isRecycled(n,m):\n 	if len(n) < 2:\n 		return 0\n 		\n 	for c in m:\n 		if c not in n:\n 			return 0\n \n 	for i in range (1, len(n)):\n 		mi = m[i:] + m[-len(m):-(len(m)-i)]\n 		if n == mi:\n 			return 1\n 	\n 	return 0\n \n \n lines = []\n for i in xrange(tCase):\n 	line = sys.stdin.readline().split()\n 	lines.append((line[0],line[1]))\n 	\n \n for i in xrange(tCase):	\n 	#case.append(frase)\n 	print "Case #%d: %s" % (i+1, alien(lines[i]))\n 	\n 	\n \n
eko	<>	32	<>	2014_2974486_5756407898963968.py	<>	import unittest\n \n import sys\n \n \n class Test(unittest.TestCase):\n 	def test_1(self):\n 		self.assertEqual(main(5, 2, 2, [2,1]), 12)\n 	def test_2(self):\n 		self.assertEqual(main(5,2,2,[1,2]), 12)\n 	def test_3(self):\n 		self.assertEqual(main(3,3,4,[4,1,3,5]), 39)\n 	def test_4(self):\n 		self.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\n \n \n #tCase = sys.stdin.readline().split()\n tCase = int(sys.stdin.readline())\n \n def main(A, B, AList, BList):\n 	resp = 0\n 	A = A - 1\n 	B = B - 1\n 	Alist = AList[A*4:A*4+4]\n 	BList = BList[B*4:B*4+4]\n 	cont = 0\n 	#print Alist, BList\n 	for aa in Alist:\n 		if aa in BList:\n 			resp = aa\n 			cont += 1\n 		\n 	if cont == 1:\n 		return resp\n 	elif cont == 0:\n 		return "Volunteer cheated!"\n 	else:\n 		return "Bad magician!"\n 		\n  \n if __name__ == '__main__':\n 	#unittest.main()\n 	for i in xrange(tCase):	\n 		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	\n 		#print "Case #%d: %s" % (i + 1, main(frase[0]))\n 		\n 		##Numbers\n 		A = [int(x) for x in sys.stdin.readline().split(' ')][0]\n 		NList = [int(x) for x in sys.stdin.readline().split(' ')]\n 		NList += [int(x) for x in sys.stdin.readline().split(' ')]\n 		NList += [int(x) for x in sys.stdin.readline().split(' ')]\n 		NList += [int(x) for x in sys.stdin.readline().split(' ')]\n 		B = [int(x) for x in sys.stdin.readline().split(' ')][0]\n 		BList = [int(x) for x in sys.stdin.readline().split(' ')]\n 		BList += [int(x) for x in sys.stdin.readline().split(' ')]\n 		BList += [int(x) for x in sys.stdin.readline().split(' ')]\n 		BList += [int(x) for x in sys.stdin.readline().split(' ')]\n 		#print A, B, NList, BList\n 		print "Case #%d: %s" % (i + 1, main(A, B, NList, BList))
eko	<>	32	<>	2012_1460488_1483485.py	<>	import sys, os\n import re\n \n fLine = sys.stdin.readline().split()\n tCase = int(fLine[0])\n \n \n dic = {		'a':'y',\n 			'b':'h',\n 			'c':'e',\n 			'd':'s',\n 			'e':'o',\n 			'f':'c',\n 			'g':'v',\n 			'h':'x',\n 			'i':'d',\n 			'j':'u',\n 			'k':'i',\n 			'l':'g',\n 			'm':'l',\n 			'n':'b',\n 			'o':'k',\n 			'p':'r',\n 			'q':'z',\n 			'r':'t',\n 			's':'n',\n 			't':'w',\n 			'u':'j',\n 			'v':'p',\n 			'w':'f',\n 			'x':'m',\n 			'y':'a',\n 			'z':'q',\n 			'\n':'',\n 			' ':' '}\n \n \n def alien(frase):\n 	resul = ""\n 	for c in frase:\n 		resul += dic[c]\n \n 	return resul\n \n \n \n frases = []\n for i in xrange(tCase):\n 	frase = sys.stdin.readline().replace("\n","")\n 	frases.append(frase)\n 	\n \n for i in xrange(tCase):	\n 	#case.append(frase)\n 	print "Case #%d: %s" % (i+1, alien(frases[i]))\n 	\n 	\n \n
eko	<>	32	<>	2014_2974486_5709773144064000.py	<>	import unittest\n \n import sys\n \n \n \n #tCase = sys.stdin.readline().split()\n tCase = int(sys.stdin.readline())\n \n def calcTemp(taxa, X):\n 	return X/taxa;\n \n def main(C, F, X):\n \n 	taxa = 2.0\n 	resp = 0\n 	\n 	\n 	while True:\n 		#print calcTemp(taxa, X), C/taxa + calcTemp(taxa + F, X), resp\n 		if C/taxa + calcTemp(taxa + F, X) < calcTemp(taxa, X):\n 			resp += C/taxa\n 			taxa += F			\n 		else:\n 			resp += calcTemp(taxa, X)\n 			return resp\n 	\n 	\n 	return 0\n 		\n  \n if __name__ == '__main__':\n 	#unittest.main()\n 	for i in xrange(tCase):	\n 		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	\n 		#print "Case #%d: %s" % (i + 1, main(frase[0]))\n 		\n 		##Numbers\n 		C, F, X = [float(x) for x in sys.stdin.readline().split(' ')]\n 		#print A, B, NList, BList\n 		print "Case #%d: %s" % (i + 1, main(C, F, X))
eko	<>	32	<>	2013_2270488_2453486.py	<>	import os, re, sys\n import unittest\n \n class Test(unittest.TestCase):\n 	def test_1(self):\n 		self.assertEqual(main('XXXT', '....', 'OO..', '....'), 'X won')\n 	def test_2(self):\n 		self.assertEqual(main('XOXT', 'XXOO', 'OXOX', 'XXOO'), 'Draw')\n 	def test_3(self):\n 		self.assertEqual(main('XOX.', 'OX..', '....', '....'), 'Game has not completed')\n 	def test_4(self):\n 		self.assertEqual(main('OOXX', 'OXXX', 'OX.T', 'O..O'), 'O won')\n 	def test_5(self):\n 		self.assertEqual(main('XXXO', '..O.', '.O..', 'T...'), 'O won')\n 	def test_6(self):\n 		self.assertEqual(main('OXXX', 'XO..', '..O.', '...O'), 'O won')\n \n #tCase = sys.stdin.readline().split()\n tCase = int(sys.stdin.readline())\n \n def main(l1, l2, l3, l4):\n 	\n 	resul = ganhador(l1[0], l1[1], l1[2], l1[3])\n 	\n 	if resul == 0:\n 		return 'X won'\n 	elif resul == 1:\n 		return 'O won'\n 		\n 	resul = ganhador(l2[0], l2[1], l2[2], l2[3])\n 	\n 	if resul == 0:\n 		return 'X won'\n 	elif resul == 1:\n 		return 'O won'\n 		\n 	resul = ganhador(l3[0], l3[1], l3[2], l3[3])\n 	\n 	if resul == 0:\n 		return 'X won'\n 	elif resul == 1:\n 		return 'O won'\n 		\n 	resul = ganhador(l4[0], l4[1], l4[2], l4[3])\n 	\n 	if resul == 0:\n 		return 'X won'\n 	elif resul == 1:\n 		return 'O won'\n 		\n 	# coluna\n 	resul = ganhador(l1[0], l2[0], l3[0], l4[0])\n 	\n 	if resul == 0:\n 		return 'X won'\n 	elif resul == 1:\n 		return 'O won'\n \n 	resul = ganhador(l1[1], l2[1], l3[1], l4[1])\n 	\n 	if resul == 0:\n 		return 'X won'\n 	elif resul == 1:\n 		return 'O won'\n \n 	resul = ganhador(l1[2], l2[2], l3[2], l4[2])\n 	\n 	if resul == 0:\n 		return 'X won'\n 	elif resul == 1:\n 		return 'O won'\n \n 	resul = ganhador(l1[3], l2[3], l3[3], l4[3])\n 	\n 	if resul == 0:\n 		return 'X won'\n 	elif resul == 1:\n 		return 'O won'\n \n 	# /\n 	resul = ganhador(l1[3], l2[2], l3[1], l4[0])\n 	\n 	if resul == 0:\n 		return 'X won'\n 	elif resul == 1:\n 		return 'O won'\n \n 	# \\n 	resul = ganhador(l1[0], l2[1], l3[2], l4[3])\n 	\n 	if resul == 0:\n 		return 'X won'\n 	elif resul == 1:\n 		return 'O won'\n 	\n 	if '.' in l1 or '.' in l2 or '.' in l3 or '.' in l4:\n 		return 'Game has not completed'\n 	else:\n 		return 'Draw'\n 	\n 	\n def ganhador(a, b, c, d):\n 	x = 0\n 	o = 0\n 	p = 0\n 	if a == 'X':\n 		x += 1\n 		p += 1\n 	if a == 'O':\n 		o += 1\n 		p += 1\n 	if a == 'T':\n 		x += 1\n 		o += 1\n 		p += 1\n 	if b == 'X':\n 		x += 1\n 		p += 1\n 	if b == 'O':\n 		o += 1\n 		p += 1\n 	if b == 'T':\n 		x += 1\n 		o += 1\n 		p += 1\n 	if c == 'X':\n 		x += 1\n 		p += 1\n 	if c == 'O':\n 		o += 1\n 		p += 1\n 	if c == 'T':\n 		x += 1\n 		o += 1\n 		p += 1\n 	if d == 'X':\n 		x += 1\n 		p += 1\n 	if d == 'O':\n 		o += 1\n 		p += 1\n 	if d == 'T':\n 		x += 1\n 		o += 1\n 		p += 1	\n 	if x == 4:\n 		return 0\n 	elif o == 4:\n 		return 1\n 	elif p == 4:\n 		return 2\n 	else: # incompleto\n 		return 3\n  \n if __name__ == '__main__':\n 	#unittest.main()\n 	for i in xrange(tCase):	\n 		l1 = [str(x) for x in sys.stdin.readline().split(' ')]\n 		l2 = [str(x) for x in sys.stdin.readline().split(' ')]	\n 		l3 = [str(x) for x in sys.stdin.readline().split(' ')]	\n 		l4 = [str(x) for x in sys.stdin.readline().split(' ')]\n 		nulo = [str(x) for x in sys.stdin.readline().split(' ')]		\n 		print "Case #%d: %s" % (i + 1, main(l1[0], l2[0], l3[0], l4[0]))\n 		\n 		##Numbers\n 		#N,M = [int(x) for x in sys.stdin.readline().split(' ')]	\n 		#print "Case #%d: %d" % (i + 1, main(N,M))
eko	<>	32	<>	2014_2974486_5690574640250880.py	<>	import os, re, sys\n import unittest\n \n \n #tCase = sys.stdin.readline().split()\n tCase = int(sys.stdin.readline())\n \n \n def map(R, C, Bombs):\n 	m = [["." for x in xrange(C)] for x in xrange(R)]\n 	print Bombs\n 	m[R-1][C-1] = 'c'\n 	lastSkip = False\n 	#for b in xrange(Bombs):\n 	for i in xrange(R):\n 		for j in xrange(C):\n 			if Bombs == 0:\n 				break\n 			\n 			if lastSkip:\n 				m[i][j] = 'f'\n 				continue\n 			\n 			if R - i == 2 or C - j == 2:\n 				if Bombs == 1:\n 					m[i][j] = 'f'\n 					lastSkip = True\n 					continue\n 			\n 				\n 			m[i][j] = '*'\n 			Bombs -= 1\n 			lastSkip = False\n 		lastSkip = False\n 				\n 	\n 	\n 	for line in m:\n 		for c in line:\n 			print c,\n 		print\n 		\n 		\n def imprimir(m):\n 	for line in m:\n 		for c in line:\n 			print c,\n 		print\n 		\n def map2(R, C, Bombs):\n 	m = [["." for x in xrange(C)] for x in xrange(R)]\n 	#print Bombs\n 	m[R-1][C-1] = 'c'\n 	lastSkip = False\n 	#for b in xrange(Bombs):\n 	\n 	ii = 0\n 	jj = 0\n 	while Bombs > 0:\n 		for j in xrange(jj, C):\n 			if Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n 				m[ii][j] = '*'\n 				Bombs -= 1\n 			else:\n 				continue\n 		\n 		\n 		for i in xrange(ii+1, R):\n 			if Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n 				m[i][jj] = '*'\n 				Bombs -= 1\n 			else:\n 				if Bombs > 0:\n 					print "Impossible"\n 					#imprimir(m)\n 					return\n 				continue\n 		jj += 1\n 		ii += 1\n 	#print "b", Bombs\n 	imprimir(m)\n 	\n 				\n 	\n 	\n \n 		\n def main(R, C, M):\n 	vazios = R * C - M\n \n 	if R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n 		map2(R, C, M)\n 	else:\n 		print "Impossible"\n \n 	#print vazios\n 	return ""\n 		\n  \n if __name__ == '__main__':\n 	#unittest.main()\n 	for i in xrange(tCase):	\n 		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	\n 		#print "Case #%d: %s" % (i + 1, main(frase[0]))\n 		\n 		##Numbers\n 		R, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n 		#YList = [float(x) for x in sys.stdin.readline().split(' ')]\n 		#ZList = [float(x) for x in sys.stdin.readline().split(' ')]\n 		#print E,R,N, NList\n 		print "Case #%d:" % (i + 1)\n 		main(R, C, M)
cheilman	<>	33	<>	2013_2270488_2463486.py	<>	#!/usr/bin/python\n \n import sys\n import math\n \n def readfile(file):\n   """\n     input:\n \n 		T (number of test cases)\n \n 		A B\n \n   """\n \n   tests = []\n \n   T = int(file.readline().strip())\n \n   for i in xrange(T):\n 		test = {}\n \n 		line = file.readline().strip()\n 		parts = line.split(" ")\n \n 		if len(parts) != 2:\n 			print "HORRIBLE ERROR IN TEST CASE %d" % (i+1,)\n 			return None\n \n 		test['A'] = int(parts[0])\n 		test['B'] = int(parts[1])\n     \n 		tests.append(test)\n \n   return tests\n \n def isPalindrome(s):\n 	"""\n 		Is s a palindrome.\n \n 		S must be a string.\n 	"""\n \n 	l = len(s)\n \n 	if (l % 2) == 0:\n 		# even\n 		frontHalf = s[0:l/2]\n 		backHalf = s[l/2:]\n 	else:\n 		# odd\n 		frontHalf = s[0:(l-1)/2]\n 		backHalf = s[(l+1)/2:]\n \n 	backHalf = backHalf[::-1]\n \n 	if frontHalf == backHalf:\n 		return True\n 	else:\n 		return False\n \n def isFairAndSquare(n):\n \n 	sqrtN = int(math.sqrt(n))\n \n 	if (sqrtN * sqrtN) != n:\n 		#print "%d is not square" % (n, )\n 		return False\n \n 	if not isPalindrome(str(n)):\n 		#print "%d is not palindrome" % (n, )\n 		return False\n \n 	if not isPalindrome(str(sqrtN)):\n 		#print "sqrt(%d) = %d is not palindrome" % (n, sqrtN)\n 		return False\n \n 	return True\n \n def run(test):\n 	"""\n 		Run a test and return output.\n 	"""\n \n 	count = 0\n \n 	for i in xrange(test['A'], test['B'] + 1):\n 		if isFairAndSquare(i):\n 			count = count + 1\n \n 	return count\n \n 	i = int(math.sqrt(test['A']))\n \n 	if (i * i) < test['A']:\n 		i = i + 1\n \n 	# Generate squares from palindromes\n 	while i < test['B']:\n 		#print "Checking %d" % (i, )\n 		if not isPalindrome(str(i)):\n 			i = i + 1\n 			continue\n \n 		# square it\n 		s = i * i\n \n 		if s <= test['B']:\n 			if isPalindrome(str(s)):\n 				#print "Counting %d" % (i * i, )\n 				count = count + 1\n 		else:\n 			# all done\n 			break\n \n 		i = i + 1\n \n 	return "%s" % (count, )\n \n file = open(sys.argv[1], "rt")\n \n tests = readfile(file)\n \n file.close()\n \n case = 1\n \n for test in tests:\n #if True:\n   #test = tests[0]\n   result = run(test)\n   print "Case #%d: %s" % (case, result)\n   case = case + 1\n
cheilman	<>	33	<>	2013_2270488_2449486.py	<>	#!/usr/bin/python\n \n import sys\n \n def readfile(file):\n   """\n     input:\n \n 		T (number of test cases)\n \n 		N M\n 		N lines of M numbers (desired height of grass)\n \n   """\n \n   tests = []\n \n   T = int(file.readline().strip())\n \n   for i in xrange(T):\n 		test = {}\n \n 		line = file.readline().strip()\n 		parts = line.split(' ')\n \n 		if len(parts) != 2:\n 			print "HORRIBLE ERROR in TEST %d!" % (i+1, )\n 			return None\n \n 		N = int(parts[0])\n 		M = int(parts[1])\n \n 		test['N'] = N\n 		test['M'] = M\n 		test['desired'] = []\n     \n 		for j in xrange(N):\n 			line = file.readline().strip()\n 			parts = line.split(' ')\n \n 			if len(parts) != M:\n 				print "TERRIBLE ERROR in TEST %d!" % (i+1, )\n 				return None\n \n 			for p in parts:\n 				k = int(p)\n 				test['desired'].append(k)\n \n 		tests.append(test)\n \n   return tests\n \n def run(test):\n 	"""\n 		Run a test and return output.\n 	"""\n \n 	# Figure out row/col min and max\n 	test['row'] = []\n 	test['col'] = []\n \n 	for row in xrange(test['N']):\n 		r = []\n \n 		for col in xrange(test['M']):\n 			i = row * test['M'] + col\n \n 			r.append(test['desired'][i])\n \n 		test['row'].append({'min' : min(r), 'max' : max(r)})\n \n 	for col in xrange(test['M']):\n 		c = []\n \n 		for row in xrange(test['N']):\n 			i = row * test['M'] + col\n \n 			c.append(test['desired'][i])\n \n 		test['col'].append({'min' : min(c), 'max' : max(c)})\n \n 	for x in xrange(test['M']):\n 		for y in xrange(test['N']):\n 			i = y * test['M'] + x\n 			v = test['desired'][i]\n \n 			# If you are smaller than someone in both directions, it's impossible\n 			rowmax = test['row'][y]['max']\n 			colmax = test['col'][x]['max']\n 			if (v < rowmax) and (v < colmax):\n 				#print "(%d,%d) = %d, row = %d, col = %d" % (x, y, v, rowmax, colmax)\n 				return "NO"\n \n 	return "YES"\n \n file = open(sys.argv[1], "rt")\n \n tests = readfile(file)\n \n file.close()\n \n case = 1\n \n for test in tests:\n #if True:\n   #test = tests[0]\n   result = run(test)\n   print "Case #%d: %s" % (case, result)\n   case = case + 1\n
cheilman	<>	33	<>	2012_1460488_1483488.py	<>	#!/usr/bin/python\n \n def readfile(filename):\n 	"""\n 	The first line of the input gives the number of test cases,\n 	T. T test cases follow. Each test case consists of a single line\n 	containing the integers A and B.\n 	"""\n \n 	file = open(filename, "rt")\n \n 	retval = {}\n \n 	T = int(file.readline().strip())\n 	retval['T'] = T\n \n 	tests = []\n \n 	for i in xrange(T):\n 		line = file.readline().strip()\n \n 		parts = line.split(" ")\n \n 		A = int(parts[0])\n 		B = int(parts[1])\n \n 		test = {'A' : A, 'B' : B}\n \n 		tests = tests + [test, ]\n \n 	retval['tests'] = tests\n \n 	return retval\n \n def isrecycled(n, m):\n 	if (len(n) != len(m)):\n 		return False\n \n 	for i in range(len(n)):\n 		left = n[:i]\n 		right = n[i:]\n \n 		flip = right + left\n \n 		if (flip == m):\n 			return True\n \n 	return False\n \n def process(test):\n 	count = 0\n \n 	A = test['A']\n 	B = test['B']\n \n 	for n in xrange(A, B):\n 		for m in xrange(n + 1, B):\n 			if (isrecycled(str(n), str(m))):\n 				count = count + 1\n \n 	return count\n \n def process2(test):\n 	count = 0\n \n 	A = test['A']\n 	B = test['B']\n \n 	for n in xrange(A, B):\n 		v = str(n)\n \n 		found = set()\n \n 		for i in xrange(len(v)):\n 			left = v[:i]\n 			right = v[i:]\n \n 			flip = right + left\n 			iflip = int(flip)\n \n 			if ((iflip > n) and (iflip <= B)):\n 				if (not iflip in found):\n 					count = count + 1\n 					found.add(iflip)\n \n 	return count\n \n data = readfile("C-small-attempt0.in")\n \n for i in xrange(data['T']):\n 	test = data['tests'][i]\n \n 	result = process2(test)\n \n 	print "Case #%d: %d" % (i + 1, result)\n
cheilman	<>	33	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/python\n \n import sys\n \n import puzutils\n \n class Magic_2014_QA(puzutils.CodeJamProblem):\n   def __init__(self, inputFilename):\n     puzutils.CodeJamProblem.__init__(self, inputFilename)\n \n     self.T = None\n \n   def load(self):\n     """\n       input:\n \n       T (number of test cases)\n \n       A (answer to first question)\n       x x x x\n       x x x x\n       x x x x\n       x x x x\n       B (answer to second question)\n       x x x x\n       x x x x\n       x x x x\n       x x x x\n \n     """\n \n     self.tests = []\n \n     with open(self.inputFilename, "rt") as file:\n       self.T = int(file.readline().strip())\n \n       for i in xrange(self.T):\n         a = int(file.readline().strip())\n         test = {'a': a}\n         board = []\n         \n         for j in xrange(4):\n           line = file.readline().strip()\n           row = set([int(x) for x in line.split(' ')])\n           board.append(row)\n \n         test['aboard'] = board\n \n         b = int(file.readline().strip())\n         test['b'] = b\n         board = []\n         \n         for j in xrange(4):\n           line = file.readline().strip()\n           row = set([int(x) for x in line.split(' ')])\n           board.append(row)\n \n         test['bboard'] = board\n \n         self.tests.append(test)\n \n     return True\n \n   def executeTest(self, test):\n     """\n       Run a test and return output.\n     """\n \n     #print "Test: %s\n" % (test, )\n \n     rowA = test['aboard'][test['a'] - 1]\n     rowB = test['bboard'][test['b'] - 1]\n \n     #print "rowA: %s\nrowB: %s\n" % (rowA, rowB)\n \n     intersect = rowA.intersection(rowB)\n \n     #print "intersect: %s\n" % (intersect, )\n \n     if (len(intersect) == 1):\n       (element,) = intersect\n       return element\n     elif (len(intersect) == 0):\n       return "Volunteer cheated!"\n     else:\n       return "Bad magician!"\n \n with Magic_2014_QA(sys.argv[1]) as problem:\n   problem.load()\n \n   problem.run()\n
cheilman	<>	33	<>	2012_1460488_1483485.py	<>	#!/usr/bin/python\n \n from string import maketrans\n \n input = "aoz"\n outpt = "yeq"\n \n input = input + "our language is impossible to understand"\n outpt = outpt + "ejp mysljylc kd kxveddknmc re jsicpdrysi"\n \n input = input + "there are twenty six factorial possibilities"\n outpt = outpt + "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"\n \n input = input + "so it is okay if you want to just give up"\n outpt = outpt + "de kr kd eoya kw aej tysr re ujdr lkgc jv"\n \n input = input + "q"\n outpt = outpt + "z"\n \n togoog = maketrans(input, outpt)\n ungoog = maketrans(outpt, input)\n \n filename = "A-small-attempt1.in"\n \n file = open(filename, "rt")\n \n T = int(file.readline().strip())\n \n for i in xrange(T):\n 	line = file.readline().strip()\n \n 	print "Case #%d: %s" % (i + 1, line.translate(ungoog))\n
cheilman	<>	33	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/python\n \n import sys\n \n import puzutils\n \n class Cookie_2014_QB(puzutils.CodeJamProblem):\n   def __init__(self, inputFilename):\n     puzutils.CodeJamProblem.__init__(self, inputFilename)\n \n     self.T = None\n \n   def load(self):\n     """\n       input:\n \n       T (number of test cases)\n \n       C F X (real numbers)\n \n     """\n \n     self.tests = []\n \n     with open(self.inputFilename, "rt") as file:\n       self.T = int(file.readline().strip())\n \n       for i in xrange(self.T):\n         (C,F,X) = [float(x) for x in file.readline().split(' ')]\n \n         self.tests.append([C,F,X])\n \n     return True\n \n   def timeToNextFarm(self, C, rate):\n     """\n       How long in seconds until we get the next farm.\n     """\n \n     return (C * 1.0) / rate\n \n   def timeToTarget(self, C, X, rate):\n     """\n       How long in seconds until we hit the target.\n     """\n \n     return ( X * 1.0) / rate\n \n   def isFarmWorthIt(self, C, X, F, rate):\n     #print "C = %.2f, F = %.2f, X = %.2f, rate = %.2f" % (C, F, X, rate)\n \n     withoutFarm = self.timeToTarget(C, X, rate)\n     withFarm = self.timeToNextFarm(C, rate) + self.timeToTarget(C, X, rate + F)\n \n     #print "With farm = %.2f" % (withFarm,)\n     #print "Without farm = %.2f" % (withoutFarm,)\n \n     if (withFarm < withoutFarm):\n       return True\n     else:\n       return False\n \n   def executeTest(self, test):\n     """\n       Run a test and return output.\n     """\n \n     (C,F,X) = test\n     rate = 2\n     elapsed = 0.0\n \n     #print "C = %.2f, F = %.2f, X = %.2f, rate = %.2f" % (C, F, X, rate)\n \n     while True:\n       if self.isFarmWorthIt(C, X, F, rate):\n         #print "%.2f: Bought farm, rate = %d" % (elapsed, rate)\n         elapsed = elapsed + self.timeToNextFarm(C, rate)\n         rate = rate + F\n       else:\n         #print "%.2f: Giving up and finishing it out, rate = %d" % (elapsed, rate)\n         elapsed = elapsed + self.timeToTarget(C, X, rate)\n         return "%0.7f" % (elapsed, )\n \n with Cookie_2014_QB(sys.argv[1]) as problem:\n   problem.load()\n \n   problem.run()\n
cheilman	<>	33	<>	2013_2270488_2453486.py	<>	#!/usr/bin/python\n \n import sys\n \n def readfile(file):\n   """\n     input:\n \n 		T (number of test cases)\n \n 		xxxx\n 		xxxx\n 		xxxx\n 		xxxx	(T boards, where x in [X,O,T,.]\n \n   """\n \n   tests = []\n \n   T = int(file.readline().strip())\n \n   for i in xrange(T):\n 		board = ""\n     \n 		for j in xrange(4):\n 			line = file.readline().strip()\n \n 			board = board + line\n \n 		file.readline()\n \n 		tests.append(board)\n \n   return tests\n \n def fourInARow(who, test):\n 	"""\n 		Find four of 'who' in a row (T wild).\n 	"""\n \n 	target = (who, 'T')\n \n 	# Horizontal/Vertical\n 	for i in range(4):\n 		horzWin = True\n 		vertWin = True\n \n 		for j in range(4):\n 			horzIndex = i * 4 + j\n 			vertIndex = j * 4 + i\n \n 			if not (test[horzIndex] in target):\n 				horzWin = False\n \n 			if not (test[vertIndex] in target):\n 				vertWin = False\n \n 		if horzWin or vertWin:\n 			return True\n \n 	# Diagonal\n 	slashWin = True\n 	bslashWin = True\n \n 	for i in range(4):\n 		x = y = i\n \n 		slashIndex = y * 4 + x\n 		bslashIndex = y * 4 + (3 - x)\n \n 		#print "Checking (%d,%d) = %s and (%d,%d) = %s" % (x, y, test[slashIndex], 3-x, y, test[bslashIndex])\n \n 		if not (test[slashIndex] in target):\n 			slashWin = False\n \n 		if not (test[bslashIndex] in target):\n 			bslashWin = False\n \n 	if slashWin or bslashWin:\n 		return True\n \n 	return False\n \n def run(test):\n 	"""\n 		Run a test and return output.\n 	"""\n \n 	if fourInARow('X', test):\n 		return "X won"\n 	elif fourInARow('O', test):\n 		return "O won"\n 	elif '.' in test:\n 		return "Game has not completed"\n 	else:\n 		return "Draw"\n \n file = open(sys.argv[1], "rt")\n \n tests = readfile(file)\n \n file.close()\n \n case = 1\n \n for test in tests:\n #if True:\n   #test = tests[0]\n   result = run(test)\n   print "Case #%d: %s" % (case, result)\n   case = case + 1\n
cheilman	<>	33	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/python\n \n import sys\n \n import puzutils\n \n class Minesweeper_2014_QC(puzutils.CodeJamProblem):\n   def __init__(self, inputFilename):\n     puzutils.CodeJamProblem.__init__(self, inputFilename)\n \n     self.T = None\n \n   def load(self):\n     """\n       input:\n \n       T (number of test cases)\n \n       R C M (integers)\n \n     """\n \n     self.tests = []\n \n     with open(self.inputFilename, "rt") as file:\n       self.T = int(file.readline().strip())\n \n       for i in xrange(self.T):\n         (R,C,M) = [int(x) for x in file.readline().split(' ')]\n \n         self.tests.append([R,C,M])\n \n     return True\n \n   def boardToString(self, board):\n     retval = ""\n \n     for row in board:\n       retval = retval + "\n" + "".join(row)\n \n     return retval\n \n   def executeTest(self, test):\n     """\n       Run a test and return output.\n     """\n \n     (R,C,M) = test\n     #print "R: %d, C: %d, M: %d" % (R,C,M)\n \n     spaces = R * C\n     blanks = spaces - M\n \n     if (blanks <= 0):\n       #print "R: %d, C: %d, M: %d, spaces: %d, blanks: %d" % (R,C,M,spaces,blanks)\n       return "Impossible"\n \n     board = [['.' for x in range(C)] for y in range(R)]\n \n     board[R-1][C-1] = "c"\n \n     badpositions=[]\n     positions=[]\n \n     for x in xrange(C):\n       for y in xrange(R):\n         if (x == (C-1)) and (y == (R-1)):\n           continue\n         if (x == (C-1)) and (y == (R-2)):\n           badpositions.append((x,y))\n           continue\n         if (x == (C-2)) and (y == (R-1)):\n           badpositions.append((x,y))\n           continue\n         if (x == (C-2)) and (y == (R-2)):\n           badpositions.append((x,y))\n           continue\n \n         positions.append((x,y))\n \n     positions.reverse()\n \n     for x in badpositions:\n       positions.insert(0, x)\n \n     m = M\n \n     while (m > 0):\n       if len(positions) <= 0:\n         #return self.boardToString(board)\n         return "Impossible"\n \n       pos = positions.pop()\n       (x,y) = pos\n \n       if (board[y][x] != "."):\n         #return self.boardToString(board)\n         return "Impossible"\n \n       board[y][x] = '*'\n       m = m - 1\n \n     mines = sum([x.count('*') for x in board])\n \n     if (mines != M):\n       #return self.boardToString(board)\n       return "Impossible"\n \n     if (blanks > 1):\n       if (R > 1):\n         if board[R - 2][C - 1] == "*":\n           #return self.boardToString(board)\n           return "Impossible"\n \n       if (C > 1):\n         if board[R - 1][C - 2] == "*":\n           #return self.boardToString(board)\n           return "Impossible"\n \n       if (R > 1) and (C > 1):\n         if board[R - 2][C - 2] == "*":\n           #return self.boardToString(board)\n           return "Impossible"\n \n     #return "Possible"\n     return self.boardToString(board)\n \n with Minesweeper_2014_QC(sys.argv[1]) as problem:\n   problem.load()\n \n   problem.run()\n
mth	<>	34	<>	2013_2270488_2463486.py	<>	#!/usr/bin/env python\n \n from math import sqrt\n \n FILE_NAME_BASE = 'C-small-attempt0'\n NUM_PROCESSES = 0\n MEM_LIMIT_GB = 1.5 # per worker process\n RECURSION_LIMIT = 1000\n \n def parse(inp):\n 	a, b = (int(x) for x in inp.readline().split())\n 	return a, b\n \n def isFair(x):\n 	l1 = list(str(x))\n 	l2 = list(l1)\n 	l2.reverse()\n 	return l1 == l2\n \n def solve(a, b):\n 	c = 0\n 	for i in xrange(a, b + 1):\n 		r = int(sqrt(i))\n 		if r * r == i and isFair(i) and isFair(r):\n 			c += 1\n \n 	return str(c)\n \n def main():\n 	import sys\n 	sys.setrecursionlimit(RECURSION_LIMIT)\n \n 	import resource\n 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n 	inp = open(FILE_NAME_BASE + '.in', 'r')\n 	numCases = int(inp.readline())\n 	if NUM_PROCESSES == 0:\n 		results = [\n 			solve(*parse(inp))\n 			for _ in range(numCases)\n 			]\n 	else:\n 		from multiprocessing import Pool\n 		pool = Pool(NUM_PROCESSES)\n 		results = [\n 			pool.apply_async(solve, parse(inp))\n 			for _ in range(numCases)\n 			]\n 	inp.close()\n 	out = open(FILE_NAME_BASE + '.out', 'w')\n 	for case, result in enumerate(results):\n 		value = result if NUM_PROCESSES == 0 else result.get()\n 		out.write('Case #%d: %s\n' % (case + 1, value))\n 		out.flush()\n 	out.close()\n \n if __name__ == '__main__':\n 	main()\n
mth	<>	34	<>	2013_2270488_2449486.py	<>	#!/usr/bin/env python\n \n FILE_NAME_BASE = 'B-small-attempt0'\n NUM_PROCESSES = 0\n MEM_LIMIT_GB = 1.5 # per worker process\n RECURSION_LIMIT = 1000\n \n def parse(inp):\n 	rows, cols = (int(x) for x in inp.readline().split())\n 	return tuple(\n 		tuple(int(x) for x in inp.readline().split())\n 		for row in xrange(rows)\n 		),\n \n def solve(lawn):\n 	#print lawn\n \n 	rowMax = tuple(max(row) for row in lawn)\n 	colMax = tuple(max(row[i] for row in lawn) for i in xrange(len(lawn[0])))\n 	#print rowMax, colMax\n \n 	def possible():\n 		for y, row in enumerate(lawn):\n 			for x, cell in enumerate(row):\n 				h = min(rowMax[y], colMax[x])\n 				if cell != h:\n 					return False\n 		return True\n \n 	return 'YES' if possible() else 'NO'\n \n def main():\n 	import sys\n 	sys.setrecursionlimit(RECURSION_LIMIT)\n \n 	import resource\n 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n 	inp = open(FILE_NAME_BASE + '.in', 'r')\n 	numCases = int(inp.readline())\n 	if NUM_PROCESSES == 0:\n 		results = [\n 			solve(*parse(inp))\n 			for _ in range(numCases)\n 			]\n 	else:\n 		from multiprocessing import Pool\n 		pool = Pool(NUM_PROCESSES)\n 		results = [\n 			pool.apply_async(solve, parse(inp))\n 			for _ in range(numCases)\n 			]\n 	inp.close()\n 	out = open(FILE_NAME_BASE + '.out', 'w')\n 	for case, result in enumerate(results):\n 		value = result if NUM_PROCESSES == 0 else result.get()\n 		out.write('Case #%d: %s\n' % (case + 1, value))\n 		out.flush()\n 	out.close()\n \n if __name__ == '__main__':\n 	main()\n
mth	<>	34	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python\n \n FILE_NAME_BASE = 'C-small-attempt0'\n NUM_PROCESSES = 0\n \n def parse(inp):\n 	a, b = (int(x) for x in inp.readline().split())\n 	return a, b\n \n def solve(a, b):\n 	count = 0\n 	for i in xrange(a, b):\n 		s = str(i)\n 		recycled = set()\n 		for d in xrange(1, len(s)):\n 			r = s[d : ] + s[ : d]\n 			if i < int(r) <= b:\n 				recycled.add(r)\n 		count += len(recycled)\n 	return count\n \n if __name__ == '__main__':\n 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')\n 	numCases = int(inp.readline())\n 	if NUM_PROCESSES == 0:\n 		results = [\n 			solve(*parse(inp))\n 			for _ in range(numCases)\n 			]\n 	else:\n 		from multiprocessing import Pool\n 		pool = Pool(NUM_PROCESSES)\n 		results = [\n 			pool.apply_async(solve, parse(inp))\n 			for _ in range(numCases)\n 			]\n 	inp.close()\n 	out = open(FILE_NAME_BASE + '.out.txt', 'w')\n 	for case, result in enumerate(results):\n 		value = result if NUM_PROCESSES == 0 else result.get()\n 		out.write('Case #%d: %s\n' % (case + 1, value))\n 		out.flush()\n 	out.close()\n
mth	<>	34	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/env python\n \n FILE_NAME_BASE = 'A-small-attempt0'\n NUM_PROCESSES = 0\n MEM_LIMIT_GB = 1.5 # per worker process\n RECURSION_LIMIT = 1000\n \n def parseBoard(inp):\n 	rowSel, = (int(x) for x in inp.readline().split())\n 	board = tuple(\n 		tuple(int(x) for x in inp.readline().split())\n 		for _ in xrange(4)\n 		)\n 	return board, rowSel - 1\n \n def parse(inp):\n 	before, beforeSel = parseBoard(inp)\n 	after, afterSel = parseBoard(inp)\n 	return before, beforeSel, after, afterSel\n \n def solve(before, beforeSel, after, afterSel):\n 	candidates = set(before[beforeSel]) & set(after[afterSel])\n \n 	if len(candidates) == 0:\n 		return "Volunteer cheated!"\n 	elif len(candidates) == 1:\n 		return candidates.pop()\n 	else:\n 		return "Bad magician!"\n \n def main():\n 	import sys\n 	sys.setrecursionlimit(RECURSION_LIMIT)\n \n 	import resource\n 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n 	inp = open(FILE_NAME_BASE + '.in', 'r')\n 	numCases = int(inp.readline())\n 	if NUM_PROCESSES == 0:\n 		results = [\n 			solve(*parse(inp))\n 			for _ in range(numCases)\n 			]\n 	else:\n 		from multiprocessing import Pool\n 		pool = Pool(NUM_PROCESSES)\n 		results = [\n 			pool.apply_async(solve, parse(inp))\n 			for _ in range(numCases)\n 			]\n 	inp.close()\n 	out = open(FILE_NAME_BASE + '.out', 'w')\n 	for case, result in enumerate(results):\n 		value = result if NUM_PROCESSES == 0 else result.get()\n 		out.write('Case #%d: %s\n' % (case + 1, value))\n 		out.flush()\n 	out.close()\n \n if __name__ == '__main__':\n 	main()\n
mth	<>	34	<>	2012_1460488_1483485.py	<>	#!/usr/bin/env python\n \n FILE_NAME_BASE = 'A-small'\n NUM_PROCESSES = 0\n \n def findMapping(knowledge):\n 	# Build Googlerese to English mapping from example text.\n 	mapping = {}\n 	for english, googlerese in knowledge:\n 		assert len(english) == len(googlerese)\n 		for engChar, gooChar in zip(english, googlerese):\n 			if ord('a') <= ord(engChar) <= ord('z'):\n 				assert ord('a') <= ord(gooChar) <= ord('z')\n 				if gooChar in mapping:\n 					assert mapping[gooChar] == engChar\n 				else:\n 					mapping[gooChar] = engChar\n 			else:\n 				assert engChar == gooChar\n \n 	# If one letter is not be specified in the example text, we can still\n 	# complete the mapping.\n 	alphabet = set(chr(i) for i in xrange(ord('a'), ord('z') + 1))\n 	gooMissing = alphabet - set(mapping.iterkeys())\n 	engMissing = alphabet - set(mapping.itervalues())\n 	assert len(gooMissing) == len(engMissing)\n 	if len(gooMissing) == 1:\n 		gooChar, = gooMissing\n 		engChar, = engMissing\n 		mapping[gooChar] = engChar\n 	else:\n 		assert len(gooMissing) == 0\n \n 	# Convert completed mapping to Python translate table.\n 	assert len(mapping) == 26, mapping\n 	return ''.join(mapping.get(chr(i), chr(i)) for i in xrange(256))\n \n def parse(inp):\n 	return inp.readline().rstrip('\n'),\n \n def solve(line):\n 	return line.translate(mapping)\n \n knowledge = (\n 	( 'our language is impossible to understand',\n 	  'ejp mysljylc kd kxveddknmc re jsicpdrysi' ),\n 	( 'there are twenty six factorial possibilities',\n 	  'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' ),\n 	( 'so it is okay if you want to just give up',\n 	  'de kr kd eoya kw aej tysr re ujdr lkgc jv' ),\n 	( 'a zoo',\n 	  'y qee' ),\n 	)\n \n mapping = findMapping(knowledge)\n \n if __name__ == '__main__':\n 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')\n 	numCases = int(inp.readline())\n 	if NUM_PROCESSES == 0:\n 		results = [\n 			solve(*parse(inp))\n 			for _ in range(numCases)\n 			]\n 	else:\n 		from multiprocessing import Pool\n 		pool = Pool(NUM_PROCESSES)\n 		results = [\n 			pool.apply_async(solve, parse(inp))\n 			for _ in range(numCases)\n 			]\n 	inp.close()\n 	out = open(FILE_NAME_BASE + '.out.txt', 'w')\n 	for case, result in enumerate(results):\n 		value = result if NUM_PROCESSES == 0 else result.get()\n 		out.write('Case #%d: %s\n' % (case + 1, value))\n 		out.flush()\n 	out.close()\n
mth	<>	34	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/env python\n \n FILE_NAME_BASE = 'B-small-attempt0'\n NUM_PROCESSES = 0\n MEM_LIMIT_GB = 1.5 # per worker process\n RECURSION_LIMIT = 1000\n \n def parse(inp):\n 	cost, prod, goal = (float(x) for x in inp.readline().split())\n 	return cost, prod, goal\n \n def solve(cost, prod, goal):\n 	rate = 2\n 	now = 0\n 	while True:\n 		nobuyEnd = goal / rate\n 		buyEnd = cost / rate + goal / (rate + prod)\n 		if buyEnd < nobuyEnd:\n 			now += cost / rate\n 			rate += prod\n 		else:\n 			return '%0.7f' % (now + nobuyEnd)\n \n def main():\n 	import sys\n 	sys.setrecursionlimit(RECURSION_LIMIT)\n \n 	import resource\n 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n 	inp = open(FILE_NAME_BASE + '.in', 'r')\n 	numCases = int(inp.readline())\n 	if NUM_PROCESSES == 0:\n 		results = [\n 			solve(*parse(inp))\n 			for _ in range(numCases)\n 			]\n 	else:\n 		from multiprocessing import Pool\n 		pool = Pool(NUM_PROCESSES)\n 		results = [\n 			pool.apply_async(solve, parse(inp))\n 			for _ in range(numCases)\n 			]\n 	inp.close()\n 	out = open(FILE_NAME_BASE + '.out', 'w')\n 	for case, result in enumerate(results):\n 		value = result if NUM_PROCESSES == 0 else result.get()\n 		out.write('Case #%d: %s\n' % (case + 1, value))\n 		out.flush()\n 	out.close()\n \n if __name__ == '__main__':\n 	main()\n
mth	<>	34	<>	2013_2270488_2453486.py	<>	#!/usr/bin/env python\n \n FILE_NAME_BASE = 'A-small-attempt0'\n NUM_PROCESSES = 0\n MEM_LIMIT_GB = 1.5 # per worker process\n RECURSION_LIMIT = 1000\n \n def parse(inp):\n 	board = tuple( inp.readline().rstrip() for _ in xrange(4) )\n 	empty = inp.readline().rstrip()\n 	assert empty == '', empty\n 	return board,\n \n def solve(board):\n \n 	def scan(start, delta):\n 		x, y = start\n 		dx, dy = delta\n 		for _ in xrange(4):\n 			yield board[y][x]\n 			x += dx\n 			y += dy\n \n 	# Look for a winner.\n 	for start, delta in (\n 		# horizontal\n 		((0, 0), (1, 0)),\n 		((0, 1), (1, 0)),\n 		((0, 2), (1, 0)),\n 		((0, 3), (1, 0)),\n 		# vertical\n 		((0, 0), (0, 1)),\n 		((1, 0), (0, 1)),\n 		((2, 0), (0, 1)),\n 		((3, 0), (0, 1)),\n 		# diagonal\n 		((0, 0), (1, 1)),\n 		((3, 0), (-1, 1)),\n 		):\n 		chars = set(scan(start, delta))\n 		if chars == set(['X']) or chars == set(['X', 'T']):\n 			return 'X won'\n 		elif chars == set(['O']) or chars == set(['O', 'T']):\n 			return 'O won'\n \n 	# No winner; draw or unfinished game?\n 	if any('.' in row for row in board):\n 		return 'Game has not completed'\n 	else:\n 		return 'Draw'\n \n def main():\n 	import sys\n 	sys.setrecursionlimit(RECURSION_LIMIT)\n \n 	import resource\n 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n 	inp = open(FILE_NAME_BASE + '.in', 'r')\n 	numCases = int(inp.readline())\n 	if NUM_PROCESSES == 0:\n 		results = [\n 			solve(*parse(inp))\n 			for _ in range(numCases)\n 			]\n 	else:\n 		from multiprocessing import Pool\n 		pool = Pool(NUM_PROCESSES)\n 		results = [\n 			pool.apply_async(solve, parse(inp))\n 			for _ in range(numCases)\n 			]\n 	inp.close()\n 	out = open(FILE_NAME_BASE + '.out', 'w')\n 	for case, result in enumerate(results):\n 		value = result if NUM_PROCESSES == 0 else result.get()\n 		out.write('Case #%d: %s\n' % (case + 1, value))\n 		out.flush()\n 	out.close()\n \n if __name__ == '__main__':\n 	main()\n
mth	<>	34	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/env python\n \n FILE_NAME_BASE = 'C-small-attempt0'\n NUM_PROCESSES = 0\n MEM_LIMIT_GB = 1.5 # per worker process\n RECURSION_LIMIT = 1000\n \n def parse(inp):\n 	rows, cols, mines = (int(x) for x in inp.readline().split())\n 	return rows, cols, mines\n \n def search(rows, cols, mines):\n 	# Boundary cases:\n 	# TODO: Might be redundant once we have a generic solution.\n \n 	# Mine count extremes.\n 	assert 0 <= mines < rows * cols\n 	if mines == 0:\n 		return ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\n 	if mines == rows * cols - 1:\n 		return ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n \n 	# One-dimensional board.\n 	if rows == 1:\n 		return ['c' + '.' * (cols - 1 - mines) + '*' * mines]\n 	if cols == 1:\n 		return ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\n \n 	# Nearly-full two-dimensional board: the clicked cell must not have any\n 	# mines as neighbours or the flooding won't start.\n 	if mines > rows * cols - 4:\n 		return None\n \n 	# TODO: For now, we just give up.\n \n 	return None\n \n class SearchBoard(object):\n \n 	def __init__(self, rows, cols):\n 		self.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\n 		self.mineCount = 0\n \n 	def addMine(self, row, col):\n 		counts = self.counts\n 		assert counts[row + 1][col + 1] < 10\n 		top = counts[row + 0]\n 		top[col + 0] += 1\n 		top[col + 1] += 1\n 		top[col + 2] += 1\n 		mid = counts[row + 1]\n 		mid[col + 0] += 1\n 		mid[col + 1] += 10\n 		mid[col + 2] += 1\n 		bot = counts[row + 2]\n 		bot[col + 0] += 1\n 		bot[col + 1] += 1\n 		bot[col + 2] += 1\n 		self.mineCount += 1\n \n 	def removeMine(self, row, col):\n 		counts = self.counts\n 		assert counts[row + 1][col + 1] >= 10\n 		top = counts[row + 0]\n 		top[col + 0] -= 1\n 		top[col + 1] -= 1\n 		top[col + 2] -= 1\n 		mid = counts[row + 1]\n 		mid[col + 0] -= 1\n 		mid[col + 1] -= 10\n 		mid[col + 2] -= 1\n 		bot = counts[row + 2]\n 		bot[col + 0] -= 1\n 		bot[col + 1] -= 1\n 		bot[col + 2] -= 1\n 		self.mineCount -= 1\n \n 	def checkConnected(self):\n 		counts = self.counts\n 		cols = len(counts[0]) - 2\n 		rows = len(counts) - 2\n \n 		# Pick a cell to click on. Any zero cell will do: if all zeroes are\n 		# connected, clicking on any zero will reveal them all.\n 		for rowIdx, row in enumerate(counts):\n 			if rowIdx == 0 or rowIdx > rows:\n 				continue\n 			try:\n 				colIdx = row.index(0, 1, -1)\n 			except ValueError:\n 				pass\n 			else:\n 				click = (rowIdx, colIdx)\n 				break\n 		else:\n 			return None\n \n 		revealed = set()\n 		def reveal(row, col):\n 			if 1 <= row <= rows and 1 <= col <= cols:\n 				pos = (row, col)\n 				if pos not in revealed:\n 					revealed.add(pos)\n 					count = counts[row][col]\n 					if count == 0:\n 						for dr in (-1, 0, 1):\n 							for dc in (-1, 0, 1):\n 								if dr != 0 or dc != 0:\n 									reveal(row + dr, col + dc)\n 					else:\n 						assert count < 10\n 		reveal(*click)\n 		numNonMines = rows * cols - self.mineCount\n 		if len(revealed) != numNonMines:\n 			assert len(revealed) < numNonMines\n 			return None\n \n 		# Construct a board in the solution syntax.\n 		board = [\n 				['.' if cell < 10 else '*' for cell in row[1 : -1]]\n 				for row in counts[1 : -1]\n 				]\n 		board[click[0] - 1][click[1] - 1] = 'c'\n 		return [''.join(row) for row in board]\n \n def searchBruteForce(rows, cols, mines):\n 	# This is the only case where there are no zero cells but there is a\n 	# solution.\n 	if mines == rows * cols - 1:\n 		return ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n \n 	searchBoard = SearchBoard(rows, cols)\n \n 	def searchRec(idx, remaining):\n 		if remaining == 0:\n 			return searchBoard.checkConnected()\n 		elif idx < remaining:\n 			return None\n 		else:\n 			pos = divmod(idx, cols)\n 			searchBoard.addMine(*pos)\n 			found = searchRec(idx - 1, remaining - 1)\n 			searchBoard.removeMine(*pos)\n 			if found is not None:\n 				return found\n 			return searchRec(idx - 1, remaining)\n \n 	return searchRec(rows * cols - 1, mines)\n \n def solve(rows, cols, mines):\n 	board = search(rows, cols, mines)\n \n 	if board is None:\n 		board = searchBruteForce(rows, cols, mines)\n 		if board is None:\n 			return '\n' + 'Impossible'\n 		print 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\n 				% (rows, cols, mines)\n 		for row in board:\n 			print row\n 		print\n \n 	# Perform sanity checks.\n 	assert len(board) == rows\n 	assert all(len(row) == cols for row in board)\n 	counts = { 'c': 0, '.': 0, '*': 0 }\n 	for row in board:\n 		for cell in row:\n 			counts[cell] += 1\n 	assert counts['c'] == 1\n 	assert counts['*'] == mines\n \n 	flowBoard = [\n 			['.' if cell == 'c' else cell for cell in row]\n 			for row in board\n 			]\n 	def countMinesOn(row, col):\n 		if 0 <= row < rows and 0 <= col < cols:\n 			return 1 if flowBoard[row][col] == '*' else 0\n 		else:\n 			return 0\n 	def countMinesNear(row, col):\n 		return sum(\n 			countMinesOn(row + dr, col + dc)\n 			for dr in (-1, 0, 1)\n 			for dc in (-1, 0, 1)\n 			)\n 	def reveal(row, col):\n 		if 0 <= row < rows and 0 <= col < cols:\n 			assert flowBoard[row][col] != '*'\n 			if flowBoard[row][col] == '.':\n 				count = countMinesNear(row, col)\n 				flowBoard[row][col] = str(count)\n 				if count == 0:\n 					for dr in (-1, 0, 1):\n 						for dc in (-1, 0, 1):\n 							reveal(row + dr, col + dc)\n 	clickRow, = [i for i, row in enumerate(board) if 'c' in row]\n 	clickCol = board[clickRow].index('c')\n 	reveal(clickRow, clickCol)\n 	assert all('.' not in row for row in flowBoard), flowBoard\n \n 	assert all(type(row) == str for row in board)\n 	return '\n' + ''.join('\n' + ''.join(row) for row in board)\n \n def main():\n 	import sys\n 	sys.setrecursionlimit(RECURSION_LIMIT)\n \n 	import resource\n 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n 	inp = open(FILE_NAME_BASE + '.in', 'r')\n 	numCases = int(inp.readline())\n 	if NUM_PROCESSES == 0:\n 		results = [\n 			solve(*parse(inp))\n 			for _ in range(numCases)\n 			]\n 	else:\n 		from multiprocessing import Pool\n 		pool = Pool(NUM_PROCESSES)\n 		results = [\n 			pool.apply_async(solve, parse(inp))\n 			for _ in range(numCases)\n 			]\n 	inp.close()\n 	out = open(FILE_NAME_BASE + '.out', 'w')\n 	for case, result in enumerate(results):\n 		value = result if NUM_PROCESSES == 0 else result.get()\n 		out.write('Case #%d: %s\n' % (case + 1, value))\n 		out.flush()\n 	out.close()\n \n if __name__ == '__main__':\n 	main()\n
jakab922	<>	35	<>	2013_2270488_2463486.py	<>	# In general 1[10]*1 square is always a palindrome and some subset of [12][012]*[12] is also good but it's just\n # too much hassle to figure that out. Also needs a more complex generator for ranges. 55p is hard...\n \n \n LIMIT = 10\n \n def check_palindrome(number):\n     rev = 0\n     runner = number\n     while runner > 0:\n         rev = rev * 10 + (runner % 10)\n         runner /= 10\n     if rev == number:\n         return True\n     else:\n         return False\n \n def list_to_number(number_list):\n     l = len(number_list)\n     res = 0; rres = 0\n     multi = 1\n     for i in xrange(1, l + 1):\n         res += number_list[l - i] * multi\n         rres += number_list[i - 1] * multi\n         multi *= 10\n     return (res, rres)\n \n def gen_one_side(side_length):\n     state = [0 for _ in xrange(side_length)]\n     done = False\n \n     while not done:\n         if state[-1] != 0:\n             yield state\n         state[-1] += 1\n         curr = side_length - 1\n         while state[curr] == LIMIT:\n             if curr == 0:\n                 done = True\n                 break\n             state[curr] = 0\n             curr -= 1\n             state[curr] += 1\n \n def gen_odd_palindrome(side_length):\n     if side_length == 0:\n         for i in xrange(1, 10):\n             yield i\n     else:\n         multi = 10**side_length\n         for one_side in gen_one_side(side_length):\n             number, rnumber = list_to_number(one_side)\n             for i in xrange(LIMIT):\n                 yield number + i * multi + rnumber * multi * 10\n \n def gen_even_palindrome(side_length):\n     multi = 10**side_length\n     for one_side in gen_one_side(side_length):\n         number, rnumber = list_to_number(one_side)\n         yield number + rnumber * multi\n \n \n def gen_palindrome():\n     l = 1\n \n     while True:\n         if l % 2 == 1:\n             for odd_pal in gen_odd_palindrome((l - 1) / 2):\n                 yield odd_pal\n         else:\n             for even_pal in gen_even_palindrome(l / 2):\n                 yield even_pal\n         l += 1\n \n \n cache = []\n upper = 10**14\n for pal in gen_palindrome():\n     pal2 = pal**2\n     if pal2 > upper:\n         break\n     if check_palindrome(pal2):\n         cache.append(pal2)\n \n cl = len(cache)\n T = int(raw_input().strip())\n for i in xrange(T):\n     low_ind = 0\n     high_ind = cl - 1\n     A, B = map(int, raw_input().strip().split(' '))\n \n     # The cache is small for 10**14\n     while cache[low_ind] < A:\n         low_ind += 1\n     while cache[high_ind] > B:\n         high_ind -= 1\n \n \n     if low_ind <= high_ind:\n         print "Case #%s: %s" % (i + 1, high_ind - low_ind + 1)\n     else:\n         print "Case #%s: 0" % (i + 1)\n
jakab922	<>	35	<>	2013_2270488_2449486.py	<>	YES = 0\n NO = 1\n \n messages = [\n     "YES",\n     "NO"\n ]\n \n # def check_height(lawn, N, M, height, was, levels):\n #     for x, y in levels[height]:\n #         if x not in was['row'] and y not in was['col']:\n #             # Try the row\n #             good_row = True\n #             for i in xrange(M):\n #                 if lawn[x][i] > height:\n #                     good_row = False\n #                     break\n #             if good_row:\n #                 was['row'].add(x)\n #                 continue\n #             good_col = True\n #             for i in xrange(N):\n #                 if lawn[i][y] > height:\n #                     good_col = False\n #                     break\n #             if good_col:\n #                 was['col'].add(y)\n #                 continue\n #             # There is no good cut for this field\n #             return False\n #     return True\n \n # def check_lawn(lawn, N, M):\n #     heights_dict = {i: False for i in xrange(1,101)}\n #     for i in xrange(N):\n #         for j in xrange(M):\n #             heights_dict[lawn[i][j]] = True\n \n #     heights = [key for key in sorted(heights_dict.keys()) if heights_dict[key]]\n #     if len(heights) == 1:\n #         return YES\n #     levels = {height: [] for height in heights}\n \n #     for i in xrange(N):\n #         for j in xrange(M):\n #             levels[lawn[i][j]].append((i, j))\n \n #     was = {\n #         "row": set()\n #         "col": set()\n #     }\n \n #     for i, height in enumerate(heights[:-1]):\n #         if not check_height(lawn, N, M, height, was, levels):\n #             return NO\n \n #     return YES\n \n def check_lawn(lawn, N, M):\n     row_maxs = [0 for _ in xrange(N)]\n     col_maxs = [0 for _ in xrange(M)]\n \n     for i in xrange(N):\n         cmax = -1\n         for j in xrange(M):\n             if lawn[i][j] > cmax:\n                 cmax = lawn[i][j]\n         row_maxs[i] = cmax\n \n     for j in xrange(M):\n         cmax = -1\n         for i in xrange(N):\n             if lawn[i][j] > cmax:\n                 cmax = lawn[i][j]\n         col_maxs[j] = cmax\n \n     for i in xrange(N):\n         for j in xrange(M):\n             if row_maxs[i] > lawn[i][j] and col_maxs[j] > lawn[i][j]:\n                 return NO\n \n     return YES\n \n \n T = int(raw_input().strip())\n for i in xrange(T):\n     N, M = map(int, raw_input().strip().split(' '))\n     lawn = [[] for j in xrange(N)]\n     for j in xrange(N):\n         lawn[j] = map(int, raw_input().strip().split(' '))\n     print "Case #%s: %s" % (i + 1, messages[check_lawn(lawn, N, M)])\n
jakab922	<>	35	<>	2012_1460488_1483488.py	<>	from sys import argv\n from math import floor, log10\n \n def grab2(x):\n 	if x < 2:\n 		return 0\n 	return x * (x - 1) / 2\n \n def solve(low, high):\n 	was = [0 for i in range(low, high + 1)]\n 	total = 0\n \n 	for i in xrange(low, high + 1):\n 		if was[i - low] == 0:\n 			was[i - low] = 1\n 			variations = set([i])\n 			\n 			if global_variations[i] != []:\n 				for j in global_variations[i]:\n 					if j >= low and j <= high:\n 						was[j - low] = 1\n 						variations.add(j)\n 			else:\n 				curr = i\n 				clen = int(floor(log10(i)))\n 				pow10 = pow(10, clen)\n 				cgvariations = set(list(variations))\n 				for i in range(clen):\n 					pre = curr % 10\n 					curr = pow10 * pre + (curr - (curr % 10)) / 10\n 					if pre != 0 and curr not in variations and curr >= low and curr <= high:\n 						variations.add(curr)\n 						was[curr - low] = 1\n 					if pre != 0 and curr < ma and curr not in cgvariations:\n 						cgvariations.add(curr)\n \n 				for cg in cgvariations:\n 					global_variations[cg] = list(cgvariations)\n \n 			total += grab2(len(variations))\n \n \n 	return total\n \n f = open(argv[1], 'r')\n T = int(f.readline().strip('\n'))\n mi = 2000000\n ma = 1\n ab = []\n for i in range(T):\n 	ab.append(map(int, f.readline().strip('\n').split(' ')))\n 	if ab[-1][1] > ma:\n 		ma = ab[-1][1]\n \n global_variations = [[] for i in range(ma + 2)]\n \n i = 1\n for x in ab:\n 	print "Case #%s: %s" % (i, solve(x[0],x[1]))\n 	i += 1
jakab922	<>	35	<>	2014_2974486_5756407898963968.py	<>	T = int(raw_input().strip())\n \n for j in xrange(T):\n 	row_num1 = int(raw_input().strip())\n 	for i in xrange(4):\n 		if i + 1 == row_num1:\n 			row1 = set(map(int, raw_input().strip().split(' ')))\n 		else:\n 			raw_input()\n 	row_num2 = int(raw_input().strip())\n 	for i in xrange(4):\n 		if i + 1 == row_num2:\n 			row2 = set(map(int, raw_input().strip().split(' ')))\n 		else:\n 			raw_input()\n 	common = row1 & row2\n 	lc = len(common)\n 	if lc == 1:\n 		stuff = list(common)[0]\n 	elif lc > 1:\n 		stuff = "Bad magician!"\n 	else:\n 		stuff = "Volunteer cheated!"\n \n 	print "Case #%s: %s" % (j + 1, stuff)\n
jakab922	<>	35	<>	2012_1460488_1483485.py	<>	from sys import argv\n \n mapping = { "a": "y", "c": "e", "b": "h", "e": "o", "d": "s", "g": "v", "f": "c", "i": "d", "h": "x", "k": "i", "j": "u", "m": "l", "l": "g", "o": "k", "n": "b", "p": "r", "s": "n", "r": "t", "u": "j", "t": "w", "w": "f", "v": "p", "y": "a", "x": "m", "q": "z", "z": "q"}\n \n def translator(s):\n 	ret = []\n 	for c in s:\n 		if ord(c) > 96 and ord(c) < 123:\n 			ret.append(mapping[c])\n 		else:\n 			ret.append(c)\n \n 	return ''.join(ret)\n \n f = open(argv[1], 'r')\n T = int(f.readline().strip('\n'))\n for i in range(T):\n 	line = f.readline().strip('\n')\n 	print "Case #%s: %s" % (i + 1, translator(line))
jakab922	<>	35	<>	2014_2974486_5709773144064000.py	<>	T = int(raw_input().strip())\n \n for i in xrange(T):\n 	C, F, X = map(float, raw_input().strip().split(' '))\n 	best = X / 2.0\n 	c_sum = 0\n 	factories = 1\n 	n_sum = c_sum + C / (2.0 + (factories - 1) * F)\n 	while n_sum + X / (2.0 + factories * F) < best:\n 		best = n_sum + X / (2.0 + factories * F)\n 		c_sum = n_sum\n 		factories += 1\n 		n_sum = c_sum + C / (2.0 + (factories - 1) * F)\n \n 	print "Case #%s: %s" % (i + 1, best)\n
jakab922	<>	35	<>	2013_2270488_2453486.py	<>	X_WON = 0\n O_WON = 1\n DRAW = 2\n NEITHER = 3\n \n messages = [\n     "X won",\n     "O won",\n     "Draw",\n     "Game has not completed"\n ]\n \n \n def check_win(state):\n     if state['X'] == 4 or state['X'] == 3 and state['T'] == 1:\n         return X_WON\n     elif state['O'] == 4 or state['O'] == 3 and state['T'] == 1:\n         return O_WON\n     else:\n         return -1\n \n def check_state(table):\n \n     # Check rows\n     for i in xrange(4):\n         state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n         for j in xrange(4):\n             state[table[i][j]] += 1\n         res = check_win(state)\n         if res != -1:\n             return res\n \n     # Check cols\n     for i in xrange(4):\n         state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n         for j in xrange(4):\n             state[table[j][i]] += 1\n         res = check_win(state)\n         if res != -1:\n             return res\n \n     # Check diags\n     # Normal\n     state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n     for i in xrange(4):\n         state[table[i][i]] +=  1\n     res = check_win(state)\n     if res != -1:\n         return res\n \n     # Cross\n     state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n     for i in xrange(4):\n         state[table[i][3 - i]] +=  1\n     res = check_win(state)\n     if res != -1:\n         return res\n \n     # Check not full\n     for i in xrange(4):\n         for j in xrange(4):\n             if table[i][j] == '.':\n                 return NEITHER\n \n     # It's a draw\n     return DRAW\n \n T = int(raw_input().strip())\n for i in xrange(T):\n     table = [[] for _ in xrange(4)]\n     for j in xrange(4):\n         table[j] = list(raw_input().strip())\n     # print "table: %s" % table\n     if i != T - 1:\n         raw_input()\n     print "Case #%s: %s" % (i + 1, messages[check_state(table)])
jakab922	<>	35	<>	2014_2974486_5690574640250880.py	<>	T = int(raw_input().strip())\n misses = set()\n \n for i in xrange(T):\n 	R, C, M = map(int, raw_input().strip().split(' '))\n 	F = R * C - M\n 	# print "F: %s, R: %s, C: %s, M: %s" % (F, R, C, M)\n 	impossible = False\n 	if F == 1:\n 		matrix = ["c" + "*" * (C - 1)]\n 		for _ in xrange(R - 1):\n 			matrix.append("*" * C)\n 	elif R == 1:\n 		matrix = ["c" + "." * (F - 1) + "*" * (C - F)]\n 	elif C == 1:\n 		matrix = ["c"]\n 		for _ in xrange(F - 1):\n 			matrix.append(".")\n 		for _ in xrange(R - F):\n 			matrix.append("*")\n 	elif R == 2:\n 		if F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\n 			matrix = [\n 				"c" + "." * (F / 2 - 1) + "*" * (C - F / 2),	\n 				"." * (F / 2) + "*" * (C - F / 2)\n 			]\n 		else:\n 			matrix = []\n 			impossible = True\n 	else:\n 		stack = []\n 		matrix = []\n 		for j in xrange(C, 1, -1):\n 			if F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\n 				stack.append([j, j])\n \n 		while stack:\n 			# print "stack: %s" % stack\n 			elems = stack.pop()\n 			se = sum(elems)\n 			if se == F:\n 				for count in elems:\n 					matrix.append("." * count + "*" * (C - count))\n 				for _ in xrange(R - len(elems)):\n 					matrix.append("*" * C)\n 				matrix[0] = "c" + matrix[0][1:]\n 				break\n 			elif len(elems) < R:\n 				for j in xrange(elems[-1], 1, -1):\n 					if F - se - j >= 0 and (R - len(elems)) * j >= F - se:\n 						stack.append(elems[::] + [j])\n \n 		if matrix == []:\n 			impossible =True\n \n 	print "Case #%s:" % (i + 1)\n 	if impossible:\n 		print "Impossible"\n 	else:\n 		for row in matrix:\n 			print row\n
chevaliermalfet	<>	36	<>	2013_2270488_2463486.py	<>	def isPalindrome(number):\n     strNum = str(number)\n     for i in range(len(strNum)/2 + 1):\n         if strNum[i] != strNum[-1*(i+1)]:\n             return False\n     return True\n \n '''for i in range(40):\n     if isPalindrome(i) and isPalindrome(i*i):\n         print i*i\n '''\n \n \n filename = "C-small-attempt0.in"\n outputname = filename + "out.txt"\n \n inFile = open(filename, 'r')\n outFile = open(outputname, 'w')\n \n \n fairAndSquareNums = [1,4,9,121,484]\n \n numTests = int(inFile.readline())\n \n for i in range(numTests):\n     line = inFile.readline().split()\n     count = 0\n     for j in range(int(line[0]), int(line[1])+1):\n         if j in fairAndSquareNums:\n             count += 1\n     outFile.write("Case #" + str(i+1) + ": " + str(count) + '\n')\n     print "Case #" + str(i+1) + ": " + str(count)\n \n inFile.close()\n outFile.close()\n
chevaliermalfet	<>	36	<>	2013_2270488_2449486.py	<>	def isMowable(lawn):\n     for i in range(len(lawn)):\n         for j in range(len(lawn[i])):\n             cellHeight = lawn[i][j]\n             vertPossible = True\n             horizPossible = True\n             for k in range(len(lawn)):\n                 if lawn[k][j] > cellHeight:\n                     vertPossible = False\n                     break\n             for k in range(len(lawn[i])):\n                 if lawn[i][k] > cellHeight:\n                     horizPossible = False\n                     break\n             if not vertPossible and not horizPossible:\n                 return "NO"\n     return "YES"\n \n \n filename = "B-small-attempt0.in"\n outputname = filename + "out.txt"\n \n inFile = open(filename, 'r')\n outFile = open(outputname, 'w')\n \n \n numTests = int(inFile.readline())\n \n     \n \n for i in range(numTests):\n     dimensions = inFile.readline().split()\n     n = int(dimensions[0])\n     m = int(dimensions[1])\n     lawn = []\n     for j in range(n):\n         line = inFile.readline().split()\n         for k in range(m):\n             line[k] = int(line[k])\n         lawn += [line]\n \n     answer = isMowable(lawn)\n     \n     \n     outFile.write("Case #" + str(i+1) + ": " + answer + '\n')\n     print "Case #" + str(i+1) + ": " + answer\n \n inFile.close()\n outFile.close()\n
chevaliermalfet	<>	36	<>	2012_1460488_1483488.py	<>	inputFile = open("C-small-attempt0.in", 'r')\n outputFile = open("recycleOut.txt", 'w')\n numTests = int(inputFile.readline())\n \n def countRecycle(a,b):\n     count = 0\n     for n in range(a,b):\n         for m in range(n+1,b+1):\n             nStr = str(n)\n             canRecycle = False\n             for k in range(len(nStr)):\n                 if nStr[k:] + nStr[0:k] == str(m):\n                     canRecycle = True\n                     break\n             if canRecycle:\n                 count += 1\n     return count\n \n for i in range(numTests):\n     line = inputFile.readline().split()\n     a = int(line[0])\n     b = int(line[1])\n     outputFile.write('Case #' + str(i+1) + ': ' + str(countRecycle(a,b)) + '\n')\n \n inputFile.close()\n outputFile.close()\n
chevaliermalfet	<>	36	<>	2014_2974486_5756407898963968.py	<>	inputFile = open('A-small-attempt0.in', 'r')\n lines = inputFile.readlines()\n inputFile.close()\n \n outputFile = open('A-small-attempt0.out', 'w')\n \n numTests = int(lines[0])\n \n \n currLine = 1\n for i in range(1, numTests+1):\n     firstRow = lines[int(lines[currLine])+currLine]\n     currLine += 5\n     secondRow = lines[int(lines[currLine])+currLine]\n     currLine += 5\n \n     firstNums = map(lambda x: int(x), firstRow.split())\n     secondNums = map(lambda x: int(x), secondRow.split())\n     \n     intersect = [v for v in firstNums if v in secondNums]\n \n     outputFile.write('Case #'+str(i)+': ')\n     if len(intersect) == 1:\n         outputFile.write(str(intersect[0])+'\n')\n     elif len(intersect) == 0:\n         outputFile.write('Volunteer cheated!\n')\n     else:\n         outputFile.write('Bad magician!\n')\n \n outputFile.close()\n     \n
chevaliermalfet	<>	36	<>	2012_1460488_1483485.py	<>	translator = {}\n translator['a'] = 'y'\n translator['b'] = 'h'\n translator['c'] = 'e'\n translator['d'] = 's'\n translator['e'] = 'o'\n translator['f'] = 'c'\n translator['g'] = 'v'\n translator['h'] = 'x'\n translator['i'] = 'd'\n translator['j'] = 'u'\n translator['k'] = 'i'\n translator['l'] = 'g'\n translator['m'] = 'l'\n translator['n'] = 'b'\n translator['o'] = 'k'\n translator['p'] = 'r'\n translator['q'] = 'z'\n translator['r'] = 't'\n translator['s'] = 'n'\n translator['t'] = 'w'\n translator['u'] = 'j'\n translator['v'] = 'p'\n translator['w'] = 'f'\n translator['x'] = 'm'\n translator['y'] = 'a'\n translator['z'] = 'q'\n \n def translate(string, translator):\n     accum = ""\n     for i in range(len(string)):\n         if string[i] == ' ':\n             accum += ' '\n         elif string[i] == '\n':\n             break\n         else:\n             accum += translator[string[i]]\n     return accum\n \n inputFile = open("A-small-attempt0.in", 'r')\n outputFile = open("tonguesOut.txt", 'w')\n numTests = int(inputFile.readline())\n \n for i in range(numTests):\n     outputFile.write('Case #' + str(i+1) + ': ' + translate(inputFile.readline(), translator) + '\n')\n \n inputFile.close()\n outputFile.close()\n \n
chevaliermalfet	<>	36	<>	2014_2974486_5709773144064000.py	<>	inputFile = open('B-small-attempt0.in', 'r')\n lines = inputFile.readlines()\n inputFile.close()\n \n outputFile = open('B-small-attempt0.out', 'w')\n \n numTests = int(lines[0])\n \n \n def solveCookies(c, f, x):\n     accumTime = 0\n     farmRate = 0\n     while True:\n         # two options: Buy, or don't buy\n         timeToWait = x/(2.0+farmRate)\n         timeIfBuyFarm = (c/(2.0+farmRate) +   # Time to get a farm\n                          x/(2.0+farmRate+f))\n         if timeToWait <= timeIfBuyFarm:\n             return accumTime+timeToWait\n         else:\n             accumTime += c/(2.0+farmRate)\n             farmRate += f\n \n for i in range(1, numTests+1):\n     [c, f, x] = map(lambda x: float(x), lines[i].split())\n \n     outputFile.write('Case #'+str(i)+': ' + str(solveCookies(c, f, x))+'\n')\n outputFile.close()\n     \n
chevaliermalfet	<>	36	<>	2013_2270488_2453486.py	<>	filename = "A-small-attempt0 (3).in"\n outputname = filename + "out.txt"\n \n inFile = open(filename, 'r')\n outFile = open(outputname, 'w')\n \n \n \n \n \n def evalGame(lines):\n     board = []\n     gameOver = True\n     \n     for line in lines:\n         bline = []\n         for i in range(len(line)):\n             if line[i] == 'X':\n                 bline += [1]\n             elif line[i] == 'O':\n                 bline += [2]\n             elif line[i] == 'T':\n                 bline += [3]\n             elif line[i] == '.':\n                 gameOver = False\n                 bline += [0]\n         board += [bline]\n \n     # Check down\n     for i in range(1):\n         for j in range(4):\n             startTile = board[i][j]\n             if startTile == 3 or startTile == 0:\n                 continue\n             winner = True\n             for k in range(1,4):\n                 if board[i+k][j] not in [startTile, 3]:\n                     winner = False\n                     break\n             if winner:\n                 return startTile\n \n     # Check right\n     for i in range(4):\n         for j in range(1):\n             startTile = board[i][j]\n             if startTile == 3 or startTile == 0:\n                 continue\n             winner = True\n             for k in range(1,4):\n                 if board[i][j+k] not in [startTile, 3]:\n                     winner = False\n                     break\n             if winner:\n                 return startTile\n \n     # Check up\n     for i in range(3,4):\n         for j in range(4):\n             startTile = board[i][j]\n             if startTile == 3 or startTile == 0:\n                 continue\n             winner = True\n             for k in range(1,4):\n                 if board[i-k][j] not in [startTile, 3]:\n                     winner = False\n                     break\n             if winner:\n                 return startTile\n \n     # Check left\n     for i in range(4):\n         for j in range(3,4):\n             startTile = board[i][j]\n             if startTile == 3 or startTile == 0:\n                 continue\n             winner = True\n             for k in range(1,4):\n                 if board[i][j-k] not in [startTile, 3]:\n                     winner = False\n                     break\n             if winner:\n                 return startTile\n     \n      # Check down right\n     startTile = board[0][0]\n     if startTile != 3 and startTile != 0:\n         winner = True\n         for k in range(1,4):\n             if board[k][k] not in [startTile, 3]:\n                 winner = False\n                 break\n         if winner:\n             return startTile\n \n      # Check up right\n     startTile = board[3][0]\n     if startTile != 3 and startTile != 0:\n         winner = True\n         for k in range(1,4):\n             if board[3-k][k] not in [startTile, 3]:\n                 winner = False\n                 break\n         if winner:\n             return startTile\n \n      # Check up left\n     startTile = board[3][3]\n     if startTile != 3 and startTile != 0:\n         winner = True\n         for k in range(1,4):\n             if board[3-k][3-k] not in [startTile, 3]:\n                 winner = False\n                 break\n         if winner:\n             return startTile\n \n      # Check down left\n     startTile = board[0][3]\n     if startTile != 3 and startTile != 0:\n         winner = True\n         for k in range(1,4):\n             if board[k][3-k] not in [startTile, 3]:\n                 winner = False\n                 break\n         if winner:\n             return startTile\n \n \n     if gameOver:\n         return 0\n \n     else:\n         return -1\n     \n                       \n \n \n \n \n \n def resultToString(result):\n     if result == 0:\n         return "Draw"\n     elif result == 1:\n         return "X won"\n     elif result == 2:\n         return "O won"\n     else:\n         return "Game has not completed"\n \n \n numCases = int(inFile.readline())\n \n for i in range(numCases):\n     lines = []\n     for j in range(4):\n         lines += [inFile.readline().strip()]\n \n     result = evalGame(lines)\n \n     print "Case #" + str(i+1) + ": " + resultToString(result)\n     outFile.write("Case #" + str(i+1) + ": " + resultToString(result) + '\n')\n     \n     if i < numCases -1:\n         inFile.readline()\n \n inFile.close()\n outFile.close()\n
chevaliermalfet	<>	36	<>	2014_2974486_5690574640250880.py	<>	inputFile = open('C-small-attempt8.in', 'r')\n lines = inputFile.readlines()\n inputFile.close()\n \n outputFile = open('C-small-attempt8.out', 'w')\n \n numTests = int(lines[0])\n \n for i in range(1, numTests+1):\n     [r, c, m] = map(lambda x: int(x), lines[i].split())\n \n     openCells = r*c - m\n \n     works = False\n     matrix = [['*']*c for j in range(r)]\n     # Try case analysis first, see if my knowledge of minesweeper can cover everything\n     # This is getting painful :(\n     if r >= 3 and c >= 3:\n         order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\n                  (2,0), (2,1)]\n         if openCells == 1 or openCells == 4 or openCells == 6:\n             works = True\n             for (x,y) in order[:openCells]:\n                 matrix[x][y] = '.'\n             matrix[0][0] = 'c'\n             \n         elif openCells >= 8:\n             works = True\n             filledRows = openCells / c\n             if filledRows >= 2:\n                 if filledRows == r:\n                     matrix = [['.']*c for j in range(r)]\n                     matrix[0][0] = 'c'\n                 else:\n                     remainder = openCells%c\n                     if not remainder == 1:\n                         for j in range(filledRows):\n                             matrix[j] = ['.']*c\n                         matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\n                     elif filledRows > 2:\n                         for j in range(filledRows-1):\n                             matrix[j] = ['.']*c\n                         matrix[filledRows-1] = ['.']*(c-1) + ['*']\n                         matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\n                     else:\n                         matrix[0] = ['.']*(c-1) + ['*']                        \n                         matrix[1] = ['.']*(c-1) + ['*']\n                         matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\n                     matrix[0][0] = 'c'\n                 \n             else:\n                 for (x,y) in order:\n                     matrix[x][y] = '.'\n                 remainingOpen = openCells - 8\n                 if remainingOpen % 2 == 0:\n                     for j in range(remainingOpen/2):\n                         matrix[0][j+3] = '.'\n                         matrix[1][j+3] = '.'\n                 else:\n                     matrix[2][2] = '.'\n                     remainingOpen -= 1\n                     for j in range(remainingOpen/2):\n                         matrix[0][j+3] = '.'\n                         matrix[1][j+3] = '.'\n                 matrix[0][0] = 'c'\n \n     elif r == 1:\n         works = True\n         matrix[0] = ['.']*(c-m) + ['*']*m\n         matrix[0][0] = 'c'\n     elif c == 1:\n         works = True\n         for j in range(r-m):\n             matrix[j][0] = '.'\n         matrix[0][0] = 'c'\n \n     #Only cases left are one or both dimensions being two\n     elif r == 2 and c == 2:\n         if m == 3:\n             works = True\n             matrix[0][0] = 'c'\n         elif m == 0:\n             works = True\n             matrix = [['c', '.'], ['.', '.']]\n     elif r == 2:\n         if m % 2 == 0 and r*c-m > 2:\n             works = True\n             matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\n             matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\n             matrix[0][0] = 'c'\n         elif r*c-m == 1:\n             works = True\n             matrix[0][0] = 'c'\n     elif c == 2:\n         if m % 2 == 0 and r*c-m > 2:\n             works = True\n             for j in range((r*c-m)/2):\n                 matrix[j] = ['.', '.']\n             matrix[0][0] = 'c'\n         elif r*c-m == 1:\n             works = True\n             matrix[0][0] = 'c'\n     \n \n     outputFile.write('Case #'+str(i)+':\n')\n     '''if len(matrix) != r:\n         print i, matrix\n     count = 0\n     for j in range(len(matrix)):\n         for k in range(len(matrix[j])):\n             if matrix[j][k] == '*':\n                 count += 1\n     if count != m:\n         print i, matrix'''\n     if not works:\n         outputFile.write('Impossible\n')\n     else:\n         for x in range(len(matrix)):\n             for y in range(len(matrix[0])):\n                 outputFile.write(matrix[x][y])\n             outputFile.write('\n')\n outputFile.close()\n             \n
bigonion	<>	37	<>	2013_2270488_2463486.py	<>	directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'\n \n \n def is_palindrome (n):\n     l = list(str(n))\n     return list(reversed(l)) == l\n \n def prepare ():\n     global fair_and_squares\n     fair_and_squares = []\n     \n     for i in range(1,10**7):\n         if is_palindrome(i):\n             sqr = i**2\n             if is_palindrome(sqr):\n                 fair_and_squares.append(sqr)\n     return\n \n         \n def solve (f_in, f_out):\n     prepare()\n     T = int(f_in.readline())\n     for testcase in range(1,T+1):\n         A,B = [int(x) for x in f_in.readline().split()]\n         count = len([x for x in fair_and_squares if (x>=A and x<=B)])\n         f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\n')\n \n \n \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (directory)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', directory)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(directory+chosen_filename+'.in')\n     f_out = open(directory+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n
bigonion	<>	37	<>	2013_2270488_2449486.py	<>	directory = 'C:/users/hai/my projects/google code jam/2013/qualification/B/'\n \n \n from copy import deepcopy\n \n def solve (f_in, f_out):\n     T = int(f_in.readline())\n     for testcase in range(1,T+1):\n         print (testcase)\n         N,M = [int(x) for x in f_in.readline().split()]\n         sqr = []\n         for i in range(N):\n             sqr.append([int(x) for x in f_in.readline().split()])\n         res = get_result(sqr)\n         f_out.write('Case #' + str(testcase) + ': ' + res + '\n')\n \n \n def get_result (sqr):\n     while len(sqr) > 1 and len(sqr[0]) > 1:\n         print (sqr)\n         r,c = 0,0\n         for row in range(len(sqr)):\n             for col in range(len(sqr[0])):\n                 if sqr[row][col] < sqr[r][c]:\n                     r,c = row, col\n         min_val = sqr[r][c]\n         whole_row = list(sqr[r])\n         whole_col = []\n         for row in range(len(sqr)):\n             whole_col.append(sqr[row][c])\n         assert min(whole_row) == min_val\n         assert min(whole_col) == min_val\n         if max(whole_row) == min_val:\n             sqr = remove_row(sqr,r)\n         elif max(whole_col) == min_val:\n             sqr = remove_col(sqr,c)\n         else:\n             return 'NO'\n \n     return 'YES'\n     \n \n \n \n \n \n def remove_row (sqr, row):\n     cpy = deepcopy(sqr)\n     del cpy[row]\n     return cpy\n \n def remove_col (sqr,col):\n     cpy = deepcopy(sqr)\n     for row in cpy:\n         del row[col]\n     return cpy\n \n \n \n \n \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (directory)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', directory)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(directory+chosen_filename+'.in')\n     f_out = open(directory+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n
bigonion	<>	37	<>	2012_1460488_1483488.py	<>	directory = 'C:/users/hai/my projects/google code jam/2012/qualification/C/'\n \n \n def solve (f_in, f_out):\n     pre_calc = prepare()\n     T = int(f_in.readline())\n     for i in range(1,T+1):\n         A,B = [int(x) for x in f_in.readline().split()]\n         c = 0\n         for m in range(A,B+1):\n             c += len ([n for n in pre_calc[m] if n >=A])\n         f_out.write('Case #' + str(i) + ': ' + str(c) + '\n')\n \n \n \n \n \n \n def prepare ():\n     l = [None]* 2000001\n     for n in range(1,2000001):\n         recycled = []\n         s = str(n)\n         for c in range(1, len(s)):\n             s2 = s[c:] + s[:c]\n             if s2[0] != '0':\n                 n2 = int(s2)\n                 if n2 < n and n2 not in recycled:\n                     recycled.append(n2)\n         #recycled.sort()\n         l [n] = recycled\n     return l\n \n \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (directory)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', directory)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(directory+chosen_filename+'.in')\n     f_out = open(directory+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n
bigonion	<>	37	<>	2014_2974486_5756407898963968.py	<>	directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'\n \n \n \n def solve (f_in, f_out):\n     T = int(f_in.readline())\n     for testcase in range(1,T+1):\n         \n         c1 = int(f_in.readline())\n         l1 = []\n         for i in range(4):\n             l1.append(f_in.readline())\n         \n         c2 = int(f_in.readline())\n         l2 = []\n         for i in range(4):\n             l2.append(f_in.readline())\n \n         d1 = l1[c1-1].split()\n         d2 = l2[c2-1].split()\n \n         foundFlag = False\n         chosenCard = None\n         badMagician = False\n         for card in d1:\n             if card in d2:\n                 if not foundFlag:\n                     foundFlag = True\n                     chosenCard = card\n                 else:\n                     badMagician = True\n \n         f_out.write('Case #' + str(testcase) + ': ')\n         if badMagician:\n             f_out.write('Bad magician!\n')\n         elif not foundFlag:\n             f_out.write('Volunteer cheated!\n')\n         else:\n             f_out.write(chosenCard + '\n')\n \n \n \n \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (directory)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', directory)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(directory+chosen_filename+'.in')\n     f_out = open(directory+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n
bigonion	<>	37	<>	2012_1460488_1483485.py	<>	directory = 'C:/users/hai/my projects/google code jam/2012/qualification/A/'\n \n \n t= '''ay\n bh\n ce\n ds\n eo\n fc\n gv\n hx\n id\n ju\n ki\n lg\n ml\n nb\n ok\n pr\n qz\n rt\n sn\n tw\n uj\n vp\n wf\n xm\n ya\n zq'''\n \n table = {}\n for line in t.split():\n     table[line[0]] = line[1]\n \n def translate (line):\n     l = list(line)\n     for i in range(len(l)):\n         if l[i] in table:\n             l[i] = table[l[i]]\n     return ''.join(l)\n \n def solve (f_in, f_out):\n     T = int(f_in.readline())\n     for i in range(1,T+1):\n         line = f_in.readline()\n         out_line = translate(line)\n         f_out.write('Case #' + str(i) + ': ' + out_line)\n \n \n \n \n \n \n \n \n \n \n def main_run():\n     import os\n     filenames = [x for x in os.listdir (directory)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', directory)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     f_in = open(directory+chosen_filename+'.in')\n     f_out = open(directory+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n \n \n \n main_run()\n
bigonion	<>	37	<>	2014_2974486_5709773144064000.py	<>	directory = 'C:/users/me/desktop/google code jam/2014/qualification/B/'\n \n \n \n def solve (f_in, f_out):\n     T = int(f_in.readline())\n     for testcase in range(1,T+1):\n         line = f_in.readline()\n         C,F,X = [float(q) for q in line.split()]\n         result = compute (C,F,X)\n         f_out.write('Case #' + str(testcase) + ': ' + str(result) + '\n')\n \n \n def compute(C,F,X):\n     cps = 2\n     farms = 0\n     timespent = 0\n     while X / cps > C/cps + X/(cps+F):\n         farms += 1\n         timespent += C/cps\n         cps += F\n \n     return timespent + X/cps\n \n \n \n \n \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (directory)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', directory)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(directory+chosen_filename+'.in')\n     f_out = open(directory+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n
bigonion	<>	37	<>	2013_2270488_2453486.py	<>	directory = 'C:/users/hai/my projects/google code jam/2013/qualification/A/'\n \n \n def solve (f_in, f_out):\n     N = int(f_in.readline())\n     for testcase in range(1,N+1):\n         sqr = []\n         for i in range(4):\n             sqr.append(list(f_in.readline().split()[0]))\n         assert len(f_in.readline().split()) == 0\n \n         f_out.write('Case #' + str(testcase) + ': ' + get_square_winner(sqr) +'\n')\n     \n \n def get_all_lines(sqr):\n     lines = []\n     for line in sqr:\n         lines.append(list(line))\n     for column in range(4):\n         line = []\n         for row in range(4):\n             line.append(sqr[row][column])\n         lines.append(list(line))\n \n     diag1 = []\n     diag2 = []\n     for  i in range(4):\n         diag1.append(sqr[i][i])\n         diag2.append(sqr[i][3-i])\n     lines.append(diag1)\n     lines.append(diag2)\n \n     return lines\n     \n def get_square_winner (sqr):\n     for line in get_all_lines(sqr):\n         if get_line_winner (line):\n             return get_line_winner (line)\n \n     for row in sqr:\n         if '.' in row:\n             return "Game has not completed"\n     return "Draw"\n \n \n \n \n def get_line_winner (line):\n     if line.count('X') == 4:\n         return "X won"\n     if line.count('X') == 3 and 'T' in line:\n         return "X won"\n     \n     if line.count('O') == 4:\n         return "O won"\n     if line.count('O') == 3 and 'T' in line:\n         return "O won"\n \n \n     return None\n \n \n \n \n \n \n \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (directory)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', directory)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(directory+chosen_filename+'.in')\n     f_out = open(directory+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n
hannanaha	<>	38	<>	2013_2270488_2463486.py	<>	import time\n import os\n import sys\n import itertools\n import functools\n import math\n \n # ----------------------------------------------------------------------\n \n def is_equal_approx(x, y, epsilon=1e-6):\n     """ Returns True iff y is within relative or absolute 'epsilon' of x.\n         By default, 'epsilon' is 1e-6.\n     """\n     # Check absolute precision.\n     if -epsilon <= x - y <= epsilon:\n         return True\n \n     # Is x or y too close to zero?\n     if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n         return False\n \n     # Check relative precision.\n     return (-epsilon <= (x - y) / x <= epsilon\n         or -epsilon <= (x - y) / y <= epsilon)\n   \n def read_syms(fd):\n     return [c for c in fd.readline().strip()]\n \n def read_ints(fd):\n     return [int(p) for p in fd.readline().strip().split()]\n \n def read_floats(fd):\n     return [float(p) for p in fd.readline().strip().split()]\n \n class Mtrx(object):\n     \n     def __init__(self, readfunc):\n         self.readfunc = readfunc\n         \n     def cell(self, r, c):\n         return self.data[r * self.cols + c]\n     \n     def getrow(self, i):\n         return [self.cell(i, c) for c in range(self.cols)]\n \n     def getcol(self, i):\n         return [self.cell(c, i) for c in range(self.rows)]\n     \n     def readfromfile(self, fd):\n         self.data = []\n         self.rows, self.cols = read_ints(fd)\n         for _ in range(self.rows):\n             line = self.readfunc(fd)\n             assert len(line) == self.cols\n             self.data.extend(line)\n             \n     def __str__(self):\n         res = ""\n         for i in xrange(self.rows):\n             res += str(self.getrow(i)) + "\n"\n         return res\n              \n class IntMatrix(Mtrx):\n     def __init__(self):\n         super(IntMatrix, self).__init__(read_ints)\n \n class SymMatrix(Mtrx):\n     def __init__(self):\n         super(IntMatrix, self).__init__(read_syms)\n \n class memoizeit(object):\n     def __init__(self, func):\n         self.func = func\n         self.cache = {}\n         \n     def __call__(self, *args):\n         try:\n             return self.cache[args]\n         except KeyError:\n             value = self.func(*args)\n             self.cache[args] = value\n             return value\n         except TypeError:\n             return self.func(*args)\n     \n     @property\n     def __name__(self):\n         return self.func.__name__\n     \n     def __get__(self, obj, objtype):\n         return functools.partial(self.__call__, obj)\n \n class timeit(object):\n     def __init__(self, func):\n         self.func = func\n     def __call__(self, *args):\n         start = time.time()\n         value = self.func(*args)\n         delta = time.time() - start\n         print self.func.__name__, "{:7.3f}s, (res: {})".format(delta, value)\n         return value\n     def __get__(self, obj, objtype):\n         return functools.partial(self.__call__, obj)\n \n # ----------------------------------------------------------------------\n
hannanaha	<>	38	<>	2013_2270488_2449486.py	<>	from gcjbase import *\n \n NO = "NO"\n YES = "YES"\n \n \n def read_input(filename):\n     data = []\n     with open(filename, "r") as f:\n         cases = read_ints(f)[0]\n         # =============================================\n         for _ in xrange(cases):\n             field = IntMatrix()\n             field.readfromfile(f)\n             data.append(field)\n         # =============================================\n     return data\n \n def make_output(fname, output):\n     CASE_PRFX = "Case #%s: "\n     fname = fname + time.strftime("%H%M%S") + ".out"\n     with open(fname, "w") as f:\n         # =============================================\n         restext = []\n         print "Output content ==============="\n         for i, v in enumerate(output):\n             line = CASE_PRFX % (i+1,) + str(v) + "\n"\n             print line[:-1]\n             restext.append(line)\n         print "=" * 30\n         f.writelines(restext)\n         # =============================================\n \n # ----------------------------------------------------------------------\n \n @timeit\n def solveit(case):\n     print case\n     for row in range(case.rows):\n         for col in range(case.cols):\n             cell = case.cell(row, col)\n             if (any([c > cell for c in case.getrow(row)]) and\n                 any([c > cell for c in case.getcol(col)])):\n                 return NO\n     return YES\n         \n @timeit\n def main(fname):\n     data = read_input(fname)\n     output = []\n     for i, case in enumerate(data):\n         # =============================================\n         res = solveit(case)\n         output.append(res)\n         # =============================================\n     make_output(fname, output)\n \n \n if __name__ == '__main__':\n #    main("sample.in")\n     main("small.in")\n     #main("large.in")
hannanaha	<>	38	<>	2012_1460488_1483488.py	<>	import time\n \n OEXT = ".out"\n CASE_PRFX = "Case #%s: "\n \n MAXB = 2000000\n \n \n \n def circlify(num, cutoff=MAXB):\n     numstr = str(num) + str(num)\n     max_opt = len(numstr) / 2\n     opts = [int(numstr[i:i+max_opt]) for i in xrange(max_opt)]\n     \n     # only values larger than num (also filters leading zeroes) \n     # and smaller than cutoff\n     opts = [o for o in opts if o > num and o <= cutoff]\n     \n     #clean dupes\n     return len(set(opts))\n \n def check(A, B):\n     res2 = 0\n     start = time.time()\n     for t in xrange(A, B):\n         res2 += circlify(t, B)\n     print res2, time.time()-start  \n \n     return res2\n \n def read_input(filename):\n     data = []\n     with open(filename, "r") as f:\n         cases = int(f.readline())\n         for _ in xrange(cases):\n             case = f.readline().strip().split()\n             data.append((int(case[0]), int(case[1])))\n     return data\n \n def make_output(fname, output):\n     fname = fname + OEXT\n     with open(fname, "w") as f:\n         restext = []\n         for i, v in enumerate(output):\n             restext.append(CASE_PRFX % (i+1,) + str(v) + "\n")\n         f.writelines(restext)\n     \n def main(fname):\n     data = read_input(fname)\n     output = []\n     for case in data:\n         output.append(check(case[0], case[1]))\n     print "output:", output\n     make_output(fname, output)\n \n main("small.in")
hannanaha	<>	38	<>	2014_2974486_5756407898963968.py	<>	# TODO FOR 14 : rounding functions, graph manipulation, desert lion\n \n import time\n import os\n import functools\n \n #EOL = os.linesep - using this causes weird \r\r\n problems\n EOL = "\n"\n \n # ----------------------------------------------------------------------\n \n def is_equal_approx(x, y, epsilon=1e-6):\n     """Returns True iff y is within relative or absolute 'epsilon' of x.\n     \n     By default, 'epsilon' is 1e-6.\n     """\n     # Check absolute precision.\n     if -epsilon <= x - y <= epsilon:\n         return True\n \n     # Is x or y too close to zero?\n     if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n         return False\n \n     # Check relative precision.\n     return (-epsilon <= (x - y) / x <= epsilon\n         or -epsilon <= (x - y) / y <= epsilon)\n   \n def read_syms(fd):\n     """Read a line of whitespace separated symbols."""\n     return fd.readline().strip().split()\n \n def read_ints(fd):\n     """Read a line of whitespace separated integers."""\n     return [int(p) for p in read_syms(fd)]\n \n def read_floats(fd):\n     """Read a line of whitespace separated floats."""\n     return [float(p) for p in read_syms(fd)]\n \n class Mtrx(object):\n     """A matrix object."""\n     \n     def __init__(self, rows, cols, data):\n         assert len(data) == rows * cols\n         self.rows = rows\n         self.cols = cols\n         self.data = data\n         \n     def cell(self, r, c):\n         return self.data[r * self.cols + c]\n     \n     def getrow(self, i):\n         return [self.cell(i, c) for c in xrange(self.cols)]\n \n     def getcol(self, i):\n         return [self.cell(c, i) for c in xrange(self.rows)]\n     \n     @classmethod\n     def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n         """Read matrix from file, assuming first line at location is `R C`.\n         \n         Return a new Mtrx object. Reading values is performed by the `readfunc`.\n         Pre-determined size can be passed using `rows` and `cols`.\n         """\n         data = []\n         if rows is None:\n             assert cols is None\n             rows, cols = read_ints(fd)\n         else:\n             assert cols is not None\n         for _ in range(rows):\n             line = readfunc(fd)\n             assert len(line) == cols\n             data.extend(line)\n         return Mtrx(rows, cols, data)\n             \n     @classmethod\n     def read_int_matrix(cls, fd, rows=None, cols=None):\n         return cls.readfromfile(fd, read_ints, rows, cols)\n             \n     @classmethod\n     def read_sym_matrix(cls, fd, rows=None, cols=None):\n         return cls.readfromfile(fd, read_syms, rows, cols)\n             \n     def __str__(self):\n         res = ""\n         for i in xrange(self.rows):\n             res += str(self.getrow(i)) + EOL\n         return res\n     \n     def __repr__(self):\n         return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,\n                                        self.cols, self.data)\n \n #===============================================================================\n # Class decorators \n #===============================================================================\n              \n cachetotals = 0\n cachemisses = 0\n \n def statreset():\n     global cachemisses, cachetotals\n     cachemisses = 0\n     cachetotals = 0\n \n class memoizeit(object):\n     """Decorator. Caches a function's return value each time it is called.\n     \n     If called later with the same arguments, the cached value is returned \n     (not reevaluated).\n     """\n     \n     def __init__(self, func):\n         self.func = func\n         self.cache = {}\n         \n     def __call__(self, *args):\n         \n         # update stats\n         global cachetotals, cachemisses\n         cachetotals += 1\n         \n         try:\n             return self.cache[args]\n         except KeyError:\n             \n             # update stats\n             cachemisses += 1\n             \n             value = self.func(*args)\n             self.cache[args] = value\n             return value\n         except TypeError:\n \n             # update stats\n             cachemisses += 1\n \n             # uncachable -- for instance, passing a list as an argument.\n             # Better to not cache than to blow up entirely.\n             return self.func(*args)\n     \n     @property\n     def __name__(self):\n         return self.func.__name__\n     \n     def __get__(self, obj, objtype):\n         """Support instance methods."""\n         return functools.partial(self.__call__, obj)\n \n class timeit(object):\n     """Decorator that times a function.\n     \n     When function ends, print name, runtime, return value and cache stats.\n     """\n     \n     def __init__(self, func):\n         self.func = func\n         \n     def __call__(self, *args):\n         start = time.time()\n         value = self.func(*args)\n         delta = time.time() - start\n         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\n             cachetotals else 0\n         print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(\n             delta, value, cachedata)\n         return value\n     \n     def __get__(self, obj, objtype):\n         return functools.partial(self.__call__, obj)\n \n # ----------------------------------------------------------------------\n
hannanaha	<>	38	<>	2012_1460488_1483485.py	<>	import string \n \n OEXT = ".out"\n IN_S = "small.in"\n IN_L = "large.in"\n CASE_PRFX = "Case #%s: "\n \n ddd = {}\n \n def read_input(filename):\n     data = []\n     with open(filename, "r") as f:\n         cases = int(f.readline())\n         for _ in xrange(cases):\n             code = f.readline()\n             data.append(code)\n     return data\n \n def make_output(fname, output):\n     fname = fname + OEXT\n     with open(fname, "w") as f:\n         restext = []\n         for i, v in enumerate(output):\n             restext.append(CASE_PRFX % (i+1,) + v)\n         f.writelines(restext)\n     \n def main(fname):\n     data = read_input(fname)\n     output = []\n     for code in data:\n         output.append("".join([ddd[k] for k in code]))\n     print output\n     make_output(fname, output)\n     \n def mainex(fname):\n     with open(fname, "r") as f:\n         cases = int(f.readline())\n         for _ in xrange(cases):\n             code = f.readline()\n             trans = f.readline()\n             for i, c in enumerate(code):\n                 ddd.setdefault(c, trans[i])\n     \n     abc = string.ascii_lowercase + " \n"\n     for c in abc:\n         if c not in ddd.values():\n             print "not in trans:", c\n             missingt = c\n         if c not in ddd.keys():\n             print "not in code:", c\n             missingc = c\n     ddd.setdefault(missingc, missingt)\n     print ddd\n     print len(ddd)\n     return ddd\n     \n     \n     \n mainex("examples.in")\n main("examples_raw.in")\n main("small.in")
hannanaha	<>	38	<>	2014_2974486_5709773144064000.py	<>	import os\n import time\n import decimal\n import functools\n \n #===============================================================================\n # Generic helpers\n #===============================================================================\n # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict\n \n #EOL = os.linesep - using this causes weird \r\r\n problems\n EOL = "\n"\n \n # ------------------------------------------------------------------------------\n \n def is_equal_approx(x, y, epsilon=1e-6):\n     """Returns True iff y is within relative or absolute 'epsilon' of x.\n     \n     By default, 'epsilon' is 1e-6.\n     """\n     # Check absolute precision.\n     if -epsilon <= x - y <= epsilon:\n         return True\n \n     # Is x or y too close to zero?\n     if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n         return False\n \n     # Check relative precision.\n     return (-epsilon <= (x - y) / x <= epsilon\n         or -epsilon <= (x - y) / y <= epsilon)\n   \n def read_syms(fd):\n     """Read a line of whitespace separated symbols."""\n     return fd.readline().strip().split()\n \n def read_ints(fd):\n     """Read a line of whitespace separated integers."""\n     return [int(p) for p in read_syms(fd)]\n \n def read_floats(fd):\n     """Read a line of whitespace separated floats."""\n     return [float(p) for p in read_syms(fd)]\n \n # ------------------------------------------------------------------------------\n \n class Mtrx(object):\n     """A matrix object."""\n     \n     def __init__(self, rows, cols, data):\n         assert len(data) == rows * cols\n         self.rows = rows\n         self.cols = cols\n         self.data = data\n         \n     def cell(self, r, c):\n         return self.data[r * self.cols + c]\n     \n     def getrow(self, i):\n         return [self.cell(i, c) for c in xrange(self.cols)]\n \n     def getcol(self, i):\n         return [self.cell(c, i) for c in xrange(self.rows)]\n     \n     @classmethod\n     def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n         """Read matrix from file, assuming first line at location is `R C`.\n         \n         Return a new Mtrx object. Reading values is performed by the `readfunc`.\n         Pre-determined size can be passed using `rows` and `cols`.\n         """\n         data = []\n         if rows is None:\n             assert cols is None\n             rows, cols = read_ints(fd)\n         else:\n             assert cols is not None\n         for _ in range(rows):\n             line = readfunc(fd)\n             assert len(line) == cols\n             data.extend(line)\n         return Mtrx(rows, cols, data)\n             \n     @classmethod\n     def read_int_matrix(cls, fd, rows=None, cols=None):\n         return cls.readfromfile(fd, read_ints, rows, cols)\n             \n     @classmethod\n     def read_sym_matrix(cls, fd, rows=None, cols=None):\n         return cls.readfromfile(fd, read_syms, rows, cols)\n             \n     def __str__(self):\n         res = ""\n         for i in xrange(self.rows):\n             res += str(self.getrow(i)) + EOL\n         return res\n     \n     def __repr__(self):\n         return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,\n                                        self.cols, self.data)\n \n # ------------------------------------------------------------------------------\n \n cachetotals = 0\n cachemisses = 0\n \n def statreset():\n     global cachemisses, cachetotals\n     cachemisses = 0\n     cachetotals = 0\n \n class memoizeit(object):\n     """Decorator. Caches a function's return value each time it is called.\n     \n     If called later with the same arguments, the cached value is returned \n     (not reevaluated).\n     """\n     \n     def __init__(self, func):\n         self.func = func\n         self.cache = {}\n         \n     def __call__(self, *args):\n         \n         # update stats\n         global cachetotals, cachemisses\n         cachetotals += 1\n         \n         try:\n             return self.cache[args]\n         except KeyError:\n             \n             # update stats\n             cachemisses += 1\n             \n             value = self.func(*args)\n             self.cache[args] = value\n             return value\n         except TypeError:\n \n             # update stats\n             cachemisses += 1\n \n             # uncachable -- for instance, passing a list as an argument.\n             # Better to not cache than to blow up entirely.\n             return self.func(*args)\n     \n     @property\n     def __name__(self):\n         return self.func.__name__\n     \n     def __get__(self, obj, objtype):\n         """Support instance methods."""\n         return functools.partial(self.__call__, obj)\n \n # ------------------------------------------------------------------------------\n \n class timeit(object):\n     """Decorator that times a function.\n     \n     When function ends, print name, runtime, return value and cache stats.\n     """\n     \n     def __init__(self, func):\n         self.func = func\n         \n     def __call__(self, *args):\n         start = time.time()\n         value = self.func(*args)\n         delta = time.time() - start\n         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\n             cachetotals else 0\n         print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(\n             delta, value, cachedata)\n         return value\n     \n     def __get__(self, obj, objtype):\n         return functools.partial(self.__call__, obj)\n \n #===============================================================================\n # Input/output\n #===============================================================================\n \n def read_input(filename):\n     data = []\n     with open(filename, "r") as f:\n         cases = read_ints(f)[0]\n         # =============================================\n         for _ in xrange(cases):\n             case = {}\n             case["C"], case["F"], case["X"] = read_floats(f)\n             data.append(case)\n         # =============================================\n     return data\n \n def make_output(fname, output):\n     CASE_PRFX = "Case #%s: "\n     fname = fname + time.strftime("%H%M%S") + ".out"\n     with open(fname, "w") as f:\n         restext = []\n         print "Output content ==============="\n         # =============================================\n         for i, outdata in enumerate(output):\n             line = CASE_PRFX % (i + 1,) + str(outdata) + EOL\n             print line,\n             restext.append(line)\n         # =============================================\n         print "=" * 30\n         f.writelines(restext)\n \n #===============================================================================\n # Actual solution\n #===============================================================================\n \n @memoizeit\n def will_a_farm_help(target, current_rate, farm_cost, farm_rate):\n     no_farm = target / current_rate\n     with_farm = farm_cost / current_rate + target / (farm_rate + current_rate)\n     if no_farm > with_farm:\n         return True, farm_cost / current_rate\n     else:\n         return False, no_farm\n \n @timeit\n def solveit(case):\n     C = case["C"]\n     F = case["F"]\n     X = case["X"]\n     \n     t = 0\n     current_rate = 2.0 # default rate of 2 cookies per seconds\n     \n     while True:\n         new_farm, add_time = will_a_farm_help(X, current_rate, C, F)\n         if new_farm:\n             t += add_time\n             current_rate += F\n         else:\n             t += add_time\n             return t\n \n #===============================================================================\n # Main\n #===============================================================================\n \n @timeit\n def main(fname):\n     data = read_input(fname)\n     output = []\n     for case in data:\n         statreset() # reset cache stats\n         # =============================================\n         res = solveit(case)\n         output.append(res)\n         # =============================================\n     make_output(fname, output)\n \n \n if __name__ == '__main__':\n #    main("sample.in")\n     main("B-small-attempt0.in")\n #    main("B-large.in")\n #    main("B-small-attempt0.in")\n #    main("A-large.in")
hannanaha	<>	38	<>	2013_2270488_2453486.py	<>	from gcjbase import *\n \n XWON = "X won"\n OWON = "O won"\n DRAW = "Draw" \n NOTOVER = "Game has not completed"\n \n \n def read_input(filename):\n     data = []\n     with open(filename, "r") as f:\n         cases = read_ints(f)[0]\n         # =============================================\n         for _ in xrange(cases):\n             board = []\n             for _ in xrange(4):\n                 board.extend(read_syms(f))\n             read_syms(f)\n             data.append(board)\n         # =============================================\n     return data\n \n def make_output(fname, output):\n     CASE_PRFX = "Case #%s: "\n     fname = fname + time.strftime("%H%M%S") + ".out"\n     with open(fname, "w") as f:\n         # =============================================\n         restext = []\n         for i, v in enumerate(output):\n             line = CASE_PRFX % (i+1,) + str(v) + "\n"\n             print line\n             restext.append(line)\n         f.writelines(restext)\n         # =============================================\n \n # ----------------------------------------------------------------------\n \n def getrow(board, i):\n     return board[i*4:4*i+4]\n \n def getcol(board, i):\n     return [c for j, c in enumerate(board) if j % 4 == i ]\n \n def getdiag(board, i):\n     if i == 0:\n         return board[0], board[5], board[10], board[15]\n     return board[3], board[6], board[9], board[12]\n \n @timeit\n def solveit(case):\n     print case\n     xcase = [(c if c != 'T' else 'X') for c in case]\n     ocase = [(c if c != 'T' else 'O') for c in case]\n     \n     # rows\n     for i in range(4):\n         if all([x == 'X' for x in getrow(xcase, i)]):\n             return XWON\n         if all([x == 'O' for x in getrow(ocase, i)]):\n             return OWON\n         \n     # cols\n     for i in range(4):\n         if all([x == 'X' for x in getcol(xcase, i)]):\n             return XWON\n         if all([x == 'O' for x in getcol(ocase, i)]):\n             return OWON\n         \n     # diag\n     for i in range(2):\n         if all([x == 'X' for x in getdiag(xcase, i)]):\n             return XWON\n         if all([x == 'O' for x in getdiag(ocase, i)]):\n             return OWON\n         \n     if any([x == '.' for x in case]):\n         return NOTOVER\n     return DRAW\n         \n @timeit\n def main(fname):\n     data = read_input(fname)\n     output = []\n     for i, case in enumerate(data):\n         # =============================================\n         res = solveit(case)\n         output.append(res)\n         # =============================================\n     make_output(fname, output)\n \n \n if __name__ == '__main__':\n     #main("sample.in")\n     main("small.in")\n     #main("sample.in")
hannanaha	<>	38	<>	2014_2974486_5690574640250880.py	<>	import os\n import time\n import decimal\n import functools\n \n #===============================================================================\n # Generic helpers\n #===============================================================================\n # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict\n \n #EOL = os.linesep - using this causes weird \r\r\n problems\n EOL = "\n"\n \n # ------------------------------------------------------------------------------\n \n def is_equal_approx(x, y, epsilon=1e-6):\n     """Returns True iff y is within relative or absolute 'epsilon' of x.\n     \n     By default, 'epsilon' is 1e-6.\n     """\n     # Check absolute precision.\n     if -epsilon <= x - y <= epsilon:\n         return True\n \n     # Is x or y too close to zero?\n     if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n         return False\n \n     # Check relative precision.\n     return (-epsilon <= (x - y) / x <= epsilon\n         or -epsilon <= (x - y) / y <= epsilon)\n   \n def read_syms(fd):\n     """Read a line of whitespace separated symbols."""\n     return fd.readline().strip().split()\n \n def read_ints(fd):\n     """Read a line of whitespace separated integers."""\n     return [int(p) for p in read_syms(fd)]\n \n def read_floats(fd):\n     """Read a line of whitespace separated floats."""\n     return [float(p) for p in read_syms(fd)]\n \n # ------------------------------------------------------------------------------\n \n class Mtrx(object):\n     """A matrix object."""\n     \n     def __init__(self, rows, cols, data):\n         assert len(data) == rows * cols\n         self.rows = rows\n         self.cols = cols\n         self.data = data\n         \n     def cell(self, r, c):\n         return self.data[r * self.cols + c]\n     \n     def getrow(self, i):\n         return [self.cell(i, c) for c in xrange(self.cols)]\n \n     def getcol(self, i):\n         return [self.cell(c, i) for c in xrange(self.rows)]\n     \n     @classmethod\n     def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n         """Read matrix from file, assuming first line at location is `R C`.\n         \n         Return a new Mtrx object. Reading values is performed by the `readfunc`.\n         Pre-determined size can be passed using `rows` and `cols`.\n         """\n         data = []\n         if rows is None:\n             assert cols is None\n             rows, cols = read_ints(fd)\n         else:\n             assert cols is not None\n         for _ in range(rows):\n             line = readfunc(fd)\n             assert len(line) == cols\n             data.extend(line)\n         return Mtrx(rows, cols, data)\n             \n     @classmethod\n     def read_int_matrix(cls, fd, rows=None, cols=None):\n         return cls.readfromfile(fd, read_ints, rows, cols)\n             \n     @classmethod\n     def read_sym_matrix(cls, fd, rows=None, cols=None):\n         return cls.readfromfile(fd, read_syms, rows, cols)\n             \n     def __str__(self):\n         res = ""\n         for i in xrange(self.rows):\n             res += str(self.getrow(i)) + EOL\n         return res\n     \n     def __repr__(self):\n         return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,\n                                        self.cols, self.data)\n \n # ------------------------------------------------------------------------------\n \n cachetotals = 0\n cachemisses = 0\n \n def statreset():\n     global cachemisses, cachetotals\n     cachemisses = 0\n     cachetotals = 0\n \n class memoizeit(object):\n     """Decorator. Caches a function's return value each time it is called.\n     \n     If called later with the same arguments, the cached value is returned \n     (not reevaluated).\n     """\n     \n     def __init__(self, func):\n         self.func = func\n         self.cache = {}\n         \n     def __call__(self, *args):\n         \n         # update stats\n         global cachetotals, cachemisses\n         cachetotals += 1\n         \n         try:\n             return self.cache[args]\n         except KeyError:\n             \n             # update stats\n             cachemisses += 1\n             \n             value = self.func(*args)\n             self.cache[args] = value\n             return value\n         except TypeError:\n \n             # update stats\n             cachemisses += 1\n \n             # uncachable -- for instance, passing a list as an argument.\n             # Better to not cache than to blow up entirely.\n             return self.func(*args)\n     \n     @property\n     def __name__(self):\n         return self.func.__name__\n     \n     def __get__(self, obj, objtype):\n         """Support instance methods."""\n         return functools.partial(self.__call__, obj)\n \n # ------------------------------------------------------------------------------\n \n class timeit(object):\n     """Decorator that times a function.\n     \n     When function ends, print name, runtime, return value and cache stats.\n     """\n     \n     def __init__(self, func):\n         self.func = func\n         \n     def __call__(self, *args):\n         start = time.time()\n         value = self.func(*args)\n         delta = time.time() - start\n         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\n             cachetotals else 0\n         print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(\n             delta, value, cachedata)\n         return value\n     \n     def __get__(self, obj, objtype):\n         return functools.partial(self.__call__, obj)\n \n #===============================================================================\n # Input/output\n #===============================================================================\n \n def read_input(filename):\n     data = []\n     with open(filename, "r") as f:\n         cases = read_ints(f)[0]\n         # =============================================\n         for _ in xrange(cases):\n             case = {}\n             case["R"], case["C"], case["M"] = read_ints(f)\n             data.append(case)\n         # =============================================\n     return data\n \n def make_output(fname, output):\n     CASE_PRFX = "Case #%s: "\n     fname = fname + time.strftime("%H%M%S") + ".out"\n     with open(fname, "w") as f:\n         restext = []\n         print "Output content ==============="\n         # =============================================\n         for i, outdata in enumerate(output):\n             line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\n             print line,\n             restext.append(line)\n         # =============================================\n         print "=" * 30\n         f.writelines(restext)\n \n #===============================================================================\n # Actual solution\n #===============================================================================\n \n MINE = "*"\n CLICK = "c"\n UNK = "."\n \n class Board(object):\n     \n     def __init__(self, r, c):\n         self.rows = r\n         self.cols = c\n         self.edge_row_idx = self.rows - 1\n         self.edge_col_idx = self.cols - 1\n         self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\n         self.board[0][0] = CLICK\n \n     def fill_edge_row(self, m):\n         i = self.edge_col_idx\n         while m > 0 and i >= 0:\n             self.board[self.edge_row_idx][i] = MINE\n             i -= 1\n             m -= 1\n         self.edge_row_idx -= 1\n \n     def fill_edge_col(self, m):\n         i = self.edge_row_idx\n         while m > 0 and i >= 0:\n             self.board[i][self.edge_col_idx] = MINE\n             i -= 1\n             m -= 1\n         self.edge_col_idx -= 1\n \n     def __str__(self):\n         return EOL.join(["".join(r) for r in self.board])\n \n @memoizeit\n def is_stage_solvable(rows, cols, mines):\n     """Return True iff stage is solvable. \n     Also return fill instruction:\n     0 if impossible/dontcare, 1 to fill row, 2 to fill column, \n     3 for row special (most in the row), 4 for col special (most in the col)\n     """\n     rc = rows * cols\n     \n     # all full\n     if mines == rc:\n         return False, 0\n \n     if rows == 1:\n         return mines <= rc - 1, 2\n     if cols == 1:\n         return mines <= rc - 1, 1\n     \n     # rows and cols > 1\n     # single cell in corner   \n     if mines == rc - 1:\n         return True, 1  # doesn't matter what to fill\n     \n     # won't find 4 cells for the corner\n     if mines > rc - 4:\n         return False, 0\n     \n     if rows == 2:\n         return (False, 0) if mines == 1 else (True, 2)\n     if cols == 2:\n         return (False, 0) if mines == 1 else (True, 1)\n         \n     # rows and cols > 2\n     if rows <= cols:\n         # try to fill columns\n         if mines >= rows:\n             return True, 2\n         if mines == rows - 1:\n             if mines == cols - 1:\n                 if rows == 3:\n                     return False, 0\n                 return True, 4 # L shape fill, most in the column\n             else:\n                 return True, 1 # fill row\n         return True, 2 \n     else:\n         # try to fill rows\n         if mines >= cols:\n             return True, 1\n         if mines == cols - 1:\n             if mines == rows - 1:\n                 if cols == 3:\n                     return False, 0\n                 return True, 3 # L shape fill, most in the row\n             else:\n                 return True, 2 # fill column\n         return True, 1 \n \n @timeit\n def solveit(case):\n     rows = case["R"]\n     cols = case["C"]\n     mines = case["M"]\n     \n     b = Board(rows, cols)\n     r, c, m = rows, cols, mines\n     \n     while m >= 0:\n         okgo, howtofill = is_stage_solvable(r, c, m)\n         if not okgo:\n             return "Impossible"\n         if howtofill == 1: # fill row\n             b.fill_edge_row(m)\n             if m <= c:\n                 break # fill and done\n             m -= c\n             r -= 1\n         elif howtofill == 2: # fill column\n             b.fill_edge_col(m)\n             if m <= r:\n                 break # fill and done\n             m -= r\n             c -= 1\n         elif howtofill == 3: # L shape fill, most in the row\n             b.fill_edge_row(m - 1)\n             b.fill_edge_col(1)\n             break # fill and done\n         elif howtofill == 4: # L shape fill, most in the column\n             b.fill_edge_col(m - 1)\n             b.fill_edge_row(1)\n             break # fill and done\n         else:\n             assert False\n \n     return str(b) \n \n \n #===============================================================================\n # Main\n #===============================================================================\n \n @timeit\n def main(fname):\n     data = read_input(fname)\n     output = []\n     for case in data:\n         statreset() # reset cache stats\n         # =============================================\n         res = solveit(case)\n         output.append(res)\n         # =============================================\n     make_output(fname, output)\n \n \n if __name__ == '__main__':\n #    main("sample.in")\n     main("C-small-attempt0.in")\n #    main("B-large.in")\n #    main("B-small-attempt0.in")\n #    main("A-large.in")
rainmayecho	<>	39	<>	2013_2270488_2463486.py	<>	def check(a,b):\n     c = 0\n     n = 1\n     for i in range(1,4):\n         if i**2 >= a and i**2 <=b:\n             c += 1\n     if 44944 >= a and 44944 <= b:\n         c += 1\n     while n < 10:\n         p1 = int('1'+'1'*n)**2\n         if p1 >= a and p1 <=b:\n             c += 1\n         n += 1\n \n \n     if 484 >= a and 484 <= b:\n         c += 1\n \n     n = 1\n     while True:\n         p2 = int('1'+'0'*n+'1')**2\n         p3 = int('2'+'0'*n+'2')**2\n         if p2 >= a and p2 <= b:\n             c += 1\n         else:\n             break\n         if p3 >= a and p3 <= b:\n             c += 1\n         else:\n             continue\n         n += 1\n \n     n = 1\n     while True:\n         t = False\n         for m in range(2,5):\n             p4 = int('1'*m+'0'*n+'1'*m)**2\n             if p4 >= a and p4 <= b:\n                 c += 1\n             else:\n                 t = True\n                 break\n         if t:\n             break\n             \n         n += 1\n     return c\n                 \n dat = raw_input().split()\n n = int(dat.pop(0))\n data = [int(e) for e in dat]\n \n for i in range(0, n*2, 2):\n     a, b = data[i], data[i+1]\n     print 'Case #%i: '%(i/2+1) + str(check(a,b)) \n \n     \n
rainmayecho	<>	39	<>	2013_2270488_2449486.py	<>	\n def check(grid, n, m):\n     for i in range(n):\n         for j in range(m):\n             if neighbor(grid,i,j,n,m):\n                 return False\n     return True\n \n def neighbor(grid,i,j,n,m):\n     u = not i\n     d = not (n-i-1)\n     l = not j\n     r = not (m-j-1)\n     if n == 1:\n         return False\n     if m == 1:\n         return False\n     if i > 0:\n         for k in range(i,-1,-1):\n             if grid[k][j] > grid[i][j]:\n                 u = 1\n             \n     if i < n-1:\n         for k in range(i,n):\n             if grid[k][j] > grid[i][j]:\n                 d = 1\n         \n     if j > 0:\n         for k in range(j,-1,-1):\n             if grid[i][k] > grid[i][j]:\n                 l = 1\n         \n     if j < m-1:\n         for k in range(j,m):\n             if grid[i][k] > grid[i][j]:\n                 r = 1\n     return (u*d*l*r)\n         \n \n dat = raw_input().split()\n c = int(dat.pop(0))\n data = [int(e) for e in dat]\n index = 0\n t = 0\n while t < c:\n     n = data[index]\n     m = data[index+1]\n     index += 2\n     grid = []\n     for i in range(n):\n         grid.append(data[index:index+m])\n         index += m\n     if check(grid, n, m):\n         print 'Case #%i: YES'%(t+1)\n     else:\n         print 'Case #%i: NO'%(t+1)\n     t += 1\n
rainmayecho	<>	39	<>	2012_1460488_1483488.py	<>	import math\n \n f = open('csmall.in','r')\n out = open('out3.txt','w')\n inp = [[int(n) for n in s.split()] for s in f.readlines()]\n count = 1\n \n for e in inp[1:len(inp)]:\n     interval = xrange(e[0],e[1]+1)\n     exp = xrange(1, int(math.log(interval[-1],10))+1)\n     skip = []\n     pairs = []\n     for i in interval:\n         if str(i)[::-1] == str(i):\n             continue\n         for j in exp:\n             val = int(str(i%10**j)+str(i/10**j))\n             if val in skip:\n                 continue\n             elif val >= interval[0] and val <= interval[-1] and not val == i:\n                 skip.append(i)\n     out.write('Case #'+str(count)+': '+str(len(skip))+'\n')\n     count += 1\n \n f.close()\n out.close()\n
rainmayecho	<>	39	<>	2014_2974486_5756407898963968.py	<>	f = open('A.in', 'r')\n g = open('outputA.txt', 'w')\n data = [[int(e) for e in line.strip("\n").split(' ')] for line in f]\n T = data[0][0]\n c = 0\n for i in xrange(1, T*10 + 1, 10):\n     c += 1\n     choice1 = data[i][0]\n     choice2 = data[i+5][0]\n     grid1, grid2 = [], []\n     for j in xrange(1,5):\n         grid1.append(data[i+j])\n \n     for j in xrange(6, 10):\n         grid2.append(data[i+j])\n \n     s1 = set(grid1[choice1-1])\n     s2 = set(grid2[choice2-1])\n \n     s = s1 & s2\n     if len(s) == 1:\n         g.write("Case #%i: %i\n" %(c, s.pop()))\n     elif not s:\n         g.write("Case #%i: Volunteer cheated!\n" %(c))\n     else:\n         g.write("Case #%i: Bad magician!\n" %(c))\n \n f.close()\n g.close()\n     \n
rainmayecho	<>	39	<>	2012_1460488_1483485.py	<>	mapping = {'y':'a','n':'b','f':'c','i':'d','c':'e','w':'f','l':'g','b':'h','k':'i','u':'j','o':'k','m':'l','x':'m','s':'n','e':'o','v':'p','p':'r','d':'s','r':'t','j':'u','g':'v','t':'w','h':'x','a':'y','q':'z','z':'q',' ':' ','\n':'\n'}\n \n f = open('cj.in','r')\n out = open('out.txt','w')\n inp = [line for line in f]\n \n i = 1\n for G in inp[1:len(inp)]:\n     string = ''\n     for e in G:\n         string+=mapping[e]\n     out.write('Case #'+str(i)+': '+string)\n     i+=1\n \n f.close()\n out.close()\n
rainmayecho	<>	39	<>	2014_2974486_5709773144064000.py	<>	f = open('Bsmall.in', 'r')\n ##f = open('test.txt', 'r')\n g = open('outputB.txt', 'w')\n \n data = [[float(e) for e in line.strip("\n").split(' ')] for line in f]\n T = int(data.pop(0)[0])\n \n for i, case in enumerate(data):\n     C, F, X = case[0], case[1], case[2]\n     n = 1\n     t = X/2\n     t_next = X/(2 + F) + C/2\n     metric = (t_next < t)\n     while metric:\n         n += 1\n         t = t_next\n         t_next = t_next - X/(2 + F*(n-1)) + C/(2 + F*(n-1)) + X/(2 + F*n)\n         metric = (t_next < t)\n     g.write('Case #%i: %f\n' %(i+1, t))\n f.close()\n g.close()\n
rainmayecho	<>	39	<>	2013_2270488_2453486.py	<>	\n def checkRow(d, t):\n     g = 0\n     for row in d:\n         a = list(row)\n         a.sort()\n         a = ''.join(a)\n         if 'TXXX' in a or 'XXXX' in a:\n             print 'Case #%i: X won' %(t/4+1)\n             return 1\n         if 'OOOT' in a or 'OOOO' in a:\n             print 'Case #%i: O won' %(t/4+1)\n             return 1\n         if '.' in a:\n             g = 10\n     return g\n \n def checkCol(d, t):\n     for j in range(4):\n         col = []\n         for row in d:\n             col.append(row[j])\n         a = list(col)\n         a.sort()\n         a = ''.join(a)\n         if 'TXXX' in a or 'XXXX' in a:\n             print 'Case #%i: X won' %(t/4+1)\n             return 1\n         if 'OOOT' in a or 'OOOO' in a:\n             print 'Case #%i: O won' %(t/4+1)\n             return 1\n     return 0\n \n def checkDiag(d1, d2, t):\n     a = list(d1)\n     b = list(d2)\n     a.sort()\n     b.sort()\n     a = ''.join(a)\n     b = ''.join(b)\n \n     if 'TXXX' in a or 'XXXX' in a:\n         print 'Case #%i: X won' %(t/4+1)\n         return 1\n     if 'OOOT' in a or 'OOOO' in a:\n         print 'Case #%i: O won' %(t/4+1)\n         return 1\n \n     if 'TXXX' in b or 'XXXX' in b:\n         print 'Case #%i: X won' %(t/4+1)\n         return 1\n     if 'OOOT' in b or 'OOOO' in b:\n         print 'Case #%i: O won' %(t/4+1)\n         return 1\n     return 0\n \n dat = raw_input()\n \n data = dat.split()\n c = int(data.pop(0))\n \n for t in range(0, 4*c, 4):\n     a = checkRow(data[t:t+4],t)\n     if a == 1:\n         continue\n     b = checkCol(data[t:t+4],t)\n     if b:\n         continue\n     d1 = data[t][0]+data[t+1][1]+data[t+2][2]+data[t+3][3]\n     d2 = data[t][3]+data[t+1][2]+data[t+2][1]+data[t+3][0]\n     c = checkDiag(d1, d2,t)\n     if c:\n         continue\n     if (a+b+c) == 0:\n         print 'Case #%i: Draw' %(t/4+1)\n     if a == 10:\n         print 'Case #%i: Game has not completed' %(t/4+1)   \n
rainmayecho	<>	39	<>	2014_2974486_5690574640250880.py	<>	def make_string(R, C, M):\n     grid = [['.' for j in xrange(C)] for i in xrange(R)]\n     grid[-1][-1] = 'c'\n     t = M\n     for i in xrange(R):\n         for j in xrange(C):\n             if M:\n                 if forbidden(R, C, t, i, j):\n                     continue\n                 grid[i][j] = '*'\n                 M -= 1\n             else:\n                 break\n     s = ''\n     if M:\n         return 'Impossible'\n     for r in grid:\n         s += ''.join(r)+'\n'\n     return s[:-1]\n \n def forbidden(R, C, M, i, j):\n     a = M / C\n     b = M % C\n     if (R*C - M == 1):\n         return False\n \n     if i >= (R-2) and j >= (C-2):\n         return True\n \n     if i >= (R-2) and b:\n         if b % 2:\n             return True\n         if j < b/2:\n             return False\n         else:\n             return True\n     return False\n         \n \n f = open('Csmall.in', 'r')\n ##f = open('test.txt', 'r')\n g = open('outputC.txt', 'w')\n \n data = [[int(e) for e in line.strip("\n").split(' ')] for line in f]\n T = int(data.pop(0)[0])\n for i, case in enumerate(data):\n     R, C, M = case[0], case[1], case[2]\n     num_cells = R*C\n     if (R-1) == 0 or (C-1) == 0:\n         s = make_string(R, C, M)\n         g.write('Case #%i:\n%s\n' %(i+1,s))\n         continue\n     else:\n         s = make_string(R, C, M)\n         g.write('Case #%i:\n%s\n' %(i+1, s))\n         \n \n f.close()\n g.close()\n
tamaeguchi	<>	40	<>	2013_2270488_2463486.py	<>	#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem C. Fair and Square\n # https://code.google.com/codejam/contest/2270488/dashboard#s=p2\n #\n \n import sys\n import math\n \n \n def ispalindrome(n):\n     return str(n) == str(n)[::-1]\n \n \n def solve(A, B):\n     solution = []\n     for n in range(int(math.sqrt(A)), int(math.sqrt(B))+1):\n         if ispalindrome(n):\n             m = n ** 2\n             if ispalindrome(m) and A <= m <= B:\n                 solution.append(n)\n     return len(solution)\n \n \n def main(IN, OUT):\n     T = int(IN.readline())\n     for index in range(T):\n         A, B = map(int, IN.readline().split())\n         OUT.write('Case #%d: %s\n' % (index + 1, solve(A, B)))\n \n \n def makesample(T=100, ABmax=1000):\n     import random\n     print T\n     for index in range(T):\n         A = random.randint(1, ABmax)\n         B = random.randint(A, ABmax)\n         print A, B\n \n \n if __name__ == '__main__':\n     if '-makesample' in sys.argv[1:]:\n         makesample()\n     else:\n         main(sys.stdin, sys.stdout)\n \n
tamaeguchi	<>	40	<>	2013_2270488_2449486.py	<>	#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem B. Lawnmower\n # https://code.google.com/codejam/contest/2270488/dashboard#s=p1\n #\n \n import sys\n \n \n def solve(board):\n     vboard = []\n     for m in range(len(board[0])):\n         vboard.append([board[n][m] for n in range(len(board))])\n \n     for n in range(len(board)):\n         for m in range(len(board[n])):\n             h = board[n][m]\n             if h < max(board[n]) and h < max(vboard[m]):\n                 return 'NO'\n     return 'YES'\n \n \n def main(IN, OUT):\n     T = int(IN.readline())\n     for index in range(T):\n         N, M = map(int, IN.readline().split())\n         field = [map(int, IN.readline().split()) for n in range(N)]\n         OUT.write('Case #%d: %s\n' % (index + 1, solve(field)))\n \n \n def makesample(NMmax=100, amax=100, T=100):\n     import random\n     print T\n     for index in range(T):\n         N = random.randint(1, NMmax)\n         M = random.randint(1, NMmax)\n         print N, M\n         for n in range(N):\n             print ' '.join(str(random.randint(1, amax)) for m in range(M))\n \n \n if __name__ == '__main__':\n     if '-makesample' in sys.argv[1:]:\n         makesample()\n     else:\n         main(sys.stdin, sys.stdout)\n \n
tamaeguchi	<>	40	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem C. Recycled Numbers\n # http://code.google.com/codejam/contest/1460488/dashboard#s=p2\n #\n \n import sys\n import string\n \n \n def solve(A, B):\n 	# Given integers A and B with the same number of digits\n 	# AB\n 	top = str(B)[0]\n \n 	count = 0\n 	for n in xrange(A, B):		# n=B (n < m <= B )\n 		digit = str(n)\n 		found = set()\n 		for index in range(1, len(digit)):\n 			if digit[index] < digit[0]:\n 				# m  n   n < m \n 				continue\n 			if digit[index] > top:\n 				# m  B   m <= B \n 				continue\n \n 			m = int(digit[index:] + digit[:index])\n 			if n < m and m <= B and m not in found:\n 				found.add(m)		# distinct ()\n 				count += 1\n 				#print n, m\n 	return count\n \n \n def main(IN, OUT):\n 	N = int(IN.readline())\n 	for index in range(N):\n 		A, B = map(int, IN.readline().strip().split())\n 		OUT.write('Case #%d: %d\n' % (index + 1, solve(A, B)))\n \n \n def makesample(ABmax=2000000, T=50):\n 	import random\n 	print T\n 	for index in range(T):\n 		A = random.randint(1, ABmax)\n 		B = random.randint(A, ABmax)\n 		print A, B\n \n \n if __name__ == '__main__':\n 	if '-makesample' in sys.argv[1:]:\n 		makesample()\n 	else:\n 		main(sys.stdin, sys.stdout)\n \n
tamaeguchi	<>	40	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem *. \n # https://code.google.com/codejam/contest/***\n #\n \n import sys\n \n \n def solve(arrange):\n     board, row = arrange[0]\n     before = board[row - 1]\n     board, row = arrange[1]\n     after = board[row - 1]\n     dup = set(before) & set(after)\n     if len(dup) == 1:\n         return dup.pop()\n     elif len(dup) >= 2:\n         return 'Bad magician!'\n     else:\n         return 'Volunteer cheated!'\n \n \n def main(IN, OUT):\n     T = int(IN.readline())\n     for index in range(T):\n         arrange = []\n         for n in range(2):\n             row = int(IN.readline())\n             board = []\n             for line in range(4):\n                 board.append(map(int, IN.readline().split()))\n             arrange.append((board, row))\n         OUT.write('Case #%d: %s\n' % (index + 1, solve(arrange)))\n \n \n def makesample(T=100):\n     import random\n     print T\n     for index in range(T):\n         for n in range(2):\n             print random.randint(1, 4)\n             board = list(range(1, 16+1))\n             random.shuffle(board)\n             while board:\n                 print ' '.join(map(str, board[:4]))\n                 board = board[4:]\n \n \n if __name__ == '__main__':\n     if '-makesample' in sys.argv[1:]:\n         makesample()\n     else:\n         main(sys.stdin, sys.stdout)\n \n
tamaeguchi	<>	40	<>	2012_1460488_1483485.py	<>	#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem A. Speaking in Tongues\n # http://code.google.com/codejam/contest/1460488/dashboard#s=p0\n #\n \n import sys\n import string\n \n INPUT = '''ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv'''\n OUTPUT = '''our language is impossible to understand\n there are twenty six factorial possibilities\n so it is okay if you want to just give up'''\n \n \n class Table(dict):\n 	TARGET = string.ascii_lowercase\n \n 	def translate(self, msg):\n 		return ''.join((self[c] if c in self.TARGET else c) for c in msg)\n \n 	@classmethod\n 	def maketable(cls, src, dst):\n 		table = cls()\n 		left = set(cls.TARGET)\n 		for s, d in zip(src, dst):\n 			if s in table:\n 				if table[s] != d:\n 					raise Exception('BAD MAPPING "%s" => "%s"/"%s"' % (s, table[s], d))\n 			elif s in cls.TARGET:\n 				table[s] = d\n 				left.remove(s)\n 		if left:\n 			if len(left) != 2:\n 				raise Exception('left letter incorrect')\n 			l1, l2 = left\n 			table[l1] = l2\n 			table[l2] = l1\n 		return table\n \n \n def main():\n 	table = Table.maketable(INPUT, OUTPUT)\n 	N = int(sys.stdin.readline())\n 	for index in range(N):\n 		line = sys.stdin.readline().strip()\n 		print 'Case #%d:' % (index + 1), table.translate(line)\n \n \n if __name__ == '__main__':\n 	main()\n \n
tamaeguchi	<>	40	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem B. Cookie Clicker Alpha\n # https://code.google.com/codejam/contest/2974486/dashboard#s=p1\n #\n \n import sys\n import itertools\n \n \n def solve(C, F, X):\n     def needtime(cookies, farm):\n         speed = 2.0 + F * farm\n         return cookies / speed\n \n     farm = 0\n     pasttime = 0\n     while True:\n         complete = needtime(X, farm)\n         nextfarm = needtime(C, farm)\n         nextchallenge = needtime(X, farm + 1)\n         if complete <= nextfarm + nextchallenge:\n             return pasttime + complete\n         pasttime += nextfarm\n         farm += 1\n \n \n def main(IN, OUT):\n     T = int(IN.readline())\n     for index in range(T):\n         C, F, X = map(float, IN.readline().split())\n         OUT.write('Case #%d: %.7f\n' % (index + 1, solve(C, F, X)))\n \n \n def makesample(maxC=500, maxF=4, maxX=2000, T=100):\n     import random\n     print T\n     for index in range(T):\n         print ' '.join('{0}'.format(random.randint(10000, maxvalue * 10000) / 10000.0)\n                        for maxvalue in (maxC, maxF, maxX))\n \n \n if __name__ == '__main__':\n     if '-makesample' in sys.argv[1:]:\n         makesample()\n     else:\n         main(sys.stdin, sys.stdout)\n \n
tamaeguchi	<>	40	<>	2013_2270488_2453486.py	<>	#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem A. Tic-Tac-Toe-Tomek\n # https://code.google.com/codejam/contest/2270488/dashboard#s=p0\n #\n \n import sys\n import string\n \n \n def solve(board):\n     rows = [board[n:][:4] for n in range(0, len(board), 4)]\n     cols = [''.join(board[step+n*4] for n in range(4)) for step in range(4)]\n     corners = [''.join(board[n] for n in range(0, len(board), 5)),\n                ''.join(board[n] for n in range(3, len(board)-1, 3))]\n     lines = rows + cols + corners\n \n     for line in lines:\n         if line.replace('T', 'X') == 'XXXX':\n             return 'X won'\n         if line.replace('T', 'O') == 'OOOO':\n             return 'O won'\n     return 'Game has not completed' if '.' in board else 'Draw'\n \n \n def main(IN, OUT):\n     T = int(IN.readline())\n     for index in range(T):\n         board = ''.join([IN.readline().strip() for row in range(4)])\n         OUT.write('Case #%d: %s\n' % (index + 1, solve(board)))\n         # empty line\n         IN.readline()\n \n \n def makesample(T=1000):\n     import random\n     print T\n     for index in range(T):\n         board = []\n         for row in range(4):\n             board.append(''.join(random.choice('XO.') for col in range(4)))\n         tcol = random.randint(0, 3)\n         trow = random.randint(0, 3)\n         board[trow] = board[trow][:tcol] + 'T' + board[trow][tcol+1:]\n         print '\n'.join(board)\n         print\n \n \n if __name__ == '__main__':\n     if '-makesample' in sys.argv[1:]:\n         makesample()\n     else:\n         main(sys.stdin, sys.stdout)\n \n
tamaeguchi	<>	40	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem C. Minesweeper Master\n # https://code.google.com/codejam/contest/2974486/dashboard#s=p2\n #\n \n import sys\n \n \n def check(R, C, M, _board):\n     # deepcopy\n     board = [line[:] for line in _board]\n \n     pos = [(0, 0)]\n     while pos:\n         row, col = pos.pop()\n         # neighbor cell list\n         neighbor = []\n         for r in (-1, 0, 1):\n             r += row\n             for c in (-1, 0, 1):\n                 c += col\n                 if r >= 0 and r < R and c >= 0 and c < C:\n                     neighbor.append((r, c))\n         # count bomb\n         count = len([1 for r, c in neighbor if board[r][c] == '*'])\n         board[row][col] = str(count)\n         # push next cell\n         if count == 0:\n             for r, c in neighbor:\n                 if board[r][c] == '.':\n                     pos.append((r, c))\n \n     flat = ''.join(''.join(line) for line in board)\n     result = not flat.count('.')\n     if not result and False: # for DEBUG\n         print '-' * 20\n         print R, C, M\n         print '\n'.join(''.join(line) for line in _board)\n         print '-' * 20\n     assert flat.count('*') == M\n     return result\n \n \n def solve(R, C, M):\n     # initialize\n     board = [['.'] * C for row in range(R)]\n     board[0][0] = 'c'\n     row = R\n     col = C\n     mine = M\n \n     # phase 1: right edge, bottom edge\n     while mine:\n         if 0 < row <= col and mine >= row:\n             for r in range(row):\n                 board[row - r - 1][col - 1] = '*'\n             mine -= row\n             col -= 1\n         elif 0 < col <= row and mine >= col:\n             for c in range(col):\n                 board[row - 1][col - c - 1] = '*'\n             mine -= col\n             row -= 1\n         else:\n             break\n \n     # phase 2:\n     if mine:\n         #print '\n'.join(''.join(line) for line in board)\n         #print 'left', mine\n         while mine and row > 2:\n             for r in range(min(mine, row - 2)):\n                 board[row - r - 1][col - 1] = '*'\n                 mine -= 1\n             col -= 1\n         while mine and col > 2:\n             for c in range(min(mine, col - 2)):\n                 board[row - 1][col - c - 1] = '*'\n                 mine -= 1\n             row -= 1\n \n     # phase 3\n     if mine:\n         # col == row == 2\n         if mine:\n             board[1][1] = '*'\n             mine -= 1\n         if mine:\n             board[1][0] = '*'\n             mine -= 1\n         if mine:\n             board[0][1] = '*'\n             mine -= 1\n \n     assert mine == 0\n     return '\n'.join(''.join(line) for line in board) if check(R, C, M, board) else 'Impossible'\n \n \n def main(IN, OUT):\n     T = int(IN.readline())\n     for index in range(T):\n         R, C, M = map(int, IN.readline().split())\n         OUT.write('Case #%d:\n%s\n' % (index + 1, solve(R, C, M)))\n \n \n def makesample(maxSize=5, T=230):\n     import random\n     print T\n     for index in range(T):\n         R = random.randint(1, maxSize)\n         C = random.randint(1, maxSize)\n         print R, C, random.randint(0, R * C - 1)\n \n \n def makesample():\n     pattern = []\n     for R in range(1, 5+1):\n         for C in range(1, 5+1):\n             for M in range(R * C):\n                 pattern.append((R, C, M))\n     print len(pattern)\n     for R, C, M in pattern:\n         print R, C, M\n \n \n if __name__ == '__main__':\n     if '-makesample' in sys.argv[1:]:\n         makesample()\n     else:\n         main(sys.stdin, sys.stdout)\n \n
cathco	<>	41	<>	2013_2270488_2463486.py	<>	import math\n \n def isPalindrome(s):\n   length = len(s)\n   for i in xrange(length / 2):\n     if s[i] != s[length - 1 - i]: \n       return False\n   return True\n \n n = int(raw_input())\n for i in range(n):\n   a, b = map(int, raw_input().strip().split(' '))\n   count = 0\n   for j in range(a, b+1):\n     if isPalindrome(str(j)):\n       s = math.sqrt(j)\n       if s == int(s) and isPalindrome(str(int(s))):\n         count += 1\n   print 'Case #%i: %i' % (i+1, count)\n
cathco	<>	41	<>	2013_2270488_2449486.py	<>	def up_down(board, height, y, x):\n   # Move up from (x, y).\n   above = y - 1\n   while above >= 0:\n     if board[above][x] > board[y][x]: \n       return False\n     above -= 1\n   # Move down from (x, y).\n   below = y + 1\n   while below < height:\n     if board[below][x] > board[y][x]: \n       return False\n     below += 1\n   return True\n   \n def left_right(board, width, y, x):\n   # Move left from (x, y).\n   before = x - 1\n   while before >= 0:\n     if board[y][before] > board[y][x]: \n       return False\n     before -= 1\n   # Move right from (x, y).\n   after = y + 1\n   while after < width:\n     if board[y][after] > board[y][x]: \n       return False\n     after += 1\n   return True\n   \n def check(board, height, width):\n   if height == 1 or width == 1:\n     return 'YES'\n   for i in range(height):\n     for j in range(width):\n       if (not up_down(board, height, i, j)) and (not left_right(board, width, i, j)):\n         return 'NO'\n   return 'YES'\n \n n = int(raw_input().strip())\n for i in range(n):\n   height, width = map(int,  raw_input().strip().split(' '))\n   board = []\n   for _ in range(height):\n     row = map(int, raw_input().strip().split(' '))\n     board.append(row)\n   print 'Case #%i: %s' % (i+1, check(board, height, width))\n
cathco	<>	41	<>	2012_1460488_1483488.py	<>	import sys\n \n def isRecycledPair(n, m):\n     m = str(m)\n     for i in range(len(m)):\n         m = m[-1] + m[:-1]\n         if n == int(m):\n             return True\n     return False\n \n T = int(sys.stdin.readline())\n for i in range(T):\n     [A, B] = map(int, sys.stdin.readline().strip().split(' '))\n     count = 0\n     for n in range(A, B+1):\n         for m in range(n, B+1):\n             if n != m and isRecycledPair(n, m):\n                 count += 1\n     print 'Case #%s: %s' % (i + 1, count)\n
cathco	<>	41	<>	2014_2974486_5756407898963968.py	<>	T = int(raw_input())\n for i in range(T):\n   index = int(raw_input())\n   X = []\n   for j in range(4):\n     X.append(map(int, raw_input().split()))\n   x1 = X[index-1]\n   index = int(raw_input())\n   X = []\n   for j in range(4):\n     X.append(map(int, raw_input().split()))\n   x2 = X[index-1]\n   ans = set(x1).intersection(set(x2))\n   if len(ans) == 0:\n     print 'Case #%i: Volunteer cheated!' % (i+1)\n   elif len(ans) == 1:\n     print 'Case #%i: %i' % (i+1, ans.pop())\n   else:\n     print 'Case #%i: Bad magician!' % (i+1)\n
cathco	<>	41	<>	2012_1460488_1483485.py	<>	import sys\n \n data = [\n     ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'],\n     ['rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'],\n     ['de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up']]\n \n trans = {'y': 'a', 'e': 'o', 'q': 'z', 'z': 'q'}\n for row in data:\n     [googlerese, english] = row\n     for i in range(0, len(googlerese)):\n         if not googlerese[i] in trans:\n             trans[googlerese[i]] = english[i]\n \n def translate(googlerese):\n     english = ''\n     for c in googlerese:\n         english += trans[c]\n     return english\n \n T = int(sys.stdin.readline())\n for i in range(T):\n     print 'Case #%s: %s' % (i+1, translate(sys.stdin.readline().strip()))\n
cathco	<>	41	<>	2014_2974486_5709773144064000.py	<>	import sys\n import time as tm\n sys.setrecursionlimit(15000)\n \n def solve(C, F, X, rate, time):\n   if (time + (X / rate)) < ((C / rate) + ((X / (rate+F)) + time)):\n     return time + (X / rate)\n   else:\n     return solve(C, F, X, rate+F, time + (C / rate))\n \n T = int(raw_input())\n for t in range(T):\n   C, F, X = map(float, raw_input().split())\n   print 'Case #%i: %.7f' % (t+1, solve(C, F, X, 2, 0))\n
cathco	<>	41	<>	2013_2270488_2453486.py	<>	def check(board):\n   # Check rows.\n   for i in range(4):\n     row = board[i]\n     if set(row) in [set(['X', 'T']), set(['X'])]:\n       return 'X won'\n     if set(row) in [set(['O', 'T']), set(['O'])]:\n       return 'O won'\n   \n   # Check columns.\n   for i in range(4):\n     column = []\n     for j in range(4):\n       column.append(board[j][i])\n     if set(column) in [set(['X', 'T']), set(['X'])]:\n       return 'X won'\n     if set(column) in [set(['O', 'T']), set(['O'])]:\n       return 'O won'\n   \n   # Check diagonal top_left->bottom_right\n   diag1 = [board[0][0], board[1][1], board[2][2], board[3][3]]\n   if set(diag1) in [set(['X', 'T']), set(['X'])]:\n       return 'X won'\n   if set(diag1) in [set(['O', 'T']), set(['O'])]:\n     return 'O won'\n   \n   # Check diagonal top_right->bottom_left\n   diag2 = [board[3][0], board[2][1], board[1][2], board[0][3]]\n   if set(diag2) in [set(['X', 'T']), set(['X'])]:\n       return 'X won'\n   if set(diag2) in [set(['O', 'T']), set(['O'])]:\n     return 'O won'\n   \n   for i in range(4):\n     for j in range(4):\n       if board[i][j] == '.':\n         return 'Game has not completed'\n   return 'Draw'\n \n n = int(raw_input().strip())\n for i in range(n):\n   board = []\n   for j in range(4):\n     line = raw_input()\n     board.append([c for c in line])\n   raw_input()\n   print 'Case #%i: %s' % (i+1, check(board))\n
cathco	<>	41	<>	2014_2974486_5690574640250880.py	<>	from copy import deepcopy\n import time\n \n def solve(W, H, M):\n   board = [['*' for x in xrange(H)] for x in xrange(W)]\n   board[0][0] = 'c'\n   \n   S = [((H*W)-1, board, 0, 0, set())]\n   H -= 1\n   W -= 1\n   while len(S) > 0:\n     state = S.pop()\n     mines = state[0]\n     board = deepcopy(state[1])\n     x = state[2]\n     y = state[3]\n     visited = deepcopy(state[4])\n     visited.add((x, y))\n     \n     if mines == M:\n       s = ''\n       for row in board:\n         s += ''.join(row)\n         s += '\n'\n       return s\n     \n     elif mines > M:\n       # Up\n       if x > 0 and board[x-1][y] == '*':\n         board[x-1][y] = '.'\n         mines -= 1\n       \n       # Down\n       if x < W and board[x+1][y] == '*':\n         board[x+1][y] = '.'\n         mines -= 1\n       \n       # Left\n       if y > 0 and board[x][y-1] == '*':\n         board[x][y-1] = '.'\n         mines -= 1\n       \n       # Right\n       if y < H and board[x][y+1] == '*':\n         board[x][y+1] = '.'\n         mines -= 1\n       \n       # Up and Left\n       if x > 0 and y > 0 and board[x-1][y-1] == '*':\n         board[x-1][y-1] = '.'\n         mines -= 1\n       \n       # Up and Right\n       if x > 0 and y < H and board[x-1][y+1] == '*':\n         board[x-1][y+1] = '.'\n         mines -= 1\n       \n       # Down and Left\n       if x < W and y > 0 and board[x+1][y-1] == '*':\n         board[x+1][y-1] = '.'\n         mines -= 1\n       \n       # Down and Right\n       if x < W and y < H and board[x+1][y+1] == '*':\n         board[x+1][y+1] = '.'\n         mines -= 1\n       \n       # Up\n       if x > 0 and not (x-1, y) in visited:\n         S.append((mines, board, x-1, y, visited))\n       \n       # Down\n       if x < W and not (x+1, y) in visited:\n         S.append((mines, board, x+1, y, visited))\n       \n       # Left\n       if y > 0 and not (x, y-1) in visited:\n         S.append((mines, board, x, y-1, visited))\n       \n       # Right\n       if y < H and not (x, y+1) in visited:\n         S.append((mines, board, x, y+1, visited))\n       \n       # Up and Left\n       if x > 0 and y > 0 and not (x-1, y-1) in visited:\n         S.append((mines, board, x-1, y-1, visited))\n       \n       # Up and Right\n       if x > 0 and y < H and not (x-1, y+1) in visited:\n         S.append((mines, board, x-1, y+1, visited))\n       \n       # Down and Left\n       if x < W and y > 0 and not (x+1, y-1) in visited:\n         S.append((mines, board, x+1, y-1, visited))\n       \n       # Down and Right\n       if x < W and y < H and not (x+1, y+1) in visited:\n         S.append((mines, board, x+1, y+1, visited))\n   return 'Impossible'\n \n T = int(raw_input())\n for t in range(T):\n   W, H, M = map(int, raw_input().split())\n   print 'Case #%i:\n%s' % (t+1, solve(W, H, M).strip())\n
pawko	<>	42	<>	2013_2270488_2463486.py	<>	# python 3\n \n import math\n \n def is_palindrome(num):\n     s = str(num)\n     end_idx = len(s)-1\n     for i in range(len(s)//2):\n         if s[i] != s[end_idx-i]:\n             return False\n     return True\n \n def is_valid_base(base):\n     return is_palindrome(base) and is_palindrome(base*base)\n \n def process_case(lo, hi):\n     cnt = 0\n     base_lo = math.ceil(math.sqrt(lo))\n     base_hi = math.floor(math.sqrt(hi))\n     for base in range(base_lo, base_hi+1):\n         if is_valid_base(base):\n             cnt += 1\n     return cnt\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         lo,hi = line_of_numbers(next(lines))\n         result = process_case(lo, hi)\n         yield 'Case #{0}: {1}\n'.format(ci, result)\n     \n def line_of_numbers(s):\n     return [int(sub) for sub in s.split()]\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('C-test')\n start('C-small-attempt0')\n ##start('C-large')\n
pawko	<>	42	<>	2013_2270488_2449486.py	<>	# python 3\n import string\n import itertools\n import sys\n \n def is_valid(height, max1, max2):\n     if height < max1 and height < max2:\n         return False\n     return True\n \n def process_case(heights):\n     nrows = len(heights)\n     ncols = len(heights[0])\n     col_max_vals = [max((heights[r][c] for r in range(nrows)))\n                     for c in range(ncols)]\n     row_max_vals = [max((heights[r][c] for c in range(ncols)))\n                     for r in range(nrows)]\n     for r in range(nrows):\n         for c in range(ncols):\n             if not is_valid(heights[r][c], row_max_vals[r], col_max_vals[c]):\n                 return 'NO'\n     return 'YES'\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         nrows, ncols = line_of_numbers(next(lines))\n         heights = [line_of_numbers(next(lines)) for r in range(nrows)]\n         result = process_case(heights)\n         yield 'Case #{0}: {1}\n'.format(ci, result)\n     \n def line_of_numbers(s):\n     return [int(sub) for sub in s.split()]\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('B-test')\n start('B-small-attempt0')\n ##start('B-large')\n
pawko	<>	42	<>	2012_1460488_1483488.py	<>	# python 3\n import string\n import itertools\n import sys\n \n def gen_rotations(num):\n     digits = [ch for ch in str(num)]\n     for i in range(1, len(digits)):\n         if digits[i] != '0':\n             result = 0\n             for d in digits[i:]:\n                 result = 10*result + ord(d) - ord('0')\n             for d in digits[:i]:\n                 result = 10*result + ord(d) - ord('0')\n             if result == num:\n                 return\n             yield result\n     \n def process_case(a,b):\n     result = 0\n     for n in range(a,b+1):\n         for m in gen_rotations(n):\n             if (n < m <= b):\n                 result += 1\n     return result\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         a,b = line_of_numbers(next(lines))\n         result = process_case(a,b)\n         yield 'Case #{0}: {1}\n'.format(ci, result)\n     \n def line_of_numbers(s):\n     return [int(sub) for sub in s.split()]\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('C-test')\n start('C-small-attempt0')\n ##start('C-large')\n
pawko	<>	42	<>	2014_2974486_5756407898963968.py	<>	# python 3\n import string\n import itertools\n import sys\n \n def process_case(row1, tab1, row2, tab2):\n     s1 = set(tab1[row1])\n     s2 = set(tab2[row2])\n     xset = s1 & s2\n     if len(xset) == 1:\n         result = xset.pop()\n     elif len(xset) == 0:\n         result = 'Volunteer cheated!'\n     else:\n         result = 'Bad magician!'\n     return result\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         row1 = int(next(lines)) - 1\n         tab1 = [line_of_numbers(next(lines)) for i in range(4)]\n         row2 = int(next(lines)) - 1\n         tab2 = [line_of_numbers(next(lines)) for i in range(4)]\n         result = process_case(row1, tab1, row2, tab2)\n         yield 'Case #{0}: {1}\n'.format(ci, result)\n     \n def line_of_numbers(s):\n     return [int(sub) for sub in s.split()]\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('A-test')\n start('A-small-attempt0')\n ##start('A-large')\n
pawko	<>	42	<>	2012_1460488_1483485.py	<>	# python 3\n import string\n import itertools\n import sys\n \n samples = [('a zoo',\n             'y qee'),\n            ('our language is impossible to understand',\n             'ejp mysljylc kd kxveddknmc re jsicpdrysi'),\n            ('there are twenty six factorial possibilities',\n             'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd'),\n            ('so it is okay if you want to just give up',\n             'de kr kd eoya kw aej tysr re ujdr lkgc jv')]\n            \n def process_case(line, trans):\n     return ''.join(trans[ch] for ch in line)\n \n def prepare_translation():\n     trans = {}\n     for eg_seqs in samples:\n         for echar,gchar in zip(*eg_seqs):\n             trans[gchar] = echar\n     miss_g = set(string.ascii_lowercase) - set(trans.keys())\n     miss_e = set(string.ascii_lowercase) - set(trans.values())\n     if (len(miss_g) == 1 and len(miss_e) == 1):\n         trans[miss_g.pop()] = miss_e.pop();\n     return trans\n \n def result_gen(lines):\n     trans = prepare_translation()\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         result = process_case(next(lines), trans)\n         yield 'Case #{0}: {1}\n'.format(ci, result)\n     \n def line_of_numbers(s):\n     return [int(sub) for sub in s.split()]\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('A-test')\n start('A-small-attempt0')\n ##start('A-large')\n
pawko	<>	42	<>	2014_2974486_5709773144064000.py	<>	# python 3\n import string\n import itertools\n import sys\n \n BASE_RATE = 2.0\n \n def process_case(C, F, X):\n     rate = BASE_RATE\n     total_time = 0.0\n     while True:        \n         xtime = X / rate\n         ctime = C / rate\n         ext_rate = rate + F\n         ext_time = ctime + (X / ext_rate)\n         if xtime <= ext_time:\n             total_time += xtime\n             break\n         total_time += ctime\n         rate = ext_rate\n     return total_time\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         C, F, X = line_of_floats(next(lines))\n         result = process_case(C, F, X)\n         yield 'Case #{0}: {1:.7f}\n'.format(ci, result)\n \n def line_of_floats(s):\n     return [float(sub) for sub in s.split()]\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('B-test')\n start('B-small-attempt0')\n ##start('B-large')\n
pawko	<>	42	<>	2014_2974486_5690574640250880.py	<>	# python 3\n import string\n import itertools\n import sys\n from pprint import pprint\n \n def mines_refill(board, xr, xc, nfree):\n     to_refill = xr*xc - nfree\n     for r in reversed(range(2, xr)):\n         for c in reversed(range(2, xc)):\n             if not to_refill:\n                 return\n             assert(board[r][c] == '.')\n             board[r][c] = '*'\n             to_refill -= 1\n     # Bad board, but valid one\n     for r in reversed(range(xr)):\n         for c in reversed(range(xc)):\n             if not to_refill:\n                 return\n             if board[r][c] == '.':\n                 board[r][c] = '*'\n                 to_refill -= 1\n     assert(to_refill == 0)\n     \n def generate_board(nrows, ncols, nmines):\n     nfree = nrows*ncols - nmines\n     xr=1; xc=1;\n     while True:\n         if xr*xc >= nfree:\n             break\n         if xr < nrows:\n             xr += 1\n         if xr*xc >= nfree:\n             break\n         if xc < ncols:\n             xc += 1\n     board = [['*' for c in range(ncols)] for r in range(nrows)]\n     for r in range(xr):\n         for c in range(xc):\n             board[r][c] = '.'\n     mines_refill(board, xr, xc, nfree)\n     board[0][0] = 'c'\n     return board\n         \n def find_click_point(board):\n     nrows = len(board)\n     ncols = len(board[0])\n     for r in range(nrows):\n         for c in range(ncols):\n             if board[r][c] == 'c':\n                 return (r,c)\n     raise ValueError('Start point not present')\n \n def enum_neighbour_coords(r0, c0, nrows, ncols):\n     for r in range(r0-1, r0+2):\n         if r<0 or r>=nrows:\n             continue\n         for c in range(c0-1, c0+2):\n             if c<0 or c>=ncols:\n                 continue\n             yield (r,c)\n \n def click_board(board, click_coords):\n     nrows = len(board)\n     ncols = len(board[0])\n     points = [click_coords]\n     while points:\n         r0,c0 = points.pop()\n         mines_cnt = 0\n         for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\n             if board[r][c] == '*':\n                 mines_cnt += 1\n         board[r0][c0] = str(mines_cnt)\n         if not mines_cnt:\n             for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\n                 if board[r][c] == '.':\n                     points.append((r,c))\n \n def all_fields_checked(board):\n     nrows = len(board)\n     ncols = len(board[0])\n     for r in range(nrows):\n         for c in range(ncols):\n             if board[r][c] == '.':\n                 return False\n     return True\n \n def is_board_oneclick(original_board):\n     board = [row[:] for row in original_board] # deep copy\n     assert(board[0][0] == 'c')\n     r,c = find_click_point(board)\n     click_board(board, (r,c))\n     is_oneclick = all_fields_checked(board)\n     return is_oneclick\n \n def board2result(board):\n     return [''.join(row) for row in board]\n \n def process_case(nrows, ncols, nmines):\n     board = generate_board(nrows, ncols, nmines)\n     if is_board_oneclick(board):\n         result = board2result(board)\n     else:\n         result = ['Impossible']\n     return result\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         R, C, M = line_of_numbers(next(lines))\n         result = process_case(R, C, M)\n         yield 'Case #{0}:\n'.format(ci, result)\n         for res_line in result:\n             yield res_line + '\n'\n     \n def line_of_numbers(s):\n     return [int(sub) for sub in s.split()]\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('C-test')\n start('C-small-attempt0')\n ##start('C-large')\n
alexamici	<>	43	<>	2013_2270488_2463486.py	<>	"""Usage:\n     X.py < X.in > X.out\n """\n \n # http://code.activestate.com/recipes/577821-integer-square-root-function/\n def isqrt(x):\n     "returns int(floor(sqrt(x))) using only integer math"\n     assert x >= 0, 'Undefined %r' % locals()\n     n = int(x)\n     if n == 0:\n         return 0\n     a, b = divmod(n.bit_length(), 2)\n     x = 2**(a+b)\n     while True:\n         y = (x + n//x)//2\n         if y >= x:\n             return x\n         x = y\n \n def setup(infile):\n     #C = {}\n     return locals()\n \n def reader(testcase, infile, **ignore):\n     #N = int(infile.next())\n     P = map(int, infile.next().split())\n     #I = map(int, infile.next().split())\n     #T = infile.next().split()\n     #S = [infile.next().strip() for i in range(N)]\n     return locals()\n \n def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n     #import collections as co\n     #import functools as ft\n     #import itertools as it\n     #import operator as op\n     #import math as ma\n     #import re\n     #import numpy as np\n     #import scipy as sp\n     #import networkx as nx\n \n     low = isqrt(P[0])\n     high = isqrt(P[1])+1\n \n     def is_pal(n):\n         n = str(n)\n         for i in range(len(n)/2+1):\n             if n[i]!=n[len(n)-1-i]:\n                 return False\n         return True\n \n     res = 0\n     for i in range(low, high+1):\n         if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):\n             res += 1\n \n     return 'Case #%s: %s\n' % (testcase, res)\n \n if __name__ == '__main__':\n     import sys\n     T = int(sys.stdin.next())\n     common = setup(sys.stdin)\n     for t in xrange(1, T+1):\n         sys.stdout.write(solver(**reader(t, **common)))\n
alexamici	<>	43	<>	2013_2270488_2449486.py	<>	"""Usage:\n     X.py < X.in > X.out\n """\n \n def setup(infile):\n     #C = {}\n     return locals()\n \n def reader(testcase, infile, **ignore):\n     #N = int(infile.next())\n     P = map(int, infile.next().split())\n     #I = map(int, infile.next().split())\n     #T = infile.next().split()\n     S = [map(int, infile.next().split()) for i in range(P[0])]\n     return locals()\n \n def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n     #import collections as co\n     #import functools as ft\n     #import itertools as it\n     #import operator as op\n     #import math as ma\n     #import re\n     import numpypy as np\n     #import scipy as sp\n     #import networkx as nx\n     \n     S = np.array(S)\n     done = np.zeros(P, dtype=int)\n     for row in range(P[0]):\n         m = S[row].max()\n         done[row][S[row]==m] = 1\n \n     for col in range(P[1]):\n         m = S[:,col].max()\n         done[:,col][S[:,col]==m] = 1\n \n     res = 'YES' if done.sum() == P[0]*P[1] else 'NO'\n     return 'Case #%s: %s\n' % (testcase, res)\n \n if __name__ == '__main__':\n     import sys\n     T = int(sys.stdin.next())\n     common = setup(sys.stdin)\n     for t in xrange(1, T+1):\n         sys.stdout.write(solver(**reader(t, **common)))\n
alexamici	<>	43	<>	2012_1460488_1483488.py	<>	"""Usage:\n     X.py < X.in > X.out\n """\n \n import sys\n \n \n class Solver(object):\n     cache = {}\n \n     def __init__(self, infile, testcase):\n         self.testcase = testcase\n         #self.N = N = int(infile.next())\n         #self.P = P = map(int, infile.next().split())\n         self.I = I = map(int, infile.next().split())\n         #self.T = T = infile.next().split()\n         #self.S = S = [infile.next().strip() for i in range(N)]\n \n         #self.init_cache()\n \n     def init_cache(self):\n         if 'main' in self.cache:\n             return\n         #self.cache['main'] = res\n \n     def solve(self):\n         #import collections as co\n         #import functools as ft\n         #import itertools as it\n         #import operator as op\n         #import math as ma\n         #import re\n         #import numpy as np\n         #import scipy as sp\n \n         #N = self.N\n         #N, M = self.P\n         I = self.I\n         #T = self.T\n         #S = self.S\n         l = len(str(I[0]))\n \n         r = 0\n         for i in xrange(I[0], I[1]):\n             ii = str(i)\n             rr = set()\n             for j in xrange(1, l):\n                 if  i < int(ii[j:]+ii[:j]) <= I[1]:\n                     rr.add(ii[j:]+ii[:j])\n             r += len(rr)\n \n         return r\n \n \n def main():\n     T = int(sys.stdin.next())\n     for t in xrange(T):\n         sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n \n \n if __name__ == '__main__':\n     main()\n
alexamici	<>	43	<>	2014_2974486_5756407898963968.py	<>	"""Usage:\n     pypy X.py < X-size.in > X-size.out\n or sometimes\n     python X.py < X-size.in > X-size.out\n """\n \n def setup(infile):\n     #C = {}\n     return locals()\n \n def reader(testcase, infile, C=None, **ignore):\n     N = int(infile.next())\n     #P = int(infile.next())\n     #P = map(int, infile.next().split())\n     I = [map(int, infile.next().split()) for i in range(4)]\n     T = int(infile.next())\n     #T = infile.next().split()\n     S = [map(int, infile.next().split()) for i in range(4)]\n     return locals()\n \n def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n     #import collections as co\n     #import functools32 as ft\n     #import itertools as it\n     #import operator as op\n     #import math as ma\n     #import re\n     #import numpypy as np\n     #import scipy as sp\n     #import networkx as nx\n \n     res = set(I[N-1]) & set(S[T-1])\n     if len(res) == 1:\n         res = res.pop()\n     elif len(res) > 1:\n         res = 'Bad magician!'\n     else:\n         res = 'Volunteer cheated!'\n     return 'Case #%s: %s\n' % (testcase, res)\n \n if __name__ == '__main__':\n     import sys\n     T = int(sys.stdin.next())\n     common = setup(sys.stdin)\n     for t in xrange(1, T+1):\n         sys.stdout.write(solver(**reader(t, **common)))\n
alexamici	<>	43	<>	2014_2974486_5709773144064000.py	<>	"""Usage:\n     pypy X.py < X-size.in > X-size.out\n or sometimes\n     python X.py < X-size.in > X-size.out\n """\n \n def setup(infile):\n     #C = {}\n     return locals()\n \n def reader(testcase, infile, C=None, **ignore):\n     #N = int(infile.next())\n     #P = map(int, infile.next().split())\n     I = map(float, infile.next().split())\n     #T = infile.next().split()\n     #S = [infile.next().strip() for i in range(N)]\n     return locals()\n \n def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n     #import collections as co\n     #import functools32 as ft\n     #import itertools as it\n     #import operator as op\n     #import math as ma\n     #import re\n     #import numpypy as np\n     #import scipy as sp\n     #import networkx as nx\n \n     C, F, X = I\n     n = [0]\n     r = 2.\n \n     res = X / r\n     while True:\n         n.append(n[-1] + C / r)\n         r += F\n         nres = n[-1] + X / r\n         if nres >= res:\n             break\n         res = nres\n \n     return 'Case #%s: %s\n' % (testcase, res)\n \n if __name__ == '__main__':\n     import sys\n     T = int(sys.stdin.next())\n     common = setup(sys.stdin)\n     for t in xrange(1, T+1):\n         sys.stdout.write(solver(**reader(t, **common)))\n
alexamici	<>	43	<>	2013_2270488_2453486.py	<>	"""Usage:\n     X.py < X.in > X.out\n """\n \n def setup(infile):\n     #C = {}\n     return locals()\n \n def reader(testcase, infile, **ignore):\n     #N = int(infile.next())\n     #P = map(int, infile.next().split())\n     #I = map(int, infile.next().split())\n     #T = infile.next().split()\n     S = [infile.next().strip() for i in range(5)]\n     return locals()\n \n def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n     #import collections as co\n     #import functools as ft\n     import itertools as it\n     #import operator as op\n     #import math as ma\n     #import re\n     #import numpy as np\n     #import scipy as sp\n     #import networkx as nx\n     \n     not_draw = False\n     for line in S[:4]:\n         not_win = set()\n         if '.' in line:\n             not_draw = True\n             continue\n         if 'O' in line:\n             not_win.add('X')\n         if 'X' in line:\n             not_win.add('O')\n         if len(not_win) == 1:\n             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n \n     ST = []\n     for j in range(4):\n         ST.append(''.join(S[i][j] for i in range(4)))\n     for line in ST:\n         not_win = set()\n         if '.' in line:\n             continue\n         if 'O' in line:\n             not_win.add('X')\n         if 'X' in line:\n             not_win.add('O')\n         if len(not_win) == 1:\n             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n \n     line = ''.join(S[i][i] for i in range(4))\n     not_win = set()\n     if '.' not in line:   \n         if 'O' in line:\n             not_win.add('X')\n         if 'X' in line:\n             not_win.add('O')\n         if len(not_win) == 1:\n             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n \n     line = ''.join(S[i][3-i] for i in range(4))\n     not_win = set()\n     if '.' not in line:\n         if 'O' in line:\n             not_win.add('X')\n         if 'X' in line:\n             not_win.add('O')\n         if len(not_win) == 1:\n             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n \n     if not_draw:\n         return 'Case #%s: %s\n' % (testcase, 'Game has not completed')\n     else:\n         return 'Case #%s: %s\n' % (testcase, 'Draw')\n \n if __name__ == '__main__':\n     import sys\n     T = int(sys.stdin.next())\n     common = setup(sys.stdin)\n     for t in xrange(1, T+1):\n         sys.stdout.write(solver(**reader(t, **common)))\n
alexamici	<>	43	<>	2014_2974486_5690574640250880.py	<>	"""Usage:\n     pypy X.py < X-size.in > X-size.out\n or sometimes\n     python X.py < X-size.in > X-size.out\n """\n \n def setup(infile):\n     #C = {}\n     return locals()\n \n def reader(testcase, infile, C=None, **ignore):\n     #N = int(infile.next())\n     P = map(int, infile.next().split())\n     #I = map(int, infile.next().split())\n     #T = infile.next().split()\n     #S = [infile.next().strip() for i in range(N)]\n     return locals()\n \n def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n     #import collections as co\n     #import functools32 as ft\n     #import itertools as it\n     #import operator as op\n     #import math as ma\n     #import re\n     import numpy as np\n     #import scipy as sp\n     #import networkx as nx\n \n     R, C, M = P\n     #print '--', R, C, M\n     MM = M\n \n     F = np.array([['.'] * C] * R)\n     while M > 0:\n         # reduce if possible\n         if R >= C and M >= C and R > 2:\n             M -= C\n             R -= 1\n             F[R] = '*'\n         elif C > R  and M >= R and C > 2:\n             M -= R\n             C -= 1\n             F[:, C] = '*'\n         # solve simple\n         elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\n             if M < C - 1:\n                 R -= 1\n                 F[R, C - M:C] = '*'\n             elif M < R - 1:\n                 C -= 1\n                 F[R - M:R, C] = '*'\n             elif M == C - 1:\n                 R -= 1\n                 F[R, C - M + 1:C] = '*'\n                 F[R - 1, C - 1] = '*'\n             else:\n                 C -= 1\n                 F[R - M + 1:R, C] = '*'\n                 F[R - 1, C - 1] = '*'\n             M = 0\n         #special cases\n         elif M == R * C - 1:\n             F[:, :] = '*'\n             M = 0\n         else:\n             #print F\n             #print R, C, M\n             return 'Case #%s:\n%s\n' % (testcase, 'Impossible')\n \n     F[0, 0] = 'c'\n     assert (F == '*').sum() == MM\n     return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))\n \n if __name__ == '__main__':\n     import sys\n     T = int(sys.stdin.next())\n     common = setup(sys.stdin)\n     for t in xrange(1, T+1):\n         sys.stdout.write(solver(**reader(t, **common)))\n
jgaten	<>	44	<>	2013_2270488_2463486.py	<>	#!/usr/bin/env python\n import sys\n \n from itertools import count\n \n def palindromes():\n     # it's not straightforward to get the numbers in order...\n     for digits in count(1):\n         for n in xrange(10**(digits-1), 10**digits):\n             n = str(n)\n             yield int(n + n[-2::-1])\n         for n in xrange(10**(digits-1), 10**digits):\n             n = str(n)\n             yield int(n + n[::-1])\n \n def is_palindrome(n):\n     n = str(n)\n     return n == n[::-1]\n \n def solve(A, B):\n     # Loop through palindromic numbers and check that their squares are palindromes.\n     count = 0\n     for n in palindromes():\n         square = n**2\n         if square > B:\n             break\n         if square >= A and is_palindrome(square):\n             count += 1\n     return count\n \n if __name__ == '__main__':\n     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n         T = int(fin.readline())\n         for case in xrange(1, T+1):\n \n             A, B = map(int,fin.readline().split())\n             soln = solve(A, B)\n \n             print >> fout, "Case #{0}: {1}".format(case, soln)\n
jgaten	<>	44	<>	2013_2270488_2449486.py	<>	#!/usr/bin/env python\n import sys\n \n def solve(N, M, grid):\n     possible = [[False for _ in xrange(M)] for _ in xrange(N)]\n     for i in xrange(N):\n         m = max(grid[i])\n         for j in xrange(M):\n             possible[i][j] = possible[i][j] or grid[i][j] == m\n \n     for j in xrange(M):\n         m = max(grid[_][j] for _ in xrange(N))\n         for i in xrange(N):\n             possible[i][j] = possible[i][j] or grid[i][j] == m\n \n     if all(all(row) for row in possible):\n         return "YES"\n     else:\n         return "NO"\n \n if __name__ == '__main__':\n     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n         T = int(fin.readline())\n         for case in xrange(1, T+1):\n             print "Case #{0}:".format(case)\n \n             N, M = map(int, fin.readline().split())\n             grid = [map(int, fin.readline().split()) for _ in xrange(N)]\n \n             soln = solve(N, M, grid)\n             print soln\n             print >> fout, "Case #{0}: {1}".format(case, soln)\n
jgaten	<>	44	<>	2012_1460488_1483488.py	<>	import sys\n \n def solve(a, b):\n     count = 0\n     for n in xrange(a, b):\n         s = str(n)\n         for i in xrange(len(s)):\n             m = int(s[i:] + s[:i])\n             if n < m <= b:\n                 count += 1\n     return count\n \n if __name__ == '__main__':\n     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n         T = int(fin.readline())\n         for case in xrange(1, T+1):\n             a, b = map(int, fin.readline().split())\n             print >> fout, "Case #{0}: {1}".format(case, solve(a, b))\n
jgaten	<>	44	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/env python\n \n import sys\n \n def read_row(fin, n):\n     rows = [set(map(int, fin.readline().strip().split())) for i in xrange(4)]\n     return rows[n-1]\n \n def solve(rowa, rowb):\n     both = rowa & rowb\n     if len(both) == 1:\n         return list(both)[0]\n     elif len(both) > 1:\n         return "Bad magician!"\n     elif not both:\n         return "Volunteer cheated!"\n \n if __name__ == '__main__':\n     fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n     fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n     with fin, fout:\n         T = int(fin.readline())\n         for case in xrange(1, T+1):\n             n = int(fin.readline())\n             rowa = read_row(fin, n)\n             n = int(fin.readline())\n             rowb = read_row(fin, n)\n             soln = solve(rowa, rowb)\n             print >> fout, "Case #{0}: {1}".format(case, soln)\n \n
jgaten	<>	44	<>	2012_1460488_1483485.py	<>	import sys\n \n from string import translate, maketrans\n \n code = maketrans("y qee"\n                  "ejp mysljylc kd kxveddknmc re jsicpdrysi"\n                  "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"\n                  "de kr kd eoya kw aej tysr re ujdr lkgc jv"\n                  "z",\n                  "a zoo"\n                  "our language is impossible to understand"\n                  "there are twenty six factorial possibilities"\n                  "so it is okay if you want to just give up"\n                  "q")\n \n if __name__ == '__main__':\n     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n         T = int(fin.readline())\n         for case in xrange(1, T+1):\n             line = fin.readline().strip('\n')\n             decrypted = translate(line, code)\n             print >> fout, "Case #{0}: {1}".format(case, decrypted)
jgaten	<>	44	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/env python\n \n import sys\n \n def solve(c, f, x):\n     time = 0\n     cps = 2.0\n     while True:\n         time_to_farm = c / cps\n         time_to_end = x / cps\n         buy_a_farm = (time_to_farm + x / (cps + f)) < time_to_end\n         #print time_to_farm, time_to_end, (time_to_farm + x / (cps + f)), buy_a_farm\n         if buy_a_farm:\n             time += time_to_farm\n             cps += f\n         else:\n             time += time_to_end\n             return time\n \n if __name__ == '__main__':\n     fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n     fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n     with fin, fout:\n         T = int(fin.readline())\n         for case in xrange(1, T+1):\n             c, f, x = map(float, fin.readline().split())\n             soln = solve(c, f, x)\n             print >> fout, "Case #{0}: {1:.7f}".format(case, soln)\n \n
jgaten	<>	44	<>	2013_2270488_2453486.py	<>	#!/usr/bin/env python\n import sys\n \n def fours(grid):\n     for i in xrange(4):\n         yield list(grid[i]) # row i\n         yield [grid[x][i] for x in xrange(4)] # column i\n     yield [grid[x][x] for x in xrange(4)] # major diagonal\n     yield [grid[x][3-x] for x in xrange(4)] # minor diagonal\n \n def solve(grid):\n     for x in fours(grid):\n         if set(x) in ({'X', 'T'}, {'X'}):\n             return "X won"\n         elif set(x) in ({'O', 'T'}, {'O'}):\n             return "O won"\n     if any('.' in x for x in grid):\n         return "Game has not completed"\n     else:\n         return "Draw"\n \n if __name__ == '__main__':\n     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n         T = int(fin.readline())\n         for case in xrange(1, T+1):\n \n             grid = [fin.readline().strip() for _ in xrange(4)]\n             assert fin.readline().strip() == ''\n \n             soln = solve(grid)\n             print >> fout, "Case #{0}: {1}".format(case, soln)\n
jgaten	<>	44	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/env python\n \n import sys\n \n IMPOSSIBLE = []\n \n def transpose(grid):\n     return map(list, zip(*grid))\n \n def find_grid(R, C, M):\n     """Return a grid of a solution, if one exists, otherwise []\n \n     Observations:\n     * WLOG, C <= R (otherwise, take the transpose of a solution)\n     * Trivial cases are:\n       - M = 0 or  M = RC - 1\n       - C = 1\n       - (R, C) = (2, 2)\n       - (R, C, M) = (3, 3, 2)\n       - (C, M) = (2, 1)\n     * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1\n     * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable\n     """\n     # Take care of simple cases\n     if M == 0:\n         #print "zero ", R, C, M\n         grid = [['.' for c in xrange(C)] for r in xrange(R)]\n         grid[0][0] = 'c'\n         return grid\n     elif M == R * C - 1:\n         #print "full ", R, C, M\n         grid = [['*' for c in xrange(C)] for r in xrange(R)]\n         grid[0][0] = 'c'\n         return grid\n     elif C > R:\n         #print "trans", R, C, M\n         return transpose(find_grid(C, R, M))\n     elif C == 1:\n         #print "C=1  ", R, C, M\n         return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]\n     elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):\n         #print "impos", R, C, M\n         return IMPOSSIBLE\n \n     assert 2 <= C <= R >= 3, "R={} C={} M={}".format(R, C, M)\n \n     if M >= C:\n         #print "M>=C ", R, C, M\n         s = find_grid(R-1, C, M-C)\n         return s and s + [['*' for c in xrange(C)]]\n     elif M <= R-2 and C >= 3:\n         #print "M+1<R", R, C, M\n         grid = [['.' for c in xrange(C)] for r in xrange(R)]\n         grid[0][0] = 'c'\n         for i in xrange(M):\n             grid[R-i-1][C-1] = '*'\n         return grid\n     elif M + 1 == R == C >= 4:\n         #print "M+1=R", R, C, M\n         grid = [['.' for c in xrange(C)] for r in xrange(R)]\n         grid[0][0] = 'c'\n         grid[R-1][C-2] = '*'\n         for i in xrange(M-1):\n             grid[R-i-1][C-1] = '*'\n         return grid\n \n     assert False, "R={} C={} M={}".format(R, C, M)\n \n def check_soln(grid, R, C, M):\n     """checking, because debugging..."""\n     error = "R={} C={} M={}".format(R, C, M)\n     assert sum(row.count('*') for row in grid) == M, error\n     assert sum(row.count('c') for row in grid) == 1, error\n     assert len(grid) == R, error\n     assert all(len(row) == C for row in grid), error\n     _ = [i for i, row in enumerate(grid) if 'c' in row][0]\n     click = (_, [i for i, c in enumerate(grid[_]) if c == 'c'][0])\n \n     def neighbours(r, c):\n         ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]\n         ns.remove((r, c))\n         return ns\n \n     cpy = map(list, grid)\n     def fill(cpy, pos):\n         cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if grid[i][j] == '*'))\n         if cpy[pos[0]][pos[1]] == '0':\n             for i, j in neighbours(*pos):\n                 if cpy[i][j] == '.':\n                     fill(cpy, (i, j))\n     fill(cpy, click)\n     assert sum(row.count('.') for row in cpy) == 0, error\n \n def solve(R, C, M):\n     soln = find_grid(R, C, M)\n     if soln == IMPOSSIBLE:\n         return "Impossible"\n     else:\n         check_soln(soln, R, C, M)\n         return '\n'.join(''.join(row) for row in soln)\n \n if __name__ == '__main__':\n     fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n     fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n     with fin, fout:\n         T = int(fin.readline())\n         for case in xrange(1, T+1):\n             r, c, m = map(int, fin.readline().split())\n             soln = solve(r, c, m)\n             print >> fout, "Case #{0}:\n{1}".format(case, soln)\n \n
argaen	<>	45	<>	2013_2270488_2463486.py	<>	def esPal(x):\n 	return str(x) == str(x)[::-1]\n \n t = int(raw_input())\n \n for case in range(t):\n 	line = raw_input().split(' ')\n 	a = int(line[0])\n 	b = int(line[1])\n \n 	i = int(a**.5)\n 	if i*i != a:\n 		i += 1\n 	max = int(b**.5)\n 	cantidad = 0\n 	while i <= max:\n 		if esPal(i) and esPal(i*i):\n 			cantidad += 1\n 		i += 1\n \n 	print 'Case #'+str(case+1)+':', cantidad\n
argaen	<>	45	<>	2013_2270488_2449486.py	<>	t = int(raw_input())\n \n for case in range(t):\n 	line = raw_input().split(' ')\n 	n = int(line[0])\n 	m = int(line[1])\n \n 	l = []\n 	for j in range(n):\n 		a = raw_input().split(' ')\n 		b = []\n 		for x in a:\n 			b.append(int(x))\n 		l.append(b)\n \n 	# para cada valor, revisar que la fila o columna que lo contenga sea de alto menor o igual\n \n 	cumple = True\n 	for i in range(n):\n 		for j in range(m):\n 			col = True\n 			fil = True\n 			for x in range(n):\n 				if l[x][j] > l[i][j]:\n 					col = False\n 					break\n 			for x in range(m):\n 				if l[i][x] > l[i][j]:\n 					fil = False\n 					break\n \n 			if not col and not fil:\n 				cumple = False\n 				break\n \n 		if not cumple:\n 			break\n \n 	if cumple:\n 		print 'Case #'+str(case+1)+': YES'\n 	else:\n 		print 'Case #'+str(case+1)+': NO'\n
argaen	<>	45	<>	2012_1460488_1483488.py	<>	t = int(raw_input())\n \n def mover(n, i):\n 	s = str(n)\n 	return int(s[i:] + s[:i])\n \n for i in range(t):\n 	s = raw_input().split(' ')\n 	a = int(s[0])\n 	b = int(s[1])\n 	total = 0\n 	for n in range(a, b):\n 		ms = []\n 		for k in range(len(s[0])):\n 			m = mover(n, k+1)\n 			if m <= b and m > n and not m in ms:\n 			#	print n, mover(n, k+1), k+1\n 				ms.append(m)\n 				total +=1\n \n \n 	print 'Case #'+str(i+1)+':', total
argaen	<>	45	<>	2014_2974486_5756407898963968.py	<>	t = int(raw_input())\n \n for case in range(t):\n 	r1 = int(raw_input())\n 	c1 = []\n 	for j in range(4):\n 		c1.append([int(i) for i in raw_input().split()])\n \n 	r2 = int(raw_input())\n 	c2 = []\n 	for j in range(4):\n 		c2.append([int(i) for i in raw_input().split()])\n \n 	num = -1\n 	possibles = 0\n 	for j in c1[r1-1]:\n 		if c2[r2-1].count(j) == 1:\n 			num = j\n 			possibles += 1\n \n 	if possibles > 1:\n 		print 'Case #'+str(case+1)+': Bad magician!'\n 	elif possibles == 0:\n 		print 'Case #'+str(case+1)+': Volunteer cheated!'\n 	else:\n 		print 'Case #'+str(case+1)+': '+str(num)\n
argaen	<>	45	<>	2012_1460488_1483485.py	<>	t = int(raw_input())\n \n code = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']\n \n for i in range(t):\n 	line = raw_input()\n 	decoded = ''\n \n 	for c in line:\n 		if c==' ':\n 			decoded += c\n 		else:\n 			decoded += code[ord(c)-97]\n \n 	print 'Case #'+str(i+1)+':', decoded\n
argaen	<>	45	<>	2014_2974486_5709773144064000.py	<>	t = int(raw_input())\n \n for case in range(t):\n \n 	c, f, x = raw_input().split()\n 	c = float(c)\n 	f = float(f)\n 	x = float(x)\n \n 	t = 0\n 	cps = 2.0\n 	while c/cps < x/cps and t+x/cps > t+c/cps + x/(cps+f):\n 		# print t, c/cps, x/cps\n 		t += c/cps\n 		cps += f\n 		# raw_input()\n \n 	t += x/cps\n \n 	print 'Case #'+str(case+1)+':', t\n
argaen	<>	45	<>	2013_2270488_2453486.py	<>	t = int(raw_input())\n \n code = 'yhesocvxduiglbkrztnwjpfmaq'\n \n for i in range(t):\n 	l = []\n 	for j in range(4):\n 		l.append(raw_input())\n 	if i != t-1:\n 		raw_input()\n \n 	# filas\n 	v = False\n 	fin = False\n 	for li in l:\n 		x = True\n 		o = True\n 		for c in li:\n 			if c != 'X' and c != 'T':\n 				x = False\n 			if c != 'O' and c != 'T':\n 				o = False\n 			if c == '.':\n 				v = True\n 		if x:\n 			print 'Case #'+str(i+1)+': X won'\n 			fin = True\n 		if o:\n 			print 'Case #'+str(i+1)+': O won'\n 			fin = True\n \n 	if fin:\n 		continue\n \n 	#columnas\n 	for a in range(4):\n 		x = True\n 		o = True\n 		for b in range(4):\n 			if l[b][a] != 'X' and l[b][a] != 'T':\n 				x = False\n 			if l[b][a] != 'O' and l[b][a] != 'T':\n 				o = False\n 		if x:\n 			print 'Case #'+str(i+1)+': X won'\n 			fin = True\n 		if o:\n 			print 'Case #'+str(i+1)+': O won'\n 			fin = True\n 	if fin:\n 		continue\n \n 	#diagonales\n 	x = True\n 	o = True\n 	for j in range(4):\n 		if l[j][j] != 'X' and l[j][j] != 'T':\n 			x = False\n 		if l[j][j] != 'O' and l[j][j] != 'T':\n 			o = False\n 	if x:\n 		print 'Case #'+str(i+1)+': X won'\n 		continue\n 	if o:\n 		print 'Case #'+str(i+1)+': O won'\n 		continue\n 	x = True\n 	o = True\n 	for j in range(4):\n 		if l[3-j][j] != 'X' and l[3-j][j] != 'T':\n 			x = False\n 		if l[3-j][j] != 'O' and l[3-j][j] != 'T':\n 			o = False\n 	if x:\n 		print 'Case #'+str(i+1)+': X won'\n 		continue\n 	if o:\n 		print 'Case #'+str(i+1)+': O won'\n 		continue\n \n 	if v:\n 		print 'Case #'+str(i+1)+': Game has not completed'\n 	else:\n 		print 'Case #'+str(i+1)+': Draw'\n
argaen	<>	45	<>	2014_2974486_5690574640250880.py	<>	t = int(raw_input())\n \n for case in range(t):\n 	print 'Case #'+str(case+1)+':'\n 	r, c, m = raw_input().split()\n 	r = int(r)\n 	c = int(c)\n 	m = int(m)\n \n 	if m==0:\n 		print 'c' + ('.'*(c-1))\n 		for i in range(r-1):\n 			print '.'*c\n 	elif r == 1:\n 		print 'c'+('.'*(c-m-1))+('*'*(m))\n 	elif c == 1:\n 		print 'c'\n 		for i in range(r-m-1):\n 			print '.'\n 		for i in range(m):\n 			print '*'\n 	elif r == 2:\n 		if m%2==0 and c>2 and m<r*c-2:\n 			print 'c'+('.'*(c-m/2-1))+('*'*(m/2))\n 			print ('.'*(c-m/2))+('*'*(m/2))\n 		elif m == r*c - 1:\n 			print 'c'+('*'*(c-1))\n 			print '*'*c\n 		else:\n 			print 'Impossible'\n 	elif c == 2:\n 		if m%2==0 and r>2 and m<r*c-2:\n 			print 'c.'\n 			for i in range(r-m/2-1):\n 				print '..'\n 			for i in range(m/2):\n 				print '**'\n 		elif m == r*c - 1:\n 			print 'c*'\n 			for i in range(r-1):\n 				print '**'\n 		else:\n 			print 'Impossible'\n 	elif c == 3 and r == 3:\n 		if m == 1:\n 			print 'c..'\n 			print '...'\n 			print '..*'\n 		elif m == 2:\n 			print 'Impossible'\n 		elif m == 3:\n 			print 'c..'\n 			print '...'\n 			print '***'\n 		elif m == 4:\n 			print 'Impossible'\n 		elif m == 5:\n 			print 'c.*'\n 			print '..*'\n 			print '***'\n 		elif m == 6:\n 			print 'Impossible'\n 		elif m == 7:\n 			print 'Impossible'\n 		elif m == 8:\n 			print 'c**'\n 			print '***'\n 			print '***'\n 	elif c == 3 and r == 4:\n 		if m == 1:\n 			print 'c..'\n 			print '...'\n 			print '...'\n 			print '..*'\n 		elif m == 2:\n 			print 'c..'\n 			print '...'\n 			print '..*'\n 			print '..*'\n 		elif m == 3:\n 			print 'c..'\n 			print '...'\n 			print '...'\n 			print '***'\n 		elif m == 4:\n 			print 'c.*'\n 			print '..*'\n 			print '..*'\n 			print '..*'\n 		elif m == 5:\n 			print 'Impossible'\n 		elif m == 6:\n 			print 'c..'\n 			print '...'\n 			print '***'\n 			print '***'\n 		elif m == 7:\n 			print 'Impossible'\n 		elif m == 8:\n 			print 'c.*'\n 			print '..*'\n 			print '***'\n 			print '***'\n 		elif m == 9:\n 			print 'Impossible'\n 		elif m == 10:\n 			print 'Impossible'\n 		elif m == 11:\n 			print 'c**'\n 			print '***'\n 			print '***'\n 			print '***'\n 	elif c == 3 and r == 5:\n 		if m == 1:\n 			print 'c..'\n 			print '...'\n 			print '...'\n 			print '...'\n 			print '..*'\n 		elif m == 2:\n 			print 'c..'\n 			print '...'\n 			print '...'\n 			print '..*'\n 			print '..*'\n 		elif m == 3:\n 			print 'c..'\n 			print '...'\n 			print '..*'\n 			print '..*'\n 			print '..*'\n 		elif m == 4:\n 			print 'c..'\n 			print '...'\n 			print '...'\n 			print '..*'\n 			print '***'\n 		elif m == 5:\n 			print 'c.*'\n 			print '..*'\n 			print '..*'\n 			print '..*'\n 			print '..*'\n 		elif m == 6:\n 			print 'c..'\n 			print '...'\n 			print '...'\n 			print '***'\n 			print '***'\n 		elif m == 7:\n 			print 'c..'\n 			print '...'\n 			print '..*'\n 			print '***'\n 			print '***'\n 		elif m == 8:\n 			print 'Impossible'\n 		elif m == 9:\n 			print 'c..'\n 			print '...'\n 			print '***'\n 			print '***'\n 			print '***'\n 		elif m == 10:\n 			print 'Impossible'\n 		elif m == 11:\n 			print 'c.*'\n 			print '..*'\n 			print '***'\n 			print '***'\n 			print '***'\n 		elif m == 12:\n 			print 'Impossible'\n 		elif m == 13:\n 			print 'Impossible'\n 		elif m == 14:\n 			print 'c**'\n 			print '***'\n 			print '***'\n 			print '***'\n 			print '***'\n 	elif c == 4 and r == 3:\n 		if m == 1:\n 			print 'c...'\n 			print '....'\n 			print '...*'\n 		elif m == 2:\n 			print 'c...'\n 			print '...*'\n 			print '...*'\n 		elif m == 3:\n 			print 'c..*'\n 			print '...*'\n 			print '...*'\n 		elif m == 4:\n 			print 'c...'\n 			print '....'\n 			print '****'\n 		elif m == 5:\n 			print 'Impossible'\n 		elif m == 6:\n 			print 'c.**'\n 			print '..**'\n 			print '..**'\n 		elif m == 7:\n 			print 'Impossible'\n 		elif m == 8:\n 			print 'c.**'\n 			print '..**'\n 			print '****'\n 		elif m == 9:\n 			print 'Impossible'\n 		elif m == 10:\n 			print 'Impossible'\n 		elif m == 11:\n 			print 'c***'\n 			print '****'\n 			print '****'\n 	elif c == 4 and r == 4:\n 		if m == 1:\n 			print 'c...'\n 			print '....'\n 			print '....'\n 			print '...*'\n 		elif m == 2:\n 			print 'c...'\n 			print '....'\n 			print '....'\n 			print '..**'\n 		elif m == 3:\n 			print 'c...'\n 			print '....'\n 			print '...*'\n 			print '..**'\n 		elif m == 4:\n 			print 'c...'\n 			print '....'\n 			print '....'\n 			print '****'\n 		elif m == 5:\n 			print 'c...'\n 			print '....'\n 			print '...*'\n 			print '****'\n 		elif m == 6:\n 			print 'c...'\n 			print '....'\n 			print '..**'\n 			print '****'\n 		elif m == 7:\n 			print 'c..*'\n 			print '...*'\n 			print '...*'\n 			print '****'\n 		elif m == 8:\n 			print 'c...'\n 			print '....'\n 			print '****'\n 			print '****'\n 		elif m == 9:\n 			print 'Impossible'\n 		elif m == 10:\n 			print 'c.**'\n 			print '..**'\n 			print '..**'\n 			print '****'\n 		elif m == 11:\n 			print 'Impossible'\n 		elif m == 12:\n 			print 'c.**'\n 			print '..**'\n 			print '****'\n 			print '****'\n 		elif m == 13:\n 			print 'Impossible'\n 		elif m == 14:\n 			print 'Impossible'\n 		elif m == 15:\n 			print 'c***'\n 			print '****'\n 			print '****'\n 			print '****'\n 	elif c == 4 and r == 5:\n 		if m == 1:\n 			print 'c...'\n 			print '....'\n 			print '....'\n 			print '....'\n 			print '...*'\n 		elif m == 2:\n 			print 'c...'\n 			print '....'\n 			print '....'\n 			print '....'\n 			print '..**'\n 		elif m == 3:\n 			print 'c...'\n 			print '....'\n 			print '...*'\n 			print '...*'\n 			print '...*'\n 		elif m == 4:\n 			print 'c...'\n 			print '....'\n 			print '....'\n 			print '....'\n 			print '****'\n 		elif m == 5:\n 			print 'c..*'\n 			print '...*'\n 			print '...*'\n 			print '...*'\n 			print '...*'\n 		elif m == 6:\n 			print 'c...'\n 			print '....'\n 			print '....'\n 			print '..**'\n 			print '****'\n 		elif m == 7:\n 			print 'c..*'\n 			print '...*'\n 			print '...*'\n 			print '..**'\n 			print '..**'\n 		elif m == 8:\n 			print 'c...'\n 			print '....'\n 			print '....'\n 			print '****'\n 			print '****'\n 		elif m == 9:\n 			print 'c..*'\n 			print '...*'\n 			print '...*'\n 			print '..**'\n 			print '****'\n 		elif m == 10:\n 			print 'c.**'\n 			print '..**'\n 			print '..**'\n 			print '..**'\n 			print '..**'\n 		elif m == 11:\n 			print 'c..*'\n 			print '...*'\n 			print '...*'\n 			print '****'\n 			print '****'\n 		elif m == 12:\n 			print 'c...'\n 			print '....'\n 			print '****'\n 			print '****'\n 			print '****'\n 		elif m == 13:\n 			print 'Impossible'\n 		elif m == 14:\n 			print 'c..*'\n 			print '...*'\n 			print '****'\n 			print '****'\n 			print '****'\n 		elif m == 15:\n 			print 'Impossible'\n 		elif m == 16:\n 			print 'c.**'\n 			print '..**'\n 			print '****'\n 			print '****'\n 			print '****'\n 		elif m == 17:\n 			print 'Impossible'\n 		elif m == 18:\n 			print 'Impossible'\n 		elif m == 19:\n 			print 'c***'\n 			print '****'\n 			print '****'\n 			print '****'\n 			print '****'\n 	elif c == 5 and r == 3:\n 		if m == 1:\n 			print 'c....'\n 			print '.....'\n 			print '....*'\n 		elif m == 2:\n 			print 'c....'\n 			print '.....'\n 			print '...**'\n 		elif m == 3:\n 			print 'c....'\n 			print '.....'\n 			print '..***'\n 		elif m == 4:\n 			print 'c...*'\n 			print '....*'\n 			print '...**'\n 		elif m == 5:\n 			print 'c....'\n 			print '.....'\n 			print '*****'\n 		elif m == 6:\n 			print 'c..**'\n 			print '...**'\n 			print '...**'\n 		elif m == 7:\n 			print 'c..**'\n 			print '...**'\n 			print '..***'\n 		elif m == 8:\n 			print 'Impossible'\n 		elif m == 9:\n 			print 'c.***'\n 			print '..***'\n 			print '..***'\n 		elif m == 10:\n 			print 'Impossible'\n 		elif m == 11:\n 			print 'c.***'\n 			print '..***'\n 			print '*****'\n 		elif m == 12:\n 			print 'Impossible'\n 		elif m == 13:\n 			print 'Impossible'\n 		elif m == 14:\n 			print 'c****'\n 			print '*****'\n 			print '*****'\n 	elif c == 5 and r == 4:\n 		if m == 1:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '....*'\n 		elif m == 2:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '...**'\n 		elif m == 3:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '..***'\n 		elif m == 4:\n 			print 'c...*'\n 			print '....*'\n 			print '....*'\n 			print '....*'\n 		elif m == 5:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '*****'\n 		elif m == 6:\n 			print 'c...*'\n 			print '....*'\n 			print '....*'\n 			print '..***'\n 		elif m == 7:\n 			print 'c....'\n 			print '.....'\n 			print '...**'\n 			print '*****'\n 		elif m == 8:\n 			print 'c..**'\n 			print '...**'\n 			print '...**'\n 			print '...**'\n 		elif m == 9:\n 			print 'c...*'\n 			print '....*'\n 			print '...**'\n 			print '*****'\n 		elif m == 10:\n 			print 'c....'\n 			print '.....'\n 			print '*****'\n 			print '*****'\n 		elif m == 11:\n 			print 'c..**'\n 			print '...**'\n 			print '...**'\n 			print '*****'\n 		elif m == 12:\n 			print 'c.***'\n 			print '..***'\n 			print '..***'\n 			print '..***'\n 		elif m == 13:\n 			print 'Impossible'\n 		elif m == 14:\n 			print 'c.***'\n 			print '..***'\n 			print '..***'\n 			print '*****'\n 		elif m == 15:\n 			print 'Impossible'\n 		elif m == 16:\n 			print 'c.***'\n 			print '..***'\n 			print '*****'\n 			print '*****'\n 		elif m == 17:\n 			print 'Impossible'\n 		elif m == 18:\n 			print 'Impossible'\n 		elif m == 19:\n 			print 'c****'\n 			print '*****'\n 			print '*****'\n 			print '*****'\n 	elif c == 5 and r == 5:\n 		if m == 1:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '.....'\n 			print '....*'\n 		elif m == 2:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '.....'\n 			print '...**'\n 		elif m == 3:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '.....'\n 			print '..***'\n 		elif m == 4:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '...**'\n 			print '...**'\n 		elif m == 5:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '.....'\n 			print '*****'\n 		elif m == 6:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '..***'\n 			print '..***'\n 		elif m == 7:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '...**'\n 			print '*****'\n 		elif m == 8:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '..***'\n 			print '*****'\n 		elif m == 9:\n 			print 'c...*'\n 			print '....*'\n 			print '....*'\n 			print '....*'\n 			print '*****'\n 		elif m == 10:\n 			print 'c....'\n 			print '.....'\n 			print '.....'\n 			print '*****'\n 			print '*****'\n 		elif m == 11:\n 			print 'c....'\n 			print '.....'\n 			print '....*'\n 			print '*****'\n 			print '*****'\n 		elif m == 12:\n 			print 'c....'\n 			print '.....'\n 			print '...**'\n 			print '*****'\n 			print '*****'\n 		elif m == 13:\n 			print 'c....'\n 			print '.....'\n 			print '..***'\n 			print '*****'\n 			print '*****'\n 		elif m == 14:\n 			print 'c..**'\n 			print '...**'\n 			print '...**'\n 			print '..***'\n 			print '*****'\n 		elif m == 15:\n 			print 'c....'\n 			print '.....'\n 			print '*****'\n 			print '*****'\n 			print '*****'\n 		elif m == 16:\n 			print 'c..**'\n 			print '...**'\n 			print '...**'\n 			print '*****'\n 			print '*****'\n 		elif m == 17:\n 			print 'c..**'\n 			print '...**'\n 			print '..***'\n 			print '*****'\n 			print '*****'\n 		elif m == 18:\n 			print 'Impossible'\n 		elif m == 19:\n 			print 'c..**'\n 			print '...**'\n 			print '*****'\n 			print '*****'\n 			print '*****'\n 		elif m == 20:\n 			print 'Impossible'\n 		elif m == 21:\n 			print 'c.***'\n 			print '..***'\n 			print '*****'\n 			print '*****'\n 			print '*****'\n 		elif m == 22:\n 			print 'Impossible'\n 		elif m == 23:\n 			print 'Impossible'\n 		elif m == 24:\n 			print 'c****'\n 			print '*****'\n 			print '*****'\n 			print '*****'\n 			print '*****'\n 	else:\n 		print 'Impossible'\n \n
j3ffreysmith	<>	46	<>	2013_2270488_2463486.py	<>	import math\n \n #wont help, runs out of memory for 10^100\n # palindromeCache = {} #ideally this is precalculated\n \n # def isPalindrome(S):\n 	# s = str(S) #so I dont need to make sure its a string\n 	# if s in palindromeCache:\n 		# return palindromeCache[s]\n 		\n 	# palindromeCache[s] = True\n 	# for i in range(len(s)//2):\n 		# if not s[i] == s[-1 - i]:\n 			# palindromeCache[s] = False\n 			# break\n 	# return palindromeCache[s]\n 	\n def isPalindrome(S):\n 	s = str(S) #so I dont need to make sure its a string\n 	for i in range(len(s)//2):\n 		if not s[i] == s[-1 - i]:\n 			return False\n 	return True\n \n def FairAndSquare(infile="C-small-attempt0.in", outfile="C-small-attempt0.out"):\n 	inF = open(infile, 'r')\n 	outF = open(outfile, 'w')\n 	\n 	for t in range(1, int(inF.readline().strip()) + 1):\n 		temp = inF.readline().strip().split()\n 		A = long(temp[0])\n 		B = long(temp[1])\n 		count = long(0)\n 		\n 		i = long(math.ceil(math.sqrt(A)))\n 		m = long(math.floor(math.sqrt(B)))\n 		while i <= m:\n 			if isPalindrome(i):\n 				if isPalindrome(i**2):\n 					count += 1\n 			i += 1\n 					\n 		outF.write("Case #" + str(t) + ": " + str(count) + "\n")\n 	\n 	#closing files\n 	inF.close()\n 	outF.close()\n 	\n 	#so I dont need to cat the file after\n 	f = open(outfile, 'r')\n 	print f.read()\n 	f.close()\n 	\n 	\n if __name__ == "__main__":\n     FairAndSquare()
j3ffreysmith	<>	46	<>	2013_2270488_2449486.py	<>	from array import array\n \n def Lawnmower(infile="B-small-attempt0.in", outfile="B-small-attempt0.out"):\n 	inF = open(infile, 'r')\n 	outF = open(outfile, 'w')\n 	\n 	for t in range(1, int(inF.readline().strip()) + 1):\n 		#read grid size\n 		temp = inF.readline().strip().split()\n 		N = int(temp[0])\n 		M = int(temp[1])\n 		L = []\n 		\n 		for i in range(N):\n 			L.append(inF.readline().strip().split()) #using an array should speed up the lookups\n 			for j in range(M):\n 				L[i][j] = int(L[i][j])\n 		\n 		for y in range(N):\n 			for x in range(M):\n 				# check horizontal\n 				for i in range(M):\n 					if L[y][i] > L[y][x]:\n 						break\n 				else:\n 					continue\n 				\n 				# check vertical\n 				for i in range(N):\n 					if L[i][x] > L[y][x]:\n 						break\n 				else:\n 					continue\n 				break\n 			else:\n 				continue\n 			break\n 		else:\n 			#good\n 			outF.write("Case #" + str(t) + ": YES\n")\n 			continue\n 		#bad\n 		outF.write("Case #" + str(t) + ": NO\n")\n 	\n 	#closing files\n 	inF.close()\n 	outF.close()\n 	\n 	#so I dont need to cat the file after\n 	f = open(outfile, 'r')\n 	print f.read()\n 	f.close()\n 	\n 	\n if __name__ == "__main__":\n     Lawnmower()
j3ffreysmith	<>	46	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python\n \n def partCa(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/C-small-attempt0.in",\\n               outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/output.txt"):\n     \n     #if not init:\n         #build_dict()\n     \n     #Reading input\n     linesA = []\n     for line in open(infile, 'r'):\n         linesA.append(line.strip())\n \n     outA = []\n         \n     #Parsing Input\n     T = int(linesA[0])\n     for i in range(1, 1 + T):\n         caseA = linesA[i].split()\n         A = int(caseA[0])\n         B = int(caseA[1])\n         \n         \n         outA.append(0)\n         #Calculating answer\n         for i in range(A,B):\n             for j in range(i + 1, B + 1):\n                 #testing pair (i, j)\n                 outA[-1] += int(isRecycled(i, j))\n     \n     #Writing Output\n     out = open(outfile, 'w')\n     print "\nOUTPUT"\n     for i in range(1, 1 + T):\n         if i != 1:\n             out.write("\n")\n         print "Case #" + str(i) + ": " +str(outA[i-1])\n         out.write("Case #" + str(i) + ": " +str(outA[i-1]))\n     out.close()\n     \n def isRecycled(n,m):\n     '''\n     Takes 2 integers and tells you if they are recycled\n     '''\n     a = str(n)\n     b = str(m)\n     if len(a) == len(b):\n         for i in range(len(a)):\n             if (a[i:] + a[:i]) == b:\n                 return True\n         \n     return False\n     \n if __name__ == "__main__":\n     partCa()\n
j3ffreysmith	<>	46	<>	2014_2974486_5756407898963968.py	<>	__author__ = 'Jeffrey'\n \n inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\A-small-attempt0.in"\n outFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\A-small-attempt0.out"\n \n \n def parseInput(f):\n     T = int(f.readline())\n     L = []\n \n     for i in range(T):\n         picks = []\n         cards = []\n         for j in range(2):\n             picks.append( int(f.readline()))\n             tempL = []\n             for k in range(4):\n                 tempL.append( [int(j) for j in f.readline().split()])\n             cards.append(tempL)\n         L.append((picks, cards))\n \n     return T, L\n \n \n def performTrick(picks, cards):\n     matchFound = False\n     matchedCard = None\n     for card in cards[0][picks[0] - 1]:\n         possibleMatch = card in cards[1][picks[1] - 1]\n         if possibleMatch and matchFound:\n             return "Bad magician!"\n         elif possibleMatch:\n             matchFound = True\n             matchedCard = card\n     if matchFound:\n         return matchedCard\n     else:\n         return "Volunteer cheated!"\n \n \n def playGame(T,L):\n     for i in range(T):\n         result = performTrick(L[i][0], L[i][1])\n         yield "Case #" + str(i + 1) + ": " + str(result)\n \n \n if __name__=="__main__":\n     iF = open(inFileName, 'r')\n     T, L = parseInput(iF)\n     iF.close()\n \n     oF = open(outFileName, "wb")\n     for out in playGame(T, L):\n         # print(out)\n         # print(bytes(out, 'utf-8'), file=oF)\n         oF.write(bytes(out + "\n",'utf-8'))\n     oF.close()\n
j3ffreysmith	<>	46	<>	2012_1460488_1483485.py	<>	from string import maketrans\n \n f = "abcdefghijklmnopqrstuvwxyz"\n o = "ynficwlbkuomxsevzpdrjgthaq"\n         \n def partAfile(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/input.txt",\\n               outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/output.txt"):\n     tempF = open(infile, 'r')\n     tempA = []\n     for line in tempF:\n         tempA.append(line.strip())\n         \n     N = int(tempA[0])\n     \n     out = open(outfile, 'w')\n     for i in range(1, 1+N):\n         if i != 1:\n             out.write("\n")\n         print "Case #" + str(i) + ": " +tempA[i].translate(maketrans(o,f))\n         out.write("Case #" + str(i) + ": " +tempA[i].translate(maketrans(o,f)))\n         \n     \n if __name__ == "__main__":\n     partAfile()\n
j3ffreysmith	<>	46	<>	2014_2974486_5709773144064000.py	<>	__author__ = 'Jeffrey'\n \n inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\B-small-attempt0.in"\n outFileName = inFileName[ : -2] + "out"\n \n \n def parseInput(f):\n     T = int(f.readline())\n     L = []\n \n     for i in range(T):\n         L.append([float(i) for i in f.readline().split()])\n \n     return T, L\n \n \n def calculateWinTime(C, F, X):\n     R = 2.0 # rate of cookie profit (cookies/s)\n     totalTime = 0.0\n     while (X / R >= C/R + X/(R + F)):\n         totalTime += C / R\n         R += F\n     return totalTime + X / R\n \n \n def playGame(T,L):\n     for i in range(T):\n         result = calculateWinTime(L[i][0], L[i][1], L[i][2])\n         yield "Case #" + str(i + 1) + ": " + "{:0.7f}".format(result)\n \n \n if __name__=="__main__":\n     iF = open(inFileName, 'r')\n     T, L = parseInput(iF)\n     iF.close()\n \n     print(T)\n     print(L)\n \n     oF = open(outFileName, "wb")\n     for out in playGame(T, L):\n         print(out)\n         # print(bytes(out, 'utf-8'), file=oF)\n         oF.write(bytes(out + "\n",'utf-8'))\n     oF.close()\n
j3ffreysmith	<>	46	<>	2013_2270488_2453486.py	<>	def checkRow(r):\n 	c = r[0];\n 	\n 	# making sure it isnt an empty line\n 	if (c == '.'):\n 		return (False, None)\n 		\n 	for i in range(1,4):\n 		if not (r[i] == c or r[i] == 'T'):\n 			return (False, None)\n 	\n 	# if it got this far it must be right\n 	return (True, c)\n \n def checkCol(L, col):\n 	c = L[0][col];\n 	\n 	# making sure it isnt an empty line\n 	if (c == '.'):\n 		return (False, None)\n 		\n 	for i in range(1,4):\n 		if not (L[i][col] == c or L[i][col] == 'T'):\n 			return (False, None)\n 	\n 	# if it got this far it must be right\n 	return (True, c)\n 	\n def checkDiag(L):\n 	c = L[0][0];\n 	\n 	for i in range(1,4):\n 		if not (L[i][i] == c or L[i][i] == 'T'):\n 			break\n 	else:\n 		if (c != '.'):\n 			# if it got this far it must be right\n 			return (True, c)\n 	\n 	#first diag failed\n 	c = L[0][3];\n 	\n 	# making sure it isnt an empty line\n 	if (c == '.'):\n 		return (False, None)\n 		\n 	for i in range(1,4):\n 		if not (L[i][3-i] == c or L[i][3-i] == 'T'):\n 			break\n 	else:\n 		# if it got this far it must be right\n 		return (True, c)\n 		\n 	return (False, None)\n 		\n def checkComplete(L):\n 	for i in range(4):\n 		if '.' in L[i]:\n 			return False\n 	return True\n \n def TicTacToeTomek(infile="A-small-attempt0.in", outfile="A-small-attempt0.out"):\n 	f = open(infile, 'r')\n 	out = open(outfile, 'w')\n 	\n 	# get the number of tests\n 	n = int(f.readline().strip())\n 	\n 	for t in range(1, n + 1):\n 		L = []\n 		# loading game\n 		for i in range(4):\n 			L.append(f.readline().strip());\n 		\n 		# checking game state\n 		for i in range(4):\n 			#checking row\n 			result = checkRow(L[i])\n 			if result[0]:\n 				out.write("Case #" + str(t) + ": " + result[1] + " won\n")\n 				break\n 			#checking column\n 			result = checkCol(L,i)\n 			if result[0]:\n 				out.write("Case #" + str(t) + ": " + result[1] + " won\n")\n 				break\n 		else:\n 			#checking column\n 			result = checkDiag(L)\n 			if result[0]:\n 				out.write("Case #" + str(t) + ": " + result[1] + " won\n")\n 			else:\n 				if checkComplete(L):\n 					out.write("Case #" + str(t) + ": Draw\n")\n 				else:\n 					out.write("Case #" + str(t) + ": Game has not completed\n")\n 				\n 		f.readline() #skipping empty line\n 	\n 	#closing files\n 	f.close()\n 	out.close()\n 	\n 	#so I dont need to cat the file after\n 	f = open(outfile, 'r')\n 	print f.read()\n 	f.close()\n 	\n 	\n if __name__ == "__main__":\n     TicTacToeTomek()
j3ffreysmith	<>	46	<>	2014_2974486_5690574640250880.py	<>	__author__ = 'Jeffrey'\n \n # inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-sample.in"\n inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-small-attempt0.in"\n # inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-large.in"\n \n outFileName = inFileName[: -2] + "out"\n \n \n def parseInput(f):\n     T = int(f.readline())\n     L = []\n \n     for i in range(T):\n         L.append([int(i) for i in f.readline().split()])\n \n     return T, L\n \n \n def calculateOneClick(R, C, M):\n     size = R * C\n     if R == 1 or C == 1 and M < size:\n         return generateWinBoardBaseCase(R, C, M)\n     elif size - M == 1:\n         return generateWinBoardBaseCase(R, C, M)\n     elif size - M >= 4:\n         return generateWinBoard(R, C, M)\n     return "Impossible"\n \n def generateWinBoard(R,C,M):\n     emptySpace = R * C - M - 4\n     out = "c"\n     if C > 1:\n         out += "."\n         for i in range(2,C):\n             if emptySpace > 0:\n                 out += "."\n                 emptySpace -= 1\n             else:\n                 out += "*"\n                 # out += '\n'\n     if R > 1:\n         out += '\n'\n         out += "."\n         if C > 1:\n             out += "."\n         for i in range(2,C):\n             if emptySpace > 0:\n                 out += "."\n                 emptySpace -= 1\n             else:\n                 out += "*"\n     for r in range(2,R):\n         out += '\n'\n         for c in range(C):\n             if emptySpace > 0:\n                 out += "."\n                 emptySpace -= 1\n             else:\n                 out += "*"\n     return out\n \n def generateWinBoardBaseCase(R,C,M):\n     emptySpace = R * C - M - 1\n     out = "c"\n     if C > 1:\n         for c in range(1,C):\n             if emptySpace > 0:\n                 out += "."\n                 emptySpace -= 1\n             else:\n                 out += "*"\n     for r in range(1,R):\n         out += '\n'\n         for c in range(C):\n             if emptySpace > 0:\n                 out += "."\n                 emptySpace -= 1\n             else:\n                 out += "*"\n     return out\n \n \n def playGame(T, L):\n     for i in range(T):\n         result = calculateOneClick(L[i][0], L[i][1], L[i][2])\n         yield "Case #" + str(i + 1) + ":\n" + str(result)\n \n \n if __name__ == "__main__":\n     iF = open(inFileName, 'r')\n     T, L = parseInput(iF)\n     iF.close()\n \n     print(T)\n     print(L)\n \n     oF = open(outFileName, "wb")\n     for out in playGame(T, L):\n         print(out)\n         # print(bytes(out, 'utf-8'), file=oF)\n         oF.write(bytes(out + "\n", 'utf-8'))\n     oF.close()\n
graygrass	<>	47	<>	2013_2270488_2463486.py	<>	import math\n \n def ss(t, amap, bmap):\n     s = 0\n     for m in amap:\n         if len(m) == 1 and t == m.keys()[0]:\n             s += m[t]\n             for b in bmap:\n                 if t in b:\n                     b[t] -= 1\n                     if b[t] == 0:\n                         b.pop(t)\n             m.clear()\n     return s           \n \n \n def solve(case, in_lines):\n     out = 'Case #%d: '%case\n  \n     rn, cn = [int(x) for x in in_lines[0].split()]\n     mtx = []\n     for i in xrange(rn):\n         mtx.append([int(x) for x in in_lines[i+1].split()])\n     rmap = [{} for x in xrange(rn)]\n     cmap = [{} for x in xrange(cn)]\n     td = {}\n     \n     for i in xrange(rn):\n         for j in range(cn):\n             k = mtx[i][j]\n             if k in rmap[i]:\n                 rmap[i][k] += 1\n             else:\n                 rmap[i][k] = 1\n             if k in cmap[j]:\n                 cmap[j][k] += 1\n             else:\n                 cmap[j][k] = 1\n             if k in td:\n                 td[k] += 1\n             else:\n                 td[k] = 1\n                 \n     while len(td):\n         k = min(td.keys())\n         sb = ss(k, rmap, cmap)\n         sb += ss(k, cmap, rmap)\n         if sb == 0:\n             break;\n         td[k] -= sb\n         if td[k] == 0:\n             td.pop(k)\n \n     return out + ('YES' if sb else 'NO')\n \n \n def main(raw):\n     lines = raw.split('\n')\n     n = int(lines[0])\n     ln = 1\n     outs = []\n     for case in xrange(1, n+1):\n         buff = []\n         cl = int(lines[ln].split()[0]) + ln + 1\n         while ln < cl and lines[ln]:\n             buff.append(lines[ln])\n             ln += 1\n         s = solve(case, buff)\n         print s\n         outs.append(s)\n     return '\n'.join(outs)\n     pass\n \n if __name__ == '__main__':\n     test_input = """4\n 4 3\n 2 5 2\n 1 1 1\n 2 4 2\n 2 3 2\n 3 3\n 2 1 2\n 1 1 1\n 2 1 2\n 5 5\n 2 2 2 2 2\n 2 1 1 1 2\n 2 1 2 1 2\n 2 1 1 1 2\n 2 2 2 2 2\n 1 3\n 1 2 1"""\n     force_no_file = False\n     in_file_name = '' if force_no_file else 'B-large.in'\n     base_path = 'G:/workspace/py/codejam2013/RQ/'\n     if in_file_name:\n         with open(base_path + in_file_name) as f:\n             raw = f.read()\n     else:\n         raw = test_input\n     out = main(raw)\n     if in_file_name:\n         with open(base_path + in_file_name + '.out', 'w') as f:\n             f.write(out)\n     pass
graygrass	<>	47	<>	2013_2270488_2449486.py	<>	import math\n \n def ss(t, amap, bmap):\n     s = 0\n     for m in amap:\n         if len(m) == 1 and t == m.keys()[0]:\n             s += m[t]\n             for b in bmap:\n                 if t in b:\n                     b[t] -= 1\n                     if b[t] == 0:\n                         b.pop(t)\n             m.clear()\n     return s           \n \n \n def solve(case, in_lines):\n     out = 'Case #%d: '%case\n  \n     rn, cn = [int(x) for x in in_lines[0].split()]\n     mtx = []\n     for i in xrange(rn):\n         mtx.append([int(x) for x in in_lines[i+1].split()])\n     rmap = [{} for x in xrange(rn)]\n     cmap = [{} for x in xrange(cn)]\n     td = {}\n     \n     for i in xrange(rn):\n         for j in range(cn):\n             k = mtx[i][j]\n             if k in rmap[i]:\n                 rmap[i][k] += 1\n             else:\n                 rmap[i][k] = 1\n             if k in cmap[j]:\n                 cmap[j][k] += 1\n             else:\n                 cmap[j][k] = 1\n             if k in td:\n                 td[k] += 1\n             else:\n                 td[k] = 1\n                 \n     while len(td):\n         k = min(td.keys())\n         sb = ss(k, rmap, cmap)\n         sb += ss(k, cmap, rmap)\n         if sb == 0:\n             break;\n         td[k] -= sb\n         if td[k] == 0:\n             td.pop(k)\n \n     return out + ('YES' if sb else 'NO')\n \n \n def main(raw):\n     lines = raw.split('\n')\n     n = int(lines[0])\n     ln = 1\n     outs = []\n     for case in xrange(1, n+1):\n         buff = []\n         cl = int(lines[ln].split()[0]) + ln + 1\n         while ln < cl and lines[ln]:\n             buff.append(lines[ln])\n             ln += 1\n         s = solve(case, buff)\n         print s\n         outs.append(s)\n     return '\n'.join(outs)\n     pass\n \n if __name__ == '__main__':\n     test_input = """4\n 4 3\n 2 5 2\n 1 1 1\n 2 4 2\n 2 3 2\n 3 3\n 2 1 2\n 1 1 1\n 2 1 2\n 5 5\n 2 2 2 2 2\n 2 1 1 1 2\n 2 1 2 1 2\n 2 1 1 1 2\n 2 2 2 2 2\n 1 3\n 1 2 1"""\n     force_no_file = False\n     in_file_name = '' if force_no_file else 'B-small-attempt0.in'\n     base_path = 'G:/workspace/py/codejam2013/RQ/'\n     if in_file_name:\n         with open(base_path + in_file_name) as f:\n             raw = f.read()\n     else:\n         raw = test_input\n     out = main(raw)\n     if in_file_name:\n         with open(base_path + in_file_name + '.out', 'w') as f:\n             f.write(out)\n     pass
graygrass	<>	47	<>	2012_1460488_1483488.py	<>	#! /usr/bin/env python\n #coding=utf-8\n \n def solve(icase, case_input):\n     case_output = 'Case #%i: '%icase\n     \n     result = 0\n     raw = case_input[0].split()\n     n = len(raw[0])\n     a = int(raw[0])\n     b = int(raw[1])\n     \n     for i in xrange(a, b):\n         rslt = set()\n         for t in xrange(1, n):\n             tt = 10**t\n             tn = 10**(n-t)\n             ia, ib = divmod(i, tt)\n             ii = ib*tn + ia\n             if ii > i and ii <= b:\n                 rslt.add(ii)\n         result += len(rslt)\n         \n \n     case_output += '%d'%result\n     \n     return case_output\n \n \n def main():\n     global use_test_data\n     global test_data\n     global input_file\n     global output_file\n     \n     if use_test_data:\n         data = [x.strip() for x in test_data.split('\n')]\n     else:\n         data = [x.strip() for x in input_file.readlines()]\n     \n     T = int(data[0])\n     iLine = 1\n     caseLineNum = 1\n     for icase in range(1, T + 1):\n         input = []\n         for i in range(caseLineNum):\n             input.append(data[iLine])\n             iLine += 1\n         rslt = solve(icase, input)\n         print rslt\n         if not use_test_data:\n             print >> output_file, rslt\n     \n     if not use_test_data:\n         input_file.close()\n         output_file.close()\n     \n     \n if __name__ == '__main__':\n     test_data = """5\n 1 9\n 10 40\n 100 500\n 1111 2222\n 1000000 2000000\n """\n     use_test_data = False\n     \n     test_file = 'C-small-attempt0.in'\n     if not use_test_data and '' != test_file:\n         input_file = open(test_file)\n         output_file = open(test_file + '.out', 'w')\n     \n     main()
graygrass	<>	47	<>	2012_1460488_1483485.py	<>	#! /usr/bin/env python\n #coding=utf-8\n \n def solve(icase, case_input):\n     case_output = 'Case #%i: '%icase\n     \n     result = ""\n     for c in case_input[0]:\n         if c in map:\n             result += map[c]\n         else:\n             result += c\n \n     case_output += '%s'%result\n     \n     return case_output\n \n \n def getmap():\n     inputs = ["ejp mysljylc kd kxveddknmc re jsicpdrysi",\n               "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n               "de kr kd eoya kw aej tysr re ujdr lkgc jv"]\n     outputs = ["our language is impossible to understand",\n                "there are twenty six factorial possibilities",\n                "so it is okay if you want to just give up"]\n     map = {}\n     for case in xrange(3):\n         for i, c in enumerate(inputs[case]):\n             map[c] = outputs[case][i]\n     \n     map['q'] = 'z'\n     map['z'] = 'q'\n     \n     print map\n     print len(map)\n     for c in "abcdefghijklmnopqrstuvwxyz":\n         if c not in map:\n             print c\n     return map\n \n \n def main():\n     global use_test_data\n     global test_data\n     global input_file\n     global output_file\n     \n     if use_test_data:\n         data = [x.strip() for x in test_data.split('\n')]\n     else:\n         data = [x.strip() for x in input_file.readlines()]\n     \n     T = int(data[0])\n     iLine = 1\n     caseLineNum = 1\n     for icase in range(1, T + 1):\n         input = []\n         for i in range(caseLineNum):\n             input.append(data[iLine])\n             iLine += 1\n         rslt = solve(icase, input)\n         print rslt\n         if not use_test_data:\n             print >> output_file, rslt\n     \n     if not use_test_data:\n         input_file.close()\n         output_file.close()\n     \n     \n if __name__ == '__main__':\n     test_data = """3\n ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv\n     """\n     use_test_data = False\n     \n     map = getmap()\n     \n     test_file = 'A-small-attempt2.in'\n     if not use_test_data and '' != test_file:\n         input_file = open(test_file)\n         output_file = open(test_file + '.out', 'w')\n     \n     main()
graygrass	<>	47	<>	2014_2974486_5709773144064000.py	<>	import os\n import math\n \n class Solver(object):\n     def __init__(self):\n         pass\n     \n     def solve(self, inputs):\n         c, f, x = [float(t) for t in inputs[0].split()]\n         if x <= c:\n             return '%.7f'%(x/2)\n         ii = int(math.ceil((f*x-2*c)/(f*c)-1))\n         if ii <= 0:\n             return '%.7f'%(x/2)\n         t = 0\n         for i in range(ii):\n             t += c/(2+i*f)\n         t += x/(2+ii*f)\n         return '%.7f'%t\n         pass\n     \n     def feed(self, inputs):\n         lines = [x.strip() for x in inputs]\n         outputs = []\n         test_case_n = int(lines[0])\n         cur = 1\n         for i in range(test_case_n):\n             i = i\n             case_line_cnt = 1\n             case_inputs = lines[cur:cur+case_line_cnt]\n             cur += case_line_cnt\n             outputs.append(self.solve(case_inputs))\n         return outputs\n \n if __name__ == '__main__':\n     iname = 'B-small-attempt0.in'\n #     iname = 'foo'\n     sample_in = '''\n     4\n 30.0 1.0 2.0\n 30.0 2.0 100.0\n 30.50000 3.14159 1999.19990\n 500.0 4.0 2000.0\n     '''\n     sample_out = '''\n Case #1: 1.0000000\n Case #2: 39.1666667\n Case #3: 63.9680013\n Case #4: 526.1904762\n     '''\n     if os.path.exists(iname):\n         with open(iname) as f:\n             inputs = f.readlines()\n     else:\n         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n     solver = Solver()\n     outputs = solver.feed(inputs)\n     fail_flag = False\n     if os.path.exists(iname):\n         with open(iname+'.out', 'w') as f:\n             for i, v in enumerate(outputs):\n                 print >> f, 'Case #%d: %s'%(i+1, str(v))\n     else:\n         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n         for i, v in enumerate(outputs):\n             t = 'Case #%d: %s'%(i+1, str(v))\n             if t not in ans:\n                 print '!!! Wrong:', t\n                 fail_flag = True\n     print '===================================================='\n     for i, v in enumerate(outputs):\n         print 'Case #%d: %s'%(i+1, str(v))\n     print '===================================================='\n     print 'done' if not fail_flag else 'fail'\n     pass
graygrass	<>	47	<>	2013_2270488_2453486.py	<>	import math\n \n mm = [0xf, 0xf0, 0xf00, 0xf000, 0x8888, 0x4444, 0x2222, 0x1111, 0x8421, 0x1248]\n \n def solve(case, in_lines):\n     out = 'Case #%d: '%case\n     s = ''.join(in_lines)\n     x = 0\n     o = 0\n     nc = False\n     for i in xrange(16):\n         m = 1 << i\n         c = s[i]\n         if c == 'X':\n             x |= m\n         elif c == 'O':\n             o |= m\n         elif c == 'T':\n             x |= m\n             o |= m\n         else:\n             nc = True\n     r = ''\n     for m in mm:\n         if m & x == m:\n             r = 'X won'\n             break\n         if m & o == m:\n             r = 'O won'\n             break\n     if not r:\n         if nc:\n             r = 'Game has not completed'\n         else:\n             r = 'Draw'\n     \n     return out + r\n \n \n def main(raw):\n     lines = raw.split('\n')\n     n = int(lines[0])\n     ln = 0\n     outs = []\n     for case in xrange(1, n+1):\n         buff = []\n         ln += 1\n         while ln < len(lines) and lines[ln]:\n             buff.append(lines[ln])\n             ln += 1\n         s = solve(case, buff)\n         print s\n         outs.append(s)\n     return '\n'.join(outs)\n     pass\n \n if __name__ == '__main__':\n     test_input = """6\n XXXT\n ....\n OO..\n ....\n \n XOXT\n XXOO\n OXOX\n XXOO\n \n XOX.\n OX..\n ....\n ....\n \n OOXX\n OXXX\n OX.T\n O..O\n \n XXXO\n ..O.\n .O..\n T...\n \n OXXX\n XO..\n ..O.\n ...O"""\n     force_no_file = False\n     in_file_name = '' if force_no_file else 'A-small-attempt0.in'\n     base_path = 'G:/workspace/py/codejam2013/RQ/'\n     if in_file_name:\n         with open(base_path + in_file_name) as f:\n             raw = f.read()\n     else:\n         raw = test_input\n     out = main(raw)\n     if in_file_name:\n         with open(base_path + in_file_name + '.out', 'w') as f:\n             f.write(out)\n     pass
graygrass	<>	47	<>	2014_2974486_5690574640250880.py	<>	import os\n \n class Solver(object):\n     def __init__(self):\n         pass\n     \n     def solve(self, inputs):\n         R, C, M = [int(x) for x in inputs[0].split()]\n         mp = []\n         for r in range(R):\n             mp.append(['.']*C)\n         mp[0][0] = 'c'\n         outputs = []\n         if M == 0:\n             for row in mp:\n                 outputs.append(''.join(row))\n             return outputs\n         rr, cc, rm = R, C, M\n         while rm >= min(rr, cc):\n             if rr <= cc:\n                 for r in range(rr):\n                     mp[r][cc-1] = '*'\n                 cc -= 1\n                 rm -= rr\n             else:\n                 for c in range(cc):\n                     mp[rr-1][c] = '*'\n                 rr -= 1\n                 rm -= cc\n         \n         if rm == 0:\n             if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\n                 return ['Impossible']\n         else:\n             if min(rr, cc) - rm >= 2:\n                 if rr <= cc:\n                     for r in range(rr-rm, rr):\n                         mp[r][cc-1] = '*'\n                 else:\n                     for c in range(cc-rm, cc):\n                         mp[rr-1][c] = '*'\n             else:\n                 if min(rr, cc) >= 4:\n                     if rr <= cc:\n                         for r in range(2, rr):\n                             mp[r][cc-1] = '*'\n                         mp[rr-1][cc-2] = '*'\n                     else:\n                         for c in range(2, cc):\n                             mp[rr-1][c] = '*'\n                         mp[rr-2][cc-1]='*'\n                 elif min(rr,cc) == 3:\n                     if max(rr, cc) == 3:\n                         return ['Impossible']\n                     else:\n                         if rr <= cc:\n                             mp[2][cc-1] = '*'\n                             mp[2][cc-2] = '*'\n                         else:\n                             mp[rr-1][2] = '*'\n                             mp[rr-2][2] = '*'\n                 else:\n                     return ['Impossible']\n                     \n         for row in mp:\n             outputs.append(''.join(row))\n         return outputs\n         pass\n     \n     def feed(self, inputs):\n         lines = [x.strip() for x in inputs]\n         outputs = []\n         test_case_n = int(lines[0])\n         cur = 1\n         for i in range(test_case_n):\n             i = i\n             case_line_cnt = 1\n             case_inputs = lines[cur:cur+case_line_cnt]\n             cur += case_line_cnt\n             R, C, M = [int(x) for x in case_inputs[0].split()]\n             rslt = self.solve(case_inputs)\n             if self.verify(rslt, R, C, M):\n                 outputs.append(rslt)\n             else:\n                 raise 'Failed'\n         return outputs\n     \n     def verify(self, outputs, RR, CC, MCNT):\n         if 'Impossible' == outputs[0]:\n             return True\n         rr = len(outputs)\n         cc = len(outputs[0])\n         if RR != rr or CC != cc:\n             return False\n         bd = []\n         mask = []\n         for i in range(rr):\n             mask.append([1]*cc)\n             bd.append([0]*cc)\n             for j in range(cc):\n                 if outputs[i][j] == '*':\n                     bd[i][j] = 9\n                 elif outputs[i][j] == 'c':\n                     start = (i, j)\n         for r in range(rr):\n             for c in range(cc):\n                 if bd[r][c] == 9:\n                     for i in [r-1,r,r+1]:\n                         for j in [c-1,c,c+1]:\n                             if 0 <= i < rr and 0 <= j < cc:\n                                 if bd[i][j] != 9:\n                                     bd[i][j] += 1\n #         for i, row in enumerate(bd):\n #             print i, row\n \n         nlist = [start]\n         while len(nlist):\n             i, j = nlist.pop(0)\n             if mask[i][j] != 0:\n                 mask[i][j] = 0\n                 if bd[i][j] == 9:\n                     raise '!!! BOMB'\n                 elif bd[i][j] == 0:\n                     for ii in [i-1,i,i+1]:\n                         for jj in [j-1,j,j+1]:\n                             if 0<=ii<rr and 0<=jj<cc:\n                                 if ii != i or jj != j:\n                                     nlist.append((ii,jj))\n         mcnt = 0\n         for r in range(rr):\n #             print mask[r]\n             for c in range(cc):\n                 if mask[r][c] == 1:\n                     mcnt += 1\n                 if mask[r][c] == 1 and bd[r][c] != 9:\n                     return False\n                 if mask[r][c] != 1 and bd[r][c] == 9:\n                     return False\n         return (mcnt == MCNT)\n                 \n \n if __name__ == '__main__':\n     iname = 'C-small-attempt0.in'\n #     iname = 'foo'\n     sample_in = '''\n 7\n 5 5 23\n 3 1 1\n 2 2 1\n 4 7 3\n 10 10 82\n 3 4 0\n 2 2 3\n     '''\n     sample_out = '''\n Case #1: 1.0000000\n Case #2: 39.1666667\n Case #3: 63.9680013\n Case #4: 526.1904762\n     '''\n     if os.path.exists(iname):\n         with open(iname) as f:\n             inputs = f.readlines()\n     else:\n         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n     solver = Solver()\n     outputs = solver.feed(inputs)\n     fail_flag = False\n     if os.path.exists(iname):\n         with open(iname+'.out', 'w') as f:\n             for i, v in enumerate(outputs):\n                 print >> f, 'Case #%d:'%(i+1)\n                 print >> f, '\n'.join(v)\n     print '===================================================='\n     for i, v in enumerate(outputs):\n         print 'Case #%d:'%(i+1)\n         print '\n'.join(v)\n     print '===================================================='\n     print 'done' if not fail_flag else 'fail'\n     pass
shishkander	<>	48	<>	2013_2270488_2463486.py	<>	import itertools, sys, os\n from itertools import *\n import time, heapq\n \n def pal(s):\n     for i in xrange(len(s)/2):\n         if s[i] != s[-i-1]:\n             return False\n     return True\n \n def pal2(x, s):\n     return pal(s) and pal(str(x*x))\n \n def E(k):\n     return 10**k\n \n \n def CREATE_DATABASE(MAX):\n     def init():\n         yield 1\n         yield 2\n         yield 3\n         yield 11\n         yield 22\n         for i in xrange(1, MAX):\n             yield 1*E(2*i) + 1\n             yield 1*E(2*i+1) + 1\n             #yield 1*E(2*i + 1) + 1\n             #yield 1*E(2*i) + 1 + 2*E(i)\n             yield 2*E(2*i) + 2\n             yield 2*E(2*i) + 2 + 1*E(i)\n             yield 2*E(2*i+1) + 2\n             \n             \n     heap = list(sorted(set(init())))\n     for i in heap:\n         print i\n     heapq.heapify(heap)\n     RES = []\n     try:\n         MAX_X = E(MAX)\n         print "MAX_X", MAX_X\n         while True:\n             x = heapq.heappop(heap)\n             #print x\n             RES.append(x)\n             if x == 3:\n                 continue\n             if x > MAX_X:\n                 break\n             s = str(x)\n             j = len(s) / 2\n             shift = 1 if len(s) == 2*j else 0\n             for i in xrange(j+1, MAX):\n                 n = E(2*i-shift) + 1 + E(i-j) * x\n                 if pal2(n,str(n)):\n                     #print ("{:^%i} => {:^%i}" % (2*MAX, 2*MAX)).format(x, n)\n                     heapq.heappush(heap, n)\n                 \n     except KeyboardInterrupt:\n         print "stopped while x is", x\n     with open("c.database", 'w') as f:\n         for i in sorted(RES + heap):\n             f.write("%i\n"%i)\n \n def READ_DATABASE():\n     with open("c.database", 'r') as f:\n         return sorted(map(lambda x: int(x.strip())**2, f))\n DB = READ_DATABASE()\n \n from bisect import bisect_left, bisect_right\n def CASE(IN):\n     def rstr(): return IN.readline().strip()\n     def rint(): return int(rstr())\n     def rints(): return map(int, rstr().split())\n     def nrints(N): return [rints() for i in xrange(N)]\n     A, B = rints()\n     i = bisect_left(DB, A) \n     j = bisect_right(DB, B)\n     return j-i\n \n def RUN(IN, OUT):\n     t = int(IN.readline().strip())\n     for i in xrange(1,t+1):\n         OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n \n if __name__ == "__main__":\n     # CREATE_DATABASE(52)\n     import sys\n     RUN(sys.stdin, sys.stdout)\n
shishkander	<>	48	<>	2013_2270488_2449486.py	<>	from itertools import izip\n \n def CASE(IN):\n     def rstr(): return IN.readline().strip()\n     def rint(): return int(rstr())\n     def rints(): return map(int, rstr().split())\n     def nrints(N): return [rints() for i in xrange(N)]\n     N, M = rints()\n     A = nrints(N)\n     R = [max(row) for row in A]\n     C = [max(col) for col in izip(*A)]\n     for i, r in enumerate(R):\n         for j, c in enumerate(C):\n             if A[i][j] != min(r,c):\n                 return "NO"\n     return "YES"\n \n def RUN(IN, OUT):\n     t = int(IN.readline().strip())\n     for i in xrange(1,t+1):\n         OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n \n if __name__ == "__main__":\n     import sys\n     RUN(sys.stdin, sys.stdout)\n
shishkander	<>	48	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python\n import cPickle, time\n F = {}\n # to compute F:\n def f(x, _x, _min, _max):\n     if x < 10: \n         #raise StopIteration\n         return set()\n     l = len(str(x)) -1\n     k = 10**l\n     res = set()\n     res.add(_x)\n     for i in xrange(l):\n         x = (x % 10) * k + x/10\n         if _min <= x <= _max and _x < x:\n             res.add(x)\n     res.remove(_x)\n     if res:\n         #print _x, "=>", res\n         F[_x] = sorted(res)\n     return res\n \n def compute_F(B):\n     for i in xrange(0, B+1):\n         f(i,i, 0, B+1)\n     with open("picle",'wb') as _file:\n         cPickle.dump( F, _file)\n \n #print "start", time.time()\n #compute_F(2000000)\n #print "end  ", time.time()\n \n \n t_start = time.time()\n print "loading..."\n with open("picle",'rb') as _file:\n     F = cPickle.load(_file)\n print "done in %.2fs" % (time.time() - t_start)\n print "loaded F with %i keys" % len(F)\n \n def case(A, B):\n     print "XXXXXXXXX ", A, B\n     res = 0\n     res2 = 0\n     for i in xrange(A, B):\n         l = F.get(i, [])\n         #l = sorted(f(i,i,A,B))\n         #res += len(l)\n         #l1 = sorted(F.get(i,[]))\n         #if l != l1:\n         #    print i, l, l1\n \n         for x in l:\n            if x <= B:\n                res += 1\n     return res\n \n def solve(fin, fout):\n     T = int(fin.readline())\n     for t in xrange(T):\n         A, B = map(int, fin.readline().strip().split(" "))\n         assert A <= B\n         fout.write("Case #%i: %i\n" % (t+1, case(A,B)) )\n     return True\n \n if __name__ == "__main__":\n     import sys\n     with open(sys.argv[1],'r') as fin:\n         with open(sys.argv[2], 'w') as fout:\n             solve(fin, fout)\n
shishkander	<>	48	<>	2014_2974486_5756407898963968.py	<>	def CASE(IN):\n     def rstr(): return IN.readline().strip()\n     def rint(): return int(rstr())\n     def rints(): return map(int, rstr().split())\n     def rr():\n         x = rint()\n         m = [rints() for i in xrange(4)]\n         return set(m[x-1])\n     s = rr().intersection(rr())\n     if not s:\n         return "Volunteer cheated!"\n     if len(s) == 1:\n         return s.pop()\n     return "Bad magician!"\n \n \n def RUN(IN, OUT):\n     t = int(IN.readline().strip())\n     for i in xrange(1,t+1):\n         OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n \n if __name__ == "__main__":\n     import sys\n     RUN(sys.stdin, sys.stdout)\n
shishkander	<>	48	<>	2012_1460488_1483485.py	<>	#!/usr/bin/env python\n \n IN = """\n ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv"""\n OUT ="""\n Case #1: our language is impossible to understand\n Case #2: there are twenty six factorial possibilities\n Case #3: so it is okay if you want to just give up"""\n \n ins = IN.strip().split("\n")\n outs = OUT.strip().split("\n")\n assert len(ins) == len(outs) == 3\n \n D = {}\n D['a'] = 'y'\n D['o'] = 'e'\n D['z'] = 'q'\n \n for case, s in enumerate(ins):\n     out = outs[case][9:] # skip "Case #?: "\n     assert len(out) == len(s)\n     for i, o in enumerate(out):\n         if o == ' ': continue\n         D[s[i]] = o\n \n if len(D) == 25:\n     chars = map(chr, xrange(97, 123))\n     key = set(chars).difference( set(D.keys()) ).pop()\n     value = set(chars).difference( set(D.values()) ).pop()\n     D[key] = value\n assert len(D) == 26\n D[' '] = ' '\n \n \n def solve(fin, fout):\n     T = int(fin.readline())\n     for t in xrange(T):\n         fout.write("Case #%i: " % (t+1) )\n         for c in fin.readline().strip():\n             fout.write(D[c])\n         fout.write('\n')\n     return True\n \n if __name__ == "__main__":\n     import sys\n     with open(sys.argv[1],'r') as fin:\n         with open(sys.argv[2], 'w') as fout:\n             solve(fin, fout)\n
shishkander	<>	48	<>	2014_2974486_5709773144064000.py	<>	def CASE(IN):\n     def rstr(): return IN.readline().strip()\n     def rint(): return int(rstr())\n     def rints(): return map(int, rstr().split())\n     def rfs(): return map(float, rstr().split())\n     c, f, x = rfs()\n     b = 2.0\n     if x <= c:\n         return x/b\n     t = 0\n     while True:\n         # we can buy a farm now, should we?\n         tf = x/(b+f) + c/b\n         tn = x/b\n         if tn <= tf:\n             return t + tn\n         t += c/b\n         b += f\n \n \n def RUN(IN, OUT):\n     t = int(IN.readline().strip())\n     for i in xrange(1,t+1):\n         OUT.write("Case #%i: %.7f\n" % (i, CASE(IN)))\n \n if __name__ == "__main__":\n     import sys\n     RUN(sys.stdin, sys.stdout)\n
shishkander	<>	48	<>	2013_2270488_2453486.py	<>	def test_win(M, c):\n     N = len(M)\n     def yielder():\n         for row in M:\n             yield row, 'row'\n         for i in xrange(N):\n             yield [row[i] for row in M], 'col'\n         yield [M[i][i] for i in xrange(N)], 'd1'\n         yield [M[i][N-i-1] for i in xrange(N)], 'd2'\n     for lst, typ in yielder():\n         if all(l == c or l == 'T' for l in lst):\n             #print "won at %s %s" % (lst, typ)\n             return True\n     return False\n \n def CASE(IN):\n     def rstr(): return IN.readline().strip()\n     def rint(): return int(rstr())\n     def rints(): return map(int, rstr().split())\n     M = [rstr() for i in xrange(4)]\n     rstr()\n     #print M\n     if test_win(M, 'X'):\n         return 'X won'\n     if test_win(M, 'O'):\n         return 'O won'\n     if any('.' in row for row in M):\n         return 'Game has not completed'\n     return 'Draw'\n \n def RUN(IN, OUT):\n     t = int(IN.readline().strip())\n     for i in xrange(1,t+1):\n         OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n \n if __name__ == "__main__":\n     import sys\n     RUN(sys.stdin, sys.stdout)\n
shishkander	<>	48	<>	2014_2974486_5690574640250880.py	<>	def get_a(r, c, f='.'):\n     A = []\n     for i in xrange(r):\n         A.append([f] * c)\n     return A\n \n \n def apply(A, r, c, B):\n     for i, b in enumerate(B):\n         for j, v in enumerate(b):\n             A[r + i][c + j] = v\n \n \n def draw(A):\n     if A is None:\n         return '\nImpossible'\n     res = ['']\n     for a in A:\n         res.append(''.join(a))\n     return '\n'.join(res)\n \n \n def trans(A):\n     if not A:\n         return None\n     B = get_a(len(A[0]), len(A))\n     for i, a in enumerate(A):\n         for j, v in enumerate(a):\n             B[j][i] = v\n     return B\n \n \n def check(A, m, r, c):\n     if A is None:\n         return True\n     cnts = {'c': 0, '*': 0, '.': 0}\n     #print draw(A)\n     #print\n \n     assert len(A) == r\n     for i in xrange(r):\n         assert len(A[i]) == c\n         for j in xrange(c):\n             cnts[A[i][j]] += 1\n     #print m, r, c, "=>", cnts\n     assert cnts['*'] == m\n     assert cnts['c'] == 1\n     assert cnts['.'] == r * c - m - 1\n \n \n def CASE(IN):\n     def rstr():\n         return IN.readline().strip()\n \n     def rint():\n         return int(rstr())\n \n     def rints():\n         return map(int, rstr().split())\n     r, c, m = rints()\n     A = solve(m, r, c)\n     if A:\n         A[-1][-1] = 'c'\n     check(A, m, r, c)\n     return draw(A)\n \n \n def solve(m, r, c):\n     if r > c:\n         return trans(solve(m, c, r))\n     assert r <= c\n     assert m != r * c\n     e = r * c - m\n     # we click always in the right bottom corner\n     if e == 1:\n         A = get_a(r, c, '*')\n         return A\n     if r == 1:\n         A = get_a(1, c, '.')\n         for i in xrange(m):\n             A[0][i] = '*'\n         return A\n     if r == 2:\n         if e == 2 or e % 2 == 1:\n             return None\n         A = get_a(2, c, '.')\n         assert m % 2 == 0\n         for i in xrange(m / 2):\n             A[0][i] = A[1][i] = '*'\n         return A\n     assert r >= 3\n     A = get_a(r, c, '*')\n     if e in (2, 3, 5, 7):\n         return None\n     E = [c] * (e / c) + ([e % c] if e % c else [])\n     if sum(E) < e:\n         E.append(e % c)\n         assert sum(E) == e\n     if len(E) == 1:\n         E = [e / 2] * 2\n         if sum(E) < e:\n             e.append(1)\n     if E[0] != E[1]:\n         s = sum(E[:2])\n         E[0] = E[1] = s / 2\n         if sum(E[:2]) != s:\n             assert len(E) == 2\n             E.append(1)\n     if E[-1] == 1:\n         if len(E) > 3:\n             E[-2] -= 1\n             E[-1] += 1\n         else:\n             E[0] -= 1\n             E[1] -= 1\n             E[2] += 2\n     for i in xrange(len(E)):\n         for j in xrange(E[i]):\n             A[-i - 1][-j - 1] = '.'\n     return A\n \n \n def RUN(IN, OUT):\n     t = int(IN.readline().strip())\n     for i in xrange(1, t + 1):\n         OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n \n if __name__ == "__main__":\n     import sys\n     RUN(sys.stdin, sys.stdout)\n
rajabaz	<>	49	<>	2013_2270488_2463486.py	<>	from math import sqrt\n \n def isqrt(num):\n     return int(sqrt(num))\n \n def is_square(num):\n     return isqrt(num)**2 == num\n \n def is_palindrome(num):\n     return str(num) == "".join(reversed(str(num)))\n \n def is_fair_and_square(num):\n     return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))\n \n def solve(A,B):\n     count = 0\n     for i in range(A,B+1):\n         if is_fair_and_square(i):\n             count += 1\n     return count\n \n if __name__ == "__main__":\n     T = int(raw_input())\n     for i in range(1, T+1):\n         A,B = [int(x) for x in raw_input().split()]\n         print "Case #%d: %d" % (i, solve(A,B))\n         \n
rajabaz	<>	49	<>	2013_2270488_2449486.py	<>	def solve(grid, M, N):\n     row_max = {}\n     column_max = {}\n     for i in range(M):\n         row_max[i] = max(grid[i])\n     for i in range(N):\n         column_max[i] = max([grid[j][i] for j in range(M)])\n     for i in range(M):\n         for j in range(N):\n             v = grid[i][j]\n             if v < row_max[i] and v < column_max[j]:\n                 return "NO"\n     return "YES"\n \n if __name__ == "__main__":\n     T = int(raw_input())\n     for i in range(1,T+1):\n         M,N = [int(x) for x in raw_input().split()]\n         grid = [[int(x) for x in raw_input().split()] for j in range(M)]\n         print "Case #%d: %s" % (i, solve(grid, M,N))\n
rajabaz	<>	49	<>	2012_1460488_1483488.py	<>	def num_rotations(n, A, B):\n     # I'm sure there's a better way to do this\n     # but this works fast enough so who cares\n     s = str(n)\n     a = set()\n     for i in range(len(s)):\n         rotated = s[i:] + s[:i]\n         r = int(rotated)\n         if rotated[0] != '0' and A <= r <= B:\n             a.add(rotated)\n     return len(a) -1\n \n def solve(A,B):\n     t  = 0\n     for i in range(A, B+1):\n         t += num_rotations(i, A, B)\n     if t % 2 != 0:\n         print "WTF", A, B, t\n     return t//2\n \n if __name__ == "__main__":\n     T = int(raw_input())\n     for i in range(1, T+1):\n         A,B = map(int, raw_input().strip().split())\n         print "Case #%d: %d" % (i, solve(A,B))\n
rajabaz	<>	49	<>	2014_2974486_5756407898963968.py	<>	def solve(c1, g1, c2, g2):\n     row_1 = g1[c1-1]\n     row_2 = g2[c2-1]\n     inter = set(row_1) & set(row_2)\n     if len(inter) == 0:\n         return "Volunteer cheated!"\n     if len(inter) > 1:\n         return "Bad magician!"\n     return str(inter.pop())\n \n if __name__ == "__main__":\n     T = int(raw_input())\n     for i in range(1,T+1):\n         c1 = int(raw_input())\n         g1 = []\n         for j in range(4):\n             g1.append(map(int, raw_input().split()))\n         c2 = int(raw_input())\n         g2 = []\n         for j in range(4):\n             g2.append(map(int, raw_input().split()))\n         print "Case #%d: %s" % (i, solve(c1,g1,c2,g2)) \n         \n     \n
rajabaz	<>	49	<>	2012_1460488_1483485.py	<>	mapping = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's',\n            'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u',\n            'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n',\n            'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a',\n            'x': 'm', 'z': 'q', 'q': 'z'}\n \n def translate(s):\n     return "".join(map(lambda a: mapping[a], s))\n \n if __name__ == "__main__":\n     T = int(raw_input())\n     for i in range(1, T+1):\n         s = translate(raw_input().strip())\n         print "Case #%d: %s" %(i, s)\n \n         \n
rajabaz	<>	49	<>	2014_2974486_5709773144064000.py	<>	def time_to_get(target, num_factories, factory_cost, factory_increase):\n     rate = 2.0\n     t = 0\n     for i in range(num_factories):\n         t += factory_cost/rate\n         rate += factory_increase\n     return t + target/rate\n     \n def solve(C,F,X):\n     min_sol = None\n     num_fact = 0\n     while True:\n         t = time_to_get(X, num_fact, C, F)\n         if min_sol is None or t < min_sol:\n             min_sol = t\n             num_fact += 1\n         else:\n             return min_sol\n \n if __name__ == "__main__":\n     T = int(raw_input())\n     for i in range(1, T+1):\n         C,F,X = map(float, raw_input().split())\n         print "Case #%d: %.07f" % (i, solve(C,F,X))\n
rajabaz	<>	49	<>	2013_2270488_2453486.py	<>	def line_status(line):\n     s = set(line)\n     if '.' in s:\n         return 'I'\n     if len(s) == 1 or (len(s) == 2 and 'T' in s):\n         player = s.pop()\n         while player == "T":\n             player = s.pop()\n         return player\n     return 'D'\n \n def grid_status(grid):\n     lines = grid\n     columns = []\n     for i in range(4):\n         columns.append([])\n         for j in range(4):\n             columns[-1].append(grid[j][i])\n     lines.extend(columns)\n     lines.append([grid[i][i] for i in range(4)])\n     lines.append([grid[i][3-i] for i in range(4)])\n     incomplete = False\n     for l in lines:\n         s = line_status(l)\n         if s == 'I':\n             incomplete = True\n         elif s in ('X', 'O'):\n             return s + " won"\n     if incomplete:\n         return "Game has not completed"\n     return "Draw"\n \n if __name__ == "__main__":\n     T = int(raw_input())\n     for i in range(1, T+1):\n         grid = [raw_input() for j in range(4)]\n         if i < T:\n             raw_input()\n         print "Case #%d: %s" % (i, grid_status(grid))\n     \n
rajabaz	<>	49	<>	2014_2974486_5690574640250880.py	<>	import sys\n \n def all_grids(R,C,M, lp=0,placed=0):\n     rem = R*C-lp\n     if M-placed >= rem:\n         if M-placed > rem:\n             return None\n         \n         res = set()\n         for i in range(lp, R*C):\n             res.add(i)\n         return [res]\n         \n     if placed == M:\n         return [set()]\n \n     res = []\n     for i in range(lp, R*C):\n         sub_sol = all_grids(R,C,M,i+1, placed+1)\n         if sub_sol is None:\n             continue\n             \n         for s in sub_sol:\n             s.add(i)\n             res.append(s)\n     return res\n \n def adj(R,C,i):\n     \n     res = []\n     left_edge = i % C == 0\n     top_edge = i // C == 0\n     right_edge = (i+1) % C == 0\n     bottom_edge = i // C == R-1\n     \n     if not left_edge:\n         res.append(i-1)\n         if not top_edge:\n             res.append(i-1-C)\n         if not bottom_edge:\n             res.append(i+C-1)\n             \n     if not right_edge:\n         res.append(i+1)\n         if not top_edge:\n             res.append(i+1-C)\n         if not bottom_edge:\n             res.append(i+1+C)\n             \n     if not bottom_edge:\n         res.append(i+C)\n     if not top_edge:\n         res.append(i-C)\n     return res\n         \n     \n     \n     \n def solution(R,C,g):\n     M = R*C\n     res = []\n     num_zeroes = 0\n     for i in range(M):\n         if i in g:\n             res.append('x')\n             continue\n         x = 0\n         for a in adj(R,C,i):\n             if a in g:\n                 x += 1\n         if x == 0:\n             num_zeroes += 1\n         res.append(x)\n         \n     for i in range(M):\n         if i in g:\n             continue\n         r = res[i]\n         if r == 0 and num_zeroes == 1:\n             continue\n         connected = False\n         for a in adj(R,C,i):\n             if res[a] == 0:\n                 connected = True\n                 break\n         if not connected:\n             return None\n     \n     return res.index(0)\n \n def transcribe(R,C, g, sol):\n     res = []\n     for i in range(R):\n         r = []\n         for j in range(C):\n             x = i*C+j\n             if x in g:\n                 r.append('*')\n             elif x == sol:\n                 r.append('c')\n             else:\n                 r.append('.')\n         res.append(r)\n     return res\n \n def printed_sol(transcript):\n     if transcript is None:\n         return "Impossible"\n     else:\n         return "\n".join("".join(row) for row in transcript)\n \n def solve(R,C,M):\n     if M == R*C-1:\n         g = []\n         for i in range(R*C-1):\n             g.append(i)\n         return transcribe(R,C, g, R*C-1)\n     \n     for g in all_grids(R,C,M):\n         sol = solution(R,C,g)\n         if sol is None:\n             continue\n         return transcribe(R,C, g, sol)\n     return None\n             \n     \n def output_grid(R,C,g):\n     for i in range(R):\n         for j in range(C):\n             if i*C+j not in g:\n                 sys.stdout.write(".")\n             else:\n                 sys.stdout.write("*")\n         sys.stdout.write("\n")\n \n if __name__ == "__main__":\n     T = int(raw_input())\n     for i in range(1,T+1):\n         R,C,M = map(int, raw_input().split())\n         print "Case #%d:" % i\n         print printed_sol(solve(R,C,M))\n
xoxie	<>	50	<>	2013_2270488_2449486.py	<>	import sys\n \n f = open( sys.argv[1] )\n t = int(f.readline())\n \n t = 1\n l = f.readline()\n while l != "":\n     n,m = [int(x) for x in l.split()]\n     lawn = [ [int(x) for x in f.readline().split()] for y in range(n)]\n \n     rowMax = [ max(x) for x in lawn ]\n     colMax = [ max([x[y] for x in lawn]) for y in range(m) ]\n \n     output = "YES"\n \n     for i in range(n):\n         for j in range(m):\n             if lawn[i][j] < rowMax[i]:\n                 if lawn[i][j] < colMax[j]:\n                     output = "NO"\n     \n     print "Case #%s: %s"%(t,output)\n     t += 1\n     l = f.readline()\n
xoxie	<>	50	<>	2012_1460488_1483488.py	<>	import sys\n from collections import deque\n \n if __name__ == "__main__":\n     f = open( "C-small-attempt0.in.txt" )\n     g = open( "output_small.txt", "w" )\n \n     numcases = int(f.readline())\n \n     caseI = 1\n     line = f.readline()\n     while line != "":\n         A,B = [int(x) for x in line.split()]\n \n         matched = [0]*(B+1)\n         pairs = deque()\n \n         for x in range(A,B+1):\n             if matched[x]:\n                 continue\n             a = str(x)\n             allcycle = deque()\n             allcycle.append(x)\n             for i in range(1,len(a)):\n                 yL,yR = a[:i],a[i:]\n                 y = int( yR+yL )\n                 if y >= A and y <= B:\n                     allcycle.append(y)\n             allcycle = list(set(allcycle))\n             allcycle.sort()\n             for y in allcycle:\n                 matched[y] = 1\n             for i in range(len(allcycle)):\n                 for j in range(i+1,len(allcycle)):\n                     pairs.append( (allcycle[i],allcycle[j]) )\n         g.write( "Case #%s: %s\n"%(caseI,len(pairs)) )\n         line = f.readline()\n         caseI += 1\n     f.close()\n     g.close()\n
xoxie	<>	50	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n if __name__ == "__main__":\n 	f = open( sys.argv[1] )\n 	int(f.readline())\n 		\n 	num = 1\n 	l = f.readline()\n 	while l != "":\n 		row1 = int(l)\n 		rows = [ f.readline() for x in range(4) ]\n 		row1 = [int(x) for x in rows[row1-1].split()]\n \n 		row2 = int(f.readline())\n 		rows = [f.readline() for x in range(4)]\n 		row2 = [int(x) for x in rows[row2-1].split()]\n \n 		result = set(row1) & set(row2)\n 		if len(result) == 1:\n 			output = str(result.pop())\n 		elif len(result) > 1:\n 			output = "Bad magician!"\n 		else:\n 			output = "Volunteer cheated!"\n \n 		print "Case #"+str(num)+": "+output\n 		num += 1\n 		l = f.readline()\n 		
xoxie	<>	50	<>	2012_1460488_1483485.py	<>	import string\n \n s1 = "ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jvyeqz"\n s2 = "our language is impossible to understand there are twenty six factorial possibilitiesso it is okay if you want to just give upaozq"\n \n mapd = string.maketrans(s1,s2)\n #print "abcdefghijklmnopqrstuvwxyz"\n #print "abcdefghijklmnopqrstuvwxyz".translate(mapd)\n \n f = open( "A-small-attempt0.in.txt" )\n g = open( "output_small.txt","w")\n \n f.readline()\n l = f.readline()\n caseI = 1\n while l != "":\n     output = l.translate(mapd)\n \n     g.write( "Case #%s: %s"%(caseI,output) )\n     l = f.readline()\n     caseI += 1\n f.close()\n g.close()\n
xoxie	<>	50	<>	2014_2974486_5709773144064000.py	<>	import sys\n import heapq\n \n f = open( sys.argv[1] )\n f.readline()\n \n numcases = 1\n input = f.readline()\n while input != "":\n 	inC,inF,inX = [float(x) for x in input.split()]\n \n 	start = (0.0,0.0,2.0)\n 	h = [start]\n 	checked =set()\n \n 	while h[0][1] < inX:\n 		x = heapq.heappop(h)\n \n 		if x in checked:\n 			continue\n 		else:\n 			checked.add(x)	\n \n 		time,numCookies,rate = x\n 		#time to win\n 		timeW = (inX - numCookies) / rate\n 		heapq.heappush( h,(time+timeW,numCookies+rate*timeW,rate) )\n \n 		#time to new farm\n 		timeF = (inC - numCookies) / rate\n 		newC = numCookies + rate*timeF\n 		newT = time + timeF\n 		heapq.heappush( h,(newT,(newC - inC),rate+inF) )\n 		heapq.heappush( h,(newT,newC,rate) )\n 		#print h\n \n 	output = "{:.7f}".format(h[0][0])\n \n 	print "Case #"+str(numcases)+": "+output\n 	input = f.readline()\n 	numcases += 1\n 	
xoxie	<>	50	<>	2013_2270488_2453486.py	<>	import sys\n \n f = open( sys.argv[1] )\n t = f.readline()\n \n t = 1\n line = f.readline()\n while line != "":\n     board = [line.strip(),\n              f.readline().strip(),\n              f.readline().strip(),\n              f.readline().strip()]\n \n     output = ""\n \n     cols = [ "".join([x[y] for x in board]) for y in range(4)]\n     diags = ["".join([x[y] for x,y in zip(board,range(4))]),\n              "".join([x[y] for x,y in zip(board,range(-1,-5,-1))])]\n     \n     rows = board + cols + diags\n \n     for row in rows:\n         x = [1 for z in row if z is "X" or z is "T"]\n         if sum(x) == 4:\n             output = "X won"\n             break\n         o = [1 for z in row if z is "O" or z is "T"]\n         if sum(o) == 4:\n             output = "O won"\n             break\n     if output == "":\n         finished = sum([ y.count(".") for y in board ])\n         if finished == 0:\n             output = "Draw"\n         else:\n             output = "Game has not completed"\n     \n     print "Case #%s: %s"%(t,output)\n     t += 1\n     line = f.readline()\n     line = f.readline()\n
xoxie	<>	50	<>	2014_2974486_5690574640250880.py	<>	import sys\n from collections import deque\n \n def makeBoardR(b):\n 	numR, numC, numMines, filledR, filledC = b\n 	q = numMines / numR\n 	r = numMines % numR\n \n 	if q <= numC-2 and r == 0:\n 		board = ["*"*(filledC + numC) for x in range (filledR)]\n 		board.append( "*"*(filledC+q)+"."*(numC-q) )\n 		board.append( "*"*(filledC+q)+"."*(numC-q-1)+"c" )\n 		output = "\n".join(board)\n 	elif numMines == numR * numC - 1:\n 		board = ["*"*(filledC + numC) for x in range (filledR+1)]\n 		board.append( "*"*(filledC+numC-1)+"c" )\n 		output = "\n".join(board)\n 	else:\n 		output = "Impossible"\n \n 	return output\n \n def makeBoardC(b):\n 	numR, numC, numMines, filledR, filledC = b\n 	q = numMines / numC\n 	r = numMines % numC\n \n 	if q <= numR-2 and r == 0:\n 		board = ["*"*(filledC+numC) for x in range(filledR+q)]\n 		for x in range( numR-1-q ):\n 			board.append( "*"*filledC + ".." )\n 		board.append( "*"*filledC + ".c" )\n 		output = "\n".join(board)\n 	elif numMines == numR * numC - 1:\n 		board = ["*"*(filledC+numC) for x in range(filledR+numR-1)]\n 		board.append( "*"*(filledC+numC-1) + "c" )\n 		output = "\n".join(board)\n 	else:\n 		output = "Impossible"\n 	return output\n \n def makeBoard(b):\n 	numR, numC, numMines, filledR, filledC = b\n 	q = numMines / (numC-2)\n 	r = numMines % (numC-2)\n \n 	board = ["*"*(numC+filledC) for x in range(filledR)]\n 	for x in range(q):\n 		board.append( "*"*(numC-2+filledC)+".." )\n 	board.append( "*"*(r+filledC)+"."*(numC-r) )\n 	for x in range(numR-q-2):\n 		board.append( "*"*filledC+"."*numC )\n 	board.append( "*"*filledC + "."*(numC-1) + "c" )\n 	return "\n".join(board)\n \n def makeBoard0(b):\n 	numR,numC,numMines,filledR,filledC = b\n 	board = ["*"*(numC+filledC) for x in range(filledR)]\n 	for x in range(numR-1):\n 		board.append( "*"*(filledC)+"."*numC )\n 	board.append( "*"*(filledC) + "."*(numC-1) + "c" )\n 	return "\n".join(board)\n \n f = open( sys.argv[1] )\n f.readline()\n \n numCase = 1\n l = f.readline()\n while l != "":\n 	numR, numC, numMines = [int(x) for x in l.split()]\n \n 	boards = deque()\n 	if numR == 1:\n 		if numC == 1 and numMines == 0:\n 			output = "c"\n 		elif numC == 1 and numMines > 0:\n 			output = "Impossible"\n 		else:\n 			output = "*"*numMines + "."*(numC-numMines-1) + "c"\n 	elif numC == 1:\n 		output = "\n".join("*"*numMines + "."*(numR-numMines-1) + "c")\n 	else:\n 		boards.append( (numR,numC,numMines,0,0) )\n 		output = "Impossible"\n \n 	while output == "Impossible" and len(boards) > 0:\n 		b = boards.popleft()\n 		#print b\n 		numR,numC,numMines,filledR,filledC = b\n 		if numMines == 0:\n 			output = makeBoard0(b)\n 			break\n \n 		if numMines >= numC and numR > 2:\n 			boards.append( (numR-1,numC,numMines-numC,filledR+1,filledC) )\n 		if numMines >= numR and numC > 2:\n 			boards.append( (numR,numC-1,numMines-numR,filledR,filledC+1) )\n \n 		if numMines <= (numR-2)*(numC-2):\n 			output = makeBoard(b)\n \n 		if numR == 2:\n 			output = makeBoardR(b)\n \n 		if numC == 2:\n 			output = makeBoardC(b)\n 		\n 	print "Case #"+str(numCase)+":\n"+output\n 	#print "Case #"+str(numCase)+": " +l+output\n 	l = f.readline()\n 	numCase += 1\n
idahojacket	<>	51	<>	2013_2270488_2463486.py	<>	import sys\n \n def is_sym( number ):\n 	num_str = str( number )\n 	num_len = len( num_str )\n 	half_len = int( num_len / 2 )\n 	end = num_str[-half_len:]\n 	rev_end = end[::-1]\n 	start = num_str[:half_len]\n 	equal = rev_end == start \n 	return equal\n \n f = open( 'palindromes.out' )\n \n numbers = [ int(x) for x in f.read().split() ]\n \n numCases = input()\n for case in range( 1, numCases + 1 ):\n 	min, max = [ int(x) for x in raw_input().split() ]\n 	count = 0\n 	for number in numbers:\n 		if min <= number and max >= number:\n 			count += 1\n \n 	print 'Case #' + str( case ) + ': ' + str( count )\n
idahojacket	<>	51	<>	2013_2270488_2449486.py	<>	import sys\n \n numCases = input()\n for case in range( 1, numCases + 1 ):\n 	sizeX, sizeY = raw_input().split()\n 	sizeX = int(sizeX)\n 	sizeY = int(sizeY)\n 	board = {}\n 	rowMax = {}\n 	colMax = {}\n 	\n 	for row in range( 0, sizeX ):\n 		row_raw = raw_input()\n 		board[ row ] = {}\n 		col = 0\n 		for value in row_raw.split():\n 			board[ row ][ col ] = int(value)\n 			colMax[ col ] = max( colMax.get(col, 0 ), board[row][col] )\n 			col += 1\n \n 		rowMax[row] = max( board[row].values() )\n 	\n 	possible = True\n 	result = 'YES'\n 	for row in range( 0, sizeX ):\n 		for col in range( 0, sizeY ):\n 			if board[ row ][ col ] != colMax[ col ] and board[ row ][ col ] != rowMax[ row ]:\n 				possible = False\n 				break\n 		if not possible:\n 			result = 'NO'\n 			break\n \n 	print 'Case #' + str( case ) + ': ' + result \n
idahojacket	<>	51	<>	2012_1460488_1483488.py	<>	import time\n \n def get_num_recycled( number_s, limit ):\n   num_digits = len(number_s)\n   num_s = number_s + number_s\n   num = int(number_s)\n   r_nums = []\n   for i in range( 1, num_digits ):\n     r_num_s = num_s[i:num_digits+i]\n     r_num = int(r_num_s)\n     if ( r_num > num and r_num <= limit ):\n       r_nums.append( r_num )\n \n   return len(set(r_nums))\n \n \n num_cases = input()\n for i in range( 1, num_cases + 1 ):\n   start, limit = raw_input().split()\n   num_recycled = 0\n   #start_t = time.clock()\n   for num in range( int(start), int(limit) + 1 ):\n      num_recycled += get_num_recycled( str(num), int(limit) )\n   #end_t = time.clock()\n   #print start_t, end_t, end_t - start_t\n   print 'Case #' + str(i) + ': ' + str( num_recycled )\n
idahojacket	<>	51	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n numCases = input()\n for case in range( 1, numCases + 1 ):\n   row1 = input()\n   grid1 = []\n   for i in range( 0, 4 ):\n     grid1.append( raw_input().split() )\n \n   cards = grid1[ row1 - 1 ]\n \n   row2 = input()\n   grid2 = []\n   for i in range( 0, 4 ):\n     grid2.append( raw_input().split() )\n \n   bad = True\n       \n   cards2 = grid2[ row2 - 1 ]\n \n   numPossibleAnswers = 0\n   for card in cards:\n     for card2 in cards2:\n       if ( card == card2 ):\n         if numPossibleAnswers == 0:\n           output = card\n         numPossibleAnswers += 1\n         break\n \n   if numPossibleAnswers == 0:\n     output = "Volunteer cheated!"\n   elif numPossibleAnswers > 1:\n     output = "Bad magician!"\n \n   print 'Case #' + str( case ) + ': ' + str( output )\n
idahojacket	<>	51	<>	2012_1460488_1483485.py	<>	import sys\n \n translation = { 'a' : 'y', 'b' : 'h', 'c' : 'e', 'd' : 's', 'e' : 'o', 'f' : 'c', 'g' : 'v', 'h' : 'x',\n 'i' : 'd', 'j' : 'u', 'k' : 'i', 'l' : 'g', 'm' : 'l', 'n' : 'b', 'o' : 'k', 'p' : 'r', 'q' : 'z', 'r' : 't',\n  's' : 'n', 't' : 'w', 'u' : 'j', 'v' : 'p', 'w' : 'f', 'x' : 'm', 'y' : 'a', 'z' : 'q', ' ' : ' ' }\n \n #words = 'ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv'\n \n numCases = input()\n for case in range( 1, numCases + 1 ):\n 	words = raw_input()\n 	output = ''\n 	\n 	for letter in words:\n 		output = output + translation[letter]\n \n 	print 'Case #' + str( case ) + ': ' + output\n
idahojacket	<>	51	<>	2014_2974486_5709773144064000.py	<>	import sys\n \n numCases = input()\n for case in range( 1, numCases + 1 ):\n   C, F, X = raw_input().split()\n   C = float(C)\n   F = float(F)\n   X = float(X)\n   time = 0.0\n   rate = 2.0\n   \n   while ( True ):\n     timeToFinish = X / rate\n     timeToFarm   = C / rate\n     farmPayoffTime = C / F\n \n     if timeToFinish < ( timeToFarm + farmPayoffTime ):\n       time += timeToFinish\n       break\n     else:\n       time += timeToFarm\n       rate += F\n \n \n   output = '{0:0.15f}'.format( time )\n \n   print 'Case #' + str( case ) + ': ' + str( output )\n
idahojacket	<>	51	<>	2013_2270488_2453486.py	<>	import sys\n \n def get_winner( row ):\n 	if row.count( 'X' ) + row.count( 'T' )  == size:\n 		return 'X won'\n 	if row.count( 'O' ) + row.count( 'T' )  == size:\n 		return 'O won'\n 	return 'Draw'\n 	\n \n numCases = input()\n for case in range( 1, numCases + 1 ):\n 	size = 4\n 	board = {}\n 	full = True\n 	winner = 'Draw'\n 	\n 	for row in range( 0, size ):\n 		row_raw = raw_input()\n 		board[row] = row_raw\n 		if '.' in row_raw:\n 			full = False\n \n 		if winner == 'Draw':\n 			winner = get_winner( row_raw )\n 	\n 	raw_input()\n \n 	if winner == 'Draw':\n 		for col in range( 0, size ):\n 			row_new = ''\n 			for row in range( 0, size ):\n 				row_new += board[row][col]\n 			winner = get_winner( row_new )\n 			if winner != 'Draw':\n 				break\n \n 	if winner == 'Draw':\n 		row_new = ''\n 		for z in range( 0, size ):\n 			row_new += board[z][z]\n 		winner = get_winner( row_new )\n 		if winner == 'Draw':\n 			row_new = ''\n 			for z in range( 0, size ):\n 				row_new += board[z][size - z - 1]\n 			winner = get_winner( row_new )\n 		\n \n 	if winner == 'Draw' and not full:\n 		winner = 'Game has not completed'\n \n 	print 'Case #' + str( case ) + ': ' + winner\n
idahojacket	<>	51	<>	2014_2974486_5690574640250880.py	<>	import sys\n \n def DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines ):\n   x = []\n   numSpaces = 0\n   numMines = 0\n \n   gridRows = max( R-2, 0 )\n   gridCols = max( C-2, 0 )\n \n   for r in xrange( 0, R ):\n     x.append( [] )\n     for c in xrange( 0, C ):\n       x[ r ].append( '.' )\n       numSpaces += 1\n \n   if gridMines > 0:\n     for r in xrange( 0, gridRows ):\n       if numMines >= gridMines:\n         break;\n       for c in xrange( 0, gridCols ):\n         x[ r ][ c ] = '*'\n         numMines += 1\n         numSpaces -= 1\n         if numMines >= gridMines:\n           break;\n \n   for r in xrange( 0, R ):\n     if sideMines <= 0:\n       break\n     for c in xrange( gridCols, C ):\n       x[ r ][ c ] = '*'\n       numMines += 1\n       numSpaces -= 1\n       sideMines -= 1\n       if sideMines <= 0:\n         break\n \n   for c in xrange( 0, C ):\n     if bottomMines <= 0:\n       break\n     for r in xrange( gridRows, R ):\n       x[ r ][ c ] = '*'\n       numMines += 1\n       numSpaces -= 1\n       bottomMines -= 1\n       if bottomMines <= 0:\n         break\n     \n   x[ R - 1][ C - 1 ] = 'c'\n   \n   if numMines != M and ( R * C ) - M != 1:\n     print "ERROR!!!!!!!!!!!!!!!!!!!!!!!!"\n     print ( R * C ) - M\n \n \n   o = ""\n \n   if Flip:\n     for c in xrange( 0, C ):\n       for r in xrange( 0, R ):\n          o += x[ r ][ c ]\n       o += '\n'\n   else:\n     for r in xrange( 0, R ):\n       for c in xrange( 0, C ):\n          o += x[ r ][ c ]\n       o += '\n'\n \n   return o[:-1] #strip the extra newline\n \n \n \n \n numCases = input()\n for case in xrange( 1, numCases + 1 ):\n   R, C, M = [int(x) for x in raw_input().split()]\n \n   Output = None\n \n   Flip = C > R\n   if Flip:\n     temp = R\n     R = C\n     C = temp\n \n   NonMines = ( R * C ) - M\n   # Special cases first\n   if ( NonMines == 0 ):\n     Output = "Impossible"\n   elif ( C == 1 ):\n     gridMines = 0\n     extraMines = M - gridMines\n     Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )\n   elif ( NonMines == 2 or  NonMines == 3 ):\n     Output = "Impossible"\n   else:\n     maxGridCols = max( 0, C - 2 )\n     maxGridRows = max( 0, R - 2 )\n     gridMines = min( M, maxGridCols * maxGridRows )\n     extraMines = M - gridMines\n     extraPairs = ( extraMines + 1 ) / 2\n     extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\n     extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\n     safeExtraPairs = extraPairsSide + extraPairsBottom\n     blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\n     blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\n     blockingPairs = blockingPairsSide + blockingPairsBottom\n     totalPairs = safeExtraPairs + blockingPairs\n \n     \n     if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\n       extraMines += 1\n       gridMines -= 1\n \n     if ( NonMines == 1 ):\n       if extraMines % 2 != 0:\n         extraMines += 1\n       blockingPairsSide += 1\n       blockingPairsBottom += 1\n     \n     if extraMines % 2 == 0:\n       sideMines = 2 * ( extraPairsSide + blockingPairsSide )\n       bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )\n       Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )\n     else:\n       Output = "Impossible"\n \n   output = "\n" + Output\n   print 'Case #' + str( case ) + ': ' + str( output )\n
fizu	<>	52	<>	2013_2270488_2463486.py	<>	import codejam\n \n possibles = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]\n \n for case in xrange(codejam.readint()):\n     A, B = map(int, codejam.readstring().split())\n     count = 0\n     for possible in possibles:\n         if A > possible:\n             continue\n \n         if B < possible:\n             break\n \n         count += 1\n \n     print "Case #%d: %d" % (case + 1, count)\n
fizu	<>	52	<>	2013_2270488_2449486.py	<>	import sys\n \n def readint():\n     return int(sys.stdin.readline())\n \n def readintarray():\n     return map(int, sys.stdin.readline().strip().split())\n \n def readpairs(start=0):\n     elems = readintarray()[start:]\n     return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n \n def readstring():\n     return sys.stdin.readline()[:-1]\n \n
fizu	<>	52	<>	2012_1460488_1483488.py	<>	from codejam import *\n \n for case in xrange(readint()):\n     A, B = readintarray()\n     res = 0\n     for i in xrange(A, B + 1):\n         for j in xrange(i + 1, B + 1):\n             ist = str(i)\n             jst = str(j)\n             if len(ist) != len(jst):\n                 continue\n \n             if ist in (jst + jst):\n                 res += 1\n \n     print "Case #%d: %d" % (case + 1, res)\n
fizu	<>	52	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n def readint():\n     return int(sys.stdin.readline())\n \n def readintarray():\n     return map(int, sys.stdin.readline().strip().split())\n \n def readpairs(start=0):\n     elems = readintarray()[start:]\n     return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n \n def readstring():\n     return sys.stdin.readline()[:-1]\n \n
fizu	<>	52	<>	2012_1460488_1483485.py	<>	from codejam import *\n from string import maketrans\n \n inp = "ejp mysljylc kd kxveddknmc re jsicpdrysi"\\n       "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"\\n       "de kr kd eoya kw aej tysr re ujdr lkgc jv zq"\n out = "our language is impossible to understand"\\n     "there are twenty six factorial possibilities"\\n     "so it is okay if you want to just give up qz"\n \n for case in xrange(readint()):\n     trantab = maketrans(inp, out)\n     line = readstring()\n     print "Case #%d: %s" % (case + 1, line.translate(trantab))\n
fizu	<>	52	<>	2014_2974486_5709773144064000.py	<>	import sys\n \n def readint():\n     return int(sys.stdin.readline())\n \n def readfloatarray():\n     return map(float, sys.stdin.readline().strip().split())\n \n def readintarray():\n     return map(int, sys.stdin.readline().strip().split())\n \n def readpairs(start=0):\n     elems = readintarray()[start:]\n     return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n \n def readstring():\n     return sys.stdin.readline()[:-1]\n \n
fizu	<>	52	<>	2013_2270488_2453486.py	<>	import sys\n \n def readint():\n     return int(sys.stdin.readline())\n \n def readintarray():\n     return map(int, sys.stdin.readline().strip().split())\n \n def readpairs(start=0):\n     elems = readintarray()[start:]\n     return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n \n def readstring():\n     return sys.stdin.readline()[:-1]\n \n
fizu	<>	52	<>	2014_2974486_5690574640250880.py	<>	import time\n import itertools\n \n from codejam import *\n \n \n directions = list(itertools.product([1, 0, -1], [1, 0, -1]))\n def count_neighbors(table, r, c):\n     cols = len(table[0])\n     rows = len(table)\n     return sum(table[r + x][c + y] == "*" for x, y in directions \n                 if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\n \n def is_valid(table):\n     cols = len(table[0])\n     rows = len(table)\n     for r in xrange(rows):\n         for c in xrange(cols):\n             has_zero = any(table[r + x][c + y] == 0 for x, y in directions \n                             if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\n             if table[r][c] != "*" and not has_zero:\n                 return False\n \n     return True\n \n \n def draw_table(table, hide=False):\n     cols = len(table[0])\n     rows = len(table)\n     ascii_table = ""\n     for r in xrange(rows):\n         for c in xrange(cols):\n             if table[r][c] != "*":\n                 ch = "c" if r == 0 and c == 0 else "."\n                 table[r][c] = count_neighbors(table, r, c) if not hide else ch\n \n             ascii_table += str(table[r][c])\n \n         ascii_table += "\n"\n \n     return ascii_table[:-1]\n \n def solve(R, C, M):\n     r = c = 0\n     current_mines = R * C\n     table = [["*"] * C for k in xrange(R)]\n     while M < current_mines:\n         if table[r][c] == '*':\n             table[r][c] = "."\n             current_mines -= 1\n \n         if current_mines > M and r + 1 < R and table[r+1][c] == "*":\n             table[r+1][c] = "."\n             current_mines -= 1\n \n         draw_table(table)\n         c += 1\n         if c >= C:\n             c = 0\n             r += 1\n \n     return table\n \n for i in xrange(readint()):\n     R, C, M = readintarray()\n \n     print "Case #%d:" % (i + 1)\n     if M < (R * C) - 1:\n         table = solve(R, C, M)\n         if is_valid(table):\n             print draw_table(table, hide=True)\n         else:\n             table = solve(C, R, M)\n             rotated = [["*"] * C for k in xrange(R)]\n             for r in xrange(R - 1, -1, -1):\n                 for c in xrange(C):\n                     rotated[R - r - 1][c] = table[c][r]\n \n             print draw_table(rotated, hide=True) if is_valid(rotated) else "Impossible"\n \n     elif M == R * C:\n         print "Impossible"\n \n     else:\n         table = [["*"] * C for k in xrange(R)]\n         table[0][0] = '.'\n         print draw_table(table, hide=True)\n
yoba	<>	53	<>	2013_2270488_2463486.py	<>	def sqrt(x, ge):\n     if x == 1:\n         return 1\n     sx = x >> 1\n     step = sx >> 1\n \n     while step:\n         if sx ** 2 >= x:\n             sx = sx - step\n         else:\n             sx = sx + step\n         step = step >> 1\n \n     if ge:\n         while not sx ** 2 < x:\n             sx = sx - 1\n         while not sx ** 2 >= x:\n             sx = sx + 1\n     else:\n         while not sx ** 2 > x:\n             sx = sx + 1\n         while not sx ** 2 <= x:\n             sx = sx - 1\n \n     return sx\n \n \n def get_start_pali(a):\n     s = str(a)\n     ls = len(s)\n     if ls == 1:\n         return s, True\n     elif ls & 1:\n         return s[:ls >> 1 + 1], True\n     else:\n         return s[:ls >> 1], False\n \n \n def get_next_pali(p, m):\n     if len(p) == p.count("9"):\n         if m:\n             return "1" + "0" * (len(p) - 1), False\n         else:\n             return "1" + "0" * len(p), True\n     else:\n         return str(int(p) + 1), m\n \n \n def pali_to_num(p, m):\n     if m:\n         return int(p + p[-2::-1])\n     else:\n         return int(p + p[::-1])\n \n \n def is_pali(a):\n     s = str(a)\n     hls = len(s) >> 1\n     return s[:hls] == s[:-hls - 1:-1]\n \n for i in range(int(input())):\n     a, b = tuple(map(int, input().split()))\n     sqa, sqb = sqrt(a, True), sqrt(b, False)\n \n     p, m = get_start_pali(sqa)\n     while pali_to_num(p, m) < sqa:\n         p, m = get_next_pali(p, m)\n \n     count = 0\n \n     while True:\n         curr = pali_to_num(p, m)\n         if curr > sqb:\n             break\n         if is_pali(curr ** 2):\n             count = count + 1\n         p, m = get_next_pali(p, m)\n \n     print("Case #{}: {}".format(i + 1, count))\n
yoba	<>	53	<>	2013_2270488_2449486.py	<>	from itertools import chain\n \n \n for i in range(int(input())):\n     n, m = tuple(map(int, input().split()))\n     l = dict(chain.from_iterable(map(lambda j: zip(zip([j] * m, range(m)), map(int, input().split())), range(n))))\n     ans = "YES"\n \n     while len(l):\n         ly, lx = min(l, key=l.get)\n         lowest = l[(ly, lx)]\n \n         if all(map(lambda j: l.get((ly, j), lowest) == lowest, range(m))):\n             for j in range(m):\n                 l.pop((ly, j), None)\n \n         elif all(map(lambda j: l.get((j, lx), lowest) == lowest, range(n))):\n             for j in range(n):\n                 l.pop((j, lx), None)\n \n         else:\n             ans = "NO"\n             break\n \n     print("Case #{}: {}".format(i + 1, ans))\n
yoba	<>	53	<>	2012_1460488_1483488.py	<>	for case in range(int(input())):\n     a, b = tuple(map(int, input().split()))\n     result = 0\n     ast, bst = str(a), str(b)\n     for x in range(a, b + 1):\n         xst = str(x)\n         added = list()\n         for j in range(len(xst)):\n             xstr = xst[j:] + xst[:j]\n             if xstr < ast or xstr > bst:\n                 continue\n             elif xst < xstr and xstr not in added:\n                 added.append(xstr)\n                 result += 1\n     print("Case #{}: {}".format(case + 1, result))\n
yoba	<>	53	<>	2014_2974486_5756407898963968.py	<>	def read_case():\n \n     answer = int(input())\n     lines = tuple(map(lambda _: set(str.split(input())), range(4)))\n     return lines[answer - 1]\n \n \n for i in range(int(input())):\n \n     intersection = read_case() & read_case()\n     count = len(intersection)\n     if count == 1:\n \n         answer = intersection.pop()\n \n     elif count > 1:\n \n         answer = "Bad magician!"\n \n     elif count < 1:\n \n         answer = "Volunteer cheated!"\n \n     print(str.format("Case #{}: {}", i + 1, answer))\n
yoba	<>	53	<>	2012_1460488_1483485.py	<>	for case in range(int(input())):\n     a, b = tuple(map(int, input().split()))\n     result = 0\n     ast, bst = str(a), str(b)\n     for x in range(a, b + 1):\n         xst = str(x)\n         added = list()\n         for j in range(len(xst)):\n             xstr = xst[j:] + xst[:j]\n             if xstr < ast or xstr > bst:\n                 continue\n             elif xst < xstr and xstr not in added:\n                 added.append(xstr)\n                 result += 1\n     print("Case #{}: {}".format(case + 1, result))\n
yoba	<>	53	<>	2014_2974486_5709773144064000.py	<>	for i in range(int(input())):\n \n     c, f, x = tuple(map(float, str.split(input())))\n \n     base_time = 0.0\n     base_rate = 2.0\n     farms_count = 0\n     best_time = None\n \n     current_time = base_time + x / (base_rate + farms_count * f)\n \n     while best_time is None or best_time > current_time:\n \n         best_time = current_time\n         base_time += c / (base_rate + farms_count * f)\n         farms_count += 1\n \n         current_time = base_time + x / (base_rate + farms_count * f)\n \n     print(str.format("Case #{}: {}", i + 1, best_time))\n
yoba	<>	53	<>	2013_2270488_2453486.py	<>	def yoba(s, ch):\n     lines = [True] * 10\n     for i in range(4):\n         for j in range(4):\n             lines[j] = lines[j] and (s[i][j] in (ch, "T"))\n             lines[j + 4] = lines[j + 4] and (s[j][i] in (ch, "T"))\n         lines[8] = lines[8] and (s[i][i] in (ch, "T"))\n         lines[9] = lines[9] and (s[3 - i][i] in (ch, "T"))\n     return any(lines)\n \n for i in range(int(input())):\n     s = tuple(map(lambda _: input(), range(4)))\n \n     if yoba(s, "X"):\n         ans = "X won"\n     elif yoba(s, "O"):\n         ans = "O won"\n     elif "." not in "".join(s):\n         ans = "Draw"\n     else:\n         ans = "Game has not completed"\n \n     input()\n     print("Case #{}: {}".format(i + 1, ans))\n
yoba	<>	53	<>	2014_2974486_5690574640250880.py	<>	import itertools\n \n \n '''\n ...\n ...\n ...\n ...\n ...\n '''\n \n for i in range(int(input())):\n \n     r, c, m = tuple(map(int, str.split(input())))\n     count = r * c - m\n     field = dict(map(lambda c: (c, "*"), itertools.product(range(c), range(r))))\n     answer = "Impossible"\n \n     if m == 0:\n \n         answer = field\n \n     elif 1 in (r, c):\n \n         for p in itertools.islice(itertools.product(range(c), range(r)), count):\n \n             field[p] = "."\n \n         answer = field\n \n     elif count in (0, 2, 3, 5, 7):\n \n         pass\n \n     elif count == 1:\n \n         answer = field\n \n     elif count // 2 < c or count == c * 2 + 1:\n \n         if count % 2 != 0:\n \n             tail = 3\n             ncount = count - 3\n \n         else:\n \n             tail = 0\n             ncount = count\n \n         for x in range(ncount // 2):\n \n             field[(x, 0)] = field[(x, 1)] = "."\n \n         for x in range(tail):\n \n             field[(x, 2)] = "."\n \n         answer = field\n \n     elif not (c == 2 and count % c == 1):\n \n         for x in range(c):\n \n             field[(x, 0)] = field[(x, 1)] = "."\n \n         count -= 2 * c\n         tail = 0\n         if count % c == 1:\n \n             tail = 2\n             count -= 1\n \n         y = 2\n         while count > 0:\n \n             rx = min(count, c)\n             for x in range(rx):\n \n                 field[(x, y)] = "."\n \n             count -= rx\n             y += 1\n \n         for x in range(tail):\n \n             field[(x, y)] = "."\n \n         answer = field\n \n     field[(0, 0)] = "c"\n     print(str.format("Case #{}:", i + 1))\n     if isinstance(answer, dict):\n \n         for y in range(r):\n \n             print(str.join("", map(lambda x: field[(x, y)], range(c))))\n \n     else:\n \n         print(answer)\n
nlse	<>	54	<>	2013_2270488_2463486.py	<>	#!/usr/bin/python\n \n import sys\n import math\n import copy\n \n f = open(sys.argv[1],'r')\n \n num = int(f.readline())\n \n def pal(x):\n     l = list(str(x))\n     l2 = copy.copy(l)\n     l2.reverse()\n     return l == l2\n \n for i in range(num):\n     count = 0\n     line = f.readline()\n     a,b = line.split()\n     a = int(a)\n     b = int(b)\n     ma = int(math.sqrt(a))\n     mb = int(math.sqrt(b))+1\n     #print a,b\n     for j in range(ma,mb+1):\n         q = j*j\n         if q < a or q > b:\n             continue\n         #print i*i\n         if pal(j) and pal(q):\n             #print i,q\n             count += 1\n     print 'Case #{}:'.format(i+1), count\n
nlse	<>	54	<>	2013_2270488_2449486.py	<>	#!/usr/bin/python\n \n import sys\n import math\n import copy\n import operator\n \n f = open(sys.argv[1],'r')\n \n num = int(f.readline())\n \n for i in range(num):\n     l = f.readline()\n     n,m = l.split()\n     n = int(n)\n     m = int(m)\n     lawn = []\n     seen = []\n     for j in range(n):\n         l = f.readline()\n         lawn.append([int(x) for x in l.split()])\n         seen.append([False]*m)\n     #print lawn\n     l = []\n     for j in range(n):\n         for k in range(m):\n             l.append((lawn[j][k], (j,k)))\n     l.sort(key=operator.itemgetter(0))\n     #print l\n     ok = True\n     for x in l:\n         if seen[x[1][0]][x[1][1]]:\n             continue\n         row = True\n         for j in range(n):\n             if not (seen[j][x[1][1]] or lawn[j][x[1][1]] <= lawn[x[1][0]][x[1][1]]):\n                 row = False\n                 break\n         if(row):\n             for j in range(n):\n                 seen[j][x[1][1]] = True\n             continue\n         col = True\n         for j in range(m):\n             if not (seen[x[1][0]][j] or lawn[x[1][0]][j] <= lawn[x[1][0]][x[1][1]]):\n                 col = False\n                 break\n         if(col):\n             for j in range(m):\n                 seen[x[1][0]][j] = True\n             continue\n         ok = False\n         break\n     if ok:\n         print 'Case #{}: YES'.format(i+1)\n     else:\n         print 'Case #{}: NO'.format(i+1)\n
nlse	<>	54	<>	2012_1460488_1483488.py	<>	#!/usr/bin/python\n \n import sys\n import re\n import math\n \n def permute(x, d):\n     perm = []\n     for i in range(1,d):\n         n = x / 10**i\n         r = x % 10**i\n         #print 'p', i, n, r\n         if r >= 10**(i-1):\n             perm.append(r * 10**(d-i) + n)\n     perm = list(set(perm))\n     while x in perm:\n         perm.remove(x)\n     return perm\n \n f = open(sys.argv[1],'r')\n \n num = int(f.readline())\n \n for i in range(num):\n     n1, n2 = [int(x) for x in f.readline().split()]\n     d = int(math.floor(math.log10(n1))) + 1\n     rec = 0\n     for j in range(n1,n2+1):\n         p = permute(j, d)\n         #print j,p\n         rec += sum([1 for x in p if x >= n1 and x <= n2])\n         #print rec\n     print 'Case #{}:'.format(i+1), rec/2\n
nlse	<>	54	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/python\n \n import sys\n import re\n import math\n import string\n \n f = open(sys.argv[1],'r')\n \n num = int(f.readline())\n \n for i in range(num):\n     q1 = int(f.readline())\n     for j in range(4):\n         if j+1 == q1:\n             line1 = f.readline()\n         else:\n             f.readline()\n     q2 = int(f.readline())\n     for j in range(4):\n         if j+1 == q2:\n             line2 = f.readline()\n         else:\n             f.readline()\n     line1 = [int(x) for x in line1.split()]\n     line2 = [int(x) for x in line2.split()]\n     count = 0\n     for x in line1:\n         if x in line2:\n             count += 1\n             y = x\n     if count == 0:\n         print 'Case #{}: Volunteer cheated!'.format(i+1)\n     elif count == 1:\n         print 'Case #{}: {}'.format(i+1, y)\n     else:\n         print 'Case #{}: Bad magician!'.format(i+1)\n
nlse	<>	54	<>	2012_1460488_1483485.py	<>	#!/usr/bin/python\n \n import sys\n import re\n import math\n import string\n \n f = open(sys.argv[1],'r')\n \n num = int(f.readline())\n \n for i in range(num):\n     s = f.readline().strip()\n     t = s.translate(string.maketrans("yeqjpmslckdxvnribtahwfougz",\n         "aozurlngeismpbtdhwyxfckjvq"))\n     #print 'Case #{}:'.format(i+1), s\n     print 'Case #{}:'.format(i+1), t\n
nlse	<>	54	<>	2013_2270488_2453486.py	<>	#!/usr/bin/python\n \n import sys\n import re\n import math\n import string\n \n f = open(sys.argv[1],'r')\n \n num = int(f.readline())\n \n def check(x, mat):\n     for i in range(4):\n         row = True\n         col = True\n         for j in range(4):\n             if not (mat[i][j] == x or mat[i][j] == 'T'):\n                 row = False\n             if not (mat[j][i] == x or mat[j][i] == 'T'):\n                 col = False\n         if row or col:\n             return True\n     diag1 = True\n     diag2 = True\n     for i in range(4):\n         if not (mat[i][i] == x or mat[i][i] == 'T'):\n             diag1 = False\n         if not (mat[3-i][i] == x or mat[3-i][i] == 'T'):\n             diag2 = False\n     if diag1 or diag2:\n         return True\n     return False\n \n def fin(mat):\n     for i in range(4):\n         for j in range(4):\n             if mat[i][j] == '.':\n                 return False\n     return True\n \n for i in range(num):\n     mat = []\n     for j in range(4):\n         mat.append(list(f.readline().strip()))\n     f.readline()\n     #print mat\n     #print check('X', mat), check('O', mat)\n     if check('X', mat):\n         print 'Case #{}: X won'.format(i+1)\n     elif check('O', mat):\n         print 'Case #{}: O won'.format(i+1)\n     elif fin(mat):\n         print 'Case #{}: Draw'.format(i+1)\n     else:\n         print 'Case #{}: Game has not completed'.format(i+1)\n
nlse	<>	54	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/python\n \n import sys\n import re\n import math\n import string\n \n f = open(sys.argv[1],'r')\n \n num = int(f.readline())\n \n def count(z, r, c):\n     return len(z_and_nei(z,r,c))\n \n def nei(z, r, c):\n     s = z_and_nei(z, r, c)\n     s -= set(z)\n     return s\n \n def z_and_nei(z, r, c):\n     s = set()\n     for x in z:\n         s.add(x)\n         s.add((x[0]-1,x[1]-1))\n         s.add((x[0]-1,x[1]))\n         s.add((x[0]-1,x[1]+1))\n         s.add((x[0],x[1]-1))\n         s.add((x[0],x[1]+1))\n         s.add((x[0]+1,x[1]-1))\n         s.add((x[0]+1,x[1]))\n         s.add((x[0]+1,x[1]+1))\n     o = set()\n     for x in s:\n         if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\n             o.add(x)\n     s-=o\n     return s\n \n def find_config(z, r, c, t):\n     if count(z,r,c) == t:\n         return z\n     if count(z,r,c) > t:\n         return []\n     n = nei(z,r,c)\n     for x in n:\n         z.append(x)\n         if find_config(z,r,c,t) != []:\n             return z\n         z.pop()\n     return []\n \n for i in range(num):\n     print 'Case #{}:'.format(i+1)\n     r, c, m = [int(x) for x in f.readline().split()]\n     if r*c-m == 1:\n         print 'c' + '*'*(c-1)\n         for i in range(r-1):\n             print '*'*c\n     else:\n         z = find_config([(0,0)], c, r, c*r-m)\n         if z == []:\n             print "Impossible"\n         else:\n             s = z_and_nei(z, c, r)\n             for j in range(r):\n                 for k in range(c):\n                     if j == 0 and k == 0:\n                         print 'c',\n                     elif (k,j) in s:\n                         print '.',\n                     else:\n                         print '*',\n                 print\n \n \n
raphaelj	<>	55	<>	2013_2270488_2463486.py	<>	import Data.Int\n import Data.List.Split\n import Text.Printf\n \n main = do\n     interact (unlines . map showCase . zip [1..] . map (solve . interval) . tail . lines)\n \n   where\n     interval :: String -> (Int64, Int64)\n     interval l =\n         let [a, b] = map read $ splitOn " " l\n         in (a, b)\n \n     showCase :: (Int64, Int) -> String\n     showCase (i, r) = printf "Case #%d: %d" i r\n \n solve :: (Int64, Int64) -> Int\n solve (a, b) =\n     length $ takeWhile (<= b) $ dropWhile (< a) [ sq\n         | x <- [0..], palindrome x, let sq = x * x, palindrome sq\n         ]\n   where\n     square x = x * x\n     start = truncate $ sqrt $ double a\n \n -- | Returns True if s is a palindrome.\n palindrome s =\n     let s' = show s\n     in s' == reverse s'\n \n double :: Int64 -> Double\n double = fromIntegral
raphaelj	<>	55	<>	2013_2270488_2449486.py	<>	import Control.Applicative\n import Data.Array.Unboxed\n import Data.List.Split\n import Text.Printf\n \n main = do\n     interact (unlines . map showCase . zip [1..] . go . tail . lines)\n \n   where\n     go :: [String] -> [Bool]\n     go []     = []\n     go (l:ls) =\n         let [h, w] = map read $ splitOn " " l\n             (ls', ls'') = splitAt h ls\n             table = map (map read . splitOn " ") ls'\n         in solve h w table : go ls''\n \n     showCase :: (Int, Bool) -> String\n     showCase (i, r) = printf "Case #%d: %s" i (if r then "YES" else "NO")\n \n solve :: Int -> Int -> [[Int]] -> Bool\n solve h w table = and [ cell >= (maxLgn ! y) || cell >= (maxCol ! x)\n     | y <- [0..h-1], x <- [0..w-1], let cell = arr ! (y, x)\n     ]\n   where\n     arr :: Array (Int, Int) Int\n     arr = listArray ((0, 0), (h-1, w-1)) $ concat table\n \n     maxLgn, maxCol :: Array Int Int\n     maxLgn = listArray (0, h-1) $ [ maximum [ arr ! (y, x) | x <- [0..w-1] ]\n         | y <- [0..h-1]\n         ]\n \n     maxCol = listArray (0, w-1) $ [ maximum [ arr ! (y, x) | y <- [0..h-1] ]\n         | x <- [0..w-1]\n         ]
raphaelj	<>	55	<>	2012_1460488_1483488.py	<>	import Data.List\n import Data.Maybe\n \n import Debug.Trace\n \n main = interact (unlines . map showCase . zip [1..] . tail . lines)\n   where\n     showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t\n \n solve = show . solve'' . map read . words\n solve' [a, b] = length [ () | \n         x <- [a..b]\n     , let digits = nDigits x, let lastY = min b (10^digits - 1)\n     , y <- [x+1..lastY]\n     , isRecycled x y digits\n     ]\n     \n solve'' [a, b] = sum [ nRecycled | \n       x <- [a..b]\n     , let digits = nDigits x\n     , let nRecycled = length [ () |\n               y <- nub $ sort $ moves x digits\n             , y <= b, y > x\n             ]\n     ]\n \n isRecycled :: Int -> Int -> Int -> Bool\n isRecycled n m digits = any (== n) (m : moves m digits)\n \n nDigits :: Int -> Int\n nDigits n = nDigits' n 0\n   where\n     nDigits' 0 acc = acc\n     nDigits' x acc = nDigits' (x `div` 10) (acc+1)\n \n moves :: Int -> Int -> [Int]\n moves n digits = [ dep n d digits | d <- [1..digits-1] ]\n dep x d digits = x * 10^d `rem` (10^digits) + x `div` 10^(digits - d)
raphaelj	<>	55	<>	2014_2974486_5756407898963968.py	<>	import Data.Int\n import Data.List\n import qualified Data.Foldable as F\n import Text.Printf\n \n import Debug.Trace\n \n data Test = Test {\n       choix1 :: Int\n     , table1 :: [[Int]]\n     , choix2 :: Int\n     , table2 :: [[Int]]\n     } deriving Show\n \n data Solution = Bonne Int | BadMag | Cheat\n \n instance Show Solution where\n     show (Bonne i) = show i\n     show BadMag    = "Bad magician!"\n     show Cheat     = "Volunteer cheated!"\n \n main = do\n     interact (unlines . map showCase . zip [1..] . map (resoudre) . goTest . tail . lines)\n \n   where\n     goTest [] = []\n     goTest ls =\n         let (c1, t1, ls')  = goTable ls\n             (c2, t2, ls'') = goTable ls'\n         in Test c1 t1 c2 t2 : goTest ls''\n \n     goTable (n:ls) =\n         let c = read n\n             (t, ls') = splitAt 4 ls\n         in (c, map goLigne t, ls')\n \n     goLigne = map read . words\n \n     showCase :: (Int, Solution) -> String\n     showCase (i, s) = printf "Case #%d: %s" i (show s)\n \n resoudre :: Test -> Solution\n resoudre Test {..} =\n     let choisis1 = table1 !! (choix1 - 1)\n         choisis2 = table2 !! (choix2 - 1)\n         communs  = filter (`elem` choisis1) choisis2\n     in case communs of\n         [x]     -> Bonne x\n         (_:_:_) -> BadMag\n         []      -> Cheat\n
raphaelj	<>	55	<>	2012_1460488_1483485.py	<>	import Data.List\n import Data.Maybe\n \n alphabet = [(' ',' '),('a','y'),('b','h'),('c','e'),('d','s'),('e','o') \n     ,('f','c'),('g','v'),('h','x'),('i','d'),('j','u'),('k','i'),('l','g')\n     ,('m','l'),('n','b'),('o','k'),('p','r'),('q','z'),('r','t'),('s','n')\n     ,('t','w'),('u','j'),('v','p'),('w','f'),('x','m'),('y','a'),('z', 'q')\n     ]\n \n main = interact (unlines . map showCase . zip [1..] . tail . lines)\n   where\n     showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t\n \n solve = map (fromJust . flip lookup alphabet)
raphaelj	<>	55	<>	2014_2974486_5709773144064000.py	<>	import Data.Int\n import Data.List\n import qualified Data.Foldable as F\n import Text.Printf\n \n import Debug.Trace\n \n data Test = Test {\n       cout     :: Double\n     , bonus    :: Double\n     , objectif :: Double\n     } deriving Show\n \n newtype Solution = Solution { temps :: Double }\n \n instance Show Solution where\n     show (Solution t) = show t\n \n main = do\n     interact (unlines . map showCase . zip [1..] . map resoudre . goTest . tail . lines)\n \n   where\n     goTest [] = []\n     goTest (l:ls) =\n         let [c, f, x] = map read $ words l\n         in Test c f x : goTest ls\n \n     showCase :: (Int, Solution) -> String\n     showCase (i, s) = printf "Case #%d: %s" i (show s)\n \n resoudre :: Test -> Solution\n resoudre Test {..} | premierAchat > sansAchat = Solution sansAchat\n                    | otherwise                = go premierAchat 2\n   where\n     go t prod | tempsAvecAchat >= tempsSansAchat = Solution (t + tempsSansAchat)\n               | otherwise                        =\n                   go (t + delaiProchainAchat) prod'\n       where\n         prod' = prod + bonus\n \n         tempsAvecAchat = objectif / prod'\n         tempsSansAchat = (objectif - cout) / prod\n \n         delaiProchainAchat = cout / prod'\n \n     premierAchat = cout / 2\n     sansAchat    = objectif / 2\n
raphaelj	<>	55	<>	2013_2270488_2453486.py	<>	t = int(input())\n \n def win(lines, player):\n     for y in range(0, 4):\n         count = 0\n         for x in range(0, 4):\n             if lines[y][x] in [player, 'T']:\n                 count += 1\n                 if count >= 4:\n                     return True\n             else:\n                 break\n \n     for x in range(0, 4):\n         count = 0\n         for y in range(0, 4):\n             if lines[y][x] in [player, 'T']:\n                 count += 1\n                 if count >= 4:\n                     return True\n             else:\n                 break\n \n     count = 0\n     for i in range(0, 4):\n         if lines[i][i] in [player, 'T']:\n             count += 1\n             if count >= 4:\n                 return True\n \n     count = 0\n     for i in range(0, 4):\n         x = 3 - i\n         if lines[i][x] in [player, 'T']:\n             count += 1\n             if count >= 4:\n                 return True\n \n     return False\n \n for i in range(0, t):\n     lines = []\n     for j in range(0, 4):\n         lines.append(input())\n     input()\n \n     if win(lines, 'X'):\n         sol = "X won"\n     elif win(lines, 'O'):\n         sol = "O won"\n     else:\n         void = False\n         for y in range(0, 4):\n             if any(c == '.' for c in lines[y]):\n                 void = True\n                 break\n \n         if void:\n             sol = "Game has not completed"\n         else:\n             sol = "Draw"\n \n \n     print ("Case #"+str(i+1)+": "+sol)
raphaelj	<>	55	<>	2014_2974486_5690574640250880.py	<>	t = int(input())\n \n VIDE = 0\n MINE = 1\n CURSEUR = 2\n \n def test_position(arr, lignes, cols, y, x):\n     def voisinage_libre(arr, y, x):\n         if y > 0:\n             if x > 0 and arr[y-1][x-1] == MINE:\n                 return False\n             if arr[y-1][x] == MINE:\n                 return False\n             if x < cols - 1 and arr[y-1][x+1] == MINE:\n                 return False\n \n         if x > 0 and arr[y][x-1] == MINE:\n             return False\n         if x < cols - 1 and arr[y][x+1] == MINE:\n             return False\n \n         if y < lignes - 1:\n             if x > 0 and arr[y+1][x-1] == MINE:\n                 return False\n             if arr[y+1][x] == MINE:\n                 return False\n             if x < cols - 1 and arr[y+1][x+1] == MINE:\n                 return False\n \n         return True\n \n     def remplissage_rec(arr, y, x):\n         if x < 0 or y < 0 or x >= cols or y >= lignes:\n             return\n         elif arr[y][x] == CURSEUR:\n             return\n \n         arr[y][x] = CURSEUR\n         if voisinage_libre(arr, y, x):\n             remplissage_rec(arr, y-1, x-1)\n             remplissage_rec(arr, y-1, x)\n             remplissage_rec(arr, y-1, x+1)\n             remplissage_rec(arr, y, x-1)\n             remplissage_rec(arr, y, x+1)\n             remplissage_rec(arr, y+1, x-1)\n             remplissage_rec(arr, y+1, x)\n             remplissage_rec(arr, y+1, x+1)\n \n     if arr[y][x] != VIDE:\n         return False\n \n     # Copie arr and arr2\n     arr2 = [ [ arr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]\n \n     remplissage_rec(arr2, y, x)\n \n     for i in range(0, lignes):\n         for j in range(0, cols):\n             if arr2[i][j] == VIDE:\n                 return False\n     return True\n \n def dfs(arr, lignes, cols, mines, y, x):\n     cases_restantes = (cols - x) + ((lignes - y) * cols)\n \n     if cases_restantes < mines:\n         return None\n     elif mines <= 0:\n         for i in range(0, lignes):\n             for j in range(0, cols):\n                 if test_position(arr, lignes, cols, i, j):\n                     return (i, j)\n     elif x >= cols:\n         return dfs(arr, lignes, cols, mines, y+1, 0)\n     elif y >= lignes:\n         return None\n     else:\n         res = dfs(arr, lignes, cols, mines, y, x+1)\n         if res != None:\n             return res\n \n         arr[y][x] = MINE\n         res = dfs(arr, lignes, cols, mines-1, y, x+1)\n         if res != None:\n             return res\n \n         arr[y][x] = VIDE\n         return None\n \n for i in range(0, t):\n     ligne  = input().split(" ")\n     lignes = int(ligne[0])\n     cols   = int(ligne[1])\n     mines  = int(ligne[2])\n \n     arr = [ [VIDE] * cols for _ in range(0, lignes) ]\n \n     res = dfs(arr, lignes, cols, mines, 0, 0)\n \n     print ("Case #"+str(i+1)+":")\n \n     if res == None:\n         print ("Impossible")\n     else:\n         (y, x) = res\n \n         for i in range(0, lignes):\n             for j in range(0, cols):\n                 if i == y and j == x:\n                     print('c', end='')\n                 elif arr[i][j] == VIDE:\n                     print('.', end='')\n                 else:\n                     print('*', end='')\n \n             print('', end='\n')\n
enterr	<>	56	<>	2013_2270488_2463486.py	<>	#\n # Google Code Jam 2013\n # Round 0: C. Fair and Square\n # submission by EnTerr\n #\n \n '''\n Limits\n \n Small dataset       1 <= T <= 100, 1 <= A <= B <= 1000.\n First large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.\n Second large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.\n \n Sample\n *** Input \n 3\n 1 4\n 10 120\n 100 1000\n  	\n *** Output \n Case #1: 2\n Case #2: 0\n Case #3: 2\n \n \n '''\n \n #import psyco\n #psyco.full()\n \n import sys\n from time import clock\n \n inf = open(sys.argv[1])\n def input(): return inf.readline().strip()\n \n # "cheat" from http://www.worldofnumbers.com/allsquar.htm\n # "Exhaustive list of Palindromic Squares up to length 31"\n # roots of palindromic squares\n pal_sqr_roots = '''1 \n 2 \n 3 \n 11 \n 22 \n 26 \n 101 \n 111 \n 121 \n 202 \n 212 \n 264 \n 307 \n 836 \n 1001 \n 1111 \n 2002 \n 2285 \n 2636 \n 10001 \n 10101 \n 10201 \n 11011 \n 11111 \n 11211 \n 20002 \n 20102 \n 22865 \n 24846 \n 30693 \n 100001 \n 101101 \n 110011 \n 111111 \n 200002 \n 798644 \n 1000001 \n 1001001 \n 1002001 \n 1010101 \n 1011101 \n 1012101 \n 1042151 \n 1100011 \n 1101011 \n 1102011 \n 1109111 \n 1110111 \n 1111111 \n 1270869 \n 2000002 \n 2001002 \n 2012748 \n 2294675 \n 3069307 \n 10000001 \n 10011001 \n 10100101 \n 10111101 \n 11000011 \n 11011011 \n 11100111 \n 11111111 \n 11129361 \n 12028229 \n 12866669 \n 20000002 \n 30001253 \n 64030648 \n 100000001 \n 100010001 \n 100020001 \n 100101001 \n 100111001 \n 100121001 \n 101000101 \n 101010101 \n 101020101 \n 101101101 \n 101111101 \n 110000011 \n 110010011 \n 110020011 \n 110091011 \n 110101011 \n 110111011 \n 111000111 \n 111010111 \n 111091111 \n 111101111 \n 111111111 \n 200000002 \n 200010002 \n 306930693 \n 1000000001 \n 1000110001 \n 1001001001 \n 1001111001 \n 1010000101 \n 1010110101 \n 1011001101 \n 1011111101 \n 1100000011 \n 1100110011 \n 1101001011 \n 1101111011 \n 1110000111 \n 1110110111 \n 1111001111 \n 2000000002 \n 2062386218 \n 2481623254 \n 10000000001 \n 10000100001 \n 10000200001 \n 10001010001 \n 10001110001 \n 10001210001 \n 10010001001 \n 10010101001 \n 10010201001 \n 10011011001 \n 10011111001 \n 10100000101 \n 10100100101 \n 10100200101 \n 10101010101 \n 10101110101 \n 10106064399 \n 10109901101 \n 10110001101 \n 10110101101 \n 10110911101 \n 10111011101 \n 10111111101 \n 10207355549 \n 11000000011 \n 11000100011 \n 11000200011 \n 11000910011 \n 11001010011 \n 11001110011 \n 11010001011 \n 11010101011 \n 11010911011 \n 11011011011 \n 11011111011 \n 11100000111 \n 11100100111 \n 11100910111 \n 11101010111 \n 11101110111 \n 11110001111 \n 11110101111 \n 13579355059 \n 20000000002 \n 20000100002 \n 22865150135 \n 30101273647 \n 30693069307 \n 83163115486 \n 100000000001 \n 100001100001 \n 100010010001 \n 100011110001 \n 100100001001 \n 100101101001 \n 100110011001 \n 100111111001 \n 101000000101 \n 101001100101 \n 101010010101 \n 101011110101 \n 101100001101 \n 101101101101 \n 101110011101 \n 101116809851 \n 110000000011 \n 110001100011 \n 110010010011 \n 110011110011 \n 110100001011 \n 110101101011 \n 110110011011 \n 111000000111 \n 111001100111 \n 111010010111 \n 111100001111 \n 111283619361 \n 112247658961 \n 128817084669 \n 200000000002 \n 1000000000001 \n 1000001000001 \n 1000002000001 \n 1000010100001 \n 1000011100001 \n 1000012100001 \n 1000100010001 \n 1000101010001 \n 1000102010001 \n 1000110110001 \n 1000111110001 \n 1001000001001 \n 1001001001001 \n 1001002001001 \n 1001010101001 \n 1001011101001 \n 1001100011001 \n 1001101011001 \n 1001110111001 \n 1001111111001 \n 1010000000101 \n 1010001000101 \n 1010002000101 \n 1010010100101 \n 1010011100101 \n 1010099010101 \n 1010100010101 \n 1010101010101 \n 1010109110101 \n 1010110110101 \n 1010111110101 \n 1011000001101 \n 1011001001101 \n 1011010101101 \n 1011011101101 \n 1011099011101 \n 1011100011101 \n 1011101011101 \n 1100000000011 \n 1100001000011 \n 1100002000011 \n 1100009100011 \n 1100010100011 \n 1100011100011 \n 1100100010011 \n 1100101010011 \n 1100110110011 \n 1100111110011 \n 1101000001011 \n 1101001001011 \n 1101009101011 \n 1101010101011 \n 1101011101011 \n 1101100011011 \n 1101101011011 \n 1110000000111 \n 1110001000111 \n 1110009100111 \n 1110010100111 \n 1110011100111 \n 1110100010111 \n 1110101010111 \n 1111000001111 \n 1111001001111 \n 1349465117841 \n 2000000000002 \n 2000001000002 \n 2149099165358 \n 2634812417864 \n 3069306930693 \n 6360832925898 \n 10000000000001 \n 10000011000001 \n 10000100100001 \n 10000111100001 \n 10001000010001 \n 10001011010001 \n 10001100110001 \n 10001111110001 \n 10010000001001 \n 10010011001001 \n 10010100101001 \n 10010111101001 \n 10011000011001 \n 10011011011001 \n 10011100111001 \n 10100000000101 \n 10100011000101 \n 10100100100101 \n 10100111100101 \n 10101000010101 \n 10101011010101 \n 10101100110101 \n 10110000001101 \n 10110011001101 \n 10110100101101 \n 10111000011101 \n 11000000000011 \n 11000011000011 \n 11000100100011 \n 11000111100011 \n 11001000010011 \n 11001011010011 \n 11001100110011 \n 11010000001011 \n 11010011001011 \n 11010100101011 \n 11011000011011 \n 11100000000111 \n 11100011000111 \n 11100100100111 \n 11101000010111 \n 11110000001111 \n 20000000000002 \n 30395080190573 \n 69800670077028 \n 98275825201587 \n 100000000000001 \n 100000010000001 \n 100000020000001 \n 100000101000001 \n 100000111000001 \n 100000121000001 \n 100001000100001 \n 100001010100001 \n 100001020100001 \n 100001101100001 \n 100001111100001 \n 100010000010001 \n 100010010010001 \n 100010020010001 \n 100010101010001 \n 100010111010001 \n 100011000110001 \n 100011010110001 \n 100011101110001 \n 100011111110001 \n 100100000001001 \n 100100010001001 \n 100100020001001 \n 100100101001001 \n 100100111001001 \n 100101000101001 \n 100101010101001 \n 100101101101001 \n 100101111101001 \n 100109990011001 \n 100110000011001 \n 100110010011001 \n 100110091011001 \n 100110101011001 \n 100110111011001 \n 100110990111001 \n 100111000111001 \n 100111010111001 \n 101000000000101 \n 101000010000101 \n 101000020000101 \n 101000101000101 \n 101000111000101 \n 101000990100101 \n 101001000100101 \n 101001010100101 \n 101001091100101 \n 101001101100101 \n 101001111100101 \n 101010000010101 \n 101010010010101 \n 101010101010101 \n 101010111010101 \n 101010990110101 \n 101011000110101 \n 101011010110101 \n 101100000001101 \n 101100010001101 \n 101100101001101 \n 101100111001101 \n 101101000101101 \n 101101010101101 \n 101110000011101 \n 101110010011101 \n 110000000000011 \n 110000010000011 \n 110000020000011 \n 110000091000011 \n 110000101000011 \n 110000111000011 \n 110001000100011 \n 110001010100011 \n 110001101100011 \n 110001111100011 \n 110010000010011 \n 110010010010011 \n 110010091010011 \n 110010101010011 \n 110010111010011 \n 110011000110011 \n 110011010110011 \n 110100000001011 \n 110100010001011 \n 110100101001011 \n 110100111001011 \n 110101000101011 \n 110101010101011 \n 110110000011011 \n 110110010011011 \n 111000000000111 \n 111000010000111 \n 111000091000111 \n 111000101000111 \n 111000111000111 \n 111001000100111 \n 111001010100111 \n 111010000010111 \n 111010010010111 \n 111100000001111 \n 111100010001111 \n 129610990752569 \n 200000000000002 \n 200000010000002 \n 210786628549538 \n 314155324482867 \n 1000000000000000 \n 1000000110000000 \n 1000001001000000 \n 1000001111000000 \n 1000010000100000 \n 1000010110100000 \n 1000011001100000 \n 1000011111100000 \n 1000100000010000 \n 1000100110010000 \n 1000101001010000 \n 1000101111010000 \n 1000110000110000 \n 1000110110110000 \n 1000111001110000 \n 1001000000001000 \n 1001000110001000 \n 1001001001001000 \n 1001001111001000 \n 1001010000101000 \n 1001010110101000 \n 1001011001101000 \n 1001100000011000 \n 1001100110011000 \n 1001101001011000 \n 1001110000111000 \n 1010000000000100 \n 1010000110000100 \n 1010001001000100 \n 1010001111000100 \n 1010010000100100 \n 1010010110100100 \n 1010011001100100 \n 1010100000010100 \n 1010100110010100 \n 1010101001010100 \n 1010110000110100 \n 1011000000001100 \n 1011000110001100 \n 1011001001001100 \n 1011010000101100 \n 1011100000011100 \n 1100000000000010 \n 1100000110000010 \n 1100001001000010 \n 1100001111000010 \n 1100010000100010 \n 1100010110100010 \n 1100011001100010 \n 1100100000010010 \n 1100100110010010 \n 1100101001010010 \n 1100110000110010 \n 1101000000001010 \n 1101000110001010 \n 1101001001001010 \n 1101010000101010 \n 1101100000011010 \n 1110000000000110 \n 1110000110000110 \n 1110001001000110 \n 1110010000100110 \n 1110100000010110 \n 1111000000001110 \n 2000000000000000 \n 2201019508986470 \n 2564053868197730 \n 3066446727654240 \n 3107974295870660 \n 3138199296186060'''\n pal_sqr_roots = map(int, pal_sqr_roots.split())\n \n # see also http://web.archive.org/web/20020614225321/http://www.geocities.com/williamrexmarshall/math/palsq.html\n # http://www.worldofnumbers.com/square.htm\n # http://mathforum.org/library/drmath/view/51510.html\n \n \n def is_palindrome(n):\n     return str(n)[::-1] == str(n)\n \n palindromic_roots = [x for x in pal_sqr_roots if is_palindrome(x)]\n \n fair_and_square = [x*x for x in palindromic_roots]\n \n \n def get_num_fair_and_square(a, b):\n     return len([x for x in fair_and_square if a <= x <= b])\n \n for caseNo in range(1, int(input())+1):\n     #tm = clock()\n     a,b = map(int, input().split())\n     print 'Case #%d:' % caseNo, get_num_fair_and_square(a, b)\n     #print >>sys.stderr, caseNo, clock() - tm\n \n
enterr	<>	56	<>	2013_2270488_2449486.py	<>	#\n # Google Code Jam 2013\n # Round 0: B. Lawnmower\n # submission by EnTerr\n #\n \n '''\n Limits\n \n 1 <= T <= 100.\n \n Small dataset   1 <= N, M <= 10. 1 <= a[i,j] <= 2.\n Large dataset   1 <= N, M <= 100. 1 <= a[i,j] <= 100.\n \n Sample\n \n *** Input \n 3\n 3 3\n 2 1 2\n 1 1 1\n 2 1 2\n 5 5\n 2 2 2 2 2\n 2 1 1 1 2\n 2 1 2 1 2\n 2 1 1 1 2\n 2 2 2 2 2\n 1 3\n 1 2 1\n \n *** Output \n Case #1: YES\n Case #2: NO\n Case #3: YES\n \n '''\n \n #import psyco\n #psyco.full()\n \n import sys\n from time import clock\n \n inf = open(sys.argv[1])\n def input(): return inf.readline().strip()\n \n \n def check_lawn(board):\n     n = len(board)\n     m = len(board[0])\n     hmax = map(max, board)\n     vmax = map(max, zip(*board))\n     for i in range(n):\n         for j in range(m):\n             if board[i][j] < min(hmax[i], vmax[j]):\n                 return 'NO'\n     return 'YES'\n \n for caseNo in range(1, int(input())+1):\n     #tm = clock()\n     n,m = map(int, input().split())\n     board = [map(int, input().split()) for _ in range(n)]\n     print 'Case #%d:' % caseNo, check_lawn(board)\n     #print >>sys.stderr, caseNo, clock() - tm\n \n
enterr	<>	56	<>	2014_2974486_5756407898963968.py	<>	#\n # Google Code Jam 2014\n # Roaund 0: A. Magic Trick\n # submission by EnTerr\n #\n \n '''\n ---Input \n 3\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 3\n 1 2 5 4\n 3 11 6 15\n 9 10 7 12\n 13 14 8 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 3\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n \n ---Output \n Case #1: 7\n Case #2: Bad magician!\n Case #3: Volunteer cheated!\n '''\n \n \n \n import sys\n from time import clock\n \n \n f = open(sys.argv[1])\n def input(): return f.readline().strip();\n \n        \n \n #clk = clock()\n \n for caseNo in xrange(1, int(input())+1):\n     #first time\n     row_no = int(input())\n     for i in 1,2,3,4:\n         row = input()\n         if i == row_no:\n             nums = set(row.split())\n             \n     #second time\n     row_no = int(input())\n     for i in 1,2,3,4:\n         row = input()\n         if i == row_no:\n             nums &= set(row.split())\n \n #    print >>sys.stderr, caseNo\n     if not nums:\n         res = 'Volunteer cheated!'\n     elif len(nums) > 1:\n         res = 'Bad magician!'        \n     else:\n         res = nums.pop()\n     print 'Case #%d:' % caseNo, res\n     \n #print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n \n
enterr	<>	56	<>	2012_1460488_1483485.py	<>	#\n # Google Code Jam 2012\n # Round 0: A. Speaking in Tongues\n # submission by EnTerr\n #\n \n '''\n Limits: 1 = T = 30. G contains at most 100 characters.\n None of the text is guaranteed to be valid English.\n Sample\n \n Input\n 3\n ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv\n \n Output\n Case #1: our language is impossible to understand\n Case #2: there are twenty six factorial possibilities\n Case #3: so it is okay if you want to just give up\n '''\n \n #import psyco\n #psyco.full()\n \n import sys\n #from time import clock\n \n inf = open(sys.argv[1])\n def input(): return inf.readline().strip()\n \n knownPairs = [\n     ('zq', 'qz'),\n     ('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'),\n     ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'),\n     ('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')\n ]\n \n xlat = [chr(0) for ch in range(256)]\n for crypt, plain in knownPairs:\n     for a,b in zip(crypt, plain):\n         xlat[ord(a)] = b\n for i in range(26):\n     xlat[ord('A')+i] = chr(ord(xlat[ord('a')+i]) - ord('a') + ord('A'))\n xlat = ''.join(xlat)\n \n for caseNo in range(1, int(input())+1):\n     #print >>sys.stderr, caseNo\n     print 'Case #%d:' % caseNo, input().translate(xlat)\n \n \n
enterr	<>	56	<>	2014_2974486_5709773144064000.py	<>	#\n # Google Code Jam 2014\n # Roaund 0: B. Cookie Clicker Alpha\n # submission by EnTerr\n #\n \n '''\n Input\n The first line of the input gives the number of test cases, T. T lines follow. \n Each line contains three space-separated real-valued numbers: C, F and X.\n \n Output\n For each test case, output one line containing "Case #x: y", where x is \n the test case number (starting from 1) and y is the minimum number of seconds \n it takes before you can have X delicious cookies.\n \n We recommend outputting y to 7 decimal places, but it is not required. \n y will be considered correct if it is close enough to the correct number: \n within an absolute or relative error of 10^-6. \n \n Limits\n 1 <= T <= 100.\n \n Small dataset\n 1 <= C <= 500.\n 1 <= F <= 4.\n 1 <= X <= 2000.\n \n Large dataset\n 1 <= C <= 10000.\n 1 <= F <= 100.\n 1 <= X <= 100000.\n \n \n ---Input  \n 4\n 30.0 1.0 2.0\n 30.0 2.0 100.0\n 30.50000 3.14159 1999.19990\n 500.0 4.0 2000.0\n \n ---Output \n Case #1: 1.0000000\n Case #2: 39.1666667\n Case #3: 63.9680013\n Case #4: 526.1904762\n \n '''\n \n \n \n import sys\n from time import clock\n \n \n f = open(sys.argv[1])\n def input(): return f.readline().strip();\n \n def bestTime(C, F, X):\n     #C= cost of cookie farm, ck\n     #F= farm production, ck/sec\n     #X= goal, ck\n     v = 2   #speed of production, cookies/sec\n     t = 0   #total time of production, sec\n     while True:\n         tX = X / v          #time to reach goal at current speed\n         tC = C / v          #time to buy farm\n         tXc = X / (v + F)   #time to reach goal after adding farm\n         if tX <= tC + tXc:\n             #no more farms\n             break\n         #we are buying farm\n         t += tC\n         v += F\n     #finishing at current speed\n     t += tX\n     return t\n \n #clk = clock()\n \n for caseNo in xrange(1, int(input())+1):\n     C, F, X = map(float, input().split())\n     #print >>sys.stderr, caseNo\n     print 'Case #%d: %.7f' % (caseNo, bestTime(C, F, X))\n     \n #print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n \n \n
enterr	<>	56	<>	2013_2270488_2453486.py	<>	#\n # Google Code Jam 2013\n # Round 0: A. Tic-Tac-Toe-Tomek\n # submission by EnTerr\n #\n \n '''\n Limits\n The game board provided will represent a valid state that was reached\n through play of the game Tic-Tac-Toe-Tomek as described above.\n \n Small dataset   1 = T = 10.\n Large dataset   1 = T = 1000.\n \n *** Sample Input \n 6\n XXXT\n ....\n OO..\n ....\n \n XOXT\n XXOO\n OXOX\n XXOO\n \n XOX.\n OX..\n ....\n ....\n \n OOXX\n OXXX\n OX.T\n O..O\n \n XXXO\n ..O.\n .O..\n T...\n \n OXXX\n XO..\n ..O.\n ...O\n \n ***Output \n Case #1: X won\n Case #2: Draw\n Case #3: Game has not completed\n Case #4: O won\n Case #5: O won\n Case #6: O won\n \n '''\n \n #import psyco\n #psyco.full()\n \n import sys\n from time import clock\n \n inf = open(sys.argv[1])\n def input(): return inf.readline().strip()\n \n import re\n \n # compile "just in case" not to rely on `re` caching\n # check horizontal or vertical or diagonal type1 or diag. type2\n x_ptrn = re.compile('X{4}|X(.{4}X){3}|X(.{3}X){3}|X(.{5}X){3}')\n o_ptrn = re.compile('O{4}|O(.{4}O){3}|O(.{3}O){3}|O(.{5}O){3}')\n \n \n def check_game_status(board):\n     if x_ptrn.search(board.replace('T','X')):\n         return 'X won'\n     elif o_ptrn.search(board.replace('T','O')):\n         return 'O won'\n     elif '.' not in board:\n         return 'Draw'\n     else:\n         return 'Game has not completed'\n \n for caseNo in range(1, int(input())+1):\n     #tm = clock()\n     board = '|'.join(input() for _ in range(4))\n     input() # skip empty line\n     print 'Case #%d:' % caseNo, check_game_status(board)\n     #print >>sys.stderr, caseNo, clock() - tm\n \n
enterr	<>	56	<>	2014_2974486_5690574640250880.py	<>	#\n # Google Code Jam 2014\n # Roaund 0: C. Minesweeper Master\n # submission by EnTerr\n #\n \n '''\n Input\n The first line of the input gives the number of test cases, T. T lines follow. \n Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\n \n Output\n For each test case, output a line containing "Case #x:", where x is the test case number. \n On the following R lines, output the board configuration with C characters per line, \n using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \n and 'c' to represent the clicked cell. If there is no possible configuration, \n then instead of the grid, output a line with "Impossible" instead. \n If there are multiple possible configurations, output any one of them.\n \n Limits\n 0 <= M < R * C.\n \n Small dataset\n 1 <= T <= 230.\n 1 <= R, C <= 5.\n \n Large dataset\n 1 <= T <= 140.\n 1 <= R, C <= 50.\n \n Sample\n ---Input \n 5\n 5 5 23\n 3 1 1\n 2 2 1\n 4 7 3\n 10 10 82\n \n ---Output \n Case #1:\n Impossible\n Case #2:\n c\n .\n *\n Case #3:\n Impossible\n Case #4:\n ......*\n .c....*\n .......\n ..*....\n Case #5:\n **********\n **********\n **********\n ****....**\n ***.....**\n ***.c...**\n ***....***\n **********\n **********\n **********\n \n \n '''\n \n import sys\n from time import clock\n \n f = open(sys.argv[1])\n def input(): return f.readline().strip();\n \n from itertools import product, combinations\n def genBoards(R, C, M):\n     #extra empty/boundary row added at the end (also reached as the one before [0])\n     #each row has extra empty/boundary element at the end\n     for mines in combinations( product(range(R), range(C)), M):\n         board = [ ['.'] * C + [''] for _ in range(R) ]\n         for row, col in mines:\n             board[row][col] = '*'\n         yield board + [[''] * (C+1)]\n     pass\n \n def oneClickSolution(R, C, M):\n     for bd in genBoards(R, C, M):\n         #count number of mines\n         minTile = 10\n         for r in range(R):\n             for c in range(C):\n                 if bd[r][c] == '.':\n                     n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\n                     bd[r][c] = `n`\n                     if n <= minTile:\n                         minTile = n\n                         minR, minC = r, c\n         if minTile < 10:\n             #use flood from a 0 square, does it reach all 0-s?\n             queue = [ (minR, minC) ]\n             nOpen = 0\n             while queue:\n                 r,c = queue.pop()\n                 if bd[r][c] == '0':\n                     for i in -1,0,1:\n                         for j in -1,0,1:\n                             if i or j: # we don't add the one we popped back\n                                 queue.append( (r+i, c+j) )\n                 if bd[r][c] not in '.*':\n                     bd[r][c] = '.'\n                     nOpen += 1\n             if M + nOpen == R*C:\n                 bd[minR][minC] = 'c'\n                 return '\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\n \n     return 'Impossible'\n \n \n clk = clock()\n \n for caseNo in xrange(1, int(input())+1):\n     R, C, M = map(int, input().split())\n     print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\n     print 'Case #%d:' % caseNo  \n     print oneClickSolution(R, C, M)\n     \n print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n \n
lookingfor	<>	57	<>	2013_2270488_2463486.py	<>	from bisect import bisect_right\n \n def generateTable(N):\n     msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]\n     nums = revnums = [1, 2]\n \n     digsums = [1, 4]\n \n     for i in xrange(2, N+1):\n         a, b, d = [], [], []\n         p = 10**(i-1)\n         for j in xrange(len(nums)):\n             for k in xrange(3):\n                 n, rn, ds = 10*nums[j] + k, revnums[j] + k*p, digsums[j] + k*k\n                 if ds < 5:\n                     a.append(n)\n                     b.append(rn)\n                     d.append(ds)\n                     msq.append(10*p*n + rn) # even length\n                     if i == N:\n                         continue\n                     for l in xrange(3): # odd length\n                         if 2*ds + l*l < 10:\n                             msq.append(100*p*n + 10*p*l + rn)\n         nums, revnums, digsums = a, b, d\n \n     msq.sort()\n     return msq\n \n def getNum(A, B):\n     return bisect_right(tab2, B) - bisect_right(tab2, A-1)\n \n N = 10\n tab = generateTable(N)\n tab2 = map(lambda n: n**2, tab)\n \n T = int(raw_input())\n for z in xrange(T):\n     A, B = map(int, raw_input().split())\n     print "Case #%d: %d" % (z+1, getNum(A, B))\n
lookingfor	<>	57	<>	2013_2270488_2449486.py	<>	T = int(raw_input())\n \n def readMatrix(nlines):\n     return [map(int, raw_input().split(' ')) for i in xrange(nlines)]\n \n def transpose(A):\n     return map(lambda i: map(lambda line: line[i], A), xrange(len(A[0])))\n \n for z in xrange(T):\n     M, N = map(int, raw_input().split(' '))\n     A = readMatrix(M)\n     b = map(max, A)\n     c = map(max, transpose(A))\n     fl = True\n     for i in xrange(M):\n         for j in xrange(N):\n             if A[i][j] != min(b[i], c[j]):\n                 fl = False\n     print "Case #%d: %s" % (z+1, "YES" if fl else "NO")
lookingfor	<>	57	<>	2012_1460488_1483488.py	<>	T = int(raw_input())\n \n def isRecycle(x, y, d):\n     k = 10**(d-1)\n     for i in xrange(ndigits):\n         y = k*(y%10) + y/10\n         if x == y:\n             return True\n     return False\n \n for z in xrange(1, T+1):\n     res = 0\n     A, B = map(int, raw_input().split())\n     ndigits = len(str(A))\n     for i in xrange(A, B):\n         for j in xrange(i+1, B+1):\n            if isRecycle(i, j, ndigits):\n                res += 1\n     print "Case #%d:" % z, res
lookingfor	<>	57	<>	2014_2974486_5756407898963968.py	<>	T = int(raw_input())\n \n def readSq(n):\n     res = []\n     for i in xrange(n):\n         res.append(set(map(int, raw_input().split())))\n     return res\n \n def solve():\n     a1 = int(raw_input())\n     s1 = readSq(4)\n     a2 = int(raw_input())\n     s2 = readSq(4)\n     ans = s1[a1-1] & s2[a2-1]\n     if len(ans) == 0:\n         return "Volunteer cheated!"\n     if len(ans) > 1:\n         return "Bad magician!"\n     return str(list(ans)[0])\n \n for z in xrange(T):\n     print "Case #%d: %s" % (z+1, solve())\n
lookingfor	<>	57	<>	2012_1460488_1483485.py	<>	inps = ["ejp mysljylc kd kxveddknmc re jsicpdrysi", "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd", "de kr kd eoya kw aej tysr re ujdr lkgc jv"]\n outs = ["our language is impossible to understand","there are twenty six factorial possibilities", "so it is okay if you want to just give up"]\n \n d = {'z':'q', 'q':'z'}\n \n for i in xrange(3):\n     inp, out = inps[i], outs[i]\n     for j in xrange(len(inp)):\n         d[inp[j]] = out[j]\n \n n = int(raw_input())\n for i in xrange(n):\n     s = raw_input()\n     print "Case #%d:" % (i+1), "".join(map(lambda c: d[c], s))
lookingfor	<>	57	<>	2014_2974486_5709773144064000.py	<>	T = int(raw_input())\n \n def solve(C, F, X):\n     best = x/2\n     buildTime, speed = 0, 2\n     while True:\n         buildTime += C/speed\n         if buildTime > best:\n             break\n         speed += F\n         best = min(best, buildTime + X/speed)\n     return best\n \n for z in xrange(T):\n     c, f, x = map(float, raw_input().split())\n     print "Case #%d: %.7f" % (z+1, solve(c, f, x))
lookingfor	<>	57	<>	2013_2270488_2453486.py	<>	n = int(raw_input())\n \n d = {'X':2, 'O': 0, 'T':1, '.':-10}\n \n def readGame():\n     return [map(lambda c:d[c], raw_input().strip()) for i in xrange(4)]\n \n def check(game):\n     s = []\n     for i in xrange(4): # horizontal\n         s.append(sum(game[i]))\n     for i in xrange(4): # vertical\n         s.append(sum(map(lambda li: li[i], game)))\n     d1 = d2 = 0 # diagonal\n     for i in xrange(4):\n         d1 += game[i][i]\n         d2 += game[i][3-i]\n     s.append(d1)\n     s.append(d2)\n     if max(s) >= 7:\n         return "X won";\n     gr0 = filter(lambda n: n >= 0, s)\n     if len(gr0) > 0 and min(gr0) <= 1:\n         return "O won"\n     if min(s) < 0:\n         return "Game has not completed"\n     return "Draw"\n \n for i in xrange(n):\n     game = readGame()\n     if i + 1 < n:\n         raw_input()\n \n     print "Case #%d: %s" % (i+1, check(game))
lookingfor	<>	57	<>	2014_2974486_5690574640250880.py	<>	from cStringIO import StringIO\n \n T = int(raw_input())\n \n def generate(R, C, a, sw):\n     if sw:\n         R, C = C, R\n     res = [['*']*C for i in xrange(R)]\n     for i in xrange(len(a)):\n         for j in xrange(a[i]):\n             if sw:\n                 res[j][i] = '.'\n             else:\n                 res[i][j] = '.'\n     res[0][0] = 'c'\n     return str(res)[2:-2].replace(' ', '').replace("'",'').replace('[', '').replace('],','\n').replace(',', '')\n \n \n def solveEq(k, s, x1):\n     if 2*(x1 + k - 2) > s or k*x1 < s:\n         return None\n     r = [0]*k\n     r[0] = r[1] = x1\n     s -= 2*x1\n     for i in xrange(k-2, 0, -1):\n         t = min(x1, s - 2*i + 2)\n         r[k-i] = t\n         s -= t\n     return r\n \n def solve(R, C, M):\n     S = R*C\n     nm = S - M\n     if R == 1 or C == 1:\n         if R == 1:\n             return '*'*M + '.'*(S-M-1) + 'c'\n         else:\n             return '*\n'*M + '.\n'*(S-M-1) + 'c'\n     else:\n         sw = False\n         if R > C:\n             R, C = C, R\n             sw = True\n         if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):\n             return "Impossible"\n         if nm == 1:\n             return generate(R, C, [1], sw)\n         for k in xrange(2, R+1):\n             for x1 in xrange(2, C+1):\n                 r = solveEq(k, nm, x1)\n                 if r != None:\n                     return generate(R, C, r, sw)\n         return "Something wrong"\n \n for z in xrange(T):\n     c, f, x = map(int, raw_input().split())\n     print "Case #%d:\n%s" % (z+1, solve(c, f, x))
pavlovic	<>	58	<>	2013_2270488_2463486.py	<>	def is_palindrome(s):\n 	if s == '':\n 		return True\n 	else:\n 		if (ord(s[0]) - ord(s[len(s)-1])) == 0:\n 			return is_palindrome(s[1 : len(s) - 1])\n 		else:\n 			return False\n \n all_fair_and_square = set()\n for i in range(10000):\n 	orig = str(i)\n 	rev = orig[::-1]\n \n 	palin = orig + rev\n 	intpalin = int(palin)\n 	if is_palindrome(str(intpalin * intpalin)):\n 		all_fair_and_square.add(intpalin * intpalin)\n \n 	palin = orig[:-1] + rev\n 	intpalin = int(palin)\n 	if is_palindrome(str(intpalin * intpalin)):\n 		all_fair_and_square.add(intpalin * intpalin)\n 	\n \n import sys\n \n t = int(sys.stdin.readline().strip())\n for ii in range(t):\n 	line = sys.stdin.readline().strip().split()\n 	a = int(line[0])\n 	b = int(line[1])\n 	count = 0\n 	for num in all_fair_and_square:\n 		if (num >= a) and (num <= b):\n 			count += 1\n 	print "Case #" + str(ii + 1) + ": " + str(count)\n \n
pavlovic	<>	58	<>	2013_2270488_2449486.py	<>	import sys\n \n direction = [[0, 1], [1, 0]]\n \n t = int(sys.stdin.readline())\n for i in range(t):\n 	line = sys.stdin.readline().strip().split()\n 	n = int(line[0])\n 	m = int(line[1])\n 	field = []\n 	for j in range(n):\n 		line = [int(x) for x in sys.stdin.readline().strip().split()]\n 		field.append(line)\n \n 	possibleLawn = True\n 	for j in range(n):\n 		for k in range(m):\n 			for direct in range(2):\n 				coords = [j if (direct == 0) else 0, 0 if (direct == 0) else k]\n 				possibleField = True\n 				while (coords[0] < n) and (coords[1] < m):\n 					if field[j][k] < field[coords[0]][coords[1]]:\n 						possibleField = False\n 					coords[0] += direction[direct][0]\n 					coords[1] += direction[direct][1]\n \n 				if possibleField:\n 					break\n 			else:\n 				possibleLawn = False\n \n 	print "Case #" + str(i + 1) + ": " + ('YES' if possibleLawn else 'NO')\n \n
pavlovic	<>	58	<>	2012_1460488_1483488.py	<>	import sys\n \n n = int(sys.stdin.readline())\n for i in range(n):\n 	inputline = sys.stdin.readline().strip()\n 	inputparams = inputline.split()\n \n 	a = int(inputparams[0])\n 	b = int(inputparams[1])\n \n 	k = a\n 	ndigits = 0\n 	while k > 0:\n 		k /= 10\n 		ndigits += 1\n \n 	cnt = 0\n \n 	dic = {}\n \n 	for n1digits in range(1, ndigits / 2 + 1):\n 		n2digits = ndigits - n1digits\n \n 		for n1 in range(a / (10 ** n2digits), b / (10 ** n2digits) + 1):\n 			for n2 in range(a / (10 ** n1digits), b / (10 ** n1digits) + 1):\n \n 				k1 = n1 * 10 ** n2digits + n2\n 				k2 = n2 * 10 ** n1digits + n1\n \n 				if (n1digits == n2digits) and (n1 >= n2):\n 					continue\n \n 				if (k1 != k2) and (k1 >=a) and (k2 >= a) and (k1 <= b) and (k2 <= b):\n \n 					if min(k1, k2) not in dic:\n 						dic[min(k1, k2)] = set()\n \n 					if max(k1, k2) not in dic[min(k1, k2)]:\n 						dic[min(k1, k2)].add(max(k1, k2))\n 						cnt += 1\n \n 	print "Case #%d: %d" % (i + 1, cnt)	\n \n
pavlovic	<>	58	<>	2014_2974486_5756407898963968.py	<>	import sys\n \n def read_row():\n 	a = int(sys.stdin.readline().strip())\n 	for j in range(a - 1):\n 		sys.stdin.readline()\n 	read_set = set(sys.stdin.readline().strip().split(" "))\n 	for j in range(5 - a - 1):\n 		sys.stdin.readline()\n 		\n 	return read_set\n \n \n t = int(sys.stdin.readline().strip())\n \n for i in range(t):\n 	print "Case #" + str(i + 1) + ":",\n \n 	set1 = read_row()\n 	set2 = read_row()\n 	\n 	intersect = set1.intersection(set2)\n 	\n 	if 1 == len(intersect):\n 		print intersect.pop()\n 	elif 0 == len(intersect):\n 		print "Volunteer cheated!"\n 	else:\n 		print "Bad magician!"\n
pavlovic	<>	58	<>	2012_1460488_1483485.py	<>	import sys\n \n inputmapping  = "abcdefghijklmnopqrstuvwxyz "\n outputmapping = "ynficwlbkuomxsevzpdrjgthaq "\n \n n = int(sys.stdin.readline())\n for i in range(n):\n 	outputstring = sys.stdin.readline().strip()\n 	inputstring = ""\n 	for j in range(len(outputstring)):\n 		outputletter = outputstring[j]\n 		k = 0\n 		while outputmapping[k] != outputletter:\n 			k += 1\n \n 		inputstring += inputmapping[k]\n \n 	print "Case #%d: %s" % (i + 1, inputstring)	\n \n 		\n
pavlovic	<>	58	<>	2014_2974486_5709773144064000.py	<>	import sys\n import math\n \n def calculate_time(c, f, x, num_farms):\n 	t = 0.0\n 	rate = 2.0\n 	for i in range(num_farms):\n 		t += c / rate\n 		rate += f\n 		\n 	t += x / rate\n 	return t	\n \n t = int(sys.stdin.readline().strip())\n \n for i in range(t):\n 	print "Case #" + str(i + 1) + ":",\n \n 	(c, f, x) = [float(i) for i in sys.stdin.readline().strip().split()]\n 	\n 	if x <= c:\n 		t = calculate_time(c, f, x, 0)\n 	else:\n 		opt_rate = f * (x - c) / c\n 		num_farms = (opt_rate - 2) / f\n 		t1 = calculate_time(c, f, x, int(math.floor(num_farms)))\n 		t2 = calculate_time(c, f, x, int(math.ceil(num_farms)))\n \n 		t = min(t1, t2)\n 		\n 	print "%.7f" % t\n
pavlovic	<>	58	<>	2013_2270488_2453486.py	<>	import sys\n \n t = int(sys.stdin.readline())\n for i in range(t):\n 	board = []\n 	for j in range(4):\n 		board.append(sys.stdin.readline().strip())\n \n 	sys.stdin.readline()\n \n 	winX = False\n 	winO = False\n 	gameEnded = True\n \n 	for j in range(4):\n 		xCount = 0\n 		oCount = 0\n 		tCount = 0\n 		for k in range(4):\n 			if board[j][k] == 'X':\n 				xCount += 1\n 			if board[j][k] == 'O':\n 				oCount += 1\n 			if board[j][k] == 'T':\n 				tCount += 1\n \n 		if xCount + tCount == 4:\n 			winX = True\n 		\n 		if oCount + tCount == 4:\n 			winO = True\n \n 		if xCount + oCount + tCount < 4:\n 			gameEnded = False\n \n 	for k in range(4):\n 		xCount = 0\n 		oCount = 0\n 		tCount = 0\n 		for j in range(4):\n 			if board[j][k] == 'X':\n 				xCount += 1\n 			if board[j][k] == 'O':\n 				oCount += 1\n 			if board[j][k] == 'T':\n 				tCount += 1\n \n 		if xCount + tCount == 4:\n 			winX = True\n 		\n 		if oCount + tCount == 4:\n 			winO = True\n \n 		if xCount + oCount + tCount < 4:\n 			gameEnded = False\n \n 	xCount = 0\n 	oCount = 0\n 	tCount = 0\n 	for j in range(4):\n 		if board[j][j] == 'X':\n 			xCount += 1\n 		if board[j][j] == 'O':\n 			oCount += 1\n 		if board[j][j] == 'T':\n 			tCount += 1\n \n 	if xCount + tCount == 4:\n 		winX = True\n 	\n 	if oCount + tCount == 4:\n 		winO = True\n \n 	if xCount + oCount + tCount < 4:\n 		gameEnded = False\n \n \n 	xCount = 0\n 	oCount = 0\n 	tCount = 0\n 	for j in range(4):\n 		if board[3 - j][j] == 'X':\n 			xCount += 1\n 		if board[3 - j][j] == 'O':\n 			oCount += 1\n 		if board[3 - j][j] == 'T':\n 			tCount += 1\n \n 	if xCount + tCount == 4:\n 		winX = True\n 	\n 	if oCount + tCount == 4:\n 		winO = True\n \n 	if xCount + oCount + tCount < 4:\n 		gameEnded = False\n \n 	print "Case #" + str(i + 1) + ": ",\n 	if winX:\n 		print "X won"\n 	elif winO:\n 		print "O won"\n 	elif gameEnded:\n 		print "Draw"\n 	else:\n 		print "Game has not completed"\n
joegunrok	<>	59	<>	2013_2270488_2463486.py	<>	import sys\n \n lines = sys.stdin.readlines()\n def parseCase(lines):\n     dims = map(int,lines[0].split(" "))\n     return 1, dims\n \n def getCases(lines):\n     i =0\n     while i < len(lines):\n         lines_used, case = parseCase(lines[i:])\n         i += lines_used\n         yield case\n \n import math\n \n fands = []\n phash = {1:True}\n def isPalindrome(p):\n     return p in phash\n \n def test(p):\n     square = p**.5\n     return square == int(square) and isPalindrome(int(square))\n \n for i in range(1,10**5):\n     if i > 9:\n         small_p = int(i * 10 ** int(math.log(i,10)) + int("".join(reversed(str(i)[:-1]))))\n     else: small_p = i\n     phash[small_p]= test(small_p)\n     if phash[small_p]: fands.append(small_p)\n     big_p = int(i * 10 ** int(math.log(i,10)+1) + int("".join(reversed(str(i)))))\n     phash[big_p] = test(big_p)\n     if phash[big_p]: fands.append(big_p)\n cNum =0\n \n for c in getCases(lines[1:]):\n     cNum += 1\n     answer = []\n     for i in fands:\n         if i < c[0]: continue\n         if i > c[1]: break\n         if phash[i]: answer.append(i)\n     answer = str(len(answer))\n     print "Case #%d: %s" % ( cNum, answer)\n \n \n     \n \n \n
joegunrok	<>	59	<>	2013_2270488_2449486.py	<>	import sys\n \n lines = sys.stdin.readlines()\n def parseCase(lines):\n     dims = map(int,lines[0].split(" "))\n     return dims[0]+1, [map(int,l.split(" ")) for l in lines[1:dims[0]+1]]\n \n \n def getCases(lines):\n     i =0\n     while i < len(lines):\n         lines_used, case = parseCase(lines[i:])\n         i += lines_used\n         yield case\n \n         \n cNum =0\n for c in getCases(lines[1:]):\n     cNum += 1\n     answer = None\n     for i in range(len(c)):\n         if answer: break\n         for j in range(len(c[i])):\n             if answer: break\n             answer = max(c[i]) > c[i][j] and max([c[k][j] for k in range(len(c))]) > c[i][j]\n     print "Case #%d: %s" % ( cNum, "NO" if answer else "YES")\n \n \n     \n \n \n
joegunrok	<>	59	<>	2012_1460488_1483488.py	<>	       \n """\n GCJ framework (gcj.fw.framework)\n  - Command Line and Package interface\n  - output redirection\n  - parsing case input\n  - executing problem code against cases\n  - testing framework\n """\n import sys\n import unittest\n import StringIO\n \n class Framework(object):\n     class Case(object):\n         def __init__(self, caseNumber, caseData=None):\n             self.number = caseNumber\n             self.data = caseData\n             self.result = None\n     \n         @classmethod\n         def parser(cls, f_in):\n             pass\n     \n         def run(self):\n             pass\n     \n         def execute(self, f_in=None):\n             if self.data is None:\n                 self.data = self.parser(f_in)\n             self.result = self.run(**self.data)\n     \n         def __str__(self):\n             return "Case #%d: %s" % (self.number, self.result)\n     \n     \n     class Result(object):\n         def __init__(self, resultData):\n             self.data = resultData\n     \n         def __str__(self):\n             return str(self.ata)\n \n     def __init__(self, f_in, f_out):\n         sys.stdout = f_out\n         self.f_in = f_in if f_in is not None else sys.stdin\n \n     def run(self):\n         nCases = int(self.f_in.readline().strip())\n         for num in xrange(nCases):\n             case = type(self).Case(num+1)\n             case.execute( f_in=self.f_in)\n             print case\n \n \n     @classmethod\n     def __main__(cls):\n         f_in = sys.stdin\n         if len(sys.argv) > 1:\n             if sys.argv[1] == "-t":\n                 unittest.main()\n                 sys.exit()\n             f_in = open(sys.argv[1])\n         framework = cls(f_in, sys.stdout)\n         framework.run()\n     \n class Test(unittest.TestCase):\n     cases = []\n     case = None\n     c=[]\n     \n     def setUp(self):\n         self.c = []\n         self.defineCases()\n         counter = 1\n         self.cases = []\n         for c in self.c:\n             case = self.case(counter)\n             case.data = case.parser(StringIO.StringIO(c[0]))\n             self.cases.append( [case, c[1]])\n     \n     def defineCases(self):\n         pass\n     \n     def tearDown(self):\n         pass \n \n     def test_Name(self):\n         self.setUp()\n         for case in self.cases:\n             print case[0].data, case[1]\n             case[0].execute()\n             self.assertEqual(case[0].result, case[1])\n '''\n Created on Apr 8, 2012\n \n @author: Joe\n '''\n \n from math import log\n class C(Framework):\n     class Case(Framework.Case):\n         def parser(self, fh):\n             args = map(int, fh.readline().strip().split(" "))\n             A,B = args[:2]\n             return {"A":A,"B":B}\n         \n         def run(self,A=None,B=None):\n             ret = 0\n             found = set()\n             for i in range(A,B+1):\n                 if i in found: continue\n                 n = int(log(i,10))\n                 nums = set([i])\n                 tmp = i\n                 for j in range(n):\n                     tmp = tmp / 10 + (tmp%10)*10**(n)\n                     if tmp <= B and tmp>= A:\n                         nums.add(tmp)\n                         found.add(tmp)\n                 ret += len(nums)*(len(nums)-1)/2\n             return str(ret)\n             \n class Test(Test):\n     def defineCases(self):\n         self.case = C.Case\n         self.c = [\n                   ["1 9", "0"],\n                   ["10 40", "3",                   ],\n                   ["10 99", "36"],\n                   ["100 500", "156"],\n                   ["1111 2222", "287"],\n                   ["1000000 2000000", "2000000"]\n                   ]\n \n if __name__ == "__main__":\n     C.__main__()\n     \n
joegunrok	<>	59	<>	2014_2974486_5756407898963968.py	<>	__author__ = 'jrokicki'\n \n import sys\n RL = lambda: sys.stdin.readline().strip()\n IA = lambda: map(int, RL().split(" "))\n LA = lambda: map(long, RL().split(" "))\n \n T = int(sys.stdin.readline())\n \n for CASE in range(T):\n     g1 = IA()[0]-1\n     board1 = []\n     for i in range(4):\n         board1.append(IA())\n     g2 = IA()[0]-1\n     board2 = []\n     for i in range(4):\n         board2.append(IA())\n \n     r1 = board1[g1]\n     r2 = board2[g2]\n \n     answer = set(r1).intersection(r2)\n     if len(answer) > 1:\n         answer = "Bad magician!"\n     elif len(answer) == 0:\n         answer = "Volunteer cheated!"\n     else:\n         answer = list(answer)[0]\n \n     print "Case #%d: %s" % (CASE+1, answer)\n \n
joegunrok	<>	59	<>	2012_1460488_1483485.py	<>	       \n """\n GCJ framework (gcj.fw.framework)\n  - Command Line and Package interface\n  - output redirection\n  - parsing case input\n  - executing problem code against cases\n  - testing framework\n """\n import sys\n import unittest\n import StringIO\n \n class Framework(object):\n     class Case(object):\n         def __init__(self, caseNumber, caseData=None):\n             self.number = caseNumber\n             self.data = caseData\n             self.result = None\n     \n         @classmethod\n         def parser(cls, f_in):\n             pass\n     \n         def run(self):\n             pass\n     \n         def execute(self, f_in=None):\n             if self.data is None:\n                 self.data = self.parser(f_in)\n             self.result = self.run(**self.data)\n     \n         def __str__(self):\n             return "Case #%d: %s" % (self.number, self.result)\n     \n     \n     class Result(object):\n         def __init__(self, resultData):\n             self.data = resultData\n     \n         def __str__(self):\n             return str(self.ata)\n \n     def __init__(self, f_in, f_out):\n         sys.stdout = f_out\n         self.f_in = f_in if f_in is not None else sys.stdin\n \n     def run(self):\n         nCases = int(self.f_in.readline().strip())\n         for num in xrange(nCases):\n             case = type(self).Case(num+1)\n             case.execute( f_in=self.f_in)\n             print case\n \n \n     @classmethod\n     def __main__(cls):\n         f_in = sys.stdin\n         if len(sys.argv) > 1:\n             if sys.argv[1] == "-t":\n                 unittest.main()\n                 sys.exit()\n             f_in = open(sys.argv[1])\n         framework = cls(f_in, sys.stdout)\n         framework.run()\n     \n class Test(unittest.TestCase):\n     cases = []\n     case = None\n     c=[]\n     \n     def setUp(self):\n         self.c = []\n         self.defineCases()\n         counter = 1\n         self.cases = []\n         for c in self.c:\n             case = self.case(counter)\n             case.data = case.parser(StringIO.StringIO(c[0]))\n             self.cases.append( [case, c[1]])\n     \n     def defineCases(self):\n         pass\n     \n     def tearDown(self):\n         pass \n \n     def test_Name(self):\n         self.setUp()\n         for case in self.cases:\n             print case[0].data, case[1]\n             case[0].execute()\n             self.assertEqual(case[0].result, case[1])\n \n D={'a':'y','o':'e','z':'q','q':'z'}\n \n a=["ejp mysljylc kd kxveddknmc re jsicpdrysi",\n    "our language is impossible to understand",\n    "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n    "there are twenty six factorial possibilities",\n    "de kr kd eoya kw aej tysr re ujdr lkgc jv",\n    "so it is okay if you want to just give up"]\n \n for i in range(0,len(a),2):\n     for j in range(0,len(a[i])):\n         D[a[i][j]] = a[i+1][j]\n \n class A(Framework):\n     class Case(Framework.Case):\n         def parser(self, fh):\n             statement = fh.readline().strip() \n             return {'secret': statement}\n         \n         def run(self, secret=None):\n             word = ""\n             for i in range(0,len(secret)):\n                 word += D[secret[i]]\n             return word\n         \n class Test(Test):\n     def defineCases(self):\n         self.case = A.Case\n         self.c = [["ejp mysljylc kd kxveddknmc re jsicpdrysi",\n    "our language is impossible to understand"],\n                   [   "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n    "there are twenty six factorial possibilities",],\n                   [ "de kr kd eoya kw aej tysr re ujdr lkgc jv",\n    "so it is okay if you want to just give up"],\n                   ]\n \n if __name__ == "__main__":\n     A.__main__()\n     \n
joegunrok	<>	59	<>	2014_2974486_5709773144064000.py	<>	__author__ = 'jrokicki'\n \n import sys\n RL = lambda: sys.stdin.readline().strip()\n IA = lambda: map(int, RL().split(" "))\n LA = lambda: map(long, RL().split(" "))\n FA = lambda: map(float, RL().split(" "))\n \n T = int(sys.stdin.readline())\n \n for CASE in range(T):\n     C,F,X = FA()\n     tick = 2.\n     answer = X/tick\n \n     game = 0\n     while True:\n         span = C / tick\n         tick += F\n         test = game + span + X/tick\n         game = game + span\n \n         if test < answer:\n             answer = test\n         else:\n             if tick > X:\n                 break\n \n     print "Case #%d: %s" % (CASE+1, answer)\n \n
joegunrok	<>	59	<>	2013_2270488_2453486.py	<>	import sys\n \n lines = sys.stdin.readlines()\n def parseCase(lines):\n     return 5,lines[0:4]\n \n def getCases(lines):\n     i =0\n     while i < len(lines):\n         lines_used, case = parseCase(lines[i:])\n         i += lines_used\n         yield case\n \n def test(r):\n     if 'O' in r and '.' not in r and 'X' not in r: \n         return "O won"\n     elif 'X' in r and '.' not in r and 'O' not in r: \n         return "X won"\n     return None\n         \n cNum =0\n for c in getCases(lines[1:]):\n     cNum += 1\n     answer = None\n     for i in range(0,4):\n         if answer: break\n         r = c[i]\n         answer = test(r) \\n             or test("".join(c[j][i] for j in range(4)))\n \n     if not answer:\n         answer = test("".join([c[j][3-j] for j in range(4)])) \\n             or test("".join(c[j][j] for j in range(4)))\n             \n     if not answer:\n         answer = any(["." in c[i] for i in range(4)]) and "Game has not completed"\n     if not answer:\n         answer = "Draw"\n     print "Case #%d: %s" % ( cNum, answer)\n \n \n \n \n \n \n \n \n \n \n \n     \n \n \n
joegunrok	<>	59	<>	2014_2974486_5690574640250880.py	<>	__author__ = 'jrokicki'\n \n import sys\n RL = lambda: sys.stdin.readline().strip()\n IA = lambda: map(int, RL().split(" "))\n LA = lambda: map(long, RL().split(" "))\n FA = lambda: map(float, RL().split(" "))\n \n T = int(sys.stdin.readline())\n \n def clear(R,C,b, x, y):\n     b = b[:]\n     n = 0\n     for i in range(max(0,x-1), min(R,x+2)):\n         for j in range(max(0,y-1), min(C, y+2)):\n             if b[C*i+j] == '*':\n                 n += 1\n                 b = b[:C*i+j] + '.' + b[C*i+j+1:]\n     return b, n\n mem = dict()\n def pb(R,C,b):\n     for x in range(R):\n         print b[x*C:x*C+C]\n \n def board(R,C,b,x,y,M,m):\n     global mem\n     print x\n     key = (R,C,b,M,x,y,m)\n     if key in mem: return mem[key]\n     if x >= R or y >= C:\n         mem[key] = None\n     else:\n         lb = b\n         n = 0\n         good = False\n         for i in range(y,C):\n             nb,nn = clear(R,C, lb, x, i)\n             n += nn\n             if m - n - M == 0:\n                 mem[key] = nb\n                 good = True\n                 break\n             elif m - n - M < 0:\n                 break\n             lb = bb\n         mem[key] = board(R,C,bb,M,x+1,0,m-n)\n     return mem[key]\n \n for CASE in range(T):\n     R,C,M = IA()\n     IMPOSSIBLE = "Impossible"\n \n     b = ""\n     cleared = R*C-M\n     for x in range(R):\n         b += "*" * C\n     if M == R*C-1:\n         b = "c" + b[1:]\n         answer = b\n     else:\n         good = False\n         x,y = 0,0\n         q = [(b,0,0,0)]\n         mem = {}\n         while not good and q:\n             board,total_cleared,x,y = q.pop(0)\n             if (board,total_cleared,x,y) in mem:\n                 continue\n             mem[(board,total_cleared,x,y)] = True\n             if x >= R: continue\n             if y >= C:\n                 q.append((last_board,total_cleared,x+1,0))\n                 continue\n             last_board = board\n             new_board, cleared_mines = clear(R,C,last_board,x,y)\n             total_cleared += cleared_mines\n \n             if total_cleared == cleared:\n                 good = True\n                 last_board = new_board\n                 q = []\n                 break\n             elif total_cleared - cleared == -1:\n                 q.append((new_board,total_cleared,x,y+1))\n                 q.append((new_board,total_cleared,x+1,0))\n                 q.append((last_board,total_cleared-cleared_mines,x+1,0))\n             elif total_cleared > cleared:\n                 q.append((last_board,total_cleared-cleared_mines,x+1,0))\n             else:\n                 q.append((new_board,total_cleared,x,y+1))\n             last_board = new_board\n         if good:\n             answer = last_board\n         else:\n             answer = None\n     if not answer:\n         answer = "Impossible"\n     else:\n         b = ""\n         for x in range(R):\n             b += answer[x*C:x*C+C] + "\n"\n         answer = "c" + b[1:-1]\n     print "Case #%d:\n%s" % (CASE+1, answer)\n \n
oonishi	<>	60	<>	2013_2270488_2463486.py	<>	# coding: cp932\n import sys\n f   = file(sys.argv[1])\n out = file(sys.argv[2], 'w')\n \n caseCnt = int(f.readline())\n \n Num = [\n 	0,\n 	1,\n 	4,\n 	9,\n 	121,\n 	484,\n 	10201,\n 	12321,\n 	14641,\n 	40804,\n 	44944,\n 	1002001,\n 	1234321,\n 	4008004,\n 	100020001,\n 	102030201,\n 	104060401,\n 	121242121,\n 	123454321,\n 	125686521,\n 	400080004,\n 	404090404,\n 	10000200001,\n 	10221412201,\n 	12102420121,\n 	12345654321,\n 	40000800004,\n 	1000002000001,\n 	1002003002001,\n 	1004006004001,\n 	1020304030201,\n 	1022325232201,\n 	1024348434201,\n 	1210024200121,\n 	1212225222121,\n 	1214428244121,\n 	1232346432321,\n 	1234567654321,\n 	4000008000004,\n 	4004009004004,\n ]\n \n for case in range(1, caseCnt+1):\n 	L, H = f.readline().split()\n 	L = int(L); H = int(H)\n 	assert L <= H\n 	\n 	for i in range(len(Num)):\n 		if L <= Num[i]:\n 			break\n 	else:\n 		print>>out, 'Case #%d:'%case, 0\n 		continue\n \n 	lb = i - 1\n \n 	for i in range(1, len(Num)+1):\n 		if H >= Num[len(Num)-i]:\n 			break\n 	else:\n 		print>>out, 'Case #%d:'%case, 0\n 		continue\n 	ub = len(Num)-i\n 		\n 	print>>out, 'Case #%d:'%case, ub - lb\n \n out.close()\n
oonishi	<>	60	<>	2013_2270488_2449486.py	<>	# coding: cp932\n import sys\n f   = file(sys.argv[1])\n out = file(sys.argv[2], 'w')\n \n caseCnt = int(f.readline())\n \n for case in range(1, caseCnt+1):\n 	V, H = f.readline().split()\n 	V = int(V); H = int(H)\n 	\n 	field = [map(int, list(f.readline().split())) for _ in range(V)]\n 	#print field\n 	\n 	rowMax = [max(row) for row in field]\n 	colMax = [max([row[i] for row in field]) for i in range(H)]\n 	#print rowMax, colMax\n 		\n 	result = 'YES'\n 	for row in range(V):\n 		for col in range(H):\n 			if field[row][col] < rowMax[row] and field[row][col] < colMax[col]:\n 				result = 'NO'\n 				break\n 		else:\n 			continue\n 		break\n 	print>>out, 'Case #%d:'%case, result\n \n out.close()\n
oonishi	<>	60	<>	2012_1460488_1483488.py	<>	# coding: shift-jis\n \n import sys\n #f = file("test.in")\n #w = sys.stdout\n f = file("C-small-attempt0.in")\n w = file("answer.txt", "w")\n cnt = int(f.readline()[:-1])\n from math import log\n for no in range(cnt):\n 	A, B = map(int, f.readline()[:-1].split())\n 	\n 	count = 0\n 	for n in range(A, B):\n 		d = int(log(n, 10))+1\n 		s = set()\n 		for e in range(1, d):\n 			c = 10**e\n 			r = (n % c)*10**(d-e)\n 			b = n / c\n 			if r+b>n and r+b<=B and (n, r+b) not in s:\n 				s.add((n, r+b))\n 				count += 1\n 				\n 	print>>w, "Case #%d:"%(no+1), count\n \n \n
oonishi	<>	60	<>	2014_2974486_5756407898963968.py	<>	# coding: cp932\n \n #input = open(r'C:\MyDocument\home\gcj\2014-04-12\a.sample')\n input = open(r'C:\MyDocument\home\gcj\2014-04-12\A-small-attempt0.in')\n caseCnt = int(input.readline())\n for caseNo in range(1, caseCnt+1):\n 	ans1 = int(input.readline())\n 	for i in range(1, 5):\n 		line = input.readline()\n 		if ans1 == i:\n 			candidates = set(map(int, line.split()))\n 		\n 	ans2 = int(input.readline())\n 	for i in range(1, 5):\n 		line = input.readline()\n 		if ans2 == i:\n 			answers = candidates.intersection(set(map(int, line.split())))\n 		\n 	if len(answers) == 0:\n 		print('Case #%d: Volunteer cheated!'%caseNo)\n 	elif len(answers) > 1:\n 		print('Case #%d: Bad magician!'%caseNo)\n 	elif len(answers) == 1:\n 		answer = answers.pop()\n 		print('Case #%d: %d'%(caseNo, answer))\n
oonishi	<>	60	<>	2012_1460488_1483485.py	<>	# coding: shift-jis\n \n a = "abcdefghijklmnopqrstuvwxyz"\n d = {}\n for c in a:\n 	d[c] = "*"\n \n i = "ejp mysljylc kd kxveddknmc re jsicpdrysi"\n o = "our language is impossible to understand"\n for k, v in zip(i, o):\n 	d[k] = v\n i = "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"\n o = "there are twenty six factorial possibilities"\n for k, v in zip(i, o):\n 	d[k] = v\n i = "de kr kd eoya kw aej tysr re ujdr lkgc jv"\n o = "so it is okay if you want to just give up"\n for k, v in zip(i, o):\n 	d[k] = v\n \n \n i = "y qee"\n o = "a zoo"\n for k, v in zip(i, o):\n 	d[k] = v\n d['z'] = 'q'\n import sys\n f = file("A-small-attempt1.in")\n #w = sys.stdout\n w = file("answer.txt", "w")\n cnt = int(f.readline()[:-1])\n for no in range(cnt):\n 	i = f.readline()[:-1]\n 	o = ""\n 	for k in i:\n 		o += d[k]\n 	print>>w, "Case #%d:"%(no+1), o\n \n \n
oonishi	<>	60	<>	2014_2974486_5709773144064000.py	<>	# coding: cp932\n \n \n lines = iter('''\n 5\n 30.0 1.0 2.0\n 30.0 2.0 100.0\n 30.50000 3.14159 1999.19990\n 500.0 4.0 2000.0\n 100.0 1.0 100000.0\n '''.splitlines(False)[1:])\n \n lines = iter(open(r'B-small-attempt0.in').readlines(False))\n \n caseCnt = int(next(lines))\n \n for case in range(1, caseCnt+1):\n 	C, F, X = map(float, next(lines).split())\n 	\n 	v = 2.0\n 	total = 0.0\n 	goal = X/v\n 	while 1:\n 		farm = C/v + total\n 		if farm >= goal:\n 			answer = goal\n 			break\n 		v += F\n 		total = farm\n 		if goal > X/v + total:\n 			goal = X/v + total	\n 	print('Case #%d: %0.6lf'%(case, answer))\n 	#import pdb;pdb.set_trace()\n 	\n \n
oonishi	<>	60	<>	2013_2270488_2453486.py	<>	# coding: cp932\n import sys\n f   = file(sys.argv[1])\n out = file(sys.argv[2], 'w')\n \n caseCnt = int(f.readline())\n \n for case in range(1, caseCnt+1):\n 	board = [\n 		f.readline()[:4],\n 		f.readline()[:4],\n 		f.readline()[:4],\n 		f.readline()[:4],\n 	]\n 	f.readline()\n 	xwin = False\n 	owin = False\n 	rest = False\n 	# \n 	for row in board:\n 		if row.replace('T', 'X') == 'XXXX':\n 			xwin = True\n 		elif row.replace('T', 'O') == 'OOOO':\n 			owin = True\n 		if '.' in row: rest = True\n 	# c\n 	for i in range(4):\n 		col = ''.join([row[i] for row in board])\n 		if col.replace('T', 'X') == 'XXXX':\n 			xwin = True\n 		elif col.replace('T', 'O') == 'OOOO':\n 			owin = True\n 	# \n 	up = ''.join([row[i] for i, row in enumerate(board)])\n 	if up.replace('T', 'X') == 'XXXX':\n 		xwin = True\n 	elif up.replace('T', 'O') == 'OOOO':\n 		owin = True\n 	down = ''.join([row[3-i] for i, row in enumerate(board)])\n 	if down.replace('T', 'X') == 'XXXX':\n 		xwin = True\n 	elif down.replace('T', 'O') == 'OOOO':\n 		owin = True\n 	\n 	assert not (xwin==owin==True)\n 	\n 	if xwin:\n 		result = 'X won'\n 	elif owin:\n 		result = 'O won'\n 	elif rest:\n 		result = 'Game has not completed'\n 	else:\n 		result = 'Draw'\n 		\n 	print>>out, 'Case #%d:'%case, result\n \n out.close()\n
oonishi	<>	60	<>	2014_2974486_5690574640250880.py	<>	# coding: cp932\n \n lines = iter('''\n 13\n 5 5 23\n 3 1 1\n 1 3 1\n 2 2 1\n 4 7 3\n 10 10 82\n 10 1 4\n 1 10 5\n 2 10 8\n 10 2 8\n 2 10 9\n 10 2 7\n 5 3 3\n '''.splitlines(False)[1:])\n import sys\n out = sys.stdout\n \n sys.setrecursionlimit(1500)\n \n \n class MyException(Exception):\n 	pass\n lines = iter(open(r'C-small-attempt7.in').readlines(False))\n out = open('c-small.answer', 'w')\n \n #lines = iter(open(r'C-large.in').readlines(False))\n #out = open('c-large.answer', 'w')\n def solve(C, R, M):\n 	board = [['.']*C for _ in range(R)]\n 	board[-1][-1] = 'c'\n 	try:\n 		for r in range(R-2):\n 			for c in range(C-2):\n 				if r == R-3 and c == C-3:\n 					raise StopIteration()\n 				board[r][c] = '*'\n 				M -= 1\n 				if M == 0:\n 					return board \n 	except StopIteration:\n 		pass\n 		\n 	if M % 2 == 0:\n 		for r in range(R-3):\n 			board[r][C-1] = '*'\n 			board[r][C-2] = '*'\n 			M -= 2\n 			if M == 0:\n 				return board\n 		for c in range(C-3):\n 			board[R-1][c] = '*'\n 			board[R-2][c] = '*'\n 			M -= 2\n 			if M == 0:\n 				return board\n 		\n 		\n 		raise MyException()\n 	else:\n 		board[R-3][C-3] = '*'\n 		M -= 1\n 		if M == 0:\n 			return board\n 		for r in range(R-2):\n 			board[r][C-1] = '*'\n 			board[r][C-2] = '*'\n 			M -= 2\n 			if M == 0:\n 				return board\n 		for c in range(C-2):\n 			board[R-1][c] = '*'\n 			board[R-2][c] = '*'\n 			M -= 2\n 			if M == 0:\n 				return board\n 		\n 		raise MyException()\n 		\n 	\n caseCnt = int(next(lines))\n \n for case in range(1, caseCnt+1):\n 	R,C,M = map(int, next(lines).split())\n 	\n 	print('Case #%d:'%case, file=out)\n 	if M == 0:\n 		print('c' + '.'*(C-1), file=out)\n 		for _ in range(R-1):\n 			print('.'*C, file=out)\n 	elif R*C==M+1:\n 		print('c' + '*'*(C-1), file=out)\n 		for _ in range(R-1):\n 			print('*'*C, file=out)\n 	elif C == 1 and R == 1:\n 		print('Impossible', file=out)\n 	elif C == 1:\n 		if M > R-1:\n 			print('Impossible', file=out)\n 		else:\n 			print('c', file=out)\n 			for _ in range(R-M-1):\n 				print('.', file=out)\n 			for _ in range(M):\n 				print('*', file=out)\n 	elif R == 1:\n 		if M > C-1:\n 			print('Impossible', file=out)\n 		else:\n 			print('c' + '.'*(C-M-1) + '*'*M, file=out)\n 	elif C == 2:\n 		if M %2 or M//2 > R-2:\n 			print('Impossible', file=out)\n 		else:\n 			print('c.', file=out)\n 			for _ in range(R-M//2-1):\n 				print('..', file=out)\n 			for _ in range(M//2):\n 				print('**', file=out)\n 	elif R == 2:\n 		if M %2 or M//2 > C-2:\n 			print('Impossible', file=out)\n 		else:\n 			print('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\n 			print(      '.'*(C-M//2)   + '*'*(M//2), file=out)\n 	elif M > R*C-4:\n 		print('Impossible', file=out)\n 	else:\n 		try:\n 			board = solve(C, R, M)\n 			for line in board:\n 				print(''.join(line), file=out)\n 		except MyException:\n 			print('Impossible', file=out)\n 	# if C == 1:\n 		# if N[0] > K[0]:\n 			# print('Case #%d: 1 1'%case, file=out)\n 		# else:\n 			# print('Case #%d: 0 0'%case, file=out)\n 		# continue\n 	\n 	#import pdb;pdb.set_trace()\n 	\n
greatlemer	<>	61	<>	2013_2270488_2463486.py	<>	from optparse import OptionParser\n import string\n import pickle\n \n def solve(lower, upper, cache):\n     counter = 0\n     for item in cache:\n         if item > upper:\n             break\n         if item < lower:\n             continue\n         counter += 1\n     return counter\n \n def is_palindrome(test_int):\n     str_arg = str(test_int)\n     return str_arg == str_arg[::-1]\n \n def generate_cache():\n     """ Generates a list of 'fair and square' numbers between 1 and 10^100\n \n     By observation of generating the first few of these numbers it became\n     obvious that the 'roots' fitted a very specific pattern, they are either\n     single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;\n     multiple digits with a 2 at the beginning and end and 1s and 0s in the\n     middle or an odd number of digits with a single 2 in the centre and 1s and\n     0s elsewhere.\n \n     This function therefore only looks at these numbers to build a list of all\n     valid results. """\n     # Put 9 in to start with as it's the only one that uses a 3.\n     cache = [9,]\n     counter = 1\n     if upper_bound is None:\n         upper_bound = pow(2,25)\n     while counter < upper_bound:\n         binary_part = "{0:b}".format(counter)\n         # Look for palindromes beginning with a 1\n         half_int = binary_part\n         # Check the odd length palindrome\n         pal_int = int(half_int + half_int[:-1][::-1])\n         pal_square = pal_int * pal_int\n         if is_palindrome(pal_square):\n             cache.append(pal_square)\n         # Check the even length palindrome\n         pal_int = int(half_int + half_int[::-1])\n         pal_square = pal_int * pal_int\n         if is_palindrome(pal_square):\n             cache.append(pal_square)\n         half_int = "%s%s" % (binary_part, 2)\n         # Check the odd length palindrome only when adding a 2\n         pal_int = int(half_int + half_int[:-1][::-1])\n         pal_square = pal_int * pal_int\n         if is_palindrome(pal_square):\n             cache.append(pal_square)\n         # Look for palindromes beginning with a 2\n         half_int = "2%s" % binary_part[1:]\n         # Check the odd length palindrome\n         pal_int = int(half_int + half_int[:-1][::-1])\n         pal_square = pal_int * pal_int\n         if is_palindrome(pal_square):\n             cache.append(pal_square)\n         # Check the even length palindrome\n         pal_int = int(half_int + half_int[::-1])\n         pal_square = pal_int * pal_int\n         if is_palindrome(pal_square):\n             cache.append(pal_square)\n         counter += 1\n     return sorted(cache)\n \n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file", dest="filename",\n                       help="read input from FILE", metavar="FILE")\n     parser.add_option("-c", "--cache", dest="cache_filename",\n                       help="read/write cache from/to CACHE_FILE", metavar="CACHE_FILE")\n     parser.add_option("-g", "--generate-cache", dest="generate_cache",\n                       help="generate the cache file", action="store_true")\n     cache = None\n     (options, args) = parser.parse_args()\n     if options.generate_cache:\n         # Generate a cache file before going through answers so that we don't\n         # waste precious time later.\n         cache = generate_cache()\n         if not options.cache_filename:\n             output_file = open(options.cache_filename, "w")\n             pickle.dump(cache, output_file)\n             output_file.close()\n     else:\n         cache_file = open(options.cache_filename, "r")\n         cache = pickle.load(cache_file)\n         cache_file.close()\n     if not options.filename:\n         parser.error("Must provide a filename.")\n     input_file = open(options.filename, "r")\n     total_cases = int(input_file.readline())\n     case_number = 0\n     while case_number < total_cases:\n         case_number += 1\n         lower,upper = input_file.readline().split()\n         lower = int(lower)\n         upper = int(upper)\n         data_args = (lower, upper, cache)\n         print "Case #%d: %s" % (case_number, solve(*data_args))\n \n if __name__ == "__main__":\n     main()
greatlemer	<>	61	<>	2013_2270488_2449486.py	<>	from optparse import OptionParser\n import string\n \n def solve(rows,cols,width,height):\n     # Calculate the lowest setting that can be used when cutting a row or col.\n     row_mins = [max(row) for row in rows]\n     col_mins = [max(col) for col in cols]\n     for row_idx in range(height):\n         for col_idx in range(width):\n             if row_mins[row_idx] > rows[row_idx][col_idx] \\n                and col_mins[col_idx] > rows[row_idx][col_idx]:\n                 return "NO"\n     return "YES"\n \n \n def parse_case(data,width,height):\n     data_line = [int(entry) for entry in reduce(lambda x,y: x+y, data, [])]\n     rows = []\n     cols = []\n     for idx in range(height):\n         offset = idx * width\n         # Pull rows\n         rows.append(data_line[offset:offset+width])\n     for idx in range(width):\n         # Pull columns\n         cols.append(data_line[idx::width][:height])\n     return (rows, cols, width, height)\n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file", dest="filename",\n                       help="read input from FILE", metavar="FILE")\n \n     (options, args) = parser.parse_args()\n     if not options.filename:\n         parser.error("Must provide a filename.")\n     input_file = open(options.filename, "r")\n     total_cases = int(input_file.readline())\n     case_number = 0\n     while case_number < total_cases:\n         case_number += 1\n         height,width = input_file.readline().split()\n         width = int(width)\n         height = int(height)\n         data = []\n         for idx in range(height):\n             data.append(input_file.readline().split())\n         data_args = parse_case(data, width, height)\n         print "Case #%d: %s" % (case_number, solve(*data_args))\n \n if __name__ == "__main__":\n     main()
greatlemer	<>	61	<>	2012_1460488_1483488.py	<>	from optparse import OptionParser\n import math\n \n # The largest number B can be\n MAX_NUMBER = 2000000\n \n # COUNT_MAP will store the number of recycled pairs that can exist for a\n # list of cycles of length n (these are the triangular numbers).\n # Calculate this now so that we don't waste time with it later on.\n COUNT_MAP = { 1: 0 }\n index = 1\n while index < math.log10(MAX_NUMBER):\n     index += 1\n     COUNT_MAP[index] = index * (index - 1) / 2\n \n def solve(minimum, maximum):\n     # Store the result\n     total_cycles = 0\n     # The numbers we need to check.  We'll remove numbers from this once we've\n     # used them in a cycle so that we don't attempt to reprocess them.\n     iter_range = range(minimum, maximum + 1)\n     # Keep looping untli we've gone through all the numbers.\n     while iter_range:\n         # Remove the first number\n         number = iter_range[0]\n         iter_range.remove(number)\n         # Add this to the list of numbers in a potential cycle.\n         cycle_numbers = [number,]\n         # Using strings for this feels icky but the modulo arithmetic seems\n         # equally icky :-(\n         # Double up the number in a string and we'll use slices to get the\n         # cycles.\n         string_rep = "%s%s" % (number, number)\n         digits = len(string_rep) / 2\n         start_index, end_index = 0, digits\n         while start_index < digits:\n             start_index += 1\n             end_index += 1\n             new_number = int(string_rep[start_index:end_index])\n             if new_number == number:\n                 # If we're repeating then there's no need to take more slices\n                 start_index = digits\n             elif new_number > number and new_number <= maximum:\n                 # We should already have dealt with numbers lower than this,\n                 # and we don't want anything above the maximum. Anything else\n                 # add to the cycle options and remove from the list of numbers\n                 # to check.\n                 cycle_numbers.append(new_number)\n                 iter_range.remove(new_number)\n         total_cycles += COUNT_MAP[len(cycle_numbers)]\n     return total_cycles\n \n def parse_case(data_line):\n     bits = data_line.split()\n     minimum = int(bits[0])\n     maximum = int(bits[1])\n     return (minimum, maximum, )\n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file", dest="filename",\n                       help="read input from FILE", metavar="FILE")\n \n     (options, args) = parser.parse_args()\n     if not options.filename:\n         parser.error("Must provide a filename.")\n     input_file = open(options.filename, "r")\n     total_cases = int(input_file.readline())\n     case_number = 0\n     while case_number < total_cases:\n     	case_number += 1\n     	data_args = parse_case(input_file.readline())\n     	print "Case #%d: %s" % (case_number, solve(*data_args))\n \n if __name__ == "__main__":\n     main()
greatlemer	<>	61	<>	2014_2974486_5756407898963968.py	<>	# Written for Python 2.7.5\n \n from optparse import OptionParser\n from StringIO import StringIO\n import sys\n \n # Expected format of TEST_CASES is a list of tuples of (input, expected_output)\n TEST_CASES = [\n     ("""3\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 3\n 1 2 5 4\n 3 11 6 15\n 9 10 7 12\n 13 14 8 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 3\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n ""","""Case #1: 7\n Case #2: Bad magician!\n Case #3: Volunteer cheated!\n """),\n     ("""1\n 1\n 15 9 16 5\n 6 10 1 3\n 2 4 12 11\n 13 14 8 7\n 1\n 5 10 9 6\n 12 15 1 11\n 14 16 4 2\n 13 3 8 7""","""Case #1: Bad magician!\n """)\n ]\n \n BAD_MAGIC = "Bad magician!"\n CHEATING = "Volunteer cheated!"\n \n def parse_input(input_reader):\n     case_count = int(input_reader.readline())\n     case_idx = 0\n     while case_count > case_idx:\n         case_idx += 1\n         rows = []\n         for loop_idx in (1,2):\n             row_idx = int(input_reader.readline())\n             for idx in (1,2,3,4):\n                 if idx == row_idx:\n                     rows.append(set(input_reader.readline().rstrip("\n").split(" ")))\n                 else:\n                     input_reader.readline()\n         input_values = {"rows":rows,\n                         "case":case_idx}\n         yield input_values\n \n \n def solve_problem(output_writer=sys.stdout, **kwargs):\n     rows = kwargs['rows']\n     case = kwargs['case']\n     intersect = rows[0].intersection(rows[1])\n     if not intersect:\n         msg = CHEATING\n     elif len(intersect) == 1:\n         msg = intersect.pop()\n     else:\n         msg = BAD_MAGIC\n     print >>output_writer, "Case #%d: %s" % (case, msg)\n \n def solve_inputs(input_reader, output_writer):\n     """\n     Loop through each problem input in input reader and solve it.\n \n     Outputs responses to output_writer.\n     """\n     for input_values in parse_input(input_reader):\n         solve_problem(output_writer=output_writer, **input_values)\n \n def run_tests():\n     """\n     Check the sample input and output match.\n     """\n     idx = 0\n     all_pass = True\n     for problem_input, expected_output in TEST_CASES:\n         idx += 1\n         input_reader = StringIO(problem_input)\n         output_writer = StringIO()\n         solve_inputs(input_reader, output_writer)\n         problem_output = output_writer.getvalue()\n         if problem_output == expected_output:\n             print "Test %d: Success" % idx\n         else:\n             all_pass = False\n             print "Test %d: Failure" % idx\n         input_reader.close()\n         output_writer.close()\n     if all_pass:\n         print "All tests were successful!"\n     else:\n         print "Something didn't match - try again."\n         print problem_output\n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file",\n                       dest="filename_stem",\n                       help="read input from FILE.in and write to FILE.out",\n                       metavar="FILE")\n \n     (options, args) = parser.parse_args()\n     if options.filename_stem:\n         print "Running in file mode."\n         input_reader = open("%s.in" % options.filename_stem, "r")\n         output_writer = open("%s.out" % options.filename_stem, "w")\n         solve_inputs(input_reader, output_writer)\n     else:\n         print "Running in test mode."\n         run_tests()\n \n if __name__ == "__main__":\n     main()
greatlemer	<>	61	<>	2012_1460488_1483485.py	<>	from optparse import OptionParser\n import string\n \n def solve(data_line):\n     english, googlerese = generate_map()\n     transmap = string.maketrans(googlerese, english)\n     return string.translate(data_line, transmap, "\n")\n \n def parse_case(data_line):\n     return (data_line, )\n \n def generate_map():\n     """ Use the known phrases we have to generate a translation map.  If\n         there's exactly one letter missing after analysing these phrases (which\n         there is) we can work it out by seeing what's left over."""\n     known_mappings = {"a zoo": "y qee",\n                       "our language is impossible to understand": "ejp mysljylc kd kxveddknmc re jsicpdrysi",\n                       "there are twenty six factorial possibilities": "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n                       "so it is okay if you want to just give up": "de kr kd eoya kw aej tysr re ujdr lkgc jv",\n                      }\n     all_letters = "abcdefghijklmnopqrstuvwxyz"\n     letter_map = {}\n     for english, googlerese in known_mappings.items():\n         pairs = zip(english, googlerese)\n         for e,g in pairs:\n             if e not in letter_map:\n                 letter_map[e] = g\n     if len(letter_map) == 26:\n         e_letter = ""\n         g_letter = ""\n         for letter in all_letters:\n             if not e_letter and letter not in letter_map.keys():\n                 e_letter = letter\n             if not g_letter and letter not in letter_map.values():\n                 g_letter = letter\n         letter_map[e_letter] = g_letter\n     return "".join(letter_map.keys()), "".join(letter_map.values())\n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file", dest="filename",\n                       help="read input from FILE", metavar="FILE")\n \n     (options, args) = parser.parse_args()\n     if not options.filename:\n         parser.error("Must provide a filename.")\n     input_file = open(options.filename, "r")\n     total_cases = int(input_file.readline())\n     case_number = 0\n     while case_number < total_cases:\n     	case_number += 1\n     	data_args = parse_case(input_file.readline())\n     	print "Case #%d: %s" % (case_number, solve(*data_args))\n \n if __name__ == "__main__":\n 	main()
greatlemer	<>	61	<>	2014_2974486_5709773144064000.py	<>	# Written for Python 2.7.5\n \n from optparse import OptionParser\n from StringIO import StringIO\n from math import ceil\n import sys\n \n # Expected format of TEST_CASES is a list of tuples of (input, expected_output)\n TEST_CASES = [\n     ("""4\n 30.0 1.0 2.0\n 30.0 2.0 100.0\n 30.50000 3.14159 1999.19990\n 500.0 4.0 2000.0\n ""","""Case #1: 1.0000000\n Case #2: 39.1666667\n Case #3: 63.9680013\n Case #4: 526.1904762\n """)\n ]\n \n """\n Z is number of farms held\n tF(Z) is time to build a farm = C / (2+(F*Z))\n tX(Z) is time to win = X / (2+(F*Z))\n No point incresing Z when tX(Z) < (tX(Z+1) + tF(Z)\n     == X / (2+(F*Z)) < (X / (2+(F*(Z+1))) + (C / (2+(F*Z)))\n     == (X - C) / (2+(F*Z)) < X / (2+(F*(Z+1)))\n     == (X - C) * (2+(F*Z)+F) < X * (2+(F*Z))\n     == 2X - 2C + XFZ - CFZ + XF - CF < 2X + XFZ\n     == XF - CF - 2C < CFZ\n     == (XF - CF - 2C) / CF < Z\n """\n \n def parse_input(input_reader):\n     case_count = int(input_reader.readline())\n     case_idx = 0\n     while case_count > case_idx:\n         case_idx += 1\n         input_line = input_reader.readline().rstrip("\n").split(" ")\n         input_values = {"C": float(input_line[0]),\n                         "F": float(input_line[1]),\n                         "X": float(input_line[2]),\n                         "case": case_idx}\n         yield input_values\n \n def solve_problem(output_writer=sys.stdout, **kwargs):\n     case = kwargs['case']\n     C_val = kwargs['C']\n     F_val = kwargs['F']\n     X_val = kwargs['X']\n \n     best_Z = ((X_val * F_val) - (C_val * F_val) - (2 * C_val)) / (C_val * F_val)\n     best_Z = int(ceil(best_Z))\n     if best_Z < 0:\n         best_Z = 0\n \n     tX = lambda z: (X_val / (2+(F_val * z)))\n     tF = lambda z: (C_val / (2+(F_val * z)))\n \n     total_time = reduce(lambda x,y: x + tF(y), range(best_Z), tX(best_Z))\n     print >> output_writer, "Case #%d: %.7f" % (case, total_time)\n \n def solve_inputs(input_reader, output_writer):\n     """\n     Loop through each problem input in input reader and solve it.\n \n     Outputs responses to output_writer.\n     """\n     for input_values in parse_input(input_reader):\n         solve_problem(output_writer=output_writer, **input_values)\n \n def run_tests():\n     idx = 0\n     all_pass = True\n     for problem_input, expected_output in TEST_CASES:\n         idx += 1\n         input_reader = StringIO(problem_input)\n         output_writer = StringIO()\n         solve_inputs(input_reader, output_writer)\n         problem_output = output_writer.getvalue()\n         if problem_output == expected_output:\n             print "Test %d: Success" % idx\n         else:\n             all_pass = False\n             print "Test %d: Failure" % idx\n         input_reader.close()\n         output_writer.close()\n     if all_pass:\n         print "All tests were successful!"\n     else:\n         print "Something didn't match - try again."\n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file",\n                       dest="filename_stem",\n                       help="read input from FILE.in and write to FILE.out",\n                       metavar="FILE")\n \n     (options, args) = parser.parse_args()\n     if options.filename_stem:\n         print "Running in file mode."\n         input_reader = open("%s.in" % options.filename_stem, "r")\n         output_writer = open("%s.out" % options.filename_stem, "w")\n         solve_inputs(input_reader, output_writer)\n     else:\n         print "Running in test mode."\n         run_tests()\n \n if __name__ == "__main__":\n     main()
greatlemer	<>	61	<>	2013_2270488_2453486.py	<>	from optparse import OptionParser\n import string\n \n def solve(data):\n     GAME_INCOMPLETE = 0\n     GAME_DRAWN = 1\n     GAME_WON = 2\n     winner = None\n     state = GAME_DRAWN\n     for row in data:\n         if "." in row:\n             state = GAME_INCOMPLETE\n         elif "X" not in row:\n             winner = "O"\n             state = GAME_WON\n             break\n         elif "O" not in row:\n             winner = "X"\n             state = GAME_WON\n             break\n     if state == GAME_WON:\n         return "%s won" % winner\n     elif state == GAME_INCOMPLETE:\n         return "Game has not completed"\n     else:\n         return "Draw"\n \n def parse_case(data):\n     data_line = "".join(data)\n     rows = []\n     for idx in range(4):\n         offset = idx * 4\n         # Pull rows\n         rows.append(data_line[offset:offset+4])\n         # Pull columns\n         rows.append(data_line[idx::4])\n     # Pull diagonals\n     rows.append(data_line[0::5])\n     rows.append(data_line[3:-1:3])\n     return (rows, )\n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file", dest="filename",\n                       help="read input from FILE", metavar="FILE")\n \n     (options, args) = parser.parse_args()\n     if not options.filename:\n         parser.error("Must provide a filename.")\n     input_file = open(options.filename, "r")\n     total_cases = int(input_file.readline())\n     case_number = 0\n     while case_number < total_cases:\n         case_number += 1\n         data = []\n         for idx in range(4):\n             data.append(input_file.readline()[:4])\n         input_file.readline()\n         data_args = parse_case(data)\n         print "Case #%d: %s" % (case_number, solve(*data_args))\n \n if __name__ == "__main__":\n     main()
greatlemer	<>	61	<>	2014_2974486_5690574640250880.py	<>	# Written for Python 2.7.5\n \n from optparse import OptionParser\n from StringIO import StringIO\n import sys\n \n # Expected format of TEST_CASES is a list of tuples of (input, expected_output)\n TEST_CASES = [\n     ("""5\n 5 5 23\n 3 1 1\n 2 2 1\n 4 7 3\n 10 10 82\n ""","""Case #1:\n Impossible\n Case #2:\n c\n .\n *\n Case #3:\n Impossible\n Case #4:\n c......\n .......\n .......\n ....***\n Case #5:\n c........*\n .........*\n **********\n **********\n **********\n **********\n **********\n **********\n **********\n **********\n """),\n     ("""3\n 5 4 3\n 5 3 8\n 5 5 14\n ""","""Case #1:\n c...\n ....\n ....\n ...*\n ..**\n Case #2:\n Impossible\n Case #3:\n c...*\n ....*\n ...**\n *****\n *****\n """)\n ]\n \n IMPOSSIBLE = "Impossible"\n \n """\n S is number of safe squares = (R*C) - M\n If S == 1 then always possible:\n     Assume click in top left, all else mines\n Special cases (R or C is small):\n If R == 1 or C == 1 then always possible:\n     Assume click in top left and all safe squares in a line\n Else if R == 2 or C == 2 then possible iff S % 2 == 0:\n     Assume click in top left and all safe squares are in a 2 * X line\n Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\n    OR if S % 2 == 0 \n """\n \n def parse_input(input_reader):\n     case_count = int(input_reader.readline())\n     case_idx = 0\n     while case_count > case_idx:\n         case_idx += 1\n         input_line = [int(x) for x in input_reader.readline().split()]\n         input_values = {"case": case_idx,\n                         "R": input_line[0],\n                         "C": input_line[1],\n                         "M": input_line[2]}\n         yield input_values\n \n \n def solve_problem(output_writer=sys.stdout, **kwargs):\n     case = kwargs['case']\n     rows = kwargs['R']\n     cols = kwargs['C']\n     mines = kwargs['M']\n     safe_squares = ((rows * cols) - mines)\n     print >> output_writer, "Case #%d:" % case\n     row_string = "{:*<%ds}" % cols\n     impossible = False\n     if safe_squares == 1:\n         print >> output_writer, row_string.format("c")\n         for row in range(1, rows):\n             print >> output_writer, row_string.format("")\n     elif rows == 1:\n         safe_string = "c" + ("." * (safe_squares - 1))\n         print >> output_writer, row_string.format(safe_string)\n     elif cols == 1:\n         for row in range(rows):\n             cell = ""\n             if row == 0:\n                 cell = "c"\n             elif row < safe_squares:\n                 cell = "."\n             print >> output_writer, row_string.format(cell)\n     elif safe_squares == 2:\n         impossible = True\n     elif rows == 2:\n         safe_cols, remainder = divmod(safe_squares, 2)\n         if remainder == 1:\n             impossible = True\n         else:\n             safe_string = "." * (safe_cols - 1)\n             print >> output_writer, row_string.format("c%s" % safe_string)\n             print >> output_writer, row_string.format(".%s" % safe_string)\n     elif cols == 2:\n         safe_rows, remainder = divmod(safe_squares, 2)\n         if remainder == 1:\n             impossible = True\n         else:\n             for row in range(rows):\n                 cells = ""\n                 if row == 0:\n                     cells = "c."\n                 elif row < safe_rows:\n                     cells = ".."\n                 print >> output_writer, row_string.format(cells)\n     else:\n         safe_rows, remainder = divmod(safe_squares, cols)\n         if remainder == 1 and cols == 3 and safe_rows == 2:\n             impossible = True\n         elif safe_rows > 1:\n             if remainder == 1 and safe_rows == 2:\n                 mid_safe = "." * (cols-2)\n                 for row in range(rows):\n                     cell_one = "."\n                     mid_cells = mid_safe\n                     last_cell = "."\n                     if row == 0:\n                         cell_one = "c"\n                     elif safe_rows == 0:\n                         cell_one = "."\n                         mid_cells = "." * (remainder + 1)\n                     elif safe_rows < 0:\n                         cell_one = ""\n                         mid_cells = ""\n                     if safe_rows < 3:\n                         last_cell = ""\n                     print >> output_writer, row_string.format("%s%s%s" % (cell_one, mid_cells, last_cell))\n                     safe_rows -= 1\n             elif remainder == 1:\n                 mid_safe = "." * (cols-2)\n                 for row in range(rows):\n                     cell_one = "."\n                     mid_cells = mid_safe\n                     last_cell = "."\n                     if row == 0:\n                         cell_one = "c"\n                     elif safe_rows == 0:\n                         cell_one = "."\n                         mid_cells = "." * remainder\n                     elif safe_rows < 0:\n                         cell_one = ""\n                         mid_cells = ""\n                     if safe_rows < 2:\n                         last_cell = ""\n                     print >> output_writer, row_string.format("%s%s%s" % (cell_one, mid_cells, last_cell))\n                     safe_rows -= 1\n             else:\n                 full_safe = "." * cols\n                 for row in range(rows):\n                     cells = full_safe\n                     if row == 0:\n                         cells = "c" + ("." * (cols - 1))\n                     elif row == safe_rows:\n                         cells = "." * remainder\n                     elif row > safe_rows:\n                         cells = ""\n                     print >> output_writer, row_string.format(cells)\n         else:\n             safe_cols, remainder = divmod(safe_squares, 2)\n             if remainder == 1 and safe_cols < 4:\n                 impossible = True\n             elif remainder == 0:\n                 print >> output_writer, row_string.format("c%s" % ("." * (safe_cols - 1)))\n                 print >> output_writer, row_string.format("." * safe_cols)\n                 for row in range(2, rows):\n                     print >> output_writer, row_string.format("")\n             else:\n                 safe_cols -= 1\n                 print >> output_writer, row_string.format("c%s" % ("." * (safe_cols - 1)))\n                 print >> output_writer, row_string.format("." * safe_cols)\n                 print >> output_writer, row_string.format("...")\n                 for row in range(3, rows):\n                     print >> output_writer, row_string.format("")\n     if impossible:\n         print >> output_writer, IMPOSSIBLE\n \n def solve_inputs(input_reader, output_writer):\n     """\n     Loop through each problem input in input reader and solve it.\n \n     Outputs responses to output_writer.\n     """\n     for input_values in parse_input(input_reader):\n         solve_problem(output_writer=output_writer, **input_values)\n \n def run_tests():\n     idx = 0\n     all_pass = True\n     for problem_input, expected_output in TEST_CASES:\n         idx += 1\n         input_reader = StringIO(problem_input)\n         output_writer = StringIO()\n         solve_inputs(input_reader, output_writer)\n         problem_output = output_writer.getvalue()\n         if problem_output == expected_output:\n             print "Test %d: Success" % idx\n         else:\n             all_pass = False\n             print "Test %d: Failure" % idx\n             print problem_output\n         input_reader.close()\n         output_writer.close()\n     if all_pass:\n         print "All tests were successful!"\n     else:\n         print "Something didn't match - try again."\n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file",\n                       dest="filename_stem",\n                       help="read input from FILE.in and write to FILE.out",\n                       metavar="FILE")\n \n     (options, args) = parser.parse_args()\n     if options.filename_stem:\n         print "Running in file mode."\n         input_reader = open("%s.in" % options.filename_stem, "r")\n         output_writer = open("%s.out" % options.filename_stem, "w")\n         solve_inputs(input_reader, output_writer)\n     else:\n         print "Running in test mode."\n         run_tests()\n \n if __name__ == "__main__":\n     main()
royf	<>	62	<>	2013_2270488_2463486.py	<>	\n import math\n import itertools\n import numpy\n \n def read_word(f):\n     return next(f).strip()\n \n def read_int(f, b=10):\n     return int(read_word(f), b)\n \n def read_letters(f):\n     return list(read_word(f))\n \n def read_digits(f, b=10):\n     return [int(x, b) for x in read_letters(f)]\n \n def read_words(f, d=' '):\n     return read_word(f).split(d)\n \n def read_ints(f, b=10, d=' '):\n     return [int(x, b) for x in read_words(f, d)]\n \n def read_floats(f, d=' '):\n     return [float(x) for x in read_words(f, d)]\n \n def read_arr(f, R, reader=read_ints, *args, **kwargs):\n     res = []\n     for i in range(R):\n         res.append(reader(f, *args, **kwargs))\n     return res\n \n def solve(solver, fn, out_fn=None):\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'w') as fo:\n             T = read_int(fi)\n             for i in range(T):\n                 case = read_case(fi)\n                 res = solver(case)\n                 write_case(fo, i, res)\n \n ################################################################################\n \n def read_case(f):\n     return read_ints(f)\n \n def write_case(f, i, res):\n     f.write('Case #%d: '%i)\n     f.write('%d'%res)\n     f.write('\n')\n \n ################################################################################\n \n def aux(A, B, x, s):\n     res = 0\n     n = int(''.join(x[::-1]+x))\n     nn = n*n\n     if nn > B:\n         return res\n     if nn >= A:\n         res += 1\n     for c in [0, 1, 2]:\n         if s + c*c < 10:\n             n = int(''.join(x[::-1]+[str(c)]+x))\n             nn = n*n\n             if nn >= A and nn <= B:\n                 res += 1\n         if s + 2*c*c < 10:\n             res += aux(A, B, [str(c)]+x, s + 2*c*c)\n     return res\n \n def solve_small(case):\n     [A, B] = case\n     res = 0\n     for n in [1, 4, 9]:\n         if n >= A and n <= B:\n             res += 1\n     for c in [1, 2]:\n         res += aux(A, B, [str(c)], 2*c*c)\n     return res\n \n def solve_large(case):\n     return solve_small(case)\n \n DEBUG = 'i'\n \n from run import *\n
royf	<>	62	<>	2013_2270488_2449486.py	<>	\n import math\n import itertools\n import numpy\n \n def read_word(f):\n     return next(f).strip()\n \n def read_int(f, b=10):\n     return int(read_word(f), b)\n \n def read_letters(f):\n     return list(read_word(f))\n \n def read_digits(f, b=10):\n     return [int(x, b) for x in read_letters(f)]\n \n def read_words(f, d=' '):\n     return read_word(f).split(d)\n \n def read_ints(f, b=10, d=' '):\n     return [int(x, b) for x in read_words(f, d)]\n \n def read_floats(f, d=' '):\n     return [float(x) for x in read_words(f, d)]\n \n def read_arr(f, R, reader=read_ints, *args, **kwargs):\n     res = []\n     for i in range(R):\n         res.append(reader(f, *args, **kwargs))\n     return res\n \n def solve(solver, fn, out_fn=None):\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'w') as fo:\n             T = read_int(fi)\n             for i in range(T):\n                 case = read_case(fi)\n                 res = solver(case)\n                 write_case(fo, i, res)\n \n ################################################################################\n \n def read_case(f):\n     [N, M] = read_ints(f)\n     A = read_arr(f, N)\n     return (N, M, A)\n \n def write_case(f, i, res):\n     f.write('Case #%d: '%i)\n     f.write('%s'%res)\n     f.write('\n')\n \n ################################################################################\n \n def solve_small(case):\n     (N, M, A) = case\n     rows = [max(row) for row in A]\n     cols = [max(row[j] for row in A) for j in range(M)]\n     for i in range(N):\n         for j in range(M):\n             if A[i][j] < min(rows[i], cols[j]):\n                 return 'NO'\n     return 'YES'\n \n def solve_large(case):\n     return solve_small(case)\n \n DEBUG = 'i'\n \n from run import *\n
royf	<>	62	<>	2014_2974486_5756407898963968.py	<>	\n import math\n import itertools\n import numpy as NP\n \n def read_word(f):\n     return next(f).strip()\n \n def read_int(f, b=10):\n     return int(read_word(f), b)\n \n def read_letters(f):\n     return list(read_word(f))\n \n def read_digits(f, b=10):\n     return [int(x, b) for x in read_letters(f)]\n \n def read_words(f, d=' '):\n     return read_word(f).split(d)\n \n def read_ints(f, b=10, d=' '):\n     return [int(x, b) for x in read_words(f, d)]\n \n def read_floats(f, d=' '):\n     return [float(x) for x in read_words(f, d)]\n \n def read_arr(f, R, reader=read_ints, *args, **kwargs):\n     return [reader(f, *args, **kwargs) for i in range(R)]\n \n def solve(solver, fn, out_fn=None):\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'w') as fo:\n             T = read_int(fi)\n             for i in range(T):\n                 case = read_case(fi)\n                 res = solver(case)\n                 write_case(fo, i, res)\n \n ################################################################################\n \n def read_case(f):\n     R1 = read_int(f)\n     Q1 = read_arr(f, 4)\n     R2 = read_int(f)\n     Q2 = read_arr(f, 4)\n     return (R1, Q1, R2, Q2)\n \n def write_case(f, i, res):\n     f.write('Case #%d: '%i)\n     f.write('%s'%res)\n     f.write('\n')\n \n ################################################################################\n \n def solve_small(case):\n     (R1, Q1, R2, Q2) = case\n     s = set(Q1[R1-1]) & set(Q2[R2-1])\n     if len(s) == 0:\n         return 'Volunteer cheated!'\n     if len(s) == 1:\n         return s.pop()\n     return 'Bad magician!'\n \n def solve_large(case):\n     return solve_small(case)\n \n DEBUG = 'i'\n \n from run import *\n
royf	<>	62	<>	2012_1460488_1483485.py	<>	\n import sys\n import os\n import itertools\n import math\n import numpy\n \n __file__ = sys.argv[0]\n __path__ = os.path.dirname(__file__)\n __prob__ = os.path.basename(__path__)\n \n def pout(s, back=0):\n     f = sys._getframe(back+1)\n     d = 0\n     if 'depth' in f.f_locals:\n         d = f.f_locals['depth']\n     print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n \n def perr(s, back=0):\n     f = sys._getframe(back+1)\n     d = 0\n     if 'depth' in f.f_locals:\n         d = f.f_locals['depth']\n     ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n \n def argmin(f, s=None):\n     a = f\n     if s is None:\n         s = range(len(a))\n         f = lambda i: a[i]\n     res = None\n     for x in s:\n         y = f(x)\n         if res is None or best > y:\n             best = y\n             res = x\n     return res\n \n def argmax(f, s=None):\n     a = f\n     if s is None:\n         s = range(len(a))\n         f = lambda i: a[i]\n     res = None\n     for x in s:\n         y = f(x)\n         if res is None or best < y:\n             best = y\n             res = x\n     return res\n \n def read_word(f):\n     return next(f).strip()\n \n def read_int(f, b=10):\n     return int(read_word(f), b)\n \n def read_words(f, d=' '):\n     return read_word(f).split(d)\n \n def read_ints(f, b=10, d=' '):\n     return [int(x, b) for x in read_words(f, d)]\n \n def read_word_arr(f, R):\n     res = []\n     for i in range(R):\n         res.append(read_word(f))\n     return res\n \n def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n     res = []\n     for i in range(R):\n         res.append(read_ints(f, *args, **kwargs))\n     return numpy.array(res, dtype)\n \n def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n     global ERR_FILE\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     err_fn = fn + '.err'\n     if start_case == 0:\n         append = True\n         if os.path.exists(out_fn):\n             with open(out_fn, 'r') as f:\n                 for l in f:\n                     if l[:6] == 'Case #':\n                         start_case = int(l[6:l.index(':')])+1\n     else:\n         append = False\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'a' if append else 'w') as fo:\n             with open(err_fn, 'w') as ERR_FILE:\n                 T = read_int(fi)\n                 for i in range(T):\n                     case = read_case(fi)\n                     if i+1 < start_case:\n                         continue\n                     print('Case #%d of %d'%(i+1, T))\n                     ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                     perr('case')\n                     res = solver(case)\n                     perr('res')\n                     write_case(fo, i, res)\n                     fo.flush()\n                     if end_case is not None and i+1 == end_case:\n                         break\n \n def test(start_case=1, end_case=None):\n     fn = os.path.join(__path__, 'test')\n     solve(solve_small, fn, start_case, end_case)\n \n def small(start_case=1, end_case=None):\n     fn = os.path.join(__path__, '%s-small-practice'%__prob__)\n     solve(solve_small, fn, start_case, end_case)\n \n def small2(start_case=1, end_case=None):\n     fn = os.path.join(__path__, '%s-small-practice'%__prob__)\n     solve(solve_large, fn, start_case, end_case, fn + '2.out')\n \n def large(start_case=0, end_case=None):\n     fn = os.path.join(__path__, '%s-large-practice'%__prob__)\n     solve(solve_large, fn, start_case, end_case)\n \n ################################################################################\n \n def read_case(f):\n     G = read_word(f)\n     return G\n \n def write_case(f, i, res):\n     f.write('Case #%d: '%(i+1))\n     f.write('%s'%res)\n     f.write('\n')\n \n FAIL = 'NO SOLUTION'\n \n TRANS = {'z': 'q', 'q': 'z', '\n': '\n', ' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm'}\n \n def solve_small(case):\n     G = case\n     return ''.join(TRANS[x] for x in G)\n \n solve_large = solve_small\n \n ##perr = pout\n ##pout = lambda s: None\n pout = perr\n
royf	<>	62	<>	2014_2974486_5709773144064000.py	<>	\n import math\n import itertools\n import numpy as NP\n \n def read_word(f):\n     return next(f).strip()\n \n def read_int(f, b=10):\n     return int(read_word(f), b)\n \n def read_letters(f):\n     return list(read_word(f))\n \n def read_digits(f, b=10):\n     return [int(x, b) for x in read_letters(f)]\n \n def read_words(f, d=' '):\n     return read_word(f).split(d)\n \n def read_ints(f, b=10, d=' '):\n     return [int(x, b) for x in read_words(f, d)]\n \n def read_floats(f, d=' '):\n     return [float(x) for x in read_words(f, d)]\n \n def read_arr(f, R, reader=read_ints, *args, **kwargs):\n     return [reader(f, *args, **kwargs) for i in range(R)]\n \n def solve(solver, fn, out_fn=None):\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'w') as fo:\n             T = read_int(fi)\n             for i in range(T):\n                 case = read_case(fi)\n                 res = solver(case)\n                 write_case(fo, i, res)\n \n ################################################################################\n \n def read_case(f):\n     return read_floats(f)\n \n def write_case(f, i, res):\n     f.write('Case #%d: '%i)\n     f.write('%s'%res)\n     f.write('\n')\n \n ################################################################################\n \n def solve_small(case):\n     (C, F, X) = case\n     res = 0\n     i = 0\n     while X/(2 + i*F) > C/(2 + i*F) + X/(2 + (i+1)*F):\n         res += C/(2 + i*F)\n         i += 1\n     return res + X/(2 + i*F)\n \n def solve_large(case):\n     return solve_small(case)\n \n DEBUG = 'i'\n \n from run import *\n
royf	<>	62	<>	2014_2974486_5690574640250880.py	<>	\n import math\n import itertools\n import numpy as NP\n \n def read_word(f):\n     return next(f).strip()\n \n def read_int(f, b=10):\n     return int(read_word(f), b)\n \n def read_letters(f):\n     return list(read_word(f))\n \n def read_digits(f, b=10):\n     return [int(x, b) for x in read_letters(f)]\n \n def read_words(f, d=' '):\n     return read_word(f).split(d)\n \n def read_ints(f, b=10, d=' '):\n     return [int(x, b) for x in read_words(f, d)]\n \n def read_floats(f, d=' '):\n     return [float(x) for x in read_words(f, d)]\n \n def read_arr(f, R, reader=read_ints, *args, **kwargs):\n     return [reader(f, *args, **kwargs) for i in range(R)]\n \n def solve(solver, fn, out_fn=None):\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'w') as fo:\n             T = read_int(fi)\n             for i in range(T):\n                 case = read_case(fi)\n                 res = solver(case)\n                 write_case(fo, i, res)\n \n ################################################################################\n \n def read_case(f):\n     return read_ints(f)\n \n def write_case(f, i, res):\n     f.write('Case #%d: '%i)\n     if isinstance(res, list):\n         res[0][0] = 'c'\n         res = '\n'.join(''.join(c for c in r) for r in res)\n     f.write('\n%s'%res)\n     f.write('\n')\n \n ################################################################################\n \n def solve_small(case):\n     (R, C, M) = case\n     if R == 1:\n         return 'c' + '.'*(C-M-1) + '*'*M\n     if C == 1:\n         return '\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\n     m = R*C - M\n     res = [['*']*C for r in range(R)]\n     if m == 1:\n         return res\n     for r in range(2, R+1):\n         c = m // r\n         z = m % r\n         if c < 2 or c + (z>0) > C:\n             continue\n         if z == 1 and (r < 3 or c < 3):\n             continue\n         for x in range(r):\n             for y in range(c):\n                 res[x][y] = '.'\n         for y in range(z):\n             res[y][c] = '.'\n         if z == 1:\n             res[z][c] = '.'\n             res[r-1][c-1] = '*'\n         return res\n     return 'Impossible'\n \n def solve_large(case):\n     return solve_small(case)\n \n DEBUG = 'f'\n \n from run import *\n
anb	<>	63	<>	2013_2270488_2463486.py	<>	from sys import stdin\n \n def read_ints():\n     return map(int, stdin.readline().rstrip().split(' '))\n \n def is_palin(n):\n     s = str(n)\n     return s == s[::-1]\n     \n def find(n, fas):\n     for i in xrange(len(fas)):\n         if fas[i] >= n:\n             return i\n     return len(fas)\n     \n def gen_fas(max):\n     fas = []\n     fasappend = fas.append\n     square, base, d = 1, 1, 3\n     while square < max:\n         if is_palin(square) and is_palin(base):\n             fasappend(square)\n         square += d\n         d += 2\n         base += 1\n     return fas\n     \n def main():\n     MAX = 1000\n     fas = gen_fas(MAX)\n     \n     T = int(stdin.readline())\n     for Ti in xrange(T):\n         A, B = read_ints()\n         answer = find(B + 1, fas) - find(A, fas)\n         print 'Case #{}: {}'.format(Ti + 1, answer)\n         \n main()\n
anb	<>	63	<>	2013_2270488_2449486.py	<>	from sys import stdin\n \n def read_ints():\n     return map(int, stdin.readline().rstrip().split(' '))\n \n def print_lawn(lawn):\n     for row in lawn:\n         print row\n         \n def is_higher(a, i, j, N, M):\n     s = a[i][j]\n     v, h = False, False\n     for ii in xrange(N):\n         if a[ii][j] > s:\n             v = True\n             break\n     for jj in xrange(M):\n         if a[i][jj] > s:\n             h = True\n             break\n     return v and h\n     \n def check(a, N, M):\n     if N == 1 or M == 1:\n         return True\n     else:\n         for i in xrange(N):\n             for j in xrange(M):\n                 h = is_higher(a, i, j, N, M)\n                 if h:\n                     return False\n         return True\n     \n def main():\n     T = int(stdin.readline())\n     for Ti in xrange(T):\n         N, M = read_ints()\n         a = []\n         for i in xrange(N):\n             a.append(read_ints())\n         answer = 'YES' if check(a, N, M) else 'NO'\n         #print_lawn(a)\n         print 'Case #{}: {}'.format(Ti + 1, answer)\n         \n main()\n
anb	<>	63	<>	2012_1460488_1483488.py	<>	from sys import stdin\n \n def program():\n 	T = int(stdin.readline())\n 	for Ti in xrange(T):\n 		A, B =  map(int, stdin.readline().rstrip().split(' '))\n 		\n 		ss = set()\n 		for n in xrange(A, B + 1):\n 			sn = str(n)\n 			for i in xrange(1, len(sn)):\n 				sm = sn[i:] + sn[:i]\n 				if sm[0] != '0':\n 					m = int(sm)\n 					if m > n and m <= B:\n 						ss.add((n, m))\n 		\n 		print 'Case #%d: %d' % (Ti + 1, len(ss))	\n 	\n if __name__ == '__main__':\n 	program()
anb	<>	63	<>	2014_2974486_5756407898963968.py	<>	from sys import stdin\n \n def read_str(): return stdin.readline().rstrip('\n')\n def read_int(): return int(stdin.readline())\n def read_ints(): return map(int, stdin.readline().split())\n \n def read_cards():\n     cards = []\n     for i in range(4):\n         cards.append(read_ints())\n     return cards\n \n def main():\n     cases = read_int()\n     for case in range(1, cases + 1):\n         row = read_int() - 1\n         cards = read_cards()\n         candidates1 = set(cards[row])\n         \n         row = read_int() - 1\n         cards = read_cards()\n         candidates2 = set(cards[row])\n         \n         candidates = candidates1.intersection(candidates2)\n         if len(candidates) == 1:\n             ans = list(candidates)[0]\n         elif len(candidates) == 0:\n             ans = 'Volunteer cheated!'\n         else:\n             ans = 'Bad magician!'\n         \n         print('Case #{}: {}'.format(case, ans))\n         \n main()\n
anb	<>	63	<>	2012_1460488_1483485.py	<>	from sys import stdin\n \n def get_mapping():\n 	d = ord('a')\n 	mapping = [ None ] * 26\n 	inputs = [ 'ejp mysljylc kd kxveddknmc re jsicpdrysi', \n 		'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', \n 		'de kr kd eoya kw aej tysr re ujdr lkgc jv' ]\n 	outputs = [ 'our language is impossible to understand', \n 		'there are twenty six factorial possibilities', \n 		'so it is okay if you want to just give up' ]\n 	\n 	for i in xrange(len(inputs)):\n 		input = inputs[i]\n 		output = outputs[i]\n 		for j in xrange(len(input)):\n 			if input[j] == ' ':\n 				continue\n 			k = ord(input[j]) - d\n 			if mapping[k] is None:\n 				mapping[k] = output[j]\n 	mapping[ord('q') - d] = 'z'\n 	mapping[ord('z') - d] = 'q'\n 				\n 	return mapping\n 			\n \n def program():\n 	T = int(stdin.readline())\n 	mapping = get_mapping()\n 	d = ord('a')\n 	for i in xrange(T):\n 		s = stdin.readline().rstrip()\n 		t = ''\n 		\n 		for ss in s:\n 			if ss == ' ':\n 				t += ' '\n 			else:\n 				t += mapping[ord(ss) - d]\n 		print 'Case #%d: %s' % (i + 1, t)\n 	\n if __name__ == '__main__':\n 	program()
anb	<>	63	<>	2014_2974486_5709773144064000.py	<>	from sys import stdin\n \n def read_str(): return stdin.readline().rstrip('\n')\n def read_int(): return int(stdin.readline())\n def read_ints(): return map(int, stdin.readline().split())\n def read_floats(): return map(float, stdin.readline().split())\n \n \n def solve_case():\n     C, F, X = read_floats()\n     rate = 2\n     current = 0\n     best = X / rate\n     \n     while True:\n         current += C / rate\n         rate += F\n         next = current + X / rate\n         if next < best:\n             best = next\n         else:\n             break\n     \n     return best\n \n     \n def main():\n     cases = read_int()\n     for case in range(1, cases + 1):\n         print('Case #{}: {:.7f}'.format(case, solve_case()))\n \n         \n main()\n
anb	<>	63	<>	2013_2270488_2453486.py	<>	from sys import stdin\n \n def won(x, o, t):\n     if x == 4 or (x == 3 and t == 1):\n         return 1\n     elif o == 4 or (o == 3 and t == 1):\n         return 2\n \n def check(board, BOARD_SIZE, RESULTS):\n     d = 0\n     for i in xrange(BOARD_SIZE):\n         x = board[i].count('X')\n         o = board[i].count('O')\n         t = board[i].count('T')\n         d += board[i].count('.')\n         w = won(x, o, t)\n         if w:\n             return w\n     for i in xrange(BOARD_SIZE):\n         vertical = [ board[j][i] for j in xrange(BOARD_SIZE) ]\n         x = vertical.count('X')\n         o = vertical.count('O')\n         t = vertical.count('T')\n         w = won(x, o, t)\n         if w:\n             return w\n     x, o, t = 0, 0, 0\n     for i in xrange(BOARD_SIZE):\n         if board[i][i] == 'X':\n             x += 1\n         elif board[i][i] == 'O':\n             o += 1\n         elif board[i][i] == 'T':\n             t += 1\n     w = won(x, o, t)\n     if w:\n         return w    \n     x, o, t = 0, 0, 0\n     for i in xrange(BOARD_SIZE):\n         if board[i][BOARD_SIZE - i - 1] == 'X':\n             x += 1\n         elif board[i][BOARD_SIZE - i - 1] == 'O':\n             o += 1\n         elif board[i][BOARD_SIZE - i - 1] == 'T':\n             t += 1\n     w = won(x, o, t)\n     if w:\n         return w\n     if d == 0:\n         return 3\n     else:\n         return 4\n     \n def main():\n     BOARD_SIZE = 4\n     RESULTS = 'X won', 'O won', 'Draw', 'Game has not completed'\n \n     T = int(stdin.readline())\n     for Ti in xrange(T):\n         board = []\n         for i in xrange(BOARD_SIZE):\n             board.append(list(stdin.readline().rstrip()))\n         print 'Case #{}: {}'.format(Ti + 1, RESULTS[check(board, BOARD_SIZE, RESULTS) - 1])    \n         stdin.readline()\n         \n main()\n
anb	<>	63	<>	2014_2974486_5690574640250880.py	<>	from sys import stdin\n \n \n def read_str(): return stdin.readline().rstrip('\n')\n def read_int(): return int(stdin.readline())\n def read_ints(): return map(int, stdin.readline().split())\n def read_floats(): return map(float, stdin.readline().split())\n \n \n def atos(A):\n     return '\n'.join([''.join(row) for row in A])\n     \n \n def get_field(r, c):\n     field = [['.'] * c for i in range(r)]\n     field[0][0] = 'c'\n     return field\n     \n     \n def is_forbidden(i, j):\n     return i == 0 and j == 0 or i == 0 and j == 1 or \\n         i == 1 and j == 0 or i == 1 and j == 1\n     \n     \n def fill(field, r, c, m):\n     left = m\n     for ii in range(r - 1, -1, -1):\n         i = ii\n         j = c - 1\n         while i < r and j >= 0:\n             if is_forbidden(i, j):\n                 i += 1\n                 j -= 1\n                 continue\n             if left == 0:\n                 return 0\n             field[i][j] = '*'\n             left -= 1\n             \n             i += 1\n             j -= 1\n             \n         if ii == 0:\n             for jj in range(c - 2, 1, -1):\n                 i = ii\n                 j = jj\n                 while i < r and j >= 0:\n                     if is_forbidden(i, j):\n                         i += 1\n                         j -= 1\n                         continue\n                     if left == 0:\n                         return 0\n                     field[i][j] = '*'\n                     left -= 1\n                     \n                     i += 1\n                     j -= 1\n             \n     if r * c == m + 1:\n         if r > 1:\n             field[1][0] = '*'\n         if c > 1:\n             field[0][1] = '*'\n         if r > 1 and c > 1:\n             field[1][1] = '*'\n         return 0\n             \n     return left\n \n     \n def solve_case():\n     r, c, m = read_ints()\n     #print('\n', r, c, m)\n     \n     field = get_field(r, c)\n         \n     left = fill(field, r, c, m)\n         \n     return 'Impossible' if left != 0 else atos(field)\n     \n     \n def main():\n     cases = read_int()\n     for case in range(1, cases + 1):\n         print('Case #{}:\n{}'.format(case, solve_case()))\n \n         \n main()\n
rmmh	<>	64	<>	2013_2270488_2463486.py	<>	import sys\n #sys.stdin = open("c_example.in")\n \n n_cases = input()\n \n def to_ints(s):\n     return map(int, s.split())\n \n def is_palindrome(n):\n     s = str(n)\n     return s == s[::-1]\n \n for case in xrange(1, n_cases + 1):\n     a, b = to_ints(raw_input())\n \n     nums = range(int(b ** .5) + 2)\n     palins = filter(is_palindrome, nums)\n     squares = [x**2 for x in palins]\n     palin_squares = filter(is_palindrome, squares)\n     range_squares = [x for x in palin_squares if a <= x <= b]\n \n     print "Case #%d: %s" % (case, len(range_squares))\n
rmmh	<>	64	<>	2013_2270488_2449486.py	<>	import sys\n #sys.stdin = open("b_example.in")\n \n n_cases = input()\n \n def to_ints(s):\n     return map(int, s.split())\n \n for case in xrange(1, n_cases + 1):\n     ydim, xdim = to_ints(raw_input())\n     heights = [to_ints(raw_input()) for _ in xrange(ydim)]\n \n     ymaxes = [max(row) for row in heights]\n     xmaxes = [max(col) for col in zip(*heights)]\n \n     #print ymaxes, xmaxes\n \n     poss = True\n \n     for y in range(ydim):\n         for x in range(xdim):\n             height = heights[y][x]\n             if not (height == xmaxes[x] or height == ymaxes[y]):\n                 poss = False\n \n \n     print "Case #%d: %s" % (case, 'YES' if poss else 'NO')\n
rmmh	<>	64	<>	2012_1460488_1483488.py	<>	n_cases = input()\n \n for case in xrange(1, n_cases + 1):\n     a, b = map(int, raw_input().split())\n \n     out = 0\n     e = 10 ** (len(str(a)) - 1)\n     for n in xrange(a, b):\n         s = str(n)\n         m = n\n         while True:\n             m = (m / 10) + (m % 10 * e)\n             if n < m <= b:\n                 out += 1\n             if m == n:\n                 break\n \n     print "Case #%d: %s" % (case, out)\n
rmmh	<>	64	<>	2014_2974486_5756407898963968.py	<>	import sys\n if len(sys.argv) == 1:\n     sys.stdin = open("A.in")\n else:\n     sys.stdin = open(sys.argv[1])\n \n def to_ints(s):\n     return map(int, s.split())\n \n def get_ints():\n     return to_ints(raw_input())\n \n n_cases = input()\n \n for case in xrange(1, n_cases + 1):\n     a_row, = get_ints()\n     a_layout = [get_ints() for _ in range(4)]\n     b_row, = get_ints()\n     b_layout = [get_ints() for _ in range(4)]\n \n     poss = set(a_layout[a_row - 1])\n     poss.intersection_update(b_layout[b_row - 1])\n \n     result = 'Bad magician!'\n \n     if len(poss) == 0:\n         result = 'Volunteer cheated!'\n     elif len(poss) == 1:\n         result = poss.pop()\n \n     print "Case #%d: %s" % (case, result)\n
rmmh	<>	64	<>	2012_1460488_1483485.py	<>	mapping = {'y':'a', 'e':'o', 'q':'z', 'z':'q'}\n \n for src, dst in [("ejp mysljylc kd kxveddknmc re jsicpdrysi", "our language is impossible to understand"),\n     ("rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd","there are twenty six factorial possibilities"),\n     ("de kr kd eoya kw aej tysr re ujdr lkgc jv","so it is okay if you want to just give up")]:\n     for a, b in zip(src,dst):\n         mapping[a] = b\n \n n_cases = input()\n \n \n for case in xrange(1, n_cases + 1):\n     string = raw_input()\n \n     out = ''.join(mapping.get(c, c) for c in string)\n             \n     print "Case #%d: %s" % (case, out)\n
rmmh	<>	64	<>	2014_2974486_5709773144064000.py	<>	import sys\n if len(sys.argv) == 1:\n     sys.stdin = open("B.in")\n else:\n     sys.stdin = open(sys.argv[1])\n \n def to_floats(s):\n     return map(float, s.split())\n \n def get_floats():\n     return to_floats(raw_input())\n \n n_cases = input()\n \n for case in xrange(1, n_cases + 1):\n     farm_cost, farm_increase, goal = get_floats()\n \n     best_time = float('inf')\n     time = 0.0\n     rate = 2.0\n     while time < best_time:\n         best_time = min(best_time, time + goal / rate)\n         time += farm_cost / rate\n         rate += farm_increase\n \n     print "Case #%d: %.7f" % (case, best_time)\n
rmmh	<>	64	<>	2013_2270488_2453486.py	<>	import sys\n #sys.stdin = open("a_example.in")\n \n n_cases = input()\n \n def xwin(s):\n     return all(c in 'XT' for c in s)\n \n def owin(s):\n     return all(c in 'OT' for c in s)\n \n for case in xrange(1, n_cases + 1):\n     board = [raw_input().strip() for _ in xrange(4)]\n     raw_input()\n \n     board_t = zip(*board)\n \n     #print board, board_t\n \n     x_win = False\n     o_win = False\n     full = not any('.' in line for line in board)\n \n     diag_nw = [board[x][x] for x in range(4)]\n     diag_ne = [board[x][3-x] for x in range(4)]\n \n     #print diag_nw, diag_ne\n \n     if xwin(diag_nw) or xwin(diag_ne):\n         x_win = True\n     if owin(diag_nw) or owin(diag_ne):\n         o_win = True\n \n     for line, line_t in zip(board, board_t):\n         if xwin(line) or xwin(line_t):\n             x_win = True\n         if owin(line) or owin(line_t):\n             o_win = True\n \n     out = 'Game has not completed'\n     if x_win:\n         out = 'X won'\n     elif o_win:\n         out = 'O won'\n     elif full:\n         out = 'Draw'\n \n     print "Case #%d: %s" % (case, out)\n
rmmh	<>	64	<>	2014_2974486_5690574640250880.py	<>	import sys\n if len(sys.argv) == 1:\n     sys.stdin = open("C.in")\n else:\n     sys.stdin = open(sys.argv[1])\n \n def to_ints(s):\n     return map(int, s.split())\n \n def get_ints():\n     return to_ints(raw_input())\n \n sys.setrecursionlimit(4000)\n \n def fill(rows, cols, mines):\n     seen = set()\n     visited = set()\n \n     # we are trying to carve through a mountain \n     # and leave 'mine' squares unseen\n     def search(numbered, zeros, min_numbered):\n         left = (rows * cols - mines) - len(numbered)\n         #print left, numbered,  min_numbered, zeros\n         if left == 0:\n             raise StopIteration((numbered, zeros))\n         if left < 0:\n             return\n         for n in xrange(min_numbered, len(numbered)):\n             number = numbered[n]\n             if number in zeros:\n                 continue\n             row, col = number\n             neigh = []\n             if row > 0:\n                 if col > 0: neigh.append((row - 1, col - 1))\n                 neigh.append((row - 1, col))\n                 if col < cols - 1: neigh.append((row - 1, col + 1))\n             if col > 0: neigh.append((row, col - 1))\n             if col < cols - 1: neigh.append((row, col + 1))\n             if row < rows - 1:\n                 if col > 0: neigh.append((row + 1, col - 1))\n                 neigh.append((row + 1, col))\n                 if col < cols - 1: neigh.append((row + 1, col + 1))\n             # BUG: we might try to walk to a diagonal, oh well\n             neigh = list(set(neigh) - set(numbered))\n             zeros.add(number)\n             search(numbered + neigh, zeros, n + 1)\n             zeros.remove(number)\n \n     try:\n         for row in xrange(rows):\n             for col in xrange(cols):\n                 search([(row, col)], set(), 0)\n     except StopIteration, e:\n         numbered, zeros = e.message\n         board = {}\n         for row, col in numbered + list(zeros):\n             board[row, col] = '.'\n         if zeros:\n             board[zeros.pop()] = 'c'\n         else: # case where first click is on a number\n             board[0, 0] = 'c'\n         out = ''\n         for row in xrange(rows):\n             for col in xrange(cols):\n                 out += board.get((row, col), '*')\n             out += '\n'\n         return out.strip()\n     return 'Impossible'\n \n n_cases = input()\n for case in xrange(1, n_cases + 1):\n     rows, cols, mines = get_ints()\n \n     result = fill(rows, cols, mines)\n \n     print "Case #%d:" % case\n     print result\n
kawasaki	<>	65	<>	2013_2270488_2463486.py	<>	# -*- coding: utf-8 -*-\n \n N_MAX = 10 ** 7  # for First large dataset\n \n \n def is_palindrome(n):\n     s = str(n)\n     for i in xrange(len(s) / 2):\n         if s[i] != s[-1 - i]:\n             return False\n     return True\n \n palindromes = [x for x in xrange(N_MAX) if is_palindrome(x)]\n palindrome_squares = [x ** 2 for x in palindromes]\n fair_and_square_palindromes = filter(is_palindrome, palindrome_squares)\n \n \n T = int(raw_input())\n for test_case_id in xrange(1, T + 1):\n     A, B = map(int, raw_input().split())\n     answer = len([x for x in fair_and_square_palindromes if A <= x <= B])\n     print 'Case #{}: {}'.format(test_case_id, answer)\n
kawasaki	<>	65	<>	2013_2270488_2449486.py	<>	# -*- coding: utf-8 -*-\n \n T = int(raw_input())\n for test_case_id in xrange(1, T + 1):\n     N, M = map(int, raw_input().split())\n     A = []\n     for i in xrange(N):\n         A.append(map(int, raw_input().split()))\n \n     heights = reduce(lambda a, b: a | b, (set(row) for row in A))\n     for y in xrange(N):\n         for x in xrange(M):\n             if (\n                 any(A[y][j] > A[y][x] for j in xrange(M)) and\n                 any(A[i][x] > A[y][x] for i in xrange(N))\n             ):\n                 # Found a region surrounded by higher regions.\n                 print 'Case #{}: NO'.format(test_case_id)\n                 break\n         else:\n             continue\n         break\n     else:\n         print 'Case #{}: YES'.format(test_case_id)\n
kawasaki	<>	65	<>	2012_1460488_1483488.py	<>	# -*- coding: utf-8 -*-\n \n \n def rotate(x, w):\n     x = str(x)\n     return int(x[-w:] + x[:-w])\n \n \n T = int(raw_input())\n for case in xrange(1, T + 1):\n     A, B = map(int, raw_input().split())\n \n     l = len(str(A))\n     assert l == len(str(B))\n \n     s = []\n     for n in xrange(A, B + 1):\n         for w in xrange(1, len(str(n))):\n             m = int(rotate(n, w))\n             if n < m <= B:\n                 s.append((n, m))\n \n     print 'Case #%d: %d' % (case, len(set(s)))\n \n
kawasaki	<>	65	<>	2014_2974486_5756407898963968.py	<>	# -*- coding: utf-8 -*-\n \n T = int(raw_input())\n for test_case in xrange(1, T + 1):\n     N1 = int(raw_input())\n     for i in xrange(4):\n         if i + 1 == N1:\n             R1 = map(int, raw_input().split(' '))\n         else:\n             raw_input()\n     N2 = int(raw_input())\n     for i in xrange(4):\n         if i + 1 == N2:\n             R2 = map(int, raw_input().split(' '))\n         else:\n             raw_input()\n     assert 1 <= N1 <= 4\n     assert 1 <= N2 <= 4\n     assert len(R1) == len(R2) == 4\n \n     num = set(R1) & set(R2)\n     if len(num) == 1:\n         answer = num.pop()\n     elif 1 < len(num):\n         answer = 'Bad magician!'\n     else:\n         answer = 'Volunteer cheated!'\n     print 'Case #{}: {}'.format(test_case, answer)\n
kawasaki	<>	65	<>	2012_1460488_1483485.py	<>	# -*- coding: utf-8 -*-\n \n import string\n \n \n str_to = '''\n ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv\n '''.replace(' ', '').replace('\n', '')\n \n str_from = '''\n our language is impossible to understand\n there are twenty six factorial possibilities\n so it is okay if you want to just give up\n '''.replace(' ', '').replace('\n', '')\n \n conv = {}\n for i, c in enumerate(str_from):\n     assert c not in conv or conv[c] == str_to[i]\n     conv[c] = str_to[i]\n conv['z'] = 'q'\n conv['q'] = 'z'\n \n assert len(set(conv.keys())) == 26\n assert len(set(conv.values())) == 26\n mat = ['', '']\n for k, v in conv.items():\n     mat[0] += v\n     mat[1] += k\n \n T = int(raw_input())\n for case in xrange(1, T + 1):\n     line = raw_input()\n     ans = string.translate(line, string.maketrans(*mat))\n     print 'Case #%d: %s' % (case, ans)\n \n
kawasaki	<>	65	<>	2014_2974486_5709773144064000.py	<>	# -*- coding: utf-8 -*-\n \n T = int(raw_input())\n for test_case in xrange(1, T + 1):\n     C, F, X = map(float, raw_input().split())\n     answer = X / 2\n     i = 0\n     last_tc = 0\n     while True:\n         tc = last_tc + C / (2 + (i * F))\n         if answer < tc:\n             break\n         answer = min(tc + X / (2 + (i + 1) * F), answer)\n \n         i += 1\n         last_tc = tc\n     print 'Case #{}: {:.7f}'.format(test_case, answer)\n
kawasaki	<>	65	<>	2013_2270488_2453486.py	<>	# -*- coding: utf-8 -*-\n \n T = int(raw_input())\n for test_case_id in xrange(1, T + 1):\n     cells = []\n     for i in xrange(4):\n         cells.append(raw_input())\n     raw_input()\n \n     R = range(4)\n     for c in 'XO':\n         if (\n             any(all(cells[i][j] in (c, 'T') for j in R) for i in R) or\n             any(all(cells[i][j] in (c, 'T') for i in R) for j in R) or\n             all(cells[i][i] in (c, 'T') for i in R) or\n             all(cells[i][3 - i] in (c, 'T') for i in R)\n         ):\n             print 'Case #{}: {} won'.format(test_case_id, c)\n             break\n     else:\n         if '.' in ''.join(cells):\n             print 'Case #{}: Game has not completed'.format(test_case_id)\n         else:\n             print 'Case #{}: Draw'.format(test_case_id)\n
kawasaki	<>	65	<>	2014_2974486_5690574640250880.py	<>	# -*- coding: utf-8 -*-\n \n T = int(raw_input())\n for test_case in xrange(1, T + 1):\n     R, C, M = map(int, raw_input().split())\n     N = R * C\n     B = N - M\n \n     W, H = (C, R) if R <= C else (R, C)\n \n     if H == 1:\n         answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\n     elif M == N - 1:\n         answer = [['*'] * W for r in xrange(H)]\n         answer[0][0] = 'c'\n     elif B < 4 or B in (5, 7):\n         answer = None\n     elif H == 2:\n         if M % 2 == 0:\n             bw = B / 2\n             answer = [\n                 ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\n                 ['.'] * bw + ['*'] * (W - bw),\n             ]\n         else:\n             answer = None\n     else:\n         answer = [['*'] * W for y in xrange(H)]\n         answer[0][0] = 'c'\n         answer[0][1] = answer[1][0] = answer[1][1] = '.'\n         left = B - 4\n         if 2 <= left:\n             answer[0][2] = answer[1][2] = '.'\n             left -= 2\n         if 2 <= left:\n             answer[2][0] = answer[2][1] = '.'\n             left -= 2\n \n         x = y = 3\n         while (x < W or y < H) and 2 <= left:\n             if x < W and 2 <= left:\n                 answer[0][x] = answer[1][x] = '.'\n                 left -= 2\n                 x += 1\n             if y < H and 2 <= left:\n                 answer[y][0] = answer[y][1] = '.'\n                 left -= 2\n                 y += 1\n \n         y = 2\n         while 0 < left and y < H:\n             x = 2\n             while 0 < left and x < W:\n                 answer[y][x] = '.'\n                 left -= 1\n                 x += 1\n             y += 1\n \n     if answer is None:\n         answer = 'Impossible'\n     else:\n         if W == R:\n             answer = map(list, zip(*answer))\n         assert len(answer) == R\n         assert len(answer[0]) == C\n         assert sum(row.count('*') for row in answer) == M\n #        # DEBUG\n #        h = len(answer)\n #        w = len(answer[0])\n #        for y in xrange(h):\n #            for x in xrange(w):\n #                if answer[y][x] in '.c':\n #                    count = 0\n #                    for dy in (-1, 0, 1):\n #                        for dx in (-1, 0, 1):\n #                            if (\n #                                0 <= x + dx < w and\n #                                0 <= y + dy < h and\n #                                answer[y + dy][x + dx] == '*'\n #                            ):\n #                                count += 1\n #                    answer[y][x] = str(count)\n         answer = '\n'.join([''.join(row) for row in answer])\n     print 'Case #{}:\n{}'.format(test_case, answer)\n
